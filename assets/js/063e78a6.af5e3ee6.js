"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[9397],{61869:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>g,contentTitle:()=>p,default:()=>R,frontMatter:()=>v,metadata:()=>c,toc:()=>j});const c=JSON.parse('{"id":"education/computer-science/algorithms/algo/fibonacci-number","title":"Fibonacci Number","description":"Fibonacci Number","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/fibonacci-number.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/fibonacci-number","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/fibonacci-number","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/fibonacci-number.mdx","tags":[],"version":"current","frontMatter":{"title":"Fibonacci Number","description":"Fibonacci Number","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Fast Powering","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/fast-powering"},"next":{"title":"Fisher\u2013Yates Shuffle","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/fisher\u2013yates-shuffle"}}');var t=i(86070),r=i(15658),a=i(33407),s=i(33903),l=i(68171);const o="package main\n\n// Recursive\nfunc fibonacciRecursive(n int) int {\n    if n <= 1 {\n        return n\n    }\n    return fibonacciRecursive(n-1) + fibonacciRecursive(n-2)\n}\n\n// Iterative\nfunc fibonacciIterative(n int) int {\n    if n <= 1 {\n        return n\n    }\n    a, b := 0, 1\n    for i := 2; i <= n; i++ {\n        a, b = b, a+b\n    }\n    return b\n}\n",u="public class Fibonacci {\n\n  // Recursive\n  public static int fibonacciRecursive(int n) {\n    if (n <= 1) {\n      return n;\n    }\n    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);\n  }\n\n  // Iterative\n  public static int fibonacciIterative(int n) {\n    if (n <= 1) {\n      return n;\n    }\n    int a = 0, b = 1;\n    for (int i = 2; i <= n; i++) {\n      int temp = b;\n      b = a + b;\n      a = temp;\n    }\n    return b;\n  }\n}\n",d="// Recursive\nfunction fibonacciRecursive(n) {\n  if (n <= 1) {\n    return n;\n  }\n  return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);\n}\n\n// Iterative\nfunction fibonacciIterative(n) {\n  if (n <= 1) {\n    return n;\n  }\n  let a = 0, b = 1;\n  for (let i = 2; i <= n; i++) {\n    let temp = b;\n    b = a + b;\n    a = temp;\n  }\n  return b;\n}\n",b="// Recursive\nfun fibonacciRecursive(n: Int): Int {\n    return if (n <= 1) n else fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2)\n}\n\n// Iterative\nfun fibonacciIterative(n: Int): Int {\n    if (n <= 1) return n\n    var a = 0\n    var b = 1\n    var temp: Int\n    for (i in 2..n) {\n        temp = b\n        b += a\n        a = temp\n    }\n    return b\n}\n",h="# Recursive\ndef fibonacciRecursive(n):\n    if n <= 1:\n        return n\n    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2)\n\n# Iterative\ndef fibonacciIterative(n):\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n",f="// Recursive\nfn fibonacci_recursive(n: i32) -> i32 {\n    if n <= 1 {\n        n\n    } else {\n        fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n    }\n}\n\n// Iterative\nfn fibonacci_iterative(n: i32) -> i32 {\n    if n <= 1 {\n        return n;\n    }\n    let mut a = 0;\n    let mut b = 1;\n    for _ in 2..=n {\n        let temp = b;\n        b += a;\n        a = temp;\n    }\n    b\n}\n",m="// Recursive\nfunction fibonacciRecursive(n: number): number {\n  if (n <= 1) return n;\n  return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);\n}\n\n// Iterative\nfunction fibonacciIterative(n: number): number {\n  if (n <= 1) return n;\n  let a = 0,\n    b = 1;\n  for (let i = 2; i <= n; i++) {\n    let temp = b;\n    b = a + b;\n    a = temp;\n  }\n  return b;\n}\n",v={title:"Fibonacci Number",description:"Fibonacci Number",hide_table_of_contents:!0},p=void 0,g={},j=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function x(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,t.jsxs)(a.A,{queryString:"primary",children:[(0,t.jsx)(s.A,{value:"definition",label:"Definition",children:(0,t.jsx)(e.p,{children:"The Fibonacci number algorithm generates a sequence of numbers known as the Fibonacci sequence, where each number is the sum of the two preceding ones, starting with 0 and 1"})}),(0,t.jsx)(s.A,{value:"how",label:"Explanation",children:(0,t.jsxs)(e.p,{children:["To compute the nth Fibonacci number, a function named ",(0,t.jsx)(e.code,{children:"fibonacci"})," is created, accepting an integer parameter ",(0,t.jsx)(e.code,{children:"n"}),". Inside this function, a base case is established: if ",(0,t.jsx)(e.code,{children:"n"})," is 0 or 1, the function returns ",(0,t.jsx)(e.code,{children:"n"}),". Otherwise, the function recursively calls itself with ",(0,t.jsx)(e.code,{children:"n - 1"})," and ",(0,t.jsx)(e.code,{children:"n - 2"}),", adding their results together. This recursive process continues until reaching the base case. Finally, the sum obtained from these recursive calls is returned as the nth Fibonacci number"]})}),(0,t.jsx)(s.A,{value:"guidance",label:"Guidance",children:(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Start with ",(0,t.jsx)(e.code,{children:"a = 0"})," and ",(0,t.jsx)(e.code,{children:"b = 1"})]}),"\n",(0,t.jsxs)(e.li,{children:["Iterate ",(0,t.jsx)(e.code,{children:"n"})," times (where ",(0,t.jsx)(e.code,{children:"n"})," is the desired Fibonacci number's position)","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["update ",(0,t.jsx)(e.code,{children:"temp"})," to ",(0,t.jsx)(e.code,{children:"a"})]}),"\n",(0,t.jsxs)(e.li,{children:["set ",(0,t.jsx)(e.code,{children:"a"})," to ",(0,t.jsx)(e.code,{children:"b"})]}),"\n",(0,t.jsxs)(e.li,{children:["update ",(0,t.jsx)(e.code,{children:"b"})," to ",(0,t.jsx)(e.code,{children:"temp + b"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["Return the value of ",(0,t.jsx)(e.code,{children:"a"})]}),"\n"]})}),(0,t.jsx)(s.A,{value:"tips",label:"Tips",children:(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"use dynamic programming for better efficiency"}),"\n",(0,t.jsx)(e.li,{children:"avoid recursive approaches for large values of n due to stack overflow"}),"\n"]})})]}),"\n",(0,t.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,t.jsxs)(a.A,{queryString:"primary",children:[(0,t.jsx)(s.A,{value:"practice",label:"Practice",children:(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"fibonacci(n):\n  if n <= 1:\n    return n\n  else:\n    return fibonacci(n - 1) + fibonacci(n - 2)\n"})})}),(0,t.jsx)(s.A,{value:"solution",label:"Solution",children:(0,t.jsxs)(a.A,{queryString:"code",children:[(0,t.jsx)(s.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,t.jsx)(l.A,{language:"go",children:o})}),(0,t.jsx)(s.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,t.jsx)(l.A,{language:"java",children:u})}),(0,t.jsx)(s.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,t.jsx)(l.A,{language:"js",children:d})}),(0,t.jsx)(s.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,t.jsx)(l.A,{language:"kotlin",children:b})}),(0,t.jsx)(s.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,t.jsx)(l.A,{language:"python",children:h})}),(0,t.jsx)(s.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,t.jsx)(l.A,{language:"rust",children:f})}),(0,t.jsx)(s.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,t.jsx)(l.A,{language:"ts",children:m})})]})})]})]})}function R(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(x,{...n})}):x(n)}}}]);