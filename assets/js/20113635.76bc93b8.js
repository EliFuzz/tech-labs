"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[2483],{4336:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>k,default:()=>N,frontMatter:()=>f,metadata:()=>y,toc:()=>x});var i=t(11527),a=t(84135),s=t(40521),d=t(74109),o=t(80035);const l='package main\n\nimport (\n\t"container/list"\n)\n\ntype LRUCacheOnMap struct {\n\tcapacity int\n\titems    map[interface{}]interface{}\n}\n\nfunc NewLRUCacheOnMap(capacity int) *LRUCacheOnMap {\n\treturn &LRUCacheOnMap{\n\t\tcapacity: capacity,\n\t\titems:    make(map[interface{}]interface{}),\n\t}\n}\n\nfunc (lru *LRUCacheOnMap) Get(key interface{}) interface{} {\n\tif val, ok := lru.items[key]; ok {\n\t\tdelete(lru.items, key)\n\t\tlru.items[key] = val\n\t\treturn val\n\t}\n\treturn nil\n}\n\nfunc (lru *LRUCacheOnMap) Set(key, val interface{}) {\n\tdelete(lru.items, key)\n\tlru.items[key] = val\n\tif len(lru.items) > lru.capacity {\n\t\tfor headKey := range lru.items {\n\t\t\tdelete(lru.items, headKey)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\ntype LinkedListNode struct {\n\tkey, val  interface{}\n\tprev, next *LinkedListNode\n}\n\ntype LRUCache struct {\n\tcapacity int\n\tnodesMap map[interface{}]*LinkedListNode\n\tsize     int\n\thead     *LinkedListNode\n\ttail     *LinkedListNode\n}\n\nfunc NewLRUCache(capacity int) *LRUCache {\n\thead := &LinkedListNode{}\n\ttail := &LinkedListNode{}\n\thead.next = tail\n\ttail.prev = head\n\n\treturn &LRUCache{\n\t\tcapacity: capacity,\n\t\tnodesMap: make(map[interface{}]*LinkedListNode),\n\t\tsize:     0,\n\t\thead:     head,\n\t\ttail:     tail,\n\t}\n}\n\nfunc (lru *LRUCache) Get(key interface{}) interface{} {\n\tif node, ok := lru.nodesMap[key]; ok {\n\t\tlru.promote(node)\n\t\treturn node.val\n\t}\n\treturn nil\n}\n\nfunc (lru *LRUCache) Set(key, val interface{}) {\n\tif node, ok := lru.nodesMap[key]; ok {\n\t\tnode.val = val\n\t\tlru.promote(node)\n\t} else {\n\t\tnode := &LinkedListNode{key: key, val: val}\n\t\tlru.append(node)\n\t}\n}\n\nfunc (lru *LRUCache) promote(node *LinkedListNode) {\n\tlru.evict(node)\n\tlru.append(node)\n}\n\nfunc (lru *LRUCache) append(node *LinkedListNode) {\n\tlru.nodesMap[node.key] = node\n\n\toldTail := lru.tail.prev\n\toldTail.next = node\n\tnode.prev = oldTail\n\tnode.next = lru.tail\n\tlru.tail.prev = node\n\n\tlru.size++\n\n\tif lru.size > lru.capacity {\n\t\tlru.evict(lru.head.next)\n\t}\n}\n\nfunc (lru *LRUCache) evict(node *LinkedListNode) {\n\tdelete(lru.nodesMap, node.key)\n\tlru.size--\n\n\tprevNode := node.prev\n\tnextNode := node.next\n\n\tprevNode.next = nextNode\n\tnextNode.prev = prevNode\n}\n',r="import java.util.HashMap;\nimport java.util.Map;\n\nclass LRUCacheOnMap {\n\n  private final int capacity;\n  private final Map<Object, Object> items;\n\n  public LRUCacheOnMap(int capacity) {\n    this.capacity = capacity;\n    this.items = new HashMap<>();\n  }\n\n  public Object get(Object key) {\n    if (!items.containsKey(key)) {\n      return null;\n    }\n    Object val = items.remove(key);\n    items.put(key, val);\n    return val;\n  }\n\n  public void set(Object key, Object val) {\n    items.remove(key);\n    items.put(key, val);\n    if (items.size() > capacity) {\n      for (Object headKey : items.keySet()) {\n        items.remove(headKey);\n        break;\n      }\n    }\n  }\n}\n\nclass LinkedListNode {\n\n  public Object key;\n  public Object val;\n  public LinkedListNode prev;\n  public LinkedListNode next;\n\n  public LinkedListNode(Object key, Object val, LinkedListNode prev, LinkedListNode next) {\n    this.key = key;\n    this.val = val;\n    this.prev = prev;\n    this.next = next;\n  }\n}\n\nclass LRUCache {\n\n  private final int capacity;\n  private final Map<Object, LinkedListNode> nodesMap;\n  private final LinkedListNode head;\n  private final LinkedListNode tail;\n  private int size;\n\n  public LRUCache(int capacity) {\n    this.capacity = capacity;\n    this.nodesMap = new HashMap<>();\n    this.size = 0;\n    this.head = new LinkedListNode(null, null, null, null);\n    this.tail = new LinkedListNode(null, null, null, null);\n    this.head.next = tail;\n    this.tail.prev = head;\n  }\n\n  public Object get(Object key) {\n    if (!nodesMap.containsKey(key)) {\n      return null;\n    }\n    LinkedListNode node = nodesMap.get(key);\n    promote(node);\n    return node.val;\n  }\n\n  public void set(Object key, Object val) {\n    if (nodesMap.containsKey(key)) {\n      LinkedListNode node = nodesMap.get(key);\n      node.val = val;\n      promote(node);\n    } else {\n      LinkedListNode node = new LinkedListNode(key, val, null, null);\n      append(node);\n    }\n  }\n\n  private void promote(LinkedListNode node) {\n    evict(node);\n    append(node);\n  }\n\n  private void append(LinkedListNode node) {\n    nodesMap.put(node.key, node);\n\n    LinkedListNode oldTail = tail.prev;\n    oldTail.next = node;\n    node.prev = oldTail;\n    node.next = tail;\n    tail.prev = node;\n\n    size += 1;\n\n    if (size > capacity) {\n      evict(head.next);\n    }\n  }\n\n  private void evict(LinkedListNode node) {\n    nodesMap.remove(node.key);\n    size -= 1;\n\n    LinkedListNode prevNode = node.prev;\n    LinkedListNode nextNode = node.next;\n\n    prevNode.next = nextNode;\n    nextNode.prev = prevNode;\n  }\n}\n",c="class LRUCacheOnMap {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.items = new Map();\n  }\n\n  get(key) {\n    if (!this.items.has(key)) {\n      return undefined;\n    }\n    const val = this.items.get(key);\n    this.items.delete(key);\n    this.items.set(key, val);\n    return val;\n  }\n\n  set(key, val) {\n    this.items.delete(key);\n    this.items.set(key, val);\n    if (this.items.size > this.capacity) {\n      for (const headKey of this.items.keys()) {\n        this.items.delete(headKey);\n        break;\n      }\n    }\n  }\n}\n\nclass LinkedListNode {\n  constructor(key, val, prev = null, next = null) {\n    this.key = key;\n    this.val = val;\n    this.prev = prev;\n    this.next = next;\n  }\n}\n\nclass LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.nodesMap = {};\n    this.size = 0;\n    this.head = new LinkedListNode();\n    this.tail = new LinkedListNode();\n  }\n\n  get(key) {\n    if (this.nodesMap[key] === undefined) {\n      return undefined;\n    }\n    const node = this.nodesMap[key];\n    this.promote(node);\n    return node.val;\n  }\n\n  set(key, val) {\n    if (this.nodesMap[key]) {\n      const node = this.nodesMap[key];\n      node.val = val;\n      this.promote(node);\n    } else {\n      const node = new LinkedListNode(key, val);\n      this.append(node);\n    }\n  }\n\n  promote(node) {\n    this.evict(node);\n    this.append(node);\n  }\n\n  append(node) {\n    this.nodesMap[node.key] = node;\n\n    if (!this.head.next) {\n      this.head.next = node;\n      this.tail.prev = node;\n      node.prev = this.head;\n      node.next = this.tail;\n    } else {\n      const oldTail = this.tail.prev;\n      oldTail.next = node;\n      node.prev = oldTail;\n      node.next = this.tail;\n      this.tail.prev = node;\n    }\n\n    this.size += 1;\n\n    if (this.size > this.capacity) {\n      this.evict(this.head.next);\n    }\n  }\n\n  evict(node) {\n    delete this.nodesMap[node.key];\n    this.size -= 1;\n\n    const prevNode = node.prev;\n    const nextNode = node.next;\n\n    if (prevNode === this.head && nextNode === this.tail) {\n      this.head.next = null;\n      this.tail.prev = null;\n      this.size = 0;\n      return;\n    }\n\n    if (prevNode === this.head) {\n      nextNode.prev = this.head;\n      this.head.next = nextNode;\n      return;\n    }\n\n    if (nextNode === this.tail) {\n      prevNode.next = this.tail;\n      this.tail.prev = prevNode;\n      return;\n    }\n\n    prevNode.next = nextNode;\n    nextNode.prev = prevNode;\n  }\n}\n",p="class LRUCacheOnMap(private val capacity: Int) {\n    private val items = mutableMapOf<Any, Any>()\n\n    fun get(key: Any): Any? {\n        if (!items.containsKey(key)) return null\n        val value = items.remove(key)\n        items[key] = value!!\n        return value\n    }\n\n    fun set(key: Any, value: Any) {\n        items.remove(key)\n        items[key] = value\n        if (items.size > capacity) {\n            val headKey = items.keys.firstOrNull()\n            items.remove(headKey)\n        }\n    }\n}\n\nclass LinkedListNode(\n        val key: Any,\n        val value: Any,\n        var prev: LinkedListNode? = null,\n        var next: LinkedListNode? = null\n)\n\nclass LRUCache(private val capacity: Int) {\n    private val nodesMap = mutableMapOf<Any, LinkedListNode>()\n    private var size = 0\n    private val head = LinkedListNode(0, 0)\n    private val tail = LinkedListNode(0, 0)\n\n    fun get(key: Any): Any? {\n        if (!nodesMap.containsKey(key)) return null\n        val node = nodesMap[key]!!\n        promote(node)\n        return node.value\n    }\n\n    fun set(key: Any, value: Any) {\n        if (nodesMap.containsKey(key)) {\n            val node = nodesMap[key]!!\n            node.value = value\n            promote(node)\n        } else {\n            val node = LinkedListNode(key, value)\n            append(node)\n        }\n    }\n\n    private fun promote(node: LinkedListNode) {\n        evict(node)\n        append(node)\n    }\n\n    private fun append(node: LinkedListNode) {\n        nodesMap[node.key] = node\n\n        if (head.next == null) {\n            head.next = node\n            tail.prev = node\n            node.prev = head\n            node.next = tail\n        } else {\n            val oldTail = tail.prev!!\n            oldTail.next = node\n            node.prev = oldTail\n            node.next = tail\n            tail.prev = node\n        }\n\n        size += 1\n\n        if (size > capacity) {\n            evict(head.next!!)\n        }\n    }\n\n    private fun evict(node: LinkedListNode) {\n        nodesMap.remove(node.key)\n        size -= 1\n\n        val prevNode = node.prev!!\n        val nextNode = node.next!!\n\n        if (prevNode == head && nextNode == tail) {\n            head.next = null\n            tail.prev = null\n            size = 0\n            return\n        }\n\n        if (prevNode == head) {\n            nextNode.prev = head\n            head.next = nextNode\n            return\n        }\n\n        if (nextNode == tail) {\n            prevNode.next = tail\n            tail.prev = prevNode\n            return\n        }\n\n        prevNode.next = nextNode\n        nextNode.prev = prevNode\n    }\n}\n",h="class LRUCacheOnMap:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.items = {}\n\n    def get(self, key):\n        if key not in self.items:\n            return None\n        val = self.items.pop(key)\n        self.items[key] = val\n        return val\n\n    def set(self, key, val):\n        if key in self.items:\n            del self.items[key]\n        self.items[key] = val\n        if len(self.items) > self.capacity:\n            head_key = next(iter(self.items))\n            del self.items[head_key]\n\n\nclass LinkedListNode:\n    def __init__(self, key, val, prev=None, next=None):\n        self.key = key\n        self.val = val\n        self.prev = prev\n        self.next = next\n\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.nodes_map = {}\n        self.size = 0\n        self.head = LinkedListNode(None, None)\n        self.tail = LinkedListNode(None, None)\n\n    def get(self, key):\n        if key not in self.nodes_map:\n            return None\n        node = self.nodes_map[key]\n        self.promote(node)\n        return node.val\n\n    def set(self, key, val):\n        if key in self.nodes_map:\n            node = self.nodes_map[key]\n            node.val = val\n            self.promote(node)\n        else:\n            node = LinkedListNode(key, val)\n            self.append(node)\n\n    def promote(self, node):\n        self.evict(node)\n        self.append(node)\n\n    def append(self, node):\n        self.nodes_map[node.key] = node\n\n        if not self.head.next:\n            self.head.next = node\n            self.tail.prev = node\n            node.prev = self.head\n            node.next = self.tail\n        else:\n            old_tail = self.tail.prev\n            old_tail.next = node\n            node.prev = old_tail\n            node.next = self.tail\n            self.tail.prev = node\n\n        self.size += 1\n\n        if self.size > self.capacity:\n            self.evict(self.head.next)\n\n    def evict(self, node):\n        if node:\n            del self.nodes_map[node.key]\n            self.size -= 1\n\n            prev_node = node.prev\n            next_node = node.next\n\n            if prev_node == self.head and next_node == self.tail:\n                self.head.next = None\n                self.tail.prev = None\n                self.size = 0\n                return\n\n            if prev_node == self.head:\n                next_node.prev = self.head\n                self.head.next = next_node\n                return\n\n            if next_node == self.tail:\n                prev_node.next = self.tail\n                self.tail.prev = prev_node\n                return\n\n            prev_node.next = next_node\n            next_node.prev = prev_node\n",v='use std::collections::{HashMap, LinkedList};\n\nstruct LRUCacheOnMap {\n    capacity: usize,\n    items: HashMap<String, i32>,\n}\n\nimpl LRUCacheOnMap {\n    fn new(capacity: usize) -> Self {\n        LRUCacheOnMap {\n            capacity,\n            items: HashMap::new(),\n        }\n    }\n\n    fn get(&mut self, key: &str) -> Option<i32> {\n        if let Some(val) = self.items.remove(key) {\n            self.items.insert(key.to_string(), val);\n            Some(val)\n        } else {\n            None\n        }\n    }\n\n    fn set(&mut self, key: &str, val: i32) {\n        self.items.remove(key);\n        self.items.insert(key.to_string(), val);\n\n        if self.items.len() > self.capacity {\n            if let Some(head_key) = self.items.keys().next().cloned() {\n                self.items.remove(&head_key);\n            }\n        }\n    }\n}\n\nstruct LinkedListNode {\n    key: String,\n    val: i32,\n    prev: Option<Box<LinkedListNode>>,\n    next: Option<Box<LinkedListNode>>,\n}\n\nimpl LinkedListNode {\n    fn new(key: String, val: i32, prev: Option<Box<LinkedListNode>>, next: Option<Box<LinkedListNode>>) -> Self {\n        LinkedListNode { key, val, prev, next }\n    }\n}\n\nstruct LRUCache {\n    capacity: usize,\n    nodes_map: HashMap<String, Box<LinkedListNode>>,\n    size: usize,\n    head: Box<LinkedListNode>,\n    tail: Box<LinkedListNode>,\n}\n\nimpl LRUCache {\n    fn new(capacity: usize) -> Self {\n        let head = Box::new(LinkedListNode::new("".to_string(), 0, None, None));\n        let tail = Box::new(LinkedListNode::new("".to_string(), 0, None, None));\n\n        LRUCache {\n            capacity,\n            nodes_map: HashMap::new(),\n            size: 0,\n            head: head.clone(),\n            tail: tail.clone(),\n        }\n    }\n\n    fn get(&mut self, key: &str) -> Option<i32> {\n        if let Some(node) = self.nodes_map.get_mut(key) {\n            self.promote(node);\n            Some(node.val)\n        } else {\n            None\n        }\n    }\n\n    fn set(&mut self, key: &str, val: i32) {\n        if let Some(node) = self.nodes_map.get_mut(key) {\n            node.val = val;\n            self.promote(node);\n        } else {\n            let node = Box::new(LinkedListNode::new(key.to_string(), val, None, None));\n            self.append(node);\n        }\n    }\n\n    fn promote(&mut self, node: &mut Box<LinkedListNode>) {\n        self.evict(node);\n        self.append(node.clone());\n    }\n\n    fn append(&mut self, mut node: Box<LinkedListNode>) {\n        self.nodes_map.insert(node.key.clone(), node.clone());\n\n        if self.head.next.is_none() {\n            self.head.next = Some(node.clone());\n            self.tail.prev = Some(node.clone());\n            node.prev = Some(self.head.clone());\n            node.next = Some(self.tail.clone());\n        } else {\n            let old_tail = self.tail.prev.take().unwrap();\n            old_tail.next = Some(node.clone());\n            node.prev = Some(old_tail.clone());\n            node.next = Some(self.tail.clone());\n            self.tail.prev = Some(node.clone());\n        }\n\n        self.size += 1;\n\n        if self.size > self.capacity {\n            self.evict(self.head.next.as_deref().unwrap());\n        }\n    }\n\n    fn evict(&mut self, node: Option<&Box<LinkedListNode>>) {\n        if let Some(node) = node {\n            self.nodes_map.remove(&node.key);\n            self.size -= 1;\n\n            let prev_node = node.prev.as_deref().unwrap();\n            let next_node = node.next.as_deref().unwrap();\n\n            if prev_node == &self.head && next_node == &self.tail {\n                self.head.next = None;\n                self.tail.prev = None;\n                self.size = 0;\n                return;\n            }\n\n            if prev_node == &self.head {\n                next_node.prev = Some(self.head.clone());\n                self.head.next = Some(next_node.clone());\n                return;\n            }\n\n            if next_node == &self.tail {\n                prev_node.next = Some(self.tail.clone());\n                self.tail.prev = Some(prev_node.clone());\n                return;\n            }\n\n            prev_node.next = Some(next_node.clone());\n            next_node.prev = Some(prev_node.clone());\n        }\n    }\n}\n',u='class LRUCacheOnMap {\n  private capacity: number;\n  private items: Map<string, any>;\n\n  constructor(capacity: number) {\n    this.capacity = capacity;\n    this.items = new Map<string, any>();\n  }\n\n  get(key: string): any | undefined {\n    if (!this.items.has(key)) {\n      return undefined;\n    }\n    const val = this.items.get(key);\n    this.items.delete(key);\n    this.items.set(key, val);\n    return val;\n  }\n\n  set(key: string, val: any): void {\n    this.items.delete(key);\n    this.items.set(key, val);\n    if (this.items.size > this.capacity) {\n      for (const headKey of this.items.keys()) {\n        this.items.delete(headKey);\n        break;\n      }\n    }\n  }\n}\n\nclass LinkedListNode {\n  public key: string;\n  public val: any;\n  public prev: LinkedListNode | null;\n  public next: LinkedListNode | null;\n\n  constructor(\n    key: string,\n    val: any,\n    prev: LinkedListNode | null = null,\n    next: LinkedListNode | null = null,\n  ) {\n    this.key = key;\n    this.val = val;\n    this.prev = prev;\n    this.next = next;\n  }\n}\n\nclass LRUCache {\n  private capacity: number;\n  private nodesMap: { [key: string]: LinkedListNode };\n  private size: number;\n  private head: LinkedListNode;\n  private tail: LinkedListNode;\n\n  constructor(capacity: number) {\n    this.capacity = capacity;\n    this.nodesMap = {};\n    this.size = 0;\n    this.head = new LinkedListNode("", null);\n    this.tail = new LinkedListNode("", null);\n  }\n\n  get(key: string): any | undefined {\n    if (this.nodesMap[key] === undefined) {\n      return undefined;\n    }\n    const node = this.nodesMap[key];\n    this.promote(node);\n    return node.val;\n  }\n\n  set(key: string, val: any): void {\n    if (this.nodesMap[key]) {\n      const node = this.nodesMap[key];\n      node.val = val;\n      this.promote(node);\n    } else {\n      const node = new LinkedListNode(key, val);\n      this.append(node);\n    }\n  }\n\n  private promote(node: LinkedListNode): void {\n    this.evict(node);\n    this.append(node);\n  }\n\n  private append(node: LinkedListNode): void {\n    this.nodesMap[node.key] = node;\n\n    if (!this.head.next) {\n      this.head.next = node;\n      this.tail.prev = node;\n      node.prev = this.head;\n      node.next = this.tail;\n    } else {\n      const oldTail = this.tail.prev as LinkedListNode;\n      oldTail.next = node;\n      node.prev = oldTail;\n      node.next = this.tail;\n      this.tail.prev = node;\n    }\n\n    this.size += 1;\n\n    if (this.size > this.capacity) {\n      this.evict(this.head.next as LinkedListNode);\n    }\n  }\n\n  private evict(node: LinkedListNode): void {\n    delete this.nodesMap[node.key];\n    this.size -= 1;\n\n    const prevNode = node.prev as LinkedListNode;\n    const nextNode = node.next as LinkedListNode;\n\n    if (prevNode === this.head && nextNode === this.tail) {\n      this.head.next = null;\n      this.tail.prev = null;\n      this.size = 0;\n      return;\n    }\n\n    if (prevNode === this.head) {\n      nextNode.prev = this.head;\n      this.head.next = nextNode;\n      return;\n    }\n\n    if (nextNode === this.tail) {\n      prevNode.next = this.tail;\n      this.tail.prev = prevNode;\n      return;\n    }\n\n    prevNode.next = nextNode;\n    nextNode.prev = prevNode;\n  }\n}\n',f={title:"LRU Cache",description:"LRU Cache Data Structure",hide_table_of_contents:!0},k=void 0,y={id:"education/computer-science/data-structures/basic/lru-cache",title:"LRU Cache",description:"LRU Cache Data Structure",source:"@site/docs/education/01-computer-science/09-data-structures/02-basic/20-lru-cache.mdx",sourceDirName:"education/01-computer-science/09-data-structures/02-basic",slug:"/education/computer-science/data-structures/basic/lru-cache",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/lru-cache",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/20-lru-cache.mdx",tags:[],version:"current",sidebarPosition:20,frontMatter:{title:"LRU Cache",description:"LRU Cache Data Structure",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Bloom Filter",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/bloom-filter"},next:{title:"Algorithms",permalink:"/tech-labs/docs/category/algorithms"}},m={},x=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function L(e){const n={code:"code",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components},{Details:f}=n;return f||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{src:t(7369).Z+""})}),"\n",(0,i.jsxs)("table",{children:[(0,i.jsxs)("thead",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Space"}),(0,i.jsx)("th",{colspan:"4",children:"Time"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{}),(0,i.jsx)("th",{children:"Access"}),(0,i.jsx)("th",{children:"Lookup"}),(0,i.jsx)("th",{children:"Insertion"}),(0,i.jsx)("th",{children:"Deletion"})]})]}),(0,i.jsx)("tbody",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"fair",children:"O(n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"good",children:"O(log n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"good",children:"O(log n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"good",children:"O(log n)"})})]})})]}),"\n",(0,i.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(s.Z,{children:[(0,i.jsxs)(d.Z,{value:"short",label:"Short",children:[(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LRU Cache"})," is a cache data structure that evicts the least recently used item when it is full."]}),(0,i.jsxs)(f,{children:[(0,i.jsx)("summary",{children:"Simplified"}),(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"LRU Cache"})," is like a clothes rack. It holds a limited amount of data. When new data comes in, it removes the least recently used data, similar to removing the least worn clothing from a full\nrack to make room for a new one. This keeps frequently used data quickly accessible."]})]})]}),(0,i.jsx)(d.Z,{value:"detailed",label:"Detailed",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"Least Recently Used (LRU) Cache"})," is a cache replacement algorithm that discards the least recently used items first. It can be implemented using a combination of a doubly linked list and a\nhash map for quick access and efficient operations or ordered map."]})})]}),"\n",(0,i.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(s.Z,{children:[(0,i.jsx)(d.Z,{value:"practice",label:"Practice",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{children:"Pseudo Code"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"LRU Cache on Map"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"get(key):\n  if key not in items:\n    return \xf8\n  value = items.get(key)\n  items.delete(key)\n  items.set(key, value)\n  return value\n\nset(key, value):\n  items.delete(key)\n  items.set(key, value)\n  if items.size > capacity:\n    for each head_key in items.keys():\n      items.delete(head_key)\n      break\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"LRU Cache on Linked List"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"get(key):\n  if nodes_map[key] == \xf8:\n    return \xf8\n  node = nodes_map[key]\n  promote(node)\n  return node.value\n\nset(key, value):\n  if nodes_map[key] == \xf8:\n    node = LinkedListNode(key, value)\n    append(node)\n  else:\n    node = nodes_map[key]\n    node.value = value\n    promote(node)\n\npromote(node):\n  evict(node)\n  append(node)\n\nappend(node):\n  nodes_map[node.key] = node\n  if head.next != \xf8:\n    head.next = node\n    tail.prev = node\n    node.prev = head\n    node.next = tail\n  else:\n    old_tail = tail.prev\n    old_tail.next = node\n    node.prev = old_tail\n    node.next = tail\n    tail.prev = node\n    size += 1\n    if size > capacity:\n      evict(head.next)\n\nevict(node):\n  delete nodes_map[node.key]\n  size -= 1\n  prev_node = node.prev\n  next_node = node.next\n  if prev_node == head and next_node == tail:\n    head.next = \xf8\n    tail.prev = \xf8\n    size = 0\n  else if prev_node == head:\n    next_node.prev = head\n    head.next = next_node\n  else if next_node == tail:\n    prev_node.next = tail\n    tail.prev = prev_node\n  else:\n    prev_node.next = next_node\n    next_node.prev = prev_node\n"})})})]})]})]})}),(0,i.jsx)(d.Z,{value:"solution",label:"Solution",children:(0,i.jsxs)(s.Z,{queryString:"code",children:[(0,i.jsx)(d.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(o.Z,{language:"go",children:l})}),(0,i.jsx)(d.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(o.Z,{language:"java",children:r})}),(0,i.jsx)(d.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(o.Z,{language:"js",children:c})}),(0,i.jsx)(d.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(o.Z,{language:"kotlin",children:p})}),(0,i.jsx)(d.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(o.Z,{language:"python",children:h})}),(0,i.jsx)(d.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(o.Z,{language:"rust",children:v})}),(0,i.jsx)(d.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(o.Z,{language:"ts",children:u})})]})})]})]})}function N(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(L,{...e})}):L(e)}},7369:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/lruCache-7dfc69f7e915a8ee0c80da2f90da300e.svg"}}]);