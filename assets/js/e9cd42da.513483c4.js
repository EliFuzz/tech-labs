"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[8147],{91984:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>j,contentTitle:()=>x,default:()=>N,frontMatter:()=>g,metadata:()=>m,toc:()=>f});var a=n(11527),r=n(84135),i=n(40521),s=n(74109),l=n(80035);const c='package main\n\ntype Node struct {\n    data int\n    next *Node\n}\n\nfunc traverseList(head *Node) {\n    current := head\n    for current != nil {\n        fmt.Print(current.data, " ")\n        current = current.next\n    }\n}\n',o='class Node {\n\n  int data;\n  Node next;\n\n  Node(int data) {\n    this.data = data;\n    next = null;\n  }\n}\n\nclass LinkedListTraversal {\n\n  static void traverseList(Node head) {\n    Node current = head;\n    while (current != null) {\n      System.out.print(current.data + " ");\n      current = current.next;\n    }\n  }\n}\n',d="class Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\nfunction traverseList(head) {\n  let current = head;\n  while (current !== null) {\n    console.log(current.data);\n    current = current.next;\n  }\n}\n",h='class Node(var data: Int) {\n    var next: Node? = null\n}\n\nfun traverseList(head: Node?) {\n    var current = head\n    while (current != null) {\n        print("${current.data} ")\n        current = current.next\n    }\n}\n',u="class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef traverse_list(head):\n    current = head\n    while current:\n        print(current.data, end=' ')\n        current = current.next\n",p='struct Node {\n    data: i32,\n    next: Option<Box<Node>>,\n}\n\nimpl Node {\n    fn new(data: i32) -> Self {\n        Node { data, next: None }\n    }\n}\n\nfn traverse_list(mut head: Option<Box<Node>>) {\n    while let Some(node) = head {\n        println!("{}", node.data);\n        head = node.next;\n    }\n}\n',v="class Node {\n  data: number;\n  next: Node | null;\n\n  constructor(data: number) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\nfunction traverseList(head: Node | null): void {\n  let current: Node | null = head;\n  while (current !== null) {\n    console.log(current.data);\n    current = current.next;\n  }\n}\n",g={title:"Straight Traversal",description:"Straight Traversal",hide_table_of_contents:!0},x=void 0,m={id:"education/computer-science/algorithms/algo/straight-traversal",title:"Straight Traversal",description:"Straight Traversal",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/straight-traversal.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/straight-traversal",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/straight-traversal",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/straight-traversal.mdx",tags:[],version:"current",frontMatter:{title:"Straight Traversal",description:"Straight Traversal",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Square Root - Newton's method",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/square-root-newtons-method"},next:{title:"Strongly Connected Components - Kosaraju's Algorithm",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/strongly-connected-components-kosarajus-algorithm"}},j={},f=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function b(e){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"definition",children:"Definition"}),"\n",(0,a.jsxs)(i.Z,{children:[(0,a.jsx)(s.Z,{value:"definition",label:"Definition",children:(0,a.jsx)(t.p,{children:"The Straight Traversal Algorithm is a method used in graph theory to traverse a graph by moving along edges in a straight path from one vertex to another, without revisiting any vertices"})}),(0,a.jsx)(s.Z,{value:"how",label:"Explanation",children:(0,a.jsx)(t.p,{children:"Select a starting vertex. Then explores adjacent vertices in a systematic manner, without revisiting any vertices already visited. The algorithm employs a data structure to keep track of visited vertices and the current path. It continues until all reachable vertices have been visited or until a specific condition is met. The choice of data structure (stack or queue) may affect the order in which vertices are visited"})}),(0,a.jsx)(s.Z,{value:"guidance",label:"Guidance",children:(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Select a vertex to start the traversal"}),"\n",(0,a.jsxs)(t.li,{children:["Initialize a data structure to keep track of visited vertices and the current path","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Explore the neighbors of the current vertex"}),"\n",(0,a.jsx)(t.li,{children:"Select the next vertex to visit based on a specific criteria (e.g., alphabetical order, distance, etc.)"}),"\n",(0,a.jsx)(t.li,{children:"Update the data structures to mark the current vertex as visited and add it to the path"}),"\n",(0,a.jsx)(t.li,{children:"Repeat the process until all reachable vertices have been visited"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.li,{children:"Terminate the algorithm when all vertices have been visited or when a specific condition is met"}),"\n"]})}),(0,a.jsx)(s.Z,{value:"tips",label:"Tips",children:(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"consider different strategies for selecting the next vertex to visit, such as depth-first or breadth-first"}),"\n",(0,a.jsx)(t.li,{children:"implement mechanisms to detect and handle cycles in the graph to prevent infinite loops"}),"\n",(0,a.jsx)(t.li,{children:"ensure the graph is properly represented to facilitate efficient traversal"}),"\n"]})})]}),"\n",(0,a.jsx)(t.h2,{id:"practice",children:"Practice"}),"\n",(0,a.jsxs)(i.Z,{children:[(0,a.jsx)(s.Z,{value:"practice",label:"Practice",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:"straightTraversal(graph, startVertex):\n  stack = empty stack\n  visited = set() // Set to keep track of visited vertices\n  path = empty list\n\n  stack.push(startVertex)\n\n  while stack is not empty:\n    currentVertex = stack.pop()\n\n    if currentVertex is not in visited:\n      add currentVertex to visited set\n      add currentVertex to path list\n\n      for each neighbor in graph.adjacent(currentVertex):\n        if neighbor is not in visited:\n          stack.push(neighbor)\n\n  return path\n"})})}),(0,a.jsx)(s.Z,{value:"solution",label:"Solution",children:(0,a.jsxs)(i.Z,{queryString:"code",children:[(0,a.jsx)(s.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,a.jsx)(l.Z,{language:"go",children:c})}),(0,a.jsx)(s.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,a.jsx)(l.Z,{language:"java",children:o})}),(0,a.jsx)(s.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,a.jsx)(l.Z,{language:"js",children:d})}),(0,a.jsx)(s.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,a.jsx)(l.Z,{language:"kotlin",children:h})}),(0,a.jsx)(s.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,a.jsx)(l.Z,{language:"python",children:u})}),(0,a.jsx)(s.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,a.jsx)(l.Z,{language:"rust",children:p})}),(0,a.jsx)(s.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,a.jsx)(l.Z,{language:"ts",children:v})})]})})]})]})}function N(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(b,{...e})}):b(e)}}}]);