"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[9658],{30303:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>p,contentTitle:()=>m,default:()=>B,frontMatter:()=>h,metadata:()=>y,toc:()=>x});var i=t(86070),r=t(25710),a=t(98459),s=t(37515),l=t(18792);const o='package main\n\nimport (\n\t"encoding/binary"\n)\n\nfunc FloatAsBinaryString(floatNumber float64, byteLength int) string {\n\tvar numberAsBinaryString string\n\n\tbuf := make([]byte, byteLength)\n\tswitch byteLength {\n\tcase 4:\n\t\tbinary.LittleEndian.PutUint32(buf, math.Float32bits(float32(floatNumber)))\n\tcase 8:\n\t\tbinary.LittleEndian.PutUint64(buf, math.Float64bits(floatNumber))\n\t}\n\n\tfor _, b := range buf {\n\t\tnumberAsBinaryString += fmt.Sprintf("%08b", b)\n\t}\n\n\treturn numberAsBinaryString\n}\n',c="import java.nio.ByteBuffer;\n\npublic class Main {\n\n  public static String floatAsBinaryString(float floatNumber, int byteLength) {\n    StringBuilder numberAsBinaryString = new StringBuilder();\n\n    ByteBuffer buffer = ByteBuffer.allocate(byteLength);\n    buffer.putFloat(floatNumber);\n\n    for (byte b : buffer.array()) {\n      numberAsBinaryString.append(String.format(\"%8s\", Integer.toBinaryString(b & 0xFF)).replace(' ', '0'));\n    }\n\n    return numberAsBinaryString.toString();\n  }\n}\n",u='function floatAsBinaryString(floatNumber, byteLength = 4) {\n  const singlePrecisionBytesLength = 4; // double precision is 8\n  const bitsInByte = 8;\n  let numberAsBinaryString = "";\n\n  const arrayBuffer = new ArrayBuffer(byteLength);\n  const dataView = new DataView(arrayBuffer);\n\n  const byteOffset = 0;\n  const littleEndian = false;\n\n  if (byteLength === singlePrecisionBytesLength) {\n    dataView.setFloat32(byteOffset, floatNumber, littleEndian);\n  } else {\n    dataView.setFloat64(byteOffset, floatNumber, littleEndian);\n  }\n\n  for (let byteIndex = 0; byteIndex < byteLength; byteIndex += 1) {\n    let bits = dataView.getUint8(byteIndex).toString(2);\n    if (bits.length < bitsInByte) {\n      bits = new Array(bitsInByte - bits.length).fill("0").join("") + bits;\n    }\n    numberAsBinaryString += bits;\n  }\n\n  return numberAsBinaryString;\n}\n',b="import java.nio.ByteBuffer\n\nfun floatAsBinaryString(floatNumber: Float, byteLength: Int): String {\n    val numberAsBinaryString = StringBuilder()\n\n    val buffer = ByteBuffer.allocate(byteLength)\n    buffer.putFloat(floatNumber)\n\n    for (b in buffer.array()) {\n        numberAsBinaryString.append(String.format(\"%8s\", Integer.toBinaryString(b.toInt() and 0xFF)).replace(' ', '0'))\n    }\n\n    return numberAsBinaryString.toString()\n}\n",g="import struct\n\ndef float_as_binary_string(float_number, byte_length):\n    number_as_binary_string = \"\"\n    if byte_length == 4:\n        number_as_binary_string = format(struct.unpack('<I', struct.pack('<f', float_number))[0], '032b')\n    elif byte_length == 8:\n        number_as_binary_string = format(struct.unpack('<Q', struct.pack('<d', float_number))[0], '064b')\n    return number_as_binary_string\n",d='use std::mem;\n\nfn float_as_binary_string(float_number: f64, byte_length: usize) -> String {\n    let mut number_as_binary_string = String::new();\n    let mut bytes = [0; 8];\n\n    match byte_length {\n        4 => {\n            let float_as_bytes = float_number.to_le_bytes();\n            bytes[..4].clone_from_slice(&float_as_bytes);\n        },\n        8 => bytes = float_number.to_le_bytes(),\n        _ => panic!("Unsupported byte length"),\n    }\n\n    for byte in bytes.iter() {\n        number_as_binary_string.push_str(&format!("{:08b}", byte));\n    }\n\n    number_as_binary_string\n}\n',f='function floatAsBinaryString(\n  floatNumber: number,\n  byteLength: number = 4,\n): string {\n  let numberAsBinaryString: string = "";\n\n  const buffer: ArrayBuffer = new ArrayBuffer(byteLength);\n  const dataView: DataView = new DataView(buffer);\n\n  if (byteLength === 4) {\n    dataView.setFloat32(0, floatNumber, false);\n  } else if (byteLength === 8) {\n    dataView.setFloat64(0, floatNumber, false);\n  } else {\n    throw new Error("Unsupported byte length");\n  }\n\n  for (let byteIndex = 0; byteIndex < byteLength; byteIndex += 1) {\n    let bits = dataView.getUint8(byteIndex).toString(2);\n    if (bits.length < 8) {\n      bits = "0".repeat(8 - bits.length) + bits;\n    }\n    numberAsBinaryString += bits;\n  }\n\n  return numberAsBinaryString;\n}\n',h={title:"Binary Floating Point",description:"Binary Floating Point",hide_table_of_contents:!0},m=void 0,y={id:"education/computer-science/algorithms/algo/binary-floating-point",title:"Binary Floating Point",description:"Binary Floating Point",source:"@site/docs/education/01-computer-science/10-algorithms/04-algo/binary-floating-point.mdx",sourceDirName:"education/01-computer-science/10-algorithms/04-algo",slug:"/education/computer-science/algorithms/algo/binary-floating-point",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/binary-floating-point",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/binary-floating-point.mdx",tags:[],version:"current",frontMatter:{title:"Binary Floating Point",description:"Binary Floating Point",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Best Time To Buy Sell Stocks",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/best-time-to-buy-sell-stocks"},next:{title:"Binary Search",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/binary-search"}},p={},x=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function j(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(a.A,{queryString:"primary",children:[(0,i.jsxs)(s.A,{value:"definition",label:"Definition",children:[(0,i.jsx)(e.p,{children:"The Binary Floating Point Algorithm is a method used for representing real numbers in a binary format. It involves breaking down a real number into its binary representation consisting of a sign bit, an exponent, and a fraction (also known as mantissa). This algorithm ensures efficient storage and arithmetic operations on floating-point numbers."}),(0,i.jsxs)(e.p,{children:["Computers store floating-point numbers using the ",(0,i.jsx)(e.strong,{children:"IEEE 754"})," standard, which allows for a wider range of values, including small numbers closer to zero and also utilizes biased exponents to allow\nfor negative exponents."]}),(0,i.jsx)(e.p,{children:"This standard splits the representation of numbers into parts:"}),(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"sign"}),"\n",(0,i.jsx)(e.li,{children:"exponent"}),"\n",(0,i.jsx)(e.li,{children:"fraction"}),"\n"]}),(0,i.jsx)(e.p,{children:"Different floating-point formats allocate varying numbers of bits for each part:"}),(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"half-precision (16 bits)"}),"\n",(0,i.jsx)(e.li,{children:"single-precision (32 bits)"}),"\n",(0,i.jsx)(e.li,{children:"double-precision (64 bits)"}),"\n"]})]}),(0,i.jsx)(s.A,{value:"how",label:"Explanation",children:(0,i.jsx)(e.p,{children:"Given a real number, first determine its sign, then normalize it by adjusting its exponent and fraction, convert the normalized components into binary, combine them to form the floating-point representation, and finally output this binary representation"})}),(0,i.jsx)(s.A,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Extract Sign","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"if the number is positive, set the sign bit to 0 else set it to 1"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Normalize","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"determine the exponent required to represent the number accurately. Adjust the fraction accordingly"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Convert to Binary","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"convert the sign bit, exponent, and fraction into their binary representations"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Combine Components","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"concatenate the binary representations of the sign, exponent, and fraction"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Output","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"output the combined binary representation as the binary floating-point format of the input number"}),"\n"]}),"\n"]}),"\n"]})}),(0,i.jsx)(s.A,{value:"tips",label:"Tips",children:(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"ensure proper handling of special cases like zero, infinity, and NaN (Not a Number)"}),"\n",(0,i.jsx)(e.li,{children:"consider the precision requirements of the application to determine the number of bits allocated for the exponent and fraction"}),"\n",(0,i.jsx)(e.li,{children:"implement proper rounding techniques to minimize errors in floating-point arithmetic"}),"\n"]})})]}),"\n",(0,i.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(a.A,{queryString:"primary",children:[(0,i.jsx)(s.A,{value:"practice",label:"Practice",children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:" function binaryFloatingPointAlgorithm(realNumber):\n   // Step 1: Extract Sign\n   if realNumber < 0:\n     signBit = 1\n   else:\n     signBit = 0\n\n   // Step 2: Normalize\n   exponent = calculateExponent(realNumber)\n   fraction = calculateFraction(realNumber, exponent)\n\n   // Step 3: Convert to Binary\n   signBinary = convertToBinary(signBit)\n   exponentBinary = convertToBinary(exponent)\n   fractionBinary = convertToBinary(fraction)\n\n   // Step 4: Combine Components\n   binaryRepresentation = concatenate(signBinary, exponentBinary, fractionBinary)\n\n   // Step 5: Output\n   return binaryRepresentation\n"})})}),(0,i.jsx)(s.A,{value:"solution",label:"Solution",children:(0,i.jsxs)(a.A,{queryString:"code",children:[(0,i.jsx)(s.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(l.A,{language:"go",children:o})}),(0,i.jsx)(s.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(l.A,{language:"java",children:c})}),(0,i.jsx)(s.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(l.A,{language:"js",children:u})}),(0,i.jsx)(s.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(l.A,{language:"kotlin",children:b})}),(0,i.jsx)(s.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(l.A,{language:"python",children:g})}),(0,i.jsx)(s.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(l.A,{language:"rust",children:d})}),(0,i.jsx)(s.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(l.A,{language:"ts",children:f})})]})})]})]})}function B(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(j,{...n})}):j(n)}}}]);