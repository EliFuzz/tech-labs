"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[6451],{29172:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>x,contentTitle:()=>g,default:()=>y,frontMatter:()=>f,metadata:()=>t,toc:()=>j});const t=JSON.parse('{"id":"education/computer-science/algorithms/algo/jump-search","title":"Jump Search (or Block Search)","description":"Jump Search (or Block Search)","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/jump-search.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/jump-search","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/jump-search","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/jump-search.mdx","tags":[],"version":"current","frontMatter":{"title":"Jump Search (or Block Search)","description":"Jump Search (or Block Search)","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Jump Game","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/jump-game"},"next":{"title":"k-Means","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/k-means"}}');var a=r(86070),i=r(15658),s=r(52421),l=r(74610),c=r(42953);const o='package main\n\nimport (\n\t"math"\n)\n\nfunc jumpSearch(arr []int, x int) int {\n\tn := len(arr)\n\tstep := int(math.Sqrt(float64(n)))\n\tprev := 0\n\n\tfor arr[int(math.Min(float64(step), float64(n))-1)] < x {\n\t\tprev = step\n\t\tstep += int(math.Sqrt(float64(n)))\n\t\tif prev >= n {\n\t\t\treturn -1\n\t\t}\n\t}\n\n\tfor arr[prev] < x {\n\t\tprev++\n\t\tif prev == int(math.Min(float64(step), float64(n))) {\n\t\t\treturn -1\n\t\t}\n\t}\n\n\tif arr[prev] == x {\n\t\treturn prev\n\t}\n\n\treturn -1\n}\n',h="import java.lang.Math;\n\npublic class JumpSearch {\n\n  public static int jumpSearch(int[] arr, int x) {\n    int n = arr.length;\n    int step = (int) Math.floor(Math.sqrt(n));\n    int prev = 0;\n\n    while (arr[Math.min(step, n) - 1] < x) {\n      prev = step;\n      step += (int) Math.floor(Math.sqrt(n));\n      if (prev >= n) {\n        return -1;\n      }\n    }\n\n    while (arr[prev] < x) {\n      prev++;\n      if (prev == Math.min(step, n)) {\n        return -1;\n      }\n    }\n\n    if (arr[prev] == x) {\n      return prev;\n    }\n\n    return -1;\n  }\n}\n",p="function jumpSearch(arr, x) {\n  const n = arr.length;\n  const step = Math.floor(Math.sqrt(n));\n  let prev = 0;\n\n  while (arr[Math.min(step, n) - 1] < x) {\n    prev = step;\n    step += Math.floor(Math.sqrt(n));\n    if (prev >= n) {\n      return -1;\n    }\n  }\n\n  while (arr[prev] < x) {\n    prev++;\n    if (prev === Math.min(step, n)) {\n      return -1;\n    }\n  }\n\n  if (arr[prev] === x) {\n    return prev;\n  }\n\n  return -1;\n}\n",u="import kotlin.math.*\n\nfun jumpSearch(arr: IntArray, x: Int): Int {\n    val n = arr.size\n    val step = sqrt(n.toDouble()).toInt()\n    var prev = 0\n\n    while (arr[min(step, n) - 1] < x) {\n        prev = step\n        step += sqrt(n.toDouble()).toInt()\n        if (prev >= n)\n            return -1\n    }\n\n    while (arr[prev] < x) {\n        prev++\n        if (prev == min(step, n))\n            return -1\n    }\n\n    return when {\n        arr[prev] == x -> prev\n        else -> -1\n    }\n}\n",m="import math\n\ndef jump_search(arr, x):\n    n = len(arr)\n    step = int(math.sqrt(n))\n    prev = 0\n\n    while arr[min(step, n) - 1] < x:\n        prev = step\n        step += int(math.sqrt(n))\n        if prev >= n:\n            return -1\n\n    while arr[prev] < x:\n        prev += 1\n        if prev == min(step, n):\n            return -1\n\n    if arr[prev] == x:\n        return prev\n\n    return -1\n",d="use std::cmp;\n\nfn jump_search(arr: &[i32], x: i32) -> i32 {\n    let n = arr.len();\n    let mut step = (n as f64).sqrt() as usize;\n    let mut prev = 0;\n\n    while arr[cmp::min(step, n) - 1] < x {\n        prev = step;\n        step += (n as f64).sqrt() as usize;\n        if prev >= n {\n            return -1;\n        }\n    }\n\n    while arr[prev] < x {\n        prev += 1;\n        if prev == cmp::min(step, n) {\n            return -1;\n        }\n    }\n\n    if arr[prev] == x {\n        return prev as i32;\n    }\n\n    -1\n}\n",v="function jumpSearch(arr: number[], x: number): number {\n  const n: number = arr.length;\n  const step: number = Math.floor(Math.sqrt(n));\n  let prev: number = 0;\n\n  while (arr[Math.min(step, n) - 1] < x) {\n    prev = step;\n    step += Math.floor(Math.sqrt(n));\n    if (prev >= n) return -1;\n  }\n\n  while (arr[prev] < x) {\n    prev++;\n    if (prev === Math.min(step, n)) return -1;\n  }\n\n  if (arr[prev] === x) return prev;\n\n  return -1;\n}\n",f={title:"Jump Search (or Block Search)",description:"Jump Search (or Block Search)",hide_table_of_contents:!0},g=void 0,x={},j=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function b(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,a.jsxs)(s.A,{queryString:"primary",children:[(0,a.jsx)(l.A,{value:"definition",label:"Definition",children:(0,a.jsx)(n.p,{children:"Jump search, also known as block search, is an algorithm for searching sorted arrays efficiently. It works by jumping ahead by fixed steps to find a range where the target element might be located, then performing a linear search within that range for the exact match"})}),(0,a.jsx)(l.A,{value:"how",label:"Explanation",children:(0,a.jsx)(n.p,{children:"Calculate the jump size (or block size) by considering the size of the array and the search key. Then, navigate through the array using this jump size until a range is identified where the search key might be situated. Within this range, conduct a linear search to pinpoint the exact match of the search key. If the key is found, return its index; otherwise, return -1 to signify that the element is not present in the array"})}),(0,a.jsx)(l.A,{value:"guidance",label:"Guidance",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Calculate the jump size using the square root of the array size or any other appropriate method"}),"\n",(0,a.jsx)(n.li,{children:"Start by setting the current position to 0 and the previous position to -1"}),"\n",(0,a.jsx)(n.li,{children:"Jump ahead by the jump size until the current element is greater than or equal to the search key, or until reaching the end of the array"}),"\n",(0,a.jsx)(n.li,{children:"Perform a linear search within the range from the previous position to the current position for the search key"}),"\n",(0,a.jsx)(n.li,{children:"If the search key is found, return its index; otherwise, return -1"}),"\n"]})}),(0,a.jsx)(l.A,{value:"tips",label:"Tips",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"choose an appropriate jump size to balance between the number of jumps and the number of comparisons"}),"\n",(0,a.jsx)(n.li,{children:"ensure that the array is sorted before applying the jump search algorithm"}),"\n",(0,a.jsx)(n.li,{children:"this algorithm works efficiently for large arrays, especially when the cost of random access is high"}),"\n"]})})]}),"\n",(0,a.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,a.jsxs)(s.A,{queryString:"primary",children:[(0,a.jsx)(l.A,{value:"practice",label:"Practice",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"jumpSearch(arr, key):\n  n = arr.length\n  jump_size = floor(sqrt(n))\n  prev = 0\n  while n > prev and arr[min(jump_size, n) - 1] < key:\n    prev = jump_size\n    jump_size += floor(sqrt(n))\n    if prev >= n:\n      return -1\n  for i from prev to min(jump_size, n):\n    if arr[i] == key:\n      return i\n  return -1\n"})})}),(0,a.jsx)(l.A,{value:"solution",label:"Solution",children:(0,a.jsxs)(s.A,{queryString:"code",children:[(0,a.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,a.jsx)(c.A,{language:"go",children:o})}),(0,a.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,a.jsx)(c.A,{language:"java",children:h})}),(0,a.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,a.jsx)(c.A,{language:"js",children:p})}),(0,a.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,a.jsx)(c.A,{language:"kotlin",children:u})}),(0,a.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,a.jsx)(c.A,{language:"python",children:m})}),(0,a.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,a.jsx)(c.A,{language:"rust",children:d})}),(0,a.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,a.jsx)(c.A,{language:"ts",children:v})})]})})]})]})}function y(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(b,{...e})}):b(e)}}}]);