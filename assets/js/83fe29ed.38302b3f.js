"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[6267],{58201:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>m,contentTitle:()=>y,default:()=>w,frontMatter:()=>p,metadata:()=>g,toc:()=>j});var r=i(11527),t=i(88672),a=i(29140),s=i(52360),o=i(52296);const l='package main\n\nimport (\n\t"errors"\n)\n\ntype FenwickTree struct {\n\tarraySize int\n\ttreeArray []int\n}\n\nfunc NewFenwickTree(arraySize int) *FenwickTree {\n\ttreeArray := make([]int, arraySize+1)\n\treturn &FenwickTree{arraySize: arraySize, treeArray: treeArray}\n}\n\nfunc (f *FenwickTree) Increase(position, value int) error {\n\tif position < 1 || position > f.arraySize {\n\t\treturn errors.New("Position is out of allowed range")\n\t}\n\n\tfor i := position; i <= f.arraySize; i += i & -i {\n\t\tf.treeArray[i] += value\n\t}\n\n\treturn nil\n}\n\nfunc (f *FenwickTree) Query(position int) (int, error) {\n\tif position < 1 || position > f.arraySize {\n\t\treturn 0, errors.New("Position is out of allowed range")\n\t}\n\n\tsum := 0\n\n\tfor i := position; i > 0; i -= i & -i {\n\t\tsum += f.treeArray[i]\n\t}\n\n\treturn sum, nil\n}\n\nfunc (f *FenwickTree) QueryRange(leftIndex, rightIndex int) (int, error) {\n\tif leftIndex > rightIndex {\n\t\treturn 0, errors.New("Left index cannot be greater than right one")\n\t}\n\n\tif leftIndex == 1 {\n\t\treturn f.Query(rightIndex)\n\t}\n\n\treturn f.Query(rightIndex) - f.Query(leftIndex-1), nil\n}\n',u='public class FenwickTree {\n\n  private int arraySize;\n  private int[] treeArray;\n\n  public FenwickTree(int arraySize) {\n    this.arraySize = arraySize;\n    this.treeArray = new int[arraySize + 1];\n  }\n\n  public FenwickTree increase(int position, int value) {\n    if (position < 1 || position > arraySize) {\n      throw new IllegalArgumentException("Position is out of allowed range");\n    }\n\n    for (int i = position; i <= arraySize; i += (i & -i)) {\n      treeArray[i] += value;\n    }\n\n    return this;\n  }\n\n  public int query(int position) {\n    if (position < 1 || position > arraySize) {\n      throw new IllegalArgumentException("Position is out of allowed range");\n    }\n\n    int sum = 0;\n\n    for (int i = position; i > 0; i -= (i & -i)) {\n      sum += treeArray[i];\n    }\n\n    return sum;\n  }\n\n  public int queryRange(int leftIndex, int rightIndex) {\n    if (leftIndex > rightIndex) {\n      throw new IllegalArgumentException("Left index can not be greater than right one");\n    }\n\n    if (leftIndex == 1) {\n      return query(rightIndex);\n    }\n\n    return query(rightIndex) - query(leftIndex - 1);\n  }\n}\n',c='class BinaryIndexedTree {\n  constructor(arraySize) {\n    this.arraySize = arraySize;\n    this.treeArray = Array(this.arraySize + 1).fill(0);\n  }\n\n  increase(position, value) {\n    if (position < 1 || position > this.arraySize) {\n      throw new Error("Position is out of allowed range");\n    }\n\n    for (let i = position; i <= this.arraySize; i += i & -i) {\n      this.treeArray[i] += value;\n    }\n\n    return this;\n  }\n\n  query(position) {\n    if (position < 1 || position > this.arraySize) {\n      throw new Error("Position is out of allowed range");\n    }\n\n    let sum = 0;\n\n    for (let i = position; i > 0; i -= i & -i) {\n      sum += this.treeArray[i];\n    }\n\n    return sum;\n  }\n\n  queryRange(leftIndex, rightIndex) {\n    if (leftIndex > rightIndex) {\n      throw new Error("Left index can not be greater than right one");\n    }\n\n    if (leftIndex === 1) {\n      return this.query(rightIndex);\n    }\n\n    return this.query(rightIndex) - this.query(leftIndex - 1);\n  }\n}\n',d='class FenwickTree(private val arraySize: Int) {\n    private val treeArray = IntArray(arraySize + 1)\n\n    fun increase(position: Int, value: Int): FenwickTree {\n        if (position < 1 || position > arraySize) {\n            throw IllegalArgumentException("Position is out of allowed range")\n        }\n\n        var i = position\n        while (i <= arraySize) {\n            treeArray[i] += value\n            i += i and -i\n        }\n\n        return this\n    }\n\n    fun query(position: Int): Int {\n        if (position < 1 || position > arraySize) {\n            throw IllegalArgumentException("Position is out of allowed range")\n        }\n\n        var sum = 0\n        var i = position\n\n        while (i > 0) {\n            sum += treeArray[i]\n            i -= i and -i\n        }\n\n        return sum\n    }\n\n    fun queryRange(leftIndex: Int, rightIndex: Int): Int {\n        if (leftIndex > rightIndex) {\n            throw IllegalArgumentException("Left index can not be greater than right one")\n        }\n\n        return if (leftIndex == 1) {\n            query(rightIndex)\n        } else {\n            query(rightIndex) - query(leftIndex - 1)\n        }\n    }\n}\n',h="class FenwickTree:\n    def __init__(self, array_size):\n        self.array_size = array_size\n        self.tree_array = [0] * (array_size + 1)\n\n    def increase(self, position, value):\n        if position < 1 or position > self.array_size:\n            raise ValueError('Position is out of allowed range')\n\n        i = position\n        while i <= self.array_size:\n            self.tree_array[i] += value\n            i += i & -i\n\n        return self\n\n    def query(self, position):\n        if position < 1 or position > self.array_size:\n            raise ValueError('Position is out of allowed range')\n\n        total_sum = 0\n        i = position\n\n        while i > 0:\n            total_sum += self.tree_array[i]\n            i -= i & -i\n\n        return total_sum\n\n    def query_range(self, left_index, right_index):\n        if left_index > right_index:\n            raise ValueError('Left index can not be greater than right one')\n\n        if left_index == 1:\n            return self.query(right_index)\n\n        return self.query(right_index) - self.query(left_index - 1)\n",f='struct FenwickTree {\n    array_size: usize,\n    tree_array: Vec<i32>,\n}\n\nimpl FenwickTree {\n    fn new(array_size: usize) -> FenwickTree {\n        FenwickTree {\n            array_size,\n            tree_array: vec![0; array_size + 1],\n        }\n    }\n\n    fn increase(&mut self, position: usize, value: i32) -> Result<(), &\'static str> {\n        if position < 1 || position > self.array_size {\n            return Err("Position is out of allowed range");\n        }\n\n        let mut i = position;\n        while i <= self.array_size {\n            self.tree_array[i] += value;\n            i += i & i.wrapping_neg();\n        }\n\n        Ok(())\n    }\n\n    fn query(&self, position: usize) -> Result<i32, &\'static str> {\n        if position < 1 || position > self.array_size {\n            return Err("Position is out of allowed range");\n        }\n\n        let mut sum = 0;\n        let mut i = position;\n\n        while i > 0 {\n            sum += self.tree_array[i];\n            i -= i & i.wrapping_neg();\n        }\n\n        Ok(sum)\n    }\n\n    fn query_range(&self, left_index: usize, right_index: usize) -> Result<i32, &\'static str> {\n        if left_index > right_index {\n            return Err("Left index can not be greater than right one");\n        }\n\n        if left_index == 1 {\n            return self.query(right_index);\n        }\n\n        Ok(self.query(right_index)? - self.query(left_index - 1)?)\n    }\n}\n',x='export default class FenwickTree {\n  private arraySize: number;\n  private treeArray: number[];\n\n  constructor(arraySize: number) {\n    this.arraySize = arraySize;\n    this.treeArray = Array(this.arraySize + 1).fill(0);\n  }\n\n  increase(position: number, value: number): FenwickTree {\n    if (position < 1 || position > this.arraySize) {\n      throw new Error("Position is out of allowed range");\n    }\n\n    for (let i = position; i <= this.arraySize; i += i & -i) {\n      this.treeArray[i] += value;\n    }\n\n    return this;\n  }\n\n  query(position: number): number {\n    if (position < 1 || position > this.arraySize) {\n      throw new Error("Position is out of allowed range");\n    }\n\n    let sum = 0;\n\n    for (let i = position; i > 0; i -= i & -i) {\n      sum += this.treeArray[i];\n    }\n\n    return sum;\n  }\n\n  queryRange(leftIndex: number, rightIndex: number): number {\n    if (leftIndex > rightIndex) {\n      throw new Error("Left index can not be greater than right one");\n    }\n\n    if (leftIndex === 1) {\n      return this.query(rightIndex);\n    }\n\n    return this.query(rightIndex) - this.query(leftIndex - 1);\n  }\n}\n',p={title:"Binary Indexed Tree",description:"Binary Indexed Tree Data Structure",hide_table_of_contents:!0},y=void 0,g={id:"education/computer-science/data-structures/basic/binary-indexed-tree",title:"Binary Indexed Tree",description:"Binary Indexed Tree Data Structure",source:"@site/docs/education/01-computer-science/09-data-structures/02-basic/14-binary-indexed-tree.mdx",sourceDirName:"education/01-computer-science/09-data-structures/02-basic",slug:"/education/computer-science/data-structures/basic/binary-indexed-tree",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/binary-indexed-tree",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/14-binary-indexed-tree.mdx",tags:[],version:"current",sidebarPosition:14,frontMatter:{title:"Binary Indexed Tree",description:"Binary Indexed Tree Data Structure",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Segment Tree",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/segment-tree"},next:{title:"Suffix Tree",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/suffix-ttree"}},m={},j=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function b(e){const n={code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components},{Details:p}=n;return p||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:i(8822).Z+""})}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsxs)("thead",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Space"}),(0,r.jsx)("th",{colspan:"4",children:"Time"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{}),(0,r.jsx)("th",{children:"Access"}),(0,r.jsx)("th",{children:"Lookup"}),(0,r.jsx)("th",{children:"Insertion"}),(0,r.jsx)("th",{children:"Deletion"})]})]}),(0,r.jsx)("tbody",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"fair",children:"O(n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"good",children:"O(log n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"good",children:"O(log n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"good",children:"O(log n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"good",children:"O(log n)"})})]})})]}),"\n",(0,r.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(a.Z,{children:[(0,r.jsxs)(s.Z,{value:"short",label:"Short",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Binary Indexed Tree"})," is a data structure that allows efficient updates and range queries on an array. It is built by storing the cumulative sums of the array elements in a binary tree, allowing\nfor efficient computation of prefix sums and range queries."]}),(0,r.jsxs)(p,{children:[(0,r.jsx)("summary",{children:"Simplified"}),(0,r.jsx)(n.p,{children:"It's like a smart organizer at a party. It quickly updates or calculates the total of a series of numbers (like candies held by people), saving a lot of time."})]})]}),(0,r.jsxs)(s.Z,{value:"detailed",label:"Detailed",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Binary Indexed Tree (Fenwick Tree)"}),", is a data structure that efficiently updates elements and calculates prefix sums in a number table."]}),(0,r.jsx)(n.p,{children:"Unlike a flat array, a Fenwick tree balances 2 operations:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"element update"}),"\n",(0,r.jsx)(n.li,{children:"prefix sum calculation"}),"\n"]}),(0,r.jsxs)(n.p,{children:["In a flat array of ",(0,r.jsx)(n.code,{children:"n"})," numbers, storing elements allows constant time operations but requires linear time for prefix sums. Storing prefix sums allows constant time operations but requires linear\ntime for element updates."]}),(0,r.jsxs)(n.p,{children:["Fenwick trees overcome this by allowing both operations in ",(0,r.jsx)(n.code,{children:"O(log n)"})," time. This is achieved by representing the numbers as a tree, where each node's value is the sum of the numbers in its\nsubtree."]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(a.Z,{children:[(0,r.jsx)(s.Z,{value:"practice",label:"Practice",children:(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Aspect"}),(0,r.jsx)("th",{children:"Pseudo Code"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Increase"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"increase(position, value):\n  if position < 1 or position > tree_array.length:\n    'Position is out of allowed range'\n  for i in range(position, tree_array.length + 1, i & -i):\n    tree_array[i] += value\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Query"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"query(position):\n  if position < 1 or position > tree_array.length:\n    'Position is out of allowed range'\n  sum = 0\n  for i in range(position, 0, -(i & -i)):\n    sum += tree_array[i]\n  return sum\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Query Range"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"query_range(left_index, right_index):\n  if left_index > right_index:\n    'Left index cannot be greater than right one'\n  if left_index == 1:\n    return query(right_index)\n  return query(right_index) - query(left_index - 1)\n\nquery(position):\n  if position < 1 or position > tree_array.length:\n    'Position is out of allowed range'\n  sum = 0\n  for i in range(position, 0, -(i & -i)):\n    sum += tree_array[i]\n  return sum\n"})})})]})]})]})}),(0,r.jsx)(s.Z,{value:"solution",label:"Solution",children:(0,r.jsxs)(a.Z,{queryString:"code",children:[(0,r.jsx)(s.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(o.Z,{language:"go",children:l})}),(0,r.jsx)(s.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(o.Z,{language:"java",children:u})}),(0,r.jsx)(s.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(o.Z,{language:"js",children:c})}),(0,r.jsx)(s.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(o.Z,{language:"kotlin",children:d})}),(0,r.jsx)(s.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(o.Z,{language:"python",children:h})}),(0,r.jsx)(s.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(o.Z,{language:"rust",children:f})}),(0,r.jsx)(s.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(o.Z,{language:"ts",children:x})})]})})]})]})}function w(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(b,{...e})}):b(e)}},8822:(e,n,i)=>{i.d(n,{Z:()=>r});const r=i.p+"assets/images/binaryIndexedTree-6d32542f62a389fc325395a838b355a4.svg"}}]);