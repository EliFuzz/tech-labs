"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[141],{20454:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>_,contentTitle:()=>p,default:()=>G,frontMatter:()=>o,metadata:()=>f,toc:()=>V});var r=t(11527),d=t(88672),s=t(29140),a=t(52360),g=t(52296);const i='package main\n\nimport (\n\t"strings"\n)\n\ntype GraphEdge struct {\n\tstartVertex *GraphVertex\n\tendVertex   *GraphVertex\n\tweight      int\n}\n\nfunc NewGraphEdge(startVertex, endVertex *GraphVertex, weight int) *GraphEdge {\n\treturn &GraphEdge{\n\t\tstartVertex: startVertex,\n\t\tendVertex:   endVertex,\n\t\tweight:      weight,\n\t}\n}\n\nfunc (edge *GraphEdge) GetKey() string {\n\tstartVertexKey := edge.startVertex.GetKey()\n\tendVertexKey := edge.endVertex.GetKey()\n\treturn fmt.Sprintf("%s_%s", startVertexKey, endVertexKey)\n}\n\nfunc (edge *GraphEdge) Reverse() *GraphEdge {\n\tedge.startVertex, edge.endVertex = edge.endVertex, edge.startVertex\n\treturn edge\n}\n\ntype GraphVertex struct {\n\tvalue interface{}\n\tedges []*GraphEdge\n}\n\nfunc NewGraphVertex(value interface{}) *GraphVertex {\n\tif value == nil {\n\t\tpanic("Graph vertex must have a value")\n\t}\n\n\treturn &GraphVertex{\n\t\tvalue: value,\n\t\tedges: make([]*GraphEdge, 0),\n\t}\n}\n\nfunc (vertex *GraphVertex) AddEdge(edge *GraphEdge) *GraphVertex {\n\tvertex.edges = append(vertex.edges, edge)\n\treturn vertex\n}\n\nfunc (vertex *GraphVertex) DeleteEdge(edge *GraphEdge) {\n\tfor i, e := range vertex.edges {\n\t\tif e == edge {\n\t\t\tvertex.edges = append(vertex.edges[:i], vertex.edges[i+1:]...)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (vertex *GraphVertex) GetNeighbors() []*GraphVertex {\n\tneighbors := make([]*GraphVertex, 0)\n\tfor _, edge := range vertex.edges {\n\t\tif edge.startVertex == vertex {\n\t\t\tneighbors = append(neighbors, edge.endVertex)\n\t\t} else {\n\t\t\tneighbors = append(neighbors, edge.startVertex)\n\t\t}\n\t}\n\treturn neighbors\n}\n\nfunc (vertex *GraphVertex) GetEdges() []*GraphEdge {\n\treturn vertex.edges\n}\n\nfunc (vertex *GraphVertex) GetDegree() int {\n\treturn len(vertex.edges)\n}\n\nfunc (vertex *GraphVertex) HasEdge(requiredEdge *GraphEdge) bool {\n\tfor _, edge := range vertex.edges {\n\t\tif edge == requiredEdge {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (vertex *GraphVertex) HasNeighbor(neighbor *GraphVertex) bool {\n\tfor _, edge := range vertex.edges {\n\t\tif edge.startVertex == neighbor || edge.endVertex == neighbor {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (vertex *GraphVertex) FindEdge(neighbor *GraphVertex) *GraphEdge {\n\tfor _, edge := range vertex.edges {\n\t\tif edge.startVertex == neighbor || edge.endVertex == neighbor {\n\t\t\treturn edge\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (vertex *GraphVertex) GetKey() string {\n\treturn fmt.Sprintf("%v", vertex.value)\n}\n\nfunc (vertex *GraphVertex) DeleteAllEdges() *GraphVertex {\n\tfor _, edge := range vertex.edges {\n\t\tedge.startVertex.DeleteEdge(edge)\n\t\tedge.endVertex.DeleteEdge(edge)\n\t}\n\tvertex.edges = nil\n\treturn vertex\n}\n\ntype Graph struct {\n\tvertices    map[string]*GraphVertex\n\tedges       map[string]*GraphEdge\n\tisDirected  bool\n}\n\nfunc NewGraph(isDirected bool) *Graph {\n\treturn &Graph{\n\t\tvertices:   make(map[string]*GraphVertex),\n\t\tedges:      make(map[string]*GraphEdge),\n\t\tisDirected: isDirected,\n\t}\n}\n\nfunc (graph *Graph) AddVertex(newVertex *GraphVertex) *Graph {\n\tgraph.vertices[newVertex.GetKey()] = newVertex\n\treturn graph\n}\n\nfunc (graph *Graph) GetVertexByKey(vertexKey string) *GraphVertex {\n\treturn graph.vertices[vertexKey]\n}\n\nfunc (graph *Graph) GetNeighbors(vertex *GraphVertex) []*GraphVertex {\n\treturn vertex.GetNeighbors()\n}\n\nfunc (graph *Graph) GetAllVertices() []*GraphVertex {\n\tvertices := make([]*GraphVertex, 0, len(graph.vertices))\n\tfor _, vertex := range graph.vertices {\n\t\tvertices = append(vertices, vertex)\n\t}\n\treturn vertices\n}\n\nfunc (graph *Graph) GetAllEdges() []*GraphEdge {\n\tedges := make([]*GraphEdge, 0, len(graph.edges))\n\tfor _, edge := range graph.edges {\n\t\tedges = append(edges, edge)\n\t}\n\treturn edges\n}\n\nfunc (graph *Graph) AddEdge(edge *GraphEdge) *Graph {\n  startVertex := graph.GetVertexByKey(edge.startVertex.GetKey())\n  endVertex := graph.GetVertexByKey(edge.endVertex.GetKey())\n\n  if startVertex == nil {\n    graph.AddVertex(edge.startVertex)\n    startVertex = graph.GetVertexByKey(edge.startVertex.GetKey())\n  }\n\n  if endVertex == nil {\n    graph.AddVertex(edge.endVertex)\n    endVertex = graph.GetVertexByKey(edge.endVertex.GetKey())\n  }\n\n  if existingEdge := graph.edges[edge.GetKey()]; existingEdge != nil {\n    panic("Edge has already been added before")\n  } else {\n    graph.edges[edge.GetKey()] = edge\n  }\n\n  if graph.isDirected {\n    startVertex.AddEdge(edge)\n  } else {\n    startVertex.AddEdge(edge)\n    endVertex.AddEdge(edge)\n  }\n\n  return graph\n}\n\nfunc (graph *Graph) DeleteEdge(edge *GraphEdge) *Graph {\n  if existingEdge := graph.edges[edge.GetKey()]; existingEdge != nil {\n    delete(graph.edges, edge.GetKey())\n  } else {\n    panic("Edge not found in graph")\n  }\n\n  startVertex := graph.GetVertexByKey(edge.startVertex.GetKey())\n  endVertex := graph.GetVertexByKey(edge.endVertex.GetKey())\n\n  startVertex.DeleteEdge(edge)\n  endVertex.DeleteEdge(edge)\n\n  return graph\n}\n\nfunc (graph *Graph) FindEdge(startVertex, endVertex *GraphVertex) *GraphEdge {\n  vertex := graph.GetVertexByKey(startVertex.GetKey())\n\n  if vertex == nil {\n    return nil\n  }\n\n  return vertex.FindEdge(endVertex)\n}\n\nfunc (graph *Graph) GetWeight() int {\n  totalWeight := 0\n  for _, graphEdge := range graph.GetAllEdges() {\n    totalWeight += graphEdge.weight\n  }\n  return totalWeight\n}\n\nfunc (graph *Graph) Reverse() *Graph {\n  for _, graphEdge := range graph.GetAllEdges() {\n    graph.DeleteEdge(graphEdge)\n    graphEdge.Reverse()\n    graph.AddEdge(graphEdge)\n  }\n  return graph\n}\n\nfunc (graph *Graph) GetVerticesIndices() map[string]int {\n  verticesIndices := make(map[string]int)\n  allVertices := graph.GetAllVertices()\n\n  for index, vertex := range allVertices {\n    verticesIndices[vertex.GetKey()] = index\n  }\n\n  return verticesIndices\n}\n\nfunc (graph *Graph) GetAdjacencyMatrix() [][]int {\n  vertices := graph.GetAllVertices()\n  verticesIndices := graph.GetVerticesIndices()\n\n  adjacencyMatrix := make([][]int, len(vertices))\n  for i := range adjacencyMatrix {\n    adjacencyMatrix[i] = make([]int, len(vertices))\n    for j := range adjacencyMatrix[i] {\n      adjacencyMatrix[i][j] = int(^uint(0) >> 1)\n    }\n  }\n\n  for vertexIndex, vertex := range vertices {\n    for _, neighbor := range vertex.GetNeighbors() {\n      neighborIndex := verticesIndices[neighbor.GetKey()]\n      adjacencyMatrix[vertexIndex][neighborIndex] = graph.FindEdge(vertex, neighbor).weight\n    }\n  }\n\n  return adjacencyMatrix\n}\n',l='import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass GraphEdge {\n\n  private final GraphVertex startVertex;\n  private final GraphVertex endVertex;\n  private final int weight;\n\n  public GraphEdge(GraphVertex startVertex, GraphVertex endVertex, int weight) {\n    this.startVertex = startVertex;\n    this.endVertex = endVertex;\n    this.weight = weight;\n  }\n\n  public String getKey() {\n    String startVertexKey = startVertex.getKey();\n    String endVertexKey = endVertex.getKey();\n    return startVertexKey + "_" + endVertexKey;\n  }\n\n  public GraphEdge reverse() {\n    GraphVertex tmp = startVertex;\n    startVertex = endVertex;\n    endVertex = tmp;\n    return this;\n  }\n\n  public String toString() {\n    return getKey();\n  }\n}\n\nclass GraphVertex {\n\n  private final Object value;\n  private final List<GraphEdge> edges;\n\n  public GraphVertex(Object value) {\n    if (value == null) {\n      throw new IllegalArgumentException("Graph vertex must have a value");\n    }\n\n    this.value = value;\n    this.edges = new ArrayList<>();\n  }\n\n  public GraphVertex addEdge(GraphEdge edge) {\n    edges.add(edge);\n    return this;\n  }\n\n  public void deleteEdge(GraphEdge edge) {\n    edges.remove(edge);\n  }\n\n  public List<GraphVertex> getNeighbors() {\n    List<GraphVertex> neighbors = new ArrayList<>();\n    for (GraphEdge edge : edges) {\n      neighbors.add(edge.startVertex == this ? edge.endVertex : edge.startVertex);\n    }\n    return neighbors;\n  }\n\n  public List<GraphEdge> getEdges() {\n    List<GraphEdge> result = new ArrayList<>();\n    for (GraphEdge edge : edges) {\n      result.add(edge);\n    }\n    return result;\n  }\n\n  public int getDegree() {\n    return edges.size();\n  }\n\n  public boolean hasEdge(GraphEdge requiredEdge) {\n    return edges.contains(requiredEdge);\n  }\n\n  public boolean hasNeighbor(GraphVertex vertex) {\n    for (GraphEdge edge : edges) {\n      if (edge.startVertex == vertex || edge.endVertex == vertex) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public GraphEdge findEdge(GraphVertex vertex) {\n    for (GraphEdge edge : edges) {\n      if (edge.startVertex == vertex || edge.endVertex == vertex) {\n        return edge;\n      }\n    }\n    return null;\n  }\n\n  public Object getKey() {\n    return value;\n  }\n\n  public GraphVertex deleteAllEdges() {\n    edges.clear();\n    return this;\n  }\n}\n\nclass Graph {\n\n  private final Map<Object, GraphVertex> vertices;\n  private final Map<String, GraphEdge> edges;\n  private final boolean isDirected;\n\n  public Graph(boolean isDirected) {\n    this.vertices = new HashMap<>();\n    this.edges = new HashMap<>();\n    this.isDirected = isDirected;\n  }\n\n  public Graph addVertex(GraphVertex newVertex) {\n    vertices.put(newVertex.getKey(), newVertex);\n    return this;\n  }\n\n  public GraphVertex getVertexByKey(Object vertexKey) {\n    return vertices.get(vertexKey);\n  }\n\n  public List<GraphVertex> getNeighbors(GraphVertex vertex) {\n    return vertex.getNeighbors();\n  }\n\n  public List<GraphVertex> getAllVertices() {\n    return new ArrayList<>(vertices.values());\n  }\n\n  public List<GraphEdge> getAllEdges() {\n    return new ArrayList<>(edges.values());\n  }\n\n  public Graph addEdge(GraphEdge edge) {\n    GraphVertex startVertex = getVertexByKey(edge.startVertex.getKey());\n    GraphVertex endVertex = getVertexByKey(edge.endVertex.getKey());\n\n    if (startVertex == null) {\n      addVertex(edge.startVertex);\n      startVertex = getVertexByKey(edge.startVertex.getKey());\n    }\n\n    if (endVertex == null) {\n      addVertex(edge.endVertex);\n      endVertex = getVertexByKey(edge.endVertex.getKey());\n    }\n\n    if (edges.containsKey(edge.getKey())) {\n      throw new IllegalStateException("Edge has already been added before");\n    } else {\n      edges.put(edge.getKey(), edge);\n    }\n\n    if (isDirected) {\n      startVertex.addEdge(edge);\n    } else {\n      startVertex.addEdge(edge);\n      endVertex.addEdge(edge);\n    }\n\n    return this;\n  }\n\n  public Graph deleteEdge(GraphEdge edge) {\n    if (edges.containsKey(edge.getKey())) {\n      edges.remove(edge.getKey());\n    } else {\n      throw new IllegalStateException("Edge not found in graph");\n    }\n\n    GraphVertex startVertex = getVertexByKey(edge.startVertex.getKey());\n    GraphVertex endVertex = getVertexByKey(edge.endVertex.getKey());\n\n    startVertex.deleteEdge(edge);\n    endVertex.deleteEdge(edge);\n\n    return this;\n  }\n\n  public GraphEdge findEdge(GraphVertex startVertex, GraphVertex endVertex) {\n    GraphVertex vertex = getVertexByKey(startVertex.getKey());\n\n    if (vertex == null) {\n      return null;\n    }\n\n    return vertex.findEdge(endVertex);\n  }\n\n  public int getWeight() {\n    int totalWeight = 0;\n    for (GraphEdge graphEdge : getAllEdges()) {\n      totalWeight += graphEdge.weight;\n    }\n    return totalWeight;\n  }\n\n  public Graph reverse() {\n    for (GraphEdge graphEdge : getAllEdges()) {\n      deleteEdge(graphEdge);\n      graphEdge.reverse();\n      addEdge(graphEdge);\n    }\n\n    return this;\n  }\n\n  public Map<Object, Integer> getVerticesIndices() {\n    Map<Object, Integer> verticesIndices = new HashMap<>();\n    List<GraphVertex> allVertices = getAllVertices();\n\n    for (int index = 0; index < allVertices.size(); index++) {\n      verticesIndices.put(allVertices.get(index).getKey(), index);\n    }\n\n    return verticesIndices;\n  }\n\n  public int[][] getAdjacencyMatrix() {\n    List<GraphVertex> vertices = getAllVertices();\n    Map<Object, Integer> verticesIndices = getVerticesIndices();\n\n    int[][] adjacencyMatrix = new int[vertices.size()][vertices.size()];\n\n    for (int i = 0; i < vertices.size(); i++) {\n      for (int j = 0; j < vertices.size(); j++) {\n        adjacencyMatrix[i][j] = Integer.MAX_VALUE;\n      }\n    }\n\n    for (int vertexIndex = 0; vertexIndex < vertices.size(); vertexIndex++) {\n      for (GraphVertex neighbor : vertices.get(vertexIndex).getNeighbors()) {\n        int neighborIndex = verticesIndices.get(neighbor.getKey());\n        GraphEdge edge = findEdge(vertices.get(vertexIndex), neighbor);\n        adjacencyMatrix[vertexIndex][neighborIndex] = (edge != null) ? edge.weight : Integer.MAX_VALUE;\n      }\n    }\n\n    return adjacencyMatrix;\n  }\n}\n',x="",h='import java.util.*\n\nclass GraphEdge(startVertex: GraphVertex, endVertex: GraphVertex, weight: Int = 0) {\n    var startVertex: GraphVertex = startVertex\n    var endVertex: GraphVertex = endVertex\n    var weight: Int = weight\n\n    fun getKey(): String {\n        val startVertexKey = startVertex.getKey()\n        val endVertexKey = endVertex.getKey()\n        return "${startVertexKey}_${endVertexKey}"\n    }\n\n    fun reverse(): GraphEdge {\n        val tmp = startVertex\n        startVertex = endVertex\n        endVertex = tmp\n        return this\n    }\n}\n\nclass GraphVertex(value: Any) {\n    var value: Any = value\n        private set\n\n    init {\n        if (value == null) {\n            throw IllegalArgumentException("Graph vertex must have a value")\n        }\n    }\n\n    var edges: MutableList<GraphEdge> = mutableListOf()\n\n    fun addEdge(edge: GraphEdge): GraphVertex {\n        edges.add(edge)\n        return this\n    }\n\n    fun deleteEdge(edge: GraphEdge) {\n        edges.remove(edge)\n    }\n\n    fun getNeighbors(): List<GraphVertex> {\n        val neighborsConverter: (GraphEdge) -> GraphVertex = { node ->\n            if (node.startVertex == this) node.endVertex else node.startVertex\n        }\n        return edges.map(neighborsConverter)\n    }\n\n    fun getEdges(): List<GraphEdge> {\n        return edges.map { it }\n    }\n\n    fun getDegree(): Int {\n        return edges.size\n    }\n\n    fun hasEdge(requiredEdge: GraphEdge): Boolean {\n        return edges.any { it == requiredEdge }\n    }\n\n    fun hasNeighbor(vertex: GraphVertex): Boolean {\n        return edges.any { it.startVertex == vertex || it.endVertex == vertex }\n    }\n\n    fun findEdge(vertex: GraphVertex): GraphEdge? {\n        return edges.firstOrNull { it.startVertex == vertex || it.endVertex == vertex }\n    }\n\n    fun getKey(): String {\n        return value.toString()\n    }\n\n    fun deleteAllEdges(): GraphVertex {\n        edges.forEach { deleteEdge(it) }\n        return this\n    }\n}\n\nclass Graph(isDirected: Boolean = false) {\n    var vertices: MutableMap<String, GraphVertex> = mutableMapOf()\n    var edges: MutableMap<String, GraphEdge> = mutableMapOf()\n    var isDirected: Boolean = isDirected\n\n    fun addVertex(newVertex: GraphVertex): Graph {\n        vertices[newVertex.getKey()] = newVertex\n        return this\n    }\n\n    fun getVertexByKey(vertexKey: String): GraphVertex? {\n        return vertices[vertexKey]\n    }\n\n    fun getNeighbors(vertex: GraphVertex): List<GraphVertex> {\n        return vertex.getNeighbors()\n    }\n\n    fun getAllVertices(): List<GraphVertex> {\n        return ArrayList(vertices.values)\n    }\n\n    fun getAllEdges(): List<GraphEdge> {\n        return ArrayList(edges.values)\n    }\n\n    fun addEdge(edge: GraphEdge): Graph {\n        var startVertex = getVertexByKey(edge.startVertex.getKey())\n        var endVertex = getVertexByKey(edge.endVertex.getKey())\n\n        if (startVertex == null) {\n            addVertex(edge.startVertex)\n            startVertex = getVertexByKey(edge.startVertex.getKey())\n        }\n\n        if (endVertex == null) {\n            addVertex(edge.endVertex)\n            endVertex = getVertexByKey(edge.endVertex.getKey())\n        }\n\n        if (edges.containsKey(edge.getKey())) {\n            throw Error("Edge has already been added before")\n        } else {\n            edges[edge.getKey()] = edge\n        }\n\n        if (isDirected) {\n            startVertex!!.addEdge(edge)\n        } else {\n            startVertex!!.addEdge(edge)\n            endVertex!!.addEdge(edge)\n        }\n\n        return this\n    }\n\n    fun deleteEdge(edge: GraphEdge) {\n        if (edges.containsKey(edge.getKey())) {\n            edges.remove(edge.getKey())\n        } else {\n            throw Error("Edge not found in graph")\n        }\n\n        val startVertex = getVertexByKey(edge.startVertex.getKey())\n        val endVertex = getVertexByKey(edge.endVertex.getKey())\n\n        startVertex?.deleteEdge(edge)\n        endVertex?.deleteEdge(edge)\n    }\n\n    fun findEdge(startVertex: GraphVertex, endVertex: GraphVertex): GraphEdge? {\n        val vertex = getVertexByKey(startVertex.getKey())\n\n        return if (vertex != null) {\n            vertex.findEdge(endVertex)\n        } else {\n            null\n        }\n    }\n\n    fun getWeight(): Int {\n        return getAllEdges().fold(0) { weight, graphEdge -> weight + graphEdge.weight }\n    }\n\n    fun reverse(): Graph {\n        getAllEdges().forEach { edge ->\n            deleteEdge(edge)\n            edge.reverse()\n            addEdge(edge)\n        }\n\n        return this\n    }\n\n    fun getVerticesIndices(): Map<String, Int> {\n        val verticesIndices = mutableMapOf<String, Int>()\n        getAllVertices().forEachIndexed { index, vertex -> verticesIndices[vertex.getKey()] = index }\n        return verticesIndices\n    }\n\n    fun getAdjacencyMatrix(): Array<IntArray> {\n        val vertices = getAllVertices()\n        val verticesIndices = getVerticesIndices()\n\n        val adjacencyMatrix = Array(vertices.size) { IntArray(vertices.size) { Int.MAX_VALUE } }\n\n        vertices.forEachIndexed { vertexIndex, vertex ->\n            vertex.getNeighbors().forEach { neighbor ->\n                val neighborIndex = verticesIndices[neighbor.getKey()]!!\n                adjacencyMatrix[vertexIndex][neighborIndex] = findEdge(vertex, neighbor)?.weight ?: 0\n            }\n        }\n\n        return adjacencyMatrix\n    }\n}\n\nclass GraphEdge(\n        var startVertex: GraphVertex,\n        var endVertex: GraphVertex,\n        var weight: Int = 0\n) {\n    fun getKey(): String {\n        val startVertexKey = startVertex.getKey()\n        val endVertexKey = endVertex.getKey()\n        return "${startVertexKey}_${endVertexKey}"\n    }\n\n    fun reverse(): GraphEdge {\n        val tmp = startVertex\n        startVertex = endVertex\n        endVertex = tmp\n        return this\n    }\n\n    override fun toString(): String {\n        return getKey()\n    }\n}\n\nclass GraphVertex(value: Any) {\n    var value: Any = value\n        private set\n\n    init {\n        if (value == null) {\n            throw IllegalArgumentException("Graph vertex must have a value")\n        }\n    }\n\n    var edges: MutableList<GraphEdge> = mutableListOf()\n\n    fun addEdge(edge: GraphEdge): GraphVertex {\n        edges.add(edge)\n        return this\n    }\n\n    fun deleteEdge(edge: GraphEdge) {\n        edges.remove(edge)\n    }\n\n    fun getNeighbors(): List<GraphVertex> {\n        val neighborsConverter: (GraphEdge) -> GraphVertex = { node ->\n            if (node.startVertex == this) node.endVertex else node.startVertex\n        }\n        return edges.map(neighborsConverter)\n    }\n\n    fun getEdges(): List<GraphEdge> {\n        return edges.map { it }\n    }\n\n    fun getDegree(): Int {\n        return edges.size\n    }\n\n    fun hasEdge(requiredEdge: GraphEdge): Boolean {\n        return edges.any { it == requiredEdge }\n    }\n\n    fun hasNeighbor(vertex: GraphVertex): Boolean {\n        return edges.any { it.startVertex == vertex || it.endVertex == vertex }\n    }\n\n    fun findEdge(vertex: GraphVertex): GraphEdge? {\n        return edges.firstOrNull { it.startVertex == vertex || it.endVertex == vertex }\n    }\n\n    fun getKey(): String {\n        return value.toString()\n    }\n\n    fun deleteAllEdges(): GraphVertex {\n        edges.forEach { deleteEdge(it) }\n        return this\n    }\n\n    fun toString(callback: ((Any) -> String)? = null): String {\n        return callback?.invoke(value) ?: value.toString()\n    }\n}\n\nclass Graph(isDirected: Boolean = false) {\n    var vertices: MutableMap<String, GraphVertex> = mutableMapOf()\n    var edges: MutableMap<String, GraphEdge> = mutableMapOf()\n    var isDirected: Boolean = isDirected\n\n    fun addVertex(newVertex: GraphVertex): Graph {\n        vertices[newVertex.getKey()] = newVertex\n        return this\n    }\n\n    fun getVertexByKey(vertexKey: String): GraphVertex? {\n        return vertices[vertexKey]\n    }\n\n    fun getNeighbors(vertex: GraphVertex): List<GraphVertex> {\n        return vertex.getNeighbors()\n    }\n\n    fun getAllVertices(): List<GraphVertex> {\n        return ArrayList(vertices.values)\n    }\n\n    fun getAllEdges(): List<GraphEdge> {\n        return ArrayList(edges.values)\n    }\n\n    fun addEdge(edge: GraphEdge): Graph {\n        var startVertex = getVertexByKey(edge.startVertex.getKey())\n        var endVertex = getVertexByKey(edge.endVertex.getKey())\n\n        if (startVertex == null) {\n            addVertex(edge.startVertex)\n            startVertex = getVertexByKey(edge.startVertex.getKey())\n        }\n\n        if (endVertex == null) {\n            addVertex(edge.endVertex)\n            endVertex = getVertexByKey(edge.endVertex.getKey())\n        }\n\n        if (edges.containsKey(edge.getKey())) {\n            throw Error("Edge has already been added before")\n        } else {\n            edges[edge.getKey()] = edge\n        }\n\n        if (isDirected) {\n            startVertex!!.addEdge(edge)\n        } else {\n            startVertex!!.addEdge(edge)\n            endVertex!!.addEdge(edge)\n        }\n\n        return this\n    }\n\n    fun deleteEdge(edge: GraphEdge) {\n        if (edges.containsKey(edge.getKey())) {\n            edges.remove(edge.getKey())\n        } else {\n            throw Error("Edge not found in graph")\n        }\n\n        val startVertex = getVertexByKey(edge.startVertex.getKey())\n        val endVertex = getVertexByKey(edge.endVertex.getKey())\n\n        startVertex?.deleteEdge(edge)\n        endVertex?.deleteEdge(edge)\n    }\n\n    fun findEdge(startVertex: GraphVertex, endVertex: GraphVertex): GraphEdge? {\n        val vertex = getVertexByKey(startVertex.getKey())\n\n        return if (vertex != null) {\n            vertex.findEdge(endVertex)\n        } else {\n            null\n        }\n    }\n\n    fun getWeight(): Int {\n        return getAllEdges().fold(0) { weight, graphEdge -> weight + graphEdge.weight }\n    }\n\n    fun reverse(): Graph {\n        getAllEdges().forEach { edge ->\n            deleteEdge(edge)\n            edge.reverse()\n            addEdge(edge)\n        }\n\n        return this\n    }\n\n    fun getVerticesIndices(): Map<String, Int> {\n        val verticesIndices = mutableMapOf<String, Int>()\n        getAllVertices().forEachIndexed { index, vertex -> verticesIndices[vertex.getKey()] = index }\n        return verticesIndices\n    }\n\n    fun getAdjacencyMatrix(): Array<IntArray> {\n        val vertices = getAllVertices()\n        val verticesIndices = getVerticesIndices()\n\n        val adjacencyMatrix = Array(vertices.size) { IntArray(vertices.size) { Int.MAX_VALUE } }\n\n        vertices.forEachIndexed { vertexIndex, vertex ->\n            vertex.getNeighbors().forEach { neighbor ->\n                val neighborIndex = verticesIndices[neighbor.getKey()]!!\n                adjacencyMatrix[vertexIndex][neighborIndex] = findEdge(vertex, neighbor)?.weight ?: 0\n            }\n        }\n\n        return adjacencyMatrix\n    }\n\n    override fun toString(): String {\n        return vertices.keys.toString()\n    }\n}\n',c="class GraphEdge:\n    def __init__(self, start_vertex, end_vertex, weight=0):\n        self.start_vertex = start_vertex\n        self.end_vertex = end_vertex\n        self.weight = weight\n\n    def get_key(self):\n        start_vertex_key = self.start_vertex.get_key()\n        end_vertex_key = self.end_vertex.get_key()\n        return f\"{start_vertex_key}_{end_vertex_key}\"\n\n    def reverse(self):\n        tmp = self.start_vertex\n        self.start_vertex = self.end_vertex\n        self.end_vertex = tmp\n        return self\n\n\nclass GraphVertex:\n    def __init__(self, value):\n        if value is None:\n            raise ValueError('Graph vertex must have a value')\n        self.value = value\n        self.edges = LinkedList(lambda edge_a, edge_b: (edge_a.get_key() > edge_b.get_key()) - (edge_a.get_key() < edge_b.get_key()))\n\n    def add_edge(self, edge):\n        self.edges.append(edge)\n        return self\n\n    def delete_edge(self, edge):\n        self.edges.delete(edge)\n\n    def get_neighbors(self):\n        edges = self.edges.to_array()\n\n        def neighbors_converter(node):\n            return node.value.start_vertex if node.value.start_vertex != self else node.value.end_vertex\n\n        return list(map(neighbors_converter, edges))\n\n    def get_edges(self):\n        return list(map(lambda node: node.value, self.edges.to_array()))\n\n    def get_degree(self):\n        return len(self.edges.to_array())\n\n    def has_edge(self, required_edge):\n        edge_node = self.edges.find(callback=lambda edge: edge == required_edge)\n        return edge_node is not None\n\n    def has_neighbor(self, vertex):\n        vertex_node = self.edges.find(callback=lambda edge: edge.start_vertex == vertex or edge.end_vertex == vertex)\n        return vertex_node is not None\n\n    def find_edge(self, vertex):\n        edge_finder = lambda edge: edge.start_vertex == vertex or edge.end_vertex == vertex\n        edge_node = self.edges.find(callback=edge_finder)\n        return edge_node.value if edge_node else None\n\n    def get_key(self):\n        return self.value\n\n    def delete_all_edges(self):\n        edges = self.get_edges()\n        for edge in edges:\n            self.delete_edge(edge)\n        return self\n\n\nclass Graph:\n    def __init__(self, is_directed=False):\n        self.vertices = {}\n        self.edges = {}\n        self.is_directed = is_directed\n\n    def add_vertex(self, new_vertex):\n        self.vertices[new_vertex.get_key()] = new_vertex\n        return self\n\n    def get_vertex_by_key(self, vertex_key):\n        return self.vertices.get(vertex_key)\n\n    def get_neighbors(self, vertex):\n        return vertex.get_neighbors()\n\n    def get_all_vertices(self):\n        return list(self.vertices.values())\n\n    def get_all_edges(self):\n        return list(self.edges.values())\n\n    def add_edge(self, edge):\n        start_vertex = self.get_vertex_by_key(edge.start_vertex.get_key())\n        end_vertex = self.get_vertex_by_key(edge.end_vertex.get_key())\n\n        if not start_vertex:\n            self.add_vertex(edge.start_vertex)\n            start_vertex = self.get_vertex_by_key(edge.start_vertex.get_key())\n\n        if not end_vertex:\n            self.add_vertex(edge.end_vertex)\n            end_vertex = self.get_vertex_by_key(edge.end_vertex.get_key())\n\n        if edge.get_key() in self.edges:\n            raise ValueError('Edge has already been added before')\n        else:\n            self.edges[edge.get_key()] = edge\n\n        if self.is_directed:\n            start_vertex.add_edge(edge)\n        else:\n            start_vertex.add_edge(edge)\n            end_vertex.add_edge(edge)\n\n        return self\n\n    def delete_edge(self, edge):\n        if edge.get_key() in self.edges:\n            del self.edges[edge.get_key()]\n        else:\n            raise ValueError('Edge not found in graph')\n\n        start_vertex = self.get_vertex_by_key(edge.start_vertex.get_key())\n        end_vertex = self.get_vertex_by_key(edge.end_vertex.get_key())\n\n        start_vertex.delete_edge(edge)\n        end_vertex.delete_edge(edge)\n\n    def find_edge(self, start_vertex, end_vertex):\n        vertex = self.get_vertex_by_key(start_vertex.get_key())\n\n        if not vertex:\n            return None\n\n        return vertex.find_edge(end_vertex)\n\n    def get_weight(self):\n        return sum([graph_edge.weight for graph_edge in self.get_all_edges()])\n\n    def reverse(self):\n        for edge in self.get_all_edges():\n            self.delete_edge(edge)\n            edge.reverse()\n            self.add_edge(edge)\n\n        return self\n\n    def get_vertices_indices(self):\n        vertices_indices = {}\n        for index, vertex in enumerate(self.get_all_vertices()):\n            vertices_indices[vertex.get_key()] = index\n\n        return vertices_indices\n\n    def get_adjacency_matrix(self):\n        vertices = self.get_all_vertices()\n        vertices_indices = self.get_vertices_indices()\n\n        num_vertices = len(vertices)\n        adjacency_matrix = [[float('inf')] * num_vertices for _ in range(num_vertices)]\n\n        for vertex_index, vertex in enumerate(vertices):\n            for neighbor in vertex.get_neighbors():\n                neighbor_index = vertices_indices[neighbor.get_key()]\n                edge = self.find_edge(vertex, neighbor)\n                adjacency_matrix[vertex_index][neighbor_index] = edge.weight\n        return adjacency_matrix\n",v='use std::collections::{HashMap, HashSet};\n\n// Define GraphEdge struct\n#[derive(Debug, Clone)]\nstruct GraphEdge<T> {\n    start_vertex: T,\n    end_vertex: T,\n    weight: i32,\n}\n\nimpl<T: Eq + std::hash::Hash + Clone> GraphEdge<T> {\n    fn get_key(&self) -> String {\n        format!("{}_{}", self.start_vertex.get_key(), self.end_vertex.get_key())\n    }\n\n    fn reverse(&mut self) {\n        std::mem::swap(&mut self.start_vertex, &mut self.end_vertex);\n    }\n}\n\n// Define GraphVertex struct\n#[derive(Debug, Clone)]\nstruct GraphVertex<T> {\n    value: T,\n    edges: Vec<GraphEdge<T>>,\n}\n\nimpl<T: Eq + std::hash::Hash + Clone> GraphVertex<T> {\n    fn new(value: T) -> Self {\n        Self {\n            value,\n            edges: Vec::new(),\n        }\n    }\n\n    fn add_edge(&mut self, edge: GraphEdge<T>) {\n        self.edges.push(edge);\n    }\n\n    fn delete_edge(&mut self, edge: &GraphEdge<T>) {\n        self.edges.retain(|e| e != edge);\n    }\n\n    fn get_neighbors(&self) -> Vec<T> {\n        self.edges.iter().map(|edge| edge.end_vertex.clone()).collect()\n    }\n\n    fn get_edges(&self) -> Vec<GraphEdge<T>> {\n        self.edges.clone()\n    }\n\n    fn get_degree(&self) -> usize {\n        self.edges.len()\n    }\n\n    fn has_edge(&self, required_edge: &GraphEdge<T>) -> Option<&GraphEdge<T>> {\n        self.edges.iter().find(|edge| edge == required_edge)\n    }\n\n    fn has_neighbor(&self, vertex: &GraphVertex<T>) -> Option<&GraphEdge<T>> {\n        self.edges.iter().find(|edge| edge.start_vertex == *vertex || edge.end_vertex == *vertex)\n    }\n\n    fn find_edge(&self, vertex: &GraphVertex<T>) -> Option<&GraphEdge<T>> {\n        self.edges.iter().find(|edge| edge.start_vertex == *vertex || edge.end_vertex == *vertex)\n    }\n\n    fn get_key(&self) -> String {\n        self.value.get_key()\n    }\n\n    fn delete_all_edges(&mut self) {\n        self.edges.clear();\n    }\n}\n\n// Define Graph struct\n#[derive(Debug, Clone)]\nstruct Graph<T> {\n    vertices: HashMap<String, GraphVertex<T>>,\n    edges: HashMap<String, GraphEdge<T>>,\n    is_directed: bool,\n}\n\nimpl<T: Eq + std::hash::Hash + Clone> Graph<T> {\n    fn new(is_directed: bool) -> Self {\n        Self {\n            vertices: HashMap::new(),\n            edges: HashMap::new(),\n            is_directed,\n        }\n    }\n\n    fn add_vertex(&mut self, new_vertex: GraphVertex<T>) -> &mut Self {\n        self.vertices.insert(new_vertex.get_key(), new_vertex);\n        self\n    }\n\n    fn get_vertex_by_key(&self, vertex_key: &str) -> Option<&GraphVertex<T>> {\n        self.vertices.get(vertex_key)\n    }\n\n    fn get_neighbors(&self, vertex: &GraphVertex<T>) -> Vec<T> {\n        vertex.get_neighbors()\n    }\n\n    fn get_all_vertices(&self) -> Vec<&GraphVertex<T>> {\n        self.vertices.values().collect()\n    }\n\n    fn get_all_edges(&self) -> Vec<&GraphEdge<T>> {\n        self.edges.values().collect()\n    }\n\n    fn add_edge(&mut self, edge: GraphEdge<T>) -> &mut Self {\n        let start_vertex_key = edge.start_vertex.get_key();\n        let end_vertex_key = edge.end_vertex.get_key();\n\n        if !self.vertices.contains_key(&start_vertex_key) {\n            self.add_vertex(edge.start_vertex.clone());\n        }\n\n        if !self.vertices.contains_key(&end_vertex_key) {\n            self.add_vertex(edge.end_vertex.clone());\n        }\n\n        if self.edges.contains_key(&edge.get_key()) {\n            panic!("Edge has already been added before");\n        } else {\n            self.edges.insert(edge.get_key(), edge.clone());\n        }\n\n        if self.is_directed {\n            if let Some(start_vertex) = self.vertices.get_mut(&start_vertex_key) {\n                start_vertex.add_edge(edge);\n            }\n        } else {\n            if let Some(start_vertex) = self.vertices.get_mut(&start_vertex_key) {\n                start_vertex.add_edge(edge.clone());\n            }\n\n            if let Some(end_vertex) = self.vertices.get_mut(&end_vertex_key) {\n                end_vertex.add_edge(edge);\n            }\n        }\n\n        self\n    }\n\n    fn delete_edge(&mut self, edge: &GraphEdge<T>) {\n        if self.edges.contains_key(&edge.get_key()) {\n            self.edges.remove(&edge.get_key());\n        } else {\n            panic!("Edge not found in graph");\n        }\n\n        if let Some(start_vertex) = self.vertices.get_mut(&edge.start_vertex.get_key()) {\n            start_vertex.delete_edge(edge);\n        }\n\n        if let Some(end_vertex) = self.vertices.get_mut(&edge.end_vertex.get_key()) {\n            end_vertex.delete_edge(edge);\n        }\n    }\n\n    fn find_edge(&self, start_vertex: &GraphVertex<T>, end_vertex: &GraphVertex<T>) -> Option<&GraphEdge<T>> {\n        if let Some(vertex) = self.vertices.get(&start_vertex.get_key()) {\n            vertex.find_edge(end_vertex)\n        } else {\n            None\n        }\n    }\n\n    fn get_weight(&self) -> i32 {\n        self.edges.values().map(|edge| edge.weight).sum()\n    }\n\n    fn reverse(&mut self) -> &mut Self {\n        for edge in self.edges.values_mut() {\n            self.delete_edge(edge);\n            edge.reverse();\n            self.add_edge(edge.clone());\n        }\n\n        self\n    }\n\n    fn get_vertices_indices(&self) -> HashMap<String, usize> {\n        self.vertices\n            .values()\n            .enumerate()\n            .map(|(index, vertex)| (vertex.get_key(), index))\n            .collect()\n    }\n\n    fn get_adjacency_matrix(&self) -> Vec<Vec<i32>> {\n        let vertices = self.get_all_vertices();\n        let vertices_indices = self.get_vertices_indices();\n\n        let mut adjacency_matrix = vec![vec![i32::MAX; vertices.len()]; vertices.len()];\n\n        for (vertex_index, vertex) in vertices.iter().enumerate() {\n            for neighbor in vertex.get_neighbors() {\n                if let Some(edge) = vertex.find_edge(self.get_vertex_by_key(&neighbor).unwrap()) {\n                    let neighbor_index = vertices_indices[&neighbor];\n                    adjacency_matrix[vertex_index][neighbor_index] = edge.weight;\n                }\n            }\n        }\n\n        adjacency_matrix\n    }\n}\n',u='class LinkedListNode<T> {\n  value: T;\n  next: LinkedListNode<T> | null;\n\n  constructor(value: T) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass LinkedList<T> {\n  head: LinkedListNode<T> | null;\n  compare: (a: T, b: T) => number;\n\n  constructor(compare: (a: T, b: T) => number) {\n    this.head = null;\n    this.compare = compare;\n  }\n\n  append(value: T): void {\n    const newNode = new LinkedListNode(value);\n\n    if (!this.head) {\n      this.head = newNode;\n      return;\n    }\n\n    let current = this.head;\n    while (current.next) {\n      current = current.next;\n    }\n\n    current.next = newNode;\n  }\n\n  delete(value: T): void {\n    if (!this.head) {\n      return;\n    }\n\n    if (this.compare(this.head.value, value) === 0) {\n      this.head = this.head.next;\n      return;\n    }\n\n    let current = this.head;\n    while (current.next) {\n      if (this.compare(current.next.value, value) === 0) {\n        current.next = current.next.next;\n        return;\n      }\n      current = current.next;\n    }\n  }\n\n  toArray(): T[] {\n    const result: T[] = [];\n    let current = this.head;\n\n    while (current) {\n      result.push(current.value);\n      current = current.next;\n    }\n\n    return result;\n  }\n\n  find(params: { callback: (value: T) => boolean }): LinkedListNode<T> | null {\n    if (!this.head) {\n      return null;\n    }\n\n    let current = this.head;\n    while (current) {\n      if (params.callback(current.value)) {\n        return current;\n      }\n      current = current.next;\n    }\n\n    return null;\n  }\n}\n\nclass GraphEdge<T> {\n  startVertex: GraphVertex<T>;\n  endVertex: GraphVertex<T>;\n  weight: number;\n\n  constructor(\n    startVertex: GraphVertex<T>,\n    endVertex: GraphVertex<T>,\n    weight = 0,\n  ) {\n    this.startVertex = startVertex;\n    this.endVertex = endVertex;\n    this.weight = weight;\n  }\n\n  getKey(): string {\n    const startVertexKey = this.startVertex.getKey();\n    const endVertexKey = this.endVertex.getKey();\n    return `${startVertexKey}_${endVertexKey}`;\n  }\n\n  reverse(): this {\n    const tmp = this.startVertex;\n    this.startVertex = this.endVertex;\n    this.endVertex = tmp;\n    return this;\n  }\n}\n\nclass GraphVertex<T> {\n  value: T;\n  edges: LinkedList<GraphEdge<T>>;\n\n  constructor(value: T) {\n    if (value === undefined) {\n      throw new Error("Graph vertex must have a value");\n    }\n\n    const edgeComparator = (edgeA: GraphEdge<T>, edgeB: GraphEdge<T>) => {\n      if (edgeA.getKey() === edgeB.getKey()) {\n        return 0;\n      }\n\n      return edgeA.getKey() < edgeB.getKey() ? -1 : 1;\n    };\n\n    this.value = value;\n    this.edges = new LinkedList(edgeComparator);\n  }\n\n  addEdge(edge: GraphEdge<T>): this {\n    this.edges.append(edge);\n    return this;\n  }\n\n  deleteEdge(edge: GraphEdge<T>): void {\n    this.edges.delete(edge);\n  }\n\n  getNeighbors(): T[] {\n    const edges = this.edges.toArray();\n\n    const neighborsConverter = (node: LinkedListNode<GraphEdge<T>>) => {\n      return node.value.startVertex === this\n        ? node.value.endVertex\n        : node.value.startVertex;\n    };\n\n    return edges.map(neighborsConverter);\n  }\n\n  getEdges(): GraphEdge<T>[] {\n    return this.edges.toArray();\n  }\n\n  getDegree(): number {\n    return this.edges.toArray().length;\n  }\n\n  hasEdge(requiredEdge: GraphEdge<T>): LinkedListNode<GraphEdge<T>> | null {\n    return this.edges.find({\n      callback: (edge) => edge === requiredEdge,\n    });\n  }\n\n  hasNeighbor(vertex: T): LinkedListNode<GraphEdge<T>> | null {\n    return this.edges.find({\n      callback: (edge) =>\n        edge.startVertex === vertex || edge.endVertex === vertex,\n    });\n  }\n\n  findEdge(vertex: T): GraphEdge<T> | null {\n    const edgeFinder = (edge: GraphEdge<T>) => {\n      return edge.startVertex === vertex || edge.endVertex === vertex;\n    };\n\n    const edgeNode = this.edges.find({ callback: edgeFinder });\n\n    return edgeNode ? edgeNode.value : null;\n  }\n\n  getKey(): string {\n    return String(this.value);\n  }\n\n  deleteAllEdges(): this {\n    this.getEdges().forEach((edge) => this.deleteEdge(edge));\n    return this;\n  }\n}\n\nclass Graph<T> {\n  vertices: { [key: string]: GraphVertex<T> };\n  edges: { [key: string]: GraphEdge<T> };\n  isDirected: boolean;\n\n  constructor(isDirected = false) {\n    this.vertices = {};\n    this.edges = {};\n    this.isDirected = isDirected;\n  }\n\n  addVertex(newVertex: GraphVertex<T>): this {\n    this.vertices[newVertex.getKey()] = newVertex;\n    return this;\n  }\n\n  getVertexByKey(vertexKey: string): GraphVertex<T> | undefined {\n    return this.vertices[vertexKey];\n  }\n\n  getNeighbors(vertex: GraphVertex<T>): T[] {\n    return vertex.getNeighbors();\n  }\n\n  getAllVertices(): GraphVertex<T>[] {\n    return Object.values(this.vertices);\n  }\n\n  getAllEdges(): GraphEdge<T>[] {\n    return Object.values(this.edges);\n  }\n\n  addEdge(edge: GraphEdge<T>): this {\n    let startVertex = this.getVertexByKey(edge.startVertex.getKey());\n    let endVertex = this.getVertexByKey(edge.endVertex.getKey());\n\n    if (!startVertex) {\n      this.addVertex(edge.startVertex);\n      startVertex = this.getVertexByKey(edge.startVertex.getKey())!;\n    }\n\n    if (!endVertex) {\n      this.addVertex(edge.endVertex);\n      endVertex = this.getVertexByKey(edge.endVertex.getKey())!;\n    }\n\n    if (this.edges[edge.getKey()]) {\n      throw new Error("Edge has already been added before");\n    } else {\n      this.edges[edge.getKey()] = edge;\n    }\n\n    if (this.isDirected) {\n      startVertex.addEdge(edge);\n    } else {\n      startVertex.addEdge(edge);\n      endVertex.addEdge(edge);\n    }\n\n    return this;\n  }\n\n  deleteEdge(edge: GraphEdge<T>): void {\n    if (this.edges[edge.getKey()]) {\n      delete this.edges[edge.getKey()];\n    } else {\n      throw new Error("Edge not found in graph");\n    }\n\n    const startVertex = this.getVertexByKey(edge.startVertex.getKey());\n    const endVertex = this.getVertexByKey(edge.endVertex.getKey());\n\n    startVertex?.deleteEdge(edge);\n    endVertex?.deleteEdge(edge);\n  }\n\n  findEdge(\n    startVertex: GraphVertex<T>,\n    endVertex: GraphVertex<T>,\n  ): GraphEdge<T> | null {\n    const vertex = this.getVertexByKey(startVertex.getKey());\n\n    if (!vertex) {\n      return null;\n    }\n\n    return vertex.findEdge(endVertex.getKey());\n  }\n\n  getWeight(): number {\n    return this.getAllEdges().reduce((weight, graphEdge) => {\n      return weight + graphEdge.weight;\n    }, 0);\n  }\n\n  reverse(): this {\n    this.getAllEdges().forEach((edge) => {\n      this.deleteEdge(edge);\n      edge.reverse();\n      this.addEdge(edge);\n    });\n\n    return this;\n  }\n\n  getVerticesIndices(): { [key: string]: number } {\n    const verticesIndices: { [key: string]: number } = {};\n    this.getAllVertices().forEach((vertex, index) => {\n      verticesIndices[vertex.getKey()] = index;\n    });\n\n    return verticesIndices;\n  }\n\n  getAdjacencyMatrix(): number[][] {\n    const vertices = this.getAllVertices();\n    const verticesIndices = this.getVerticesIndices();\n\n    const adjacencyMatrix: number[][] = Array(vertices.length)\n      .fill(null)\n      .map(() => {\n        return Array(vertices.length).fill(Infinity);\n      });\n\n    vertices.forEach((vertex, vertexIndex) => {\n      vertex.getNeighbors().forEach((neighbor) => {\n        const neighborIndex = verticesIndices[neighbor.getKey()];\n        const edge = this.findEdge(\n          vertex,\n          this.getVertexByKey(neighbor.getKey())!,\n        );\n        adjacencyMatrix[vertexIndex][neighborIndex] = edge.weight;\n      });\n    });\n\n    return adjacencyMatrix;\n  }\n}\n',o={title:"Graph",description:"Graph Data Structure",hide_table_of_contents:!0},p=void 0,f={id:"education/computer-science/data-structures/basic/graph",title:"Graph",description:"Graph Data Structure",source:"@site/docs/education/01-computer-science/09-data-structures/02-basic/17-graph.mdx",sourceDirName:"education/01-computer-science/09-data-structures/02-basic",slug:"/education/computer-science/data-structures/basic/graph",permalink:"/docs/education/computer-science/data-structures/basic/graph",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/17-graph.mdx",tags:[],version:"current",sidebarPosition:17,frontMatter:{title:"Graph",description:"Graph Data Structure",hide_table_of_contents:!0},sidebar:"education",previous:{title:"R-Tree",permalink:"/docs/education/computer-science/data-structures/basic/r-tree"},next:{title:"Disjoint Set",permalink:"/docs/education/computer-science/data-structures/basic/disjoint-set"}},_={},V=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function y(e){const n={admonition:"admonition",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,d.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(80300).Z+""})}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsxs)("thead",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Representation"}),(0,r.jsx)("th",{children:"Space"}),(0,r.jsx)("th",{colspan:"4",children:"Time"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{}),(0,r.jsx)("th",{}),(0,r.jsx)("th",{children:"Access"}),(0,r.jsx)("th",{children:"Lookup"}),(0,r.jsx)("th",{children:"Insertion"}),(0,r.jsx)("th",{children:"Deletion"})]})]}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(n.strong,{children:"Adjacency Matrix"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"horrible",children:"O(V\xb2)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"fair",children:"O(V)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"excellent",children:"O(1)"})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(n.strong,{children:"Adjacency List"})}),(0,r.jsx)("td",{children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)("code",{className:"fair",children:"O(V+E)"})," ",(0,r.jsx)("br",{})," \u2022 ",(0,r.jsx)(n.code,{children:"V"})," is the number of\nvertices ",(0,r.jsx)("br",{})," \u2022 ",(0,r.jsx)(n.code,{children:"E"})," is the number of edges"]})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"excellent",children:"O(1)"})})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(s.Z,{children:[(0,r.jsxs)(a.Z,{value:"short",label:"Short",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Graph"})," is a collection of nodes connected by edges, where each node represents a entity and each edge represents a relationship between 2 entities."]}),(0,r.jsx)(n.admonition,{title:"Simplified",type:"note",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Graph"})," in software engineering is like a city map. It shows how different things, like cities (nodes), are connected by roads (edges). It's used to solve complex problems, like finding the\nshortest route or recommending friends on social media."]})})]}),(0,r.jsxs)(a.Z,{value:"detailed",label:"Detailed",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Graph"})," is a data type that represents both undirected and directed graphs from mathematical graph theory."]}),(0,r.jsx)(n.p,{children:"A graph data structure has a finite set of vertices (or nodes), along with a set of pairs of these vertices. For an undirected graph, the pairs are unordered, while for a directed graph, they're\nordered. These pairs are called edges for undirected graphs and arrows for directed ones. The vertices can be part of the graph structure itself or external entities represented by indices or\nreferences."}),(0,r.jsx)(n.p,{children:"A graph can be directed or undirected, weighted or unweighted, and can have cycles or be acyclic. There are many different types of graphs, including trees, forests, complete graphs, and bipartite\ngraphs."})]})]}),"\n",(0,r.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(s.Z,{children:[(0,r.jsx)(a.Z,{value:"practice",label:"Practice",children:(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Aspect"}),(0,r.jsx)("th",{children:"Pseudo Code"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Graph Edge"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"GraphEdge\n  get_key()\n    return start_vertex.value + '_' + end_vertex.value\n\n  reverse()\n    tmp = start_vertex\n    start_vertex = end_vertex\n    end_vertex = tmp\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Graph Vertex"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"GraphVertex\n  add_edge(edge)\n    edges.append(edge)\n\n  delete_edge(edge)\n    edges.delete(edge)\n\n  get_neighbors()\n    neighbors = []\n    for (node in edges):\n      if node.value.start_vertex == this:\n        neighbors.add(node.value.end_vertex)\n      else:\n        neighbors.add(node.value.start_vertex)\n    return neighbors\n\n  getEdges()\n    edges = []\n    for (node in edges):\n      edges.add(node.value)\n\n  get_degree()\n    edges.length\n\n  has_edge(required_edge)\n    return edges.find(required_edge)\n\n  has_neighbor(vertex)\n    return edges.find(start_vertex === vertex or edge.end_vertex === vertex)\n\n  find_edge(vertex)\n    return edges.find(edge.start_vertex === vertex or edge.end_vertex === vertex)\n\n  delete_all_edges()\n    for (node in get_edges()):\n      delete_edge(node)\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Get Vertex by Key"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"get_vertex_by_key(vertexKey)\n  return vertices[vertexKey]\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Add Edge"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"add_edge(edge)\n  start_vertex = get_vertex_by_key(edge.start_vertex.value)\n  end_vertex = get_vertex_by_key(edge.end_vertex.value)\n\n  if start_vertex != \xf8:\n    add_vertex(edge.start_vertex)\n    start_vertex = get_vertex_by_key(edge.start_vertex.value)\n\n  if end_vertex != \xf8:\n    add_vertex(edge.end_vertex)\n    end_vertex = get_vertex_by_key(edge.end_vertex.value)\n\n  if edges[edge.get_key()]:\n    throw Error('Edge has already been added before')\n  else:\n    edges[edge.get_key()] = edge\n\n  if isDirected:\n    start_vertex.add_edge(edge)\n  else:\n    start_vertex.add_edge(edge)\n    end_vertex.add_edge(edge)\n\n  add_vertex(new_vertex)\n    vertices[new_vertex.value] = new_vertex\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Delete Edge"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"delete_edge(edge)\n  if edges[edge.get_key()]:\n    delete edges[edge.get_key()]\n  else:\n    'Edge not found in graph'\n\n  start_vertex = get_vertex_by_key(edge.start_vertex.value)\n  end_vertex = get_vertex_by_key(edge.end_vertex.value)\n\n  start_vertex.delete_edge(edge)\n  end_vertex.delete_edge(edge)\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Get All Edges"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"get_all_edges()\n  edges = []\n  for {key, edge} in edges:\n    vertices.add(vertex)\n  return edges\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Get Weight"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"get_weight()\n  weight = 0\n  for graph_edge in get_all_edges():\n    weight += graph_edge.weight\n  return weight\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Reverse"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"reverse()\n  for edge in get_all_edges():\n    delete_edge(edge)\n    edge.reverse()\n    add_edge(edge)\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Find Edge"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"find_edge(start_vertex, end_vertex)\n  vertex = get_vertex_by_key(start_vertex.value)\n  if vertex != \xf8\n    return null\n  return vertex.find_edge(end_vertex)\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Get Adjacency Matrix"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"get_adjacency_matrix()\n  vertices_indices = get_vertices_indices()\n  adjacency_matrix = [][]\n  for {i, vertex} in get_all_vertices():\n    for neighbor in vertex.get_neighbors():\n      adjacency_matrix[vertexIndex][vertices_indices[neighbor.get_key()]] = find_edge(vertex, neighbor).weight))\n  return adjacency_matrix\n\nget_vertices_indices()\n  vertices_indices = Map()\n  for {i, vertex} in vertices:\n    vertices_indices[vertex.value] = index\n  return vertices_indices\n\nget_neighbors(vertex)\n  return vertex.get_neighbors()\n\nget_all_vertices()\n  vertices = []\n  for {key, vertex} in vertices:\n    vertices.add(vertex)\n  return vertices\n"})})})]})]})]})}),(0,r.jsx)(a.Z,{value:"solution",label:"Solution",children:(0,r.jsxs)(s.Z,{queryString:"code",children:[(0,r.jsx)(a.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(g.Z,{language:"go",children:i})}),(0,r.jsx)(a.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(g.Z,{language:"java",children:l})}),(0,r.jsx)(a.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(g.Z,{language:"js",children:x})}),(0,r.jsx)(a.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(g.Z,{language:"kotlin",children:h})}),(0,r.jsx)(a.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(g.Z,{language:"python",children:c})}),(0,r.jsx)(a.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(g.Z,{language:"rust",children:v})}),(0,r.jsx)(a.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(g.Z,{language:"ts",children:u})})]})})]})]})}function G(e={}){const{wrapper:n}={...(0,d.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(y,{...e})}):y(e)}},80300:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/images/graph-9c12894435131ecc7172d25547d2815c.svg"}}]);