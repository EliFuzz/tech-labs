"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[6639],{3187:(t,s,n)=>{n.r(s),n.d(s,{assets:()=>h,contentTitle:()=>g,default:()=>b,frontMatter:()=>d,metadata:()=>_,toc:()=>v});var e=n(11527),r=n(88672),i=n(29140),a=n(52360),u=n(52296);const m="package main\n\nfunc recursiveStaircaseBruteforce(stairsNum int) int {\n\tif stairsNum <= 0 {\n\t\treturn 0\n\t}\n\n\tif stairsNum == 1 || stairsNum == 2 {\n\t\treturn stairsNum\n\t}\n\n\treturn recursiveStaircaseBruteforce(stairsNum-1) + recursiveStaircaseBruteforce(stairsNum-2)\n}\n\nfunc recursiveStaircaseIterative(stairsNum int) int {\n\tif stairsNum <= 0 {\n\t\treturn 0\n\t}\n\n\tsteps := []int{1, 2}\n\n\tif stairsNum <= 2 {\n\t\treturn steps[stairsNum-1]\n\t}\n\n\tfor currentStep := 3; currentStep <= stairsNum; currentStep++ {\n\t\tsteps[0], steps[1] = steps[1], steps[0]+steps[1]\n\t}\n\n\treturn steps[1]\n}\n\nfunc recursiveStaircaseDynamicProgramming(stairsNum int) int {\n\tif stairsNum < 0 {\n\t\treturn 0\n\t}\n\n\tsteps := make([]int, stairsNum+1)\n\n\tsteps[0] = 0\n\tsteps[1] = 1\n\tsteps[2] = 2\n\n\tif stairsNum <= 2 {\n\t\treturn steps[stairsNum]\n\t}\n\n\tfor currentStep := 3; currentStep <= stairsNum; currentStep++ {\n\t\tsteps[currentStep] = steps[currentStep-1] + steps[currentStep-2]\n\t}\n\n\treturn steps[stairsNum]\n}\n\nfunc recursiveStaircaseMemoization(totalStairs int) int {\n\tmemo := make([]int, totalStairs+1)\n\n\tvar getSteps func(int) int\n\tgetSteps = func(stairsNum int) int {\n\t\tif stairsNum <= 0 {\n\t\t\treturn 0\n\t\t}\n\n\t\tif stairsNum == 1 || stairsNum == 2 {\n\t\t\treturn stairsNum\n\t\t}\n\n\t\tif memo[stairsNum] != 0 {\n\t\t\treturn memo[stairsNum]\n\t\t}\n\n\t\tmemo[stairsNum] = getSteps(stairsNum-1) + getSteps(stairsNum-2)\n\n\t\treturn memo[stairsNum]\n\t}\n\n\treturn getSteps(totalStairs)\n}\n",c="import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n\n  public static int recursiveStaircaseBruteforce(int stairsNum) {\n    if (stairsNum <= 0) {\n      return 0;\n    }\n\n    if (stairsNum == 1 || stairsNum == 2) {\n      return stairsNum;\n    }\n\n    return recursiveStaircaseBruteforce(stairsNum - 1) +\n        recursiveStaircaseBruteforce(stairsNum - 2);\n  }\n\n  public static int recursiveStaircaseIterative(int stairsNum) {\n    if (stairsNum <= 0) {\n      return 0;\n    }\n\n    int[] steps = {1, 2};\n\n    if (stairsNum <= 2) {\n      return steps[stairsNum - 1];\n    }\n\n    for (int currentStep = 3; currentStep <= stairsNum; currentStep++) {\n      int temp = steps[0];\n      steps[0] = steps[1];\n      steps[1] = temp + steps[1];\n    }\n\n    return steps[1];\n  }\n\n  public static int recursiveStaircaseDynamicProgramming(int stairsNum) {\n    if (stairsNum < 0) {\n      return 0;\n    }\n\n    int[] steps = new int[stairsNum + 1];\n\n    steps[0] = 0;\n    steps[1] = 1;\n    steps[2] = 2;\n\n    if (stairsNum <= 2) {\n      return steps[stairsNum];\n    }\n\n    for (int currentStep = 3; currentStep <= stairsNum; currentStep++) {\n      steps[currentStep] = steps[currentStep - 1] + steps[currentStep - 2];\n    }\n\n    return steps[stairsNum];\n  }\n\n  public static int recursiveStaircaseMemoization(int totalStairs) {\n    Map<Integer, Integer> memo = new HashMap<>();\n\n    return getSteps(totalStairs, memo);\n  }\n\n  private static int getSteps(int stairsNum, Map<Integer, Integer> memo) {\n    if (stairsNum <= 0) {\n      return 0;\n    }\n\n    if (stairsNum == 1 || stairsNum == 2) {\n      return stairsNum;\n    }\n\n    if (memo.containsKey(stairsNum)) {\n      return memo.get(stairsNum);\n    }\n\n    int result = getSteps(stairsNum - 1, memo) + getSteps(stairsNum - 2, memo);\n    memo.put(stairsNum, result);\n\n    return result;\n  }\n}\n",o="function recursiveStaircaseBruteforce(stairsNum) {\n  if (stairsNum <= 0) {\n    return 0;\n  }\n\n  if (stairsNum === 1 || stairsNum === 2) {\n    return stairsNum;\n  }\n\n  return (\n    recursiveStaircaseBruteforce(stairsNum - 1) +\n    recursiveStaircaseBruteforce(stairsNum - 2)\n  );\n}\n\nfunction recursiveStaircaseIterative(stairsNum) {\n  if (stairsNum <= 0) {\n    return 0;\n  }\n\n  const steps = [1, 2];\n\n  if (stairsNum <= 2) {\n    return steps[stairsNum - 1];\n  }\n\n  for (let currentStep = 3; currentStep <= stairsNum; currentStep += 1) {\n    [steps[0], steps[1]] = [steps[1], steps[0] + steps[1]];\n  }\n\n  return steps[1];\n}\n\nfunction recursiveStaircaseDynamicProgramming(stairsNum) {\n  if (stairsNum < 0) {\n    return 0;\n  }\n\n  const steps = new Array(stairsNum + 1).fill(0);\n\n  steps[0] = 0;\n  steps[1] = 1;\n  steps[2] = 2;\n\n  if (stairsNum <= 2) {\n    return steps[stairsNum];\n  }\n\n  for (let currentStep = 3; currentStep <= stairsNum; currentStep += 1) {\n    steps[currentStep] = steps[currentStep - 1] + steps[currentStep - 2];\n  }\n\n  return steps[stairsNum];\n}\n\nfunction recursiveStaircaseMemoization(totalStairs) {\n  const memo = [];\n\n  const getSteps = (stairsNum) => {\n    if (stairsNum <= 0) {\n      return 0;\n    }\n\n    if (stairsNum === 1 || stairsNum === 2) {\n      return stairsNum;\n    }\n\n    if (memo[stairsNum]) {\n      return memo[stairsNum];\n    }\n\n    memo[stairsNum] = getSteps(stairsNum - 1) + getSteps(stairsNum - 2);\n\n    return memo[stairsNum];\n  };\n\n  return getSteps(totalStairs);\n}\n",p="fun recursiveStaircaseBruteforce(stairsNum: Int): Int {\n    if (stairsNum <= 0) {\n        return 0\n    }\n    if (stairsNum == 1 || stairsNum == 2) {\n        return stairsNum\n    }\n    return recursiveStaircaseBruteforce(stairsNum - 1) + recursiveStaircaseBruteforce(stairsNum - 2)\n}\n\nfun recursiveStaircaseIterative(stairsNum: Int): Int {\n    if (stairsNum <= 0) {\n        return 0\n    }\n    val steps = intArrayOf(1, 2)\n    if (stairsNum <= 2) {\n        return steps[stairsNum - 1]\n    }\n    for (currentStep in 3..stairsNum) {\n        steps[0] = steps[1].also { steps[1] += steps[0] }\n    }\n    return steps[1]\n}\n\nfun recursiveStaircaseDynamicProgramming(stairsNum: Int): Int {\n    if (stairsNum < 0) {\n        return 0\n    }\n    val steps = IntArray(stairsNum + 1) { 0 }\n    steps[1] = 1\n    steps[2] = 2\n    if (stairsNum <= 2) {\n        return steps[stairsNum]\n    }\n    for (currentStep in 3..stairsNum) {\n        steps[currentStep] = steps[currentStep - 1] + steps[currentStep - 2]\n    }\n    return steps[stairsNum]\n}\n\nfun recursiveStaircaseMemoization(totalStairs: Int): Int {\n    val memo = mutableMapOf<Int, Int>()\n\n    fun getSteps(stairsNum: Int): Int {\n        if (stairsNum <= 0) {\n            return 0\n        }\n        if (stairsNum == 1 || stairsNum == 2) {\n            return stairsNum\n        }\n        if (memo.containsKey(stairsNum)) {\n            return memo[stairsNum]!!\n        }\n        memo[stairsNum] = getSteps(stairsNum - 1) + getSteps(stairsNum - 2)\n        return memo[stairsNum]!!\n    }\n\n    return getSteps(totalStairs)\n}\n",l="def recursive_staircase_bruteforce(stairs_num):\n    if stairs_num <= 0:\n        return 0\n    if stairs_num == 1 or stairs_num == 2:\n        return stairs_num\n    return (recursive_staircase_bruteforce(stairs_num - 1) +\n            recursive_staircase_bruteforce(stairs_num - 2))\n\n\ndef recursive_staircase_iterative(stairs_num):\n    if stairs_num <= 0:\n        return 0\n    steps = [1, 2]\n    if stairs_num <= 2:\n        return steps[stairs_num - 1]\n    for current_step in range(3, stairs_num + 1):\n        steps[0], steps[1] = steps[1], steps[0] + steps[1]\n    return steps[1]\n\n\ndef recursive_staircase_dynamic_programming(stairs_num):\n    if stairs_num < 0:\n        return 0\n    steps = [0] * (stairs_num + 1)\n    steps[1] = 1\n    steps[2] = 2\n    if stairs_num <= 2:\n        return steps[stairs_num]\n    for current_step in range(3, stairs_num + 1):\n        steps[current_step] = steps[current_step - 1] + steps[current_step - 2]\n    return steps[stairs_num]\n\n\ndef recursive_staircase_memoization(total_stairs):\n    memo = {}\n\n    def get_steps(stairs_num):\n        if stairs_num <= 0:\n            return 0\n        if stairs_num == 1 or stairs_num == 2:\n            return stairs_num\n        if stairs_num in memo:\n            return memo[stairs_num]\n        memo[stairs_num] = get_steps(stairs_num - 1) + get_steps(stairs_num - 2)\n        return memo[stairs_num]\n\n    return get_steps(total_stairs)\n",f="fn recursive_staircase_bruteforce(stairs_num: i32) -> i32 {\n    if stairs_num <= 0 {\n        return 0;\n    }\n    if stairs_num == 1 || stairs_num == 2 {\n        return stairs_num;\n    }\n    recursive_staircase_bruteforce(stairs_num - 1) + recursive_staircase_bruteforce(stairs_num - 2)\n}\n\nfn recursive_staircase_iterative(stairs_num: i32) -> i32 {\n    if stairs_num <= 0 {\n        return 0;\n    }\n    let mut steps = vec![1, 2];\n    if stairs_num <= 2 {\n        return steps[(stairs_num - 1) as usize];\n    }\n    for current_step in 3..=stairs_num {\n        steps[0] = steps[1];\n        steps[1] += steps[0];\n    }\n    steps[1]\n}\n\nfn recursive_staircase_dynamic_programming(stairs_num: i32) -> i32 {\n    if stairs_num < 0 {\n        return 0;\n    }\n    let mut steps = vec![0; (stairs_num + 1) as usize];\n    steps[1] = 1;\n    steps[2] = 2;\n    if stairs_num <= 2 {\n        return steps[stairs_num as usize];\n    }\n    for current_step in 3..=stairs_num {\n        steps[current_step as usize] = steps[(current_step - 1) as usize] + steps[(current_step - 2) as usize];\n    }\n    steps[stairs_num as usize]\n}\n\nfn recursive_staircase_memoization(total_stairs: i32) -> i32 {\n    let mut memo = vec![0; (total_stairs + 1) as usize];\n\n    fn get_steps(stairs_num: i32, memo: &mut Vec<i32>) -> i32 {\n        if stairs_num <= 0 {\n            return 0;\n        }\n        if stairs_num == 1 || stairs_num == 2 {\n            return stairs_num;\n        }\n        if memo[stairs_num as usize] != 0 {\n            return memo[stairs_num as usize];\n        }\n        memo[stairs_num as usize] = get_steps(stairs_num - 1, memo) + get_steps(stairs_num - 2, memo);\n        memo[stairs_num as usize]\n    }\n\n    get_steps(total_stairs, &mut memo)\n}\n",N="function recursiveStaircaseBruteforce(stairsNum: number): number {\n  if (stairsNum <= 0) {\n    return 0;\n  }\n\n  if (stairsNum === 1 || stairsNum === 2) {\n    return stairsNum;\n  }\n\n  return (\n    recursiveStaircaseBruteforce(stairsNum - 1) +\n    recursiveStaircaseBruteforce(stairsNum - 2)\n  );\n}\n\nfunction recursiveStaircaseIterative(stairsNum: number): number {\n  if (stairsNum <= 0) {\n    return 0;\n  }\n\n  const steps: number[] = [1, 2];\n\n  if (stairsNum <= 2) {\n    return steps[stairsNum - 1];\n  }\n\n  for (let currentStep = 3; currentStep <= stairsNum; currentStep += 1) {\n    [steps[0], steps[1]] = [steps[1], steps[0] + steps[1]];\n  }\n\n  return steps[1];\n}\n\nfunction recursiveStaircaseDynamicProgramming(stairsNum: number): number {\n  if (stairsNum < 0) {\n    return 0;\n  }\n\n  const steps: number[] = new Array(stairsNum + 1).fill(0);\n\n  steps[0] = 0;\n  steps[1] = 1;\n  steps[2] = 2;\n\n  if (stairsNum <= 2) {\n    return steps[stairsNum];\n  }\n\n  for (let currentStep = 3; currentStep <= stairsNum; currentStep += 1) {\n    steps[currentStep] = steps[currentStep - 1] + steps[currentStep - 2];\n  }\n\n  return steps[stairsNum];\n}\n\nfunction recursiveStaircaseMemoization(totalStairs: number): number {\n  const memo: number[] = [];\n\n  const getSteps = (stairsNum: number): number => {\n    if (stairsNum <= 0) {\n      return 0;\n    }\n\n    if (stairsNum === 1 || stairsNum === 2) {\n      return stairsNum;\n    }\n\n    if (memo[stairsNum]) {\n      return memo[stairsNum];\n    }\n\n    memo[stairsNum] = getSteps(stairsNum - 1) + getSteps(stairsNum - 2);\n\n    return memo[stairsNum];\n  };\n\n  return getSteps(totalStairs);\n}\n",d={title:"Recursive Staircase",description:"Recursive Staircase",hide_table_of_contents:!0},g=void 0,_={id:"education/computer-science/algorithms/algo/recursive-staircase",title:"Recursive Staircase",description:"Recursive Staircase",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/recursive-staircase.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/recursive-staircase",permalink:"/docs/education/computer-science/algorithms/algo/recursive-staircase",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/recursive-staircase.mdx",tags:[],version:"current",frontMatter:{title:"Recursive Staircase",description:"Recursive Staircase",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Rain Terraces",permalink:"/docs/education/computer-science/algorithms/algo/rain-terraces"},next:{title:"Regular Expression Matching",permalink:"/docs/education/computer-science/algorithms/algo/regular-expression-matching"}},h={},v=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function S(t){const s={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...t.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(s.h2,{id:"definition",children:"Definition"}),"\n",(0,e.jsxs)(i.Z,{children:[(0,e.jsx)(a.Z,{value:"definition",label:"Definition",children:(0,e.jsx)(s.p,{children:"The Recursive Staircase Algorithm (Fibonacci) is a dynamic programming approach to efficiently solve the problem of finding the number of ways to climb a staircase with a given number of steps, where you can take either 1 or 2 steps at a time. It optimizes the computation by storing previously calculated results, avoiding redundant calculations"})}),(0,e.jsx)(a.Z,{value:"how",label:"Explanation",children:(0,e.jsxs)(s.p,{children:["It calculates the number of ways to climb a staircase with ",(0,e.jsx)(s.code,{children:"n"})," steps by recursively breaking down the problem into smaller subproblems. At each step, it considers two possibilities: either taking one step or taking two steps. It then sums up the results of these two possibilities to find the total number of ways to climb ",(0,e.jsx)(s.code,{children:"n"})," steps. By memoizing previously computed results, it avoids redundant calculations and optimizes the overall computation."]})}),(0,e.jsx)(a.Z,{value:"guidance",label:"Guidance",children:(0,e.jsxs)(s.ul,{children:["\n",(0,e.jsxs)(s.li,{children:["Base cases","\n",(0,e.jsxs)(s.ul,{children:["\n",(0,e.jsx)(s.li,{children:"if n is 0 or 1, there is only one way to climb the staircase (either by taking no steps or taking one step)"}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(s.li,{children:["If the result for ",(0,e.jsx)(s.code,{children:"n"})," is already computed (memoized), return it","\n",(0,e.jsxs)(s.ul,{children:["\n",(0,e.jsxs)(s.li,{children:["Otherwise, recursively compute the number of ways to climb ",(0,e.jsx)(s.code,{children:"n-1"})," steps and ",(0,e.jsx)(s.code,{children:"n-2"})," steps"]}),"\n",(0,e.jsxs)(s.li,{children:["Memoize the result for ",(0,e.jsx)(s.code,{children:"n"})]}),"\n",(0,e.jsxs)(s.li,{children:["Return the sum of the results computed for ",(0,e.jsx)(s.code,{children:"n-1"})," and ",(0,e.jsx)(s.code,{children:"n-2"})]}),"\n"]}),"\n"]}),"\n"]})}),(0,e.jsx)(a.Z,{value:"tips",label:"Tips",children:(0,e.jsxs)(s.ul,{children:["\n",(0,e.jsx)(s.li,{children:"utilize memoization to store previously computed results and avoid redundant calculations, significantly improving efficiency"}),"\n",(0,e.jsx)(s.li,{children:"start by considering the base cases (0 and 1 steps) to build the recursive solution from the ground up"}),"\n",(0,e.jsx)(s.li,{children:"be cautious of potential stack overflow issues with deep recursion for large values of n; consider optimizing with iterative approaches or tail recursion if necessary"}),"\n"]})})]}),"\n",(0,e.jsx)(s.h2,{id:"practice",children:"Practice"}),"\n",(0,e.jsxs)(i.Z,{children:[(0,e.jsx)(a.Z,{value:"practice",label:"Practice",children:(0,e.jsx)(s.pre,{children:(0,e.jsx)(s.code,{className:"language-python",children:"countWays(n):\n  if n <= 1:\n    return 1  # Base cases\n\n  if memo[n] is not None:\n    return memo[n]  # Return memoized result if available\n\n  # Recursive calls\n  memo[n] = countWays(n-1) + countWays(n-2)\n\n  return memo[n]\n\n# Initialize memoization array\nmemo = [None] * (max_steps + 1)\n"})})}),(0,e.jsx)(a.Z,{value:"solution",label:"Solution",children:(0,e.jsxs)(i.Z,{queryString:"code",children:[(0,e.jsx)(a.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,e.jsx)(u.Z,{language:"go",children:m})}),(0,e.jsx)(a.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,e.jsx)(u.Z,{language:"java",children:c})}),(0,e.jsx)(a.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,e.jsx)(u.Z,{language:"js",children:o})}),(0,e.jsx)(a.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,e.jsx)(u.Z,{language:"kotlin",children:p})}),(0,e.jsx)(a.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,e.jsx)(u.Z,{language:"python",children:l})}),(0,e.jsx)(a.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,e.jsx)(u.Z,{language:"rust",children:f})}),(0,e.jsx)(a.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,e.jsx)(u.Z,{language:"ts",children:N})})]})})]})]})}function b(t={}){const{wrapper:s}={...(0,r.a)(),...t.components};return s?(0,e.jsx)(s,{...t,children:(0,e.jsx)(S,{...t})}):S(t)}}}]);