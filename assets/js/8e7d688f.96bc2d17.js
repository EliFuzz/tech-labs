"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[5423],{93844:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>l,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"education/programming-languages/frontend/js/framework/react/react","title":"Basics","description":"React Basics","source":"@site/docs/education/02-programming-languages/02-frontend/01-js/03-framework/01-react/01-react.mdx","sourceDirName":"education/02-programming-languages/02-frontend/01-js/03-framework/01-react","slug":"/education/programming-languages/frontend/js/framework/react/","permalink":"/tech-labs/docs/education/programming-languages/frontend/js/framework/react/","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/02-programming-languages/02-frontend/01-js/03-framework/01-react/01-react.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Basics","description":"React Basics","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"React","permalink":"/tech-labs/docs/category/react"},"next":{"title":"State Management","permalink":"/tech-labs/docs/education/programming-languages/frontend/js/framework/react/state-management"}}');var t=s(86070),o=s(15658),a=s(52421),i=s(74610);const l={title:"Basics",description:"React Basics",hide_table_of_contents:!0},d=void 0,c={},h=[{value:"Re-Rendering",id:"re-rendering",level:2},{value:"Anti-pattern: Creating components in render function",id:"anti-pattern-creating-components-in-render-function",level:3},{value:"Moving state down",id:"moving-state-down",level:3},{value:"Children as props",id:"children-as-props",level:3},{value:"Components as props",id:"components-as-props",level:3},{value:"React.memo",id:"reactmemo",level:3},{value:"Component with props",id:"component-with-props",level:3},{value:"Components as props or children",id:"components-as-props-or-children",level:3},{value:"Necessary useMemo/useCallback",id:"necessary-usememousecallback",level:3},{value:"useMemo for expensive calculations",id:"usememo-for-expensive-calculations",level:3},{value:"Memoizing Provider value",id:"memoizing-provider-value",level:3},{value:"Splitting data and API",id:"splitting-data-and-api",level:3},{value:"Splitting data into chunks",id:"splitting-data-into-chunks",level:3},{value:"Context selectors",id:"context-selectors",level:3},{value:"Anti-pattern: random value as key in lists",id:"anti-pattern-random-value-as-key-in-lists",level:3}];function m(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"re-rendering",children:"Re-Rendering"}),"\n",(0,t.jsxs)(a.A,{queryString:"primary",children:[(0,t.jsx)(i.A,{value:"glossary",label:"Glossary",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"initial render"})," - happens when a component first appears on the screen"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"re-render"})," - second and any consecutive render of a component that is already on the screen. Re-renders in React happen when the app updates with new data, usually from user interactions or asynchronous requests"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"necessary re-render"})," - updates a component directly reflecting changes (e.g., input field updates on keystrokes)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"unnecessary re-render"})," - caused by inefficiencies, leading to broader re-renders (e.g., entire page re-renders on keystrokes). Excessive re-renders can cause lag, delays, or unresponsiveness"]}),"\n"]})}),(0,t.jsx)(i.A,{value:"reasons",label:"Reasons",children:(0,t.jsxs)(a.A,{queryString:"secondary",children:[(0,t.jsxs)(i.A,{value:"state",label:"State",attributes:{className:"tabs__vertical"},children:[(0,t.jsxs)(n.p,{children:["when a component's state changes, it re-renders, typically in a callback or the ",(0,t.jsx)(n.code,{children:"useEffect"})," hook. State changes are the primary cause of re-renders"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => {\n  const [state, setState] = useState(); // 1. state changed\n\n  return (...);\n}                                       // 2. re-render whole component\n"})})]}),(0,t.jsxs)(i.A,{value:"parent",label:"Parent",children:[(0,t.jsxs)(n.p,{children:["re-rendering flows down the tree ",(0,t.jsx)(n.strong,{children:"parent \u2192 children"})," but not vice versa"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Parent = () => { // 1. re-renders\n\n  return <Child />     // 2. re-renders children\n}\n"})})]}),(0,t.jsxs)(i.A,{value:"context",label:"Context",children:[(0,t.jsx)(n.p,{children:"when the value in a Context Provider changes, all components using that Context will re-render, even if they don't directly use the changed data (cascading). Memoization can't prevent these re-renders"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,6,13}",children:"// useUser.js\nconst useUser = useContext(UserContext) => { // 1. re-renders\n\n}\n\n// UserProfile.js\nconst userProfile = () => {\n  const user = useUser();\n\n  return (...);\n}\n\n// UserDetails.js\nconst UserDetails = () => {\n  const user = useUser();\n\n  return (...);\n}                                             // 2. both will be re-rendered (UserProfile and UserDetails)\n"})})]}),(0,t.jsxs)(i.A,{value:"hooks",label:"Hooks",children:[(0,t.jsxs)(n.p,{children:["all actions within a hook are tied to the component that uses it. The same rules for ",(0,t.jsx)(n.strong,{children:"Context"})," and ",(0,t.jsx)(n.strong,{children:"State"})," changes apply:"]}),(0,t.jsxs)("ul",{children:[(0,t.jsx)("li",{children:"state change within the hook will cause an unavoidable re-render of the host component"}),(0,t.jsx)("li",{children:"if the hook uses Context and its value changes, it will also trigger an unavoidable re-render of the host component"})]}),(0,t.jsx)(n.p,{children:"Hooks can be chained, and each hook in the chain remains associated with the host component, following the same rules"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,8}",children:"// useUser.js\nconst useUser = useContext(UserContext) => { // 1. value changes\n  const useName = {                          // 2. chain reaction\n    useName()\n  }\n}\n\n// UserComponent.js\nconst UserComponent = () => {                // 3. re-renders\n  const name = useName();\n\n  return (...);\n}\n"})})]}),(0,t.jsxs)(i.A,{value:"props",label:"Props (myth)",children:[(0,t.jsxs)(n.p,{children:["For non-memoized components, it doesn't matter if the component's props change (they are not the sole reason for re-renders); if the parent re-renders, the child will re-render as well. Props can only change if the parent updates them, which triggers the child's re-render. However, when using memoization techniques like ",(0,t.jsx)(n.code,{children:"React.memo"})," or ",(0,t.jsx)(n.code,{children:"useMemo"}),", prop changes become significant"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Parent = () => {              // 1. re-renders\n  return <Child value={{value}} />;\n}                                   // 2. doesn't matter of props change children will re-render\n"})})]})]})}),(0,t.jsx)(i.A,{value:"prevention",label:"Prevention",children:(0,t.jsxs)(a.A,{queryString:"secondary",children:[(0,t.jsxs)(i.A,{value:"composition",label:"Composition",attributes:{className:"tabs__vertical"},children:[(0,t.jsx)(n.h3,{id:"anti-pattern-creating-components-in-render-function",children:"Anti-pattern: Creating components in render function"}),(0,t.jsx)(n.p,{children:"Creating components inside the render function of another component is an anti-pattern that can severely impact performance. Each re-render causes React to re-mount the inner component, which is slower than a normal re-render."}),(0,t.jsx)(n.p,{children:"This can lead to issues such as:"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'content "flashes" during re-renders'}),"\n",(0,t.jsx)(n.li,{children:"state being reset with each re-render"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"useEffect"})," without dependencies triggering on every re-render"]}),"\n",(0,t.jsx)(n.li,{children:"loss of focus if the component was focused"}),"\n"]}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => {            // 1. re-renders\n  const SlowComponent = () => <></>; // 2. new component\n\n  return (\n    <>\n      <SlowComponent />              // 3. re-mounts\n    </>\n  );\n}\n"})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const SlowComponent = () => <></>; // 2. same component\n\nconst Component = () => {          // 1. re-renders\n  return (\n    <>\n      <SlowComponent />            // 3. just re-renders\n    </>\n  );\n}\n"})})})]})})]}),(0,t.jsx)(n.h3,{id:"moving-state-down",children:"Moving state down"}),(0,t.jsx)(n.p,{children:"Useful when a heavy component manages state that only affects a small, isolated part of the render tree. For example, consider a complex component that opens or closes a dialog with a button click"}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => {\n  const [open, setOpen] = useState(false); // 2. updated\n\n  return (\n    <>\n      <button\n        onClick={() => setOpen(true)}      // 1. triggers re-render\n      >\n      Open\n      </button>\n      {open && <Modal />}\n      <SlowComponent />\n    </>\n  );\n}                                         // 3. re-renders whole component\n"})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,17}",children:"// ButtonWithDialog.js\nconst ButtonWithDialog = () => {\n  const [open, setOpen] = useState(false); // 2. updated\n\n  return (\n    <>\n      <button\n        onClick={() => setOpen(true)}      // 1. triggers re-render\n      >\n      Open\n      </button>\n      {open && <Modal />}\n    </>\n  );\n}                                          // 3. re-renders whole component\n\n// Component.js\nconst Component = () => {\n  return (\n    <>\n      <ButtonWithDialog />\n      <SlowComponent />                    // not affected\n    </>\n  );\n}\n"})})})]})})]}),(0,t.jsx)(n.h3,{id:"children-as-props",children:"Children as props"}),(0,t.jsxs)(n.p,{children:['Known as "wrapping state around children," is similar to "moving state down" but focuses on encapsulating state changes in a smaller component that wraps a slower part of the render tree. A common example is using ',(0,t.jsx)(n.code,{children:"onScroll"})," or ",(0,t.jsx)(n.code,{children:"onMouseMove"})," callbacks on the root element of a component"]}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => {\n  const [value, setValue] = useState({}); // 2. updated\n\n  return (\n    <div\n      onScroll={(e) => setValue(e)}       // 1. triggers re-render\n    >\n      <SlowComponent />\n    </div>\n  );\n}                                         // 3. re-renders whole component\n"})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,14}",children:"// ComponentWithScroll.js\nconst ComponentWithScroll = ({ children }) => {\n  const [value, setValue] = useState({}); // 2. updated\n\n  return (\n    <div\n      onScroll={(e) => setValue(e)}       // 1. triggers re-render\n    >\n      {children}                          // 3. just props, not affected\n    </div>\n  );\n}\n\n// Component.js\nconst Component = () => {\n  return (\n    <>\n      <ComponentWithScroll>\n        <SlowComponent />                 // not affected\n      </ComponentWithScroll>\n    </>\n  );\n}\n"})})})]})})]}),(0,t.jsx)(n.h3,{id:"components-as-props",children:"Components as props"}),(0,t.jsx)(n.p,{children:"Encapsulates state within a smaller component while passing heavy components as props. Since props are not affected by state changes, the heavy components won't re-render. Useful when several heavy components are independent of the state but cannot be extracted as a group of children"}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => {\n  const [value, setValue] = useState({}); // 2. updated\n\n  return (\n    <div\n      onScroll={(e) => setValue(e)}       // 1. triggers re-render\n    >\n      <SlowComponent />\n      <UserComponent />\n      <AnotherSlowComponent />\n    </div>\n  );\n}                                         // 3. re-renders whole component\n"})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,16}",children:"// ComponentWithScroll.js\nconst ComponentWithScroll = ({ above, below }) => {\n  const [value, setValue] = useState({}); // 2. updated\n\n  return (\n    <div\n      onScroll={(e) => setValue(e)}       // 1. triggers re-render\n    >\n      {above}                             // 3. just props, not affected\n      <UserComponent />\n      {below}                             // 3. just props, not affected\n    </div>\n  );\n}\n\n// Component.js\nconst Component = () => {\n  return (\n    <ComponentWithScroll\n      above={<SlowComponent />}           // not affected\n      below={<AnotherSlowComponent />}    // not affected\n    />\n  );\n}\n"})})})]})})]})]}),(0,t.jsxs)(i.A,{value:"react-memo",label:"React.memo",children:[(0,t.jsx)(n.h3,{id:"reactmemo",children:"React.memo"}),(0,t.jsxs)(n.p,{children:["Wrapping a component in ",(0,t.jsx)(n.code,{children:"React.memo"})," will prevent downstream re-renders triggered by changes higher up in the render tree, unless the component's props have changed. Useful for rendering heavy components that do not depend on the source of re-renders, such as state or updated data."]}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Parent = () => {  // 1. re-renders\n  return <Child />;     // 2. re-renders children\n}\n"})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,4}",children:"// ChildMemo.js\nconst ChildMemo = React.memo(Child);\n\n// Parent.js\nconst Parent = () => {  // 1. re-renders\n  return <ChildMemo />; // 2. doesn't re-render\n}\n"})})})]})})]}),(0,t.jsx)(n.h3,{id:"component-with-props",children:"Component with props"}),(0,t.jsxs)(n.p,{children:["For ",(0,t.jsx)(n.code,{children:"React.memo"})," to work effectively, all props that are not primitive values must be memoized"]}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,4}",children:"// ChildMemo.js\nconst ChildMemo = React.memo(Child);\n\n// Parent.js\nconst Parent = () => {   // 1. re-renders\n  return (\n    <ChildMemo\n      value={{ value }}  // 2. doesn't re-render\n    />\n  );\n}\n"})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,4}",children:"// ChildMemo.js\nconst ChildMemo = React.memo(Child);\n\n// Parent.js\nconst Parent = () => {                          // 1. re-renders\n  const value - useMemo(() => ({ value }), []); // 2. stays the same\n\n  return (\n    <ChildMemo\n      value={ value }                           // 3. doesn't re-render\n    />\n  );\n}\n"})})})]})})]}),(0,t.jsx)(n.h3,{id:"components-as-props-or-children",children:"Components as props or children"}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"React.memo"})," must be applied to the elements passed as children or props. Simply memoizing the parent component won't suffice, as children and props are typically objects that change with every re-render"]}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,4}",children:"// ChildMemo.js\nconst ChildMemo = React.memo(Child);\n\n// Parent.js\nconst Parent = () => {      // 1. re-renders\n\n  return (\n    <ChildMemo\n      right={<Component />}\n    >\n      <GrandChild />\n    </ChildMemo>\n  );                        // 2. re-renders whole component\n}\n"})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,4,7}",children:"// ComponentMemo.js\nconst ComponentMemo = React.memo(Component);\n\n// GrandChildMemo.js\nconst GrandChildMemo = React.memo(GrandChild);\n\n// Parent.js\nconst Parent = () => {          // 1. re-renders\n  return (\n    <Child\n      right={<ComponentMemo />} // 2. doesn't re-render\n    >\n      <GrandChildMemo />        // 3. doesn't re-render\n    </Child>\n  );\n}\n"})})})]})})]})]}),(0,t.jsxs)(i.A,{value:"useMemo",label:"useMemo/useCallback",children:[(0,t.jsx)(n.h3,{id:"necessary-usememousecallback",children:"Necessary useMemo/useCallback"}),(0,t.jsx)(n.p,{children:"Memoizing props alone won't prevent a child component from re-rendering. If the parent component re-renders, it will trigger a re-render of the child component, regardless of the props"}),(0,t.jsxs)(n.p,{children:["If a child component is wrapped in ",(0,t.jsx)(n.code,{children:"React.memo"}),", all non-primitive props must be memoized to prevent unnecessary re-renders. If a component uses a non-primitive value as a dependency in hooks like ",(0,t.jsx)(n.code,{children:"useEffect"}),", ",(0,t.jsx)(n.code,{children:"useMemo"}),", or ",(0,t.jsx)(n.code,{children:"useCallback"}),", that value should be memoized to avoid unnecessary re-renders or recalculations"]}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Parent = () => {                      // 1. re-renders\n  const value = useMemo(() => ({ value }));\n\n  return <Child value={value} />;           // 2. value doesn't matter, re-renders\n}\n"})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,4,15}",children:"// ChildMemo.js\nconst ChildMemo = React.memo(Child);\n\n// Parent.js\nconst Parent = () => {  // 1. re-renders\n  const value = useMemo(() => ({ value }));\n\n  return (\n    <ChildMemo\n     value={value}     // 2. should be memoized, doesn't re-render\n    />\n  );\n}\n\n// ParentWithUseEffect.js\nconst Parent = () => {  // 1. re-renders\n  const value = useMemo(() => ({ value }));\n\n  useEffect(() => {\n\n  }, [value]);          // 2. should be memoized\n\n  return (...);\n}\n"})})})]})})]}),(0,t.jsx)(n.h3,{id:"usememo-for-expensive-calculations",children:"useMemo for expensive calculations"}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"useMemo"})," has its own cost, consuming some memory and slightly slowing down the initial render, so it shouldn't be used for every calculation. In most cases, mounting and updating components are the most expensive operations, unless you're performing complex calculations like generating prime numbers, which should generally be avoided on the frontend. Typically, ",(0,t.jsx)(n.code,{children:"useMemo"}),' is best used to memoize React elements, such as parts of an existing render tree or results from a map function that generates new elements. The cost of "pure" JavaScript operations like sorting or filtering an array is usually negligible compared to component updates']}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => { // 1. re-renders\n  return (\n    <>\n      <FirstComponent />\n      <SlowComponent />\n      <SecondComponent />\n    </>\n  );                      // 2. re-renders whole component\n}\n"})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => {     // 1. re-renders\n  const SlowComponent = useMemo(()=> {\n    return <SlowComponent />;\n  }, []);\n\n  return (\n    <>\n      <FirstComponent />\n      {SlowComponent}        // 2. doesn't re-render\n      <SecondComponent />\n    </>\n  );\n}\n"})})})]})})]})]}),(0,t.jsxs)(i.A,{value:"prevention-context",label:"Context",children:[(0,t.jsx)(n.h3,{id:"memoizing-provider-value",children:"Memoizing Provider value"}),(0,t.jsx)(n.p,{children:"If a Context Provider is not placed at the very root of the app and may re-render due to changes in its ancestor components, its value should be memoized. This helps prevent unnecessary re-renders of components that consume the context"}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => { // 1. re-renders\n  return (\n    <Context.Provider\n      data={{value}}      // 2. on value changes every consumer re-renders\n    >\n      {children}\n    </Context.Provider>\n  );\n}\n"})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => { // 1. re-renders\n  const memoValue = useMemo(() => ({ value }), []);\n\n  return (\n    <Context.Provider\n      data={memoValue}    // 2. stays the same no one re-renders\n    >\n      {children}\n    </Context.Provider>\n  );\n}\n"})})})]})})]}),(0,t.jsx)(n.h3,{id:"splitting-data-and-api",children:"Splitting data and API"}),(0,t.jsx)(n.p,{children:"If a Context contains both data and API (getters and setters), they can be split into separate Providers within the same component. This way, components that only use the API won't re-render when the data changes"}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => {\n  const [state, setState] = useState(); // 1. state change\n\n  const memo = useMemo(() => ({\n    data: state,\n    api: (data) => setState(data)\n  }), [state]);\n\n  return (\n    <Context.Provider\n      data={value}                     // 2. every consumer re-renders\n    >\n      {children}\n    </Context.Provider>\n  );\n}\n"})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => {\n  const [state, setState] = useState(); // 1. state change\n\n  return (\n    <DataContext.Provider\n      data={state}\n    >\n      <ApiContext.Provider\n        data={setState}                 // 2. API consumers won't re-render\n      >\n        {children}\n      </ApiContext.Provider>\n    </DataContext.Provider>\n  );\n}\n"})})})]})})]}),(0,t.jsx)(n.h3,{id:"splitting-data-into-chunks",children:"Splitting data into chunks"}),(0,t.jsx)(n.p,{children:"If a Context manages multiple independent data chunks, they can be split into smaller providers under the same parent provider. This approach ensures that only the consumers of the changed data chunk will re-render"}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => {\n  const [first, setFirst] = useState();   // 1. state change\n  const [second, setSecond] = useState();\n\n  const data = useMemo(() => ({\n    first: first,\n    second: second\n  }), [first, second]);\n\n  return (\n    <Context.Provider\n      data={data}                        // 2. every consumer re-renders\n    >\n      {children}\n    </Context.Provider>\n  );\n}\n"})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => {\n  const [first, setFirst] = useState(); // 1. state change\n  const [second, setSecond] = useState();\n\n  return (\n    <Data1Context.Provider\n      data={first}\n    >\n      <Data2Context.Provider\n        data={second}               // 2. 2nd state consumers won't re-render\n      >\n        {children}\n      </Data2Context.Provider>\n    </Data1Context.Provider>\n  );\n}\n"})})})]})})]}),(0,t.jsx)(n.h3,{id:"context-selectors",children:"Context selectors"}),(0,t.jsxs)(n.p,{children:["There is no way to prevent a component that uses a portion of a Context value from re-rendering, even if that specific piece of data hasn't changed, and even with the ",(0,t.jsx)(n.code,{children:"useMemo"})," hook. However, Context selectors can be simulated using higher-order components and ",(0,t.jsx)(n.code,{children:"React.memo"})," to optimize re-renders"]}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,8}",children:'// useUser.js\nconst useUser = () => {\n  const { name } = useContext(UserContext); // 1. will re-render\n                                            // even if "name" hasn\'t change\n\n  return useMemo(() => name, [name]);       // 2. useMemo won\'t help\n}\n\n// Component.js\nconst Component = () => {\n  const { name } = useUser();               // 1. will re-render\n                                            // even if "name" hasn\'t change\n\n  return (...);\n}\n'})})}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,13}",children:'// withUser.js\nconst withUser = (Component) => {\n  const MemoComponent = React.memo(Component);// 1. component is memomized\n\n  return () => {\n    const { name } = useUser();\n\n    return <MemoComponent name={name} />;     // 2. re-renders\n                                              // only if "name" changes\n  };\n}\n\n// Component.js\nconst Component = withUser(({ name }) => {    // 3. re-renders\n                                              // only if "name" changes\n  return (...);\n});\n'})})})]})})]})]}),(0,t.jsxs)(i.A,{value:"lists",label:"Performance of Lists",children:[(0,t.jsx)(n.h3,{id:"anti-pattern-random-value-as-key-in-lists",children:"Anti-pattern: random value as key in lists"}),(0,t.jsxs)(n.p,{children:["Simply providing a ",(0,t.jsx)(n.code,{children:"key"})," attribute won't improve performance; to prevent re-renders of list elements, you need to wrap them in ",(0,t.jsx)(n.code,{children:"React.memo"})," and follow its best practices. The ",(0,t.jsx)(n.code,{children:"key"})," value should be a consistent string for each element in the list across re-renders, typically using an item's ID or the array's index. Using the array's index as a key is acceptable for static lists where elements are not added, removed, or reordered"]}),(0,t.jsx)(n.p,{children:"Randomly generated values or index as a key in dynamic lists should never be used as the key attribute in lists. Doing so will cause React to re-mount items on every re-render, resulting in:"}),(0,t.jsxs)("ul",{children:[(0,t.jsx)("li",{children:"bugs if items have state or uncontrolled elements (like form inputs)"}),(0,t.jsxs)("li",{children:["degraded performance if items are wrapped in ",(0,t.jsx)(n.code,{children:"React.memo"})]})]}),(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Case"}),(0,t.jsx)("th",{children:"Solution"})]})}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsxs)("td",{children:[(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:"const Component = () => { // 1. re-renders\n  return (\n    <>\n      {items.map((item) => (\n       <Child\n        key={item.id}    // 2. key doesn't prevent re-renders\n        item={item}\n       />\n      ))}\n    </>\n  );\n}\n"})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,4}",children:"// ChildMemo.js\nconst ChildMemo = React.memo(Child);\n\n// Parent.js\nconst Parent = () => {    // 1. re-renders\n  return (\n    <>\n      {items.map((item) => (\n       <ChildMemo\n        key={Math.random()}    // 2. causes re-mount on every re-render\n        item={item}\n       />\n      ))}\n    </>\n  );\n}\n"})})]}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",metastring:"{1,4}",children:"// ChildMemo.js\nconst ChildMemo = React.memo(Child);\n\n// Parent.js\nconst Parent = () => {    // 1. re-renders\n  return (\n    <>\n      {items.map((item) => (\n       <ChildMemo\n        key={item.id}    // 2. doesn't re-render\n        item={item}\n       />\n      ))}\n    </>\n  );\n}\n"})})})]})})]})]})]})})]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}}}]);