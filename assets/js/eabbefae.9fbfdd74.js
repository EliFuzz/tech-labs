"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[3298],{75552:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>g,contentTitle:()=>x,default:()=>y,frontMatter:()=>p,metadata:()=>f,toc:()=>v});var t=i(86070),s=i(25710),r=i(98459),l=i(37515),c=i(18792);const a="package main\n\nfunc min(a, b, c int) int {\n    if a <= b && a <= c {\n        return a\n    } else if b <= a && b <= c {\n        return b\n    } else {\n        return c\n    }\n}\n\nfunc levenshteinDistance(s1, s2 string) int {\n    m, n := len(s1), len(s2)\n    dp := make([][]int, m+1)\n    for i := range dp {\n        dp[i] = make([]int, n+1)\n    }\n\n    for i := 0; i <= m; i++ {\n        for j := 0; j <= n; j++ {\n            if i == 0 {\n                dp[i][j] = j\n            } else if j == 0 {\n                dp[i][j] = i\n            } else if s1[i-1] == s2[j-1] {\n                dp[i][j] = dp[i-1][j-1]\n            } else {\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n            }\n        }\n    }\n\n    return dp[m][n]\n}\n",o="public class LevenshteinDistance {\n\n  public static int min(int x, int y, int z) {\n    if (x <= y && x <= z) {\n      return x;\n    }\n    if (y <= x && y <= z) {\n      return y;\n    }\n    return z;\n  }\n\n  public static int levenshteinDistance(String s1, String s2) {\n    int m = s1.length();\n    int n = s2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n      for (int j = 0; j <= n; j++) {\n        if (i == 0) {\n          dp[i][j] = j;\n        } else if (j == 0) {\n          dp[i][j] = i;\n        } else if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n          dp[i][j] = dp[i - 1][j - 1];\n        } else {\n          dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n        }\n      }\n    }\n    return dp[m][n];\n  }\n}\n",d="function min(x, y, z) {\n  if (x <= y && x <= z) {\n    return x;\n  }\n  if (y <= x && y <= z) {\n    return y;\n  }\n  return z;\n}\n\nfunction levenshteinDistance(s1, s2) {\n  const m = s1.length;\n  const n = s2.length;\n  const dp = [];\n  for (let i = 0; i <= m; i++) {\n    dp[i] = [];\n    for (let j = 0; j <= n; j++) {\n      if (i === 0) {\n        dp[i][j] = j;\n      } else if (j === 0) {\n        dp[i][j] = i;\n      } else if (s1[i - 1] === s2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n      }\n    }\n  }\n  return dp[m][n];\n}\n",h="fun min(x: Int, y: Int, z: Int) = if (x <= y && x <= z) x else if (y <= x && y <= z) y else z\n\nfun levenshteinDistance(s1: String, s2: String): Int {\n    val m = s1.length\n    val n = s2.length\n    val dp = Array(m + 1) { IntArray(n + 1) }\n\n    for (i in 0..m) {\n        for (j in 0..n) {\n            when {\n                i == 0 -> dp[i][j] = j\n                j == 0 -> dp[i][j] = i\n                s1[i - 1] == s2[j - 1] -> dp[i][j] = dp[i - 1][j - 1]\n                else -> dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n            }\n        }\n    }\n    return dp[m][n]\n}\n",j="def levenshtein_distance(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n\n    return dp[m][n]\n",m="fn min(x: usize, y: usize, z: usize) -> usize {\n    if x <= y && x <= z {\n        x\n    } else if y <= x && y <= z {\n        y\n    } else {\n        z\n    }\n}\n\nfn levenshtein_distance(s1: &str, s2: &str) -> usize {\n    let m = s1.chars().count();\n    let n = s2.chars().count();\n    let mut dp = vec![vec![0; n + 1]; m + 1];\n\n    for i in 0..=m {\n        for j in 0..=n {\n            dp[i][j] = if i == 0 {\n                j\n            } else if j == 0 {\n                i\n            } else if s1.chars().nth(i - 1) == s2.chars().nth(j - 1) {\n                dp[i - 1][j - 1]\n            } else {\n                1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n            };\n        }\n    }\n\n    dp[m][n]\n}\n",u="function min(x: number, y: number, z: number): number {\n  if (x <= y && x <= z) return x;\n  if (y <= x && y <= z) return y;\n  return z;\n}\n\nfunction levenshteinDistance(s1: string, s2: string): number {\n  const m = s1.length;\n  const n = s2.length;\n  const dp: number[][] = [];\n  for (let i = 0; i <= m; i++) {\n    dp[i] = [];\n    for (let j = 0; j <= n; j++) {\n      if (i === 0) {\n        dp[i][j] = j;\n      } else if (j === 0) {\n        dp[i][j] = i;\n      } else if (s1.charAt(i - 1) === s2.charAt(j - 1)) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);\n      }\n    }\n  }\n  return dp[m][n];\n}\n",p={title:"Levenshtein Distance",description:"Levenshtein Distance",hide_table_of_contents:!0},x=void 0,f={id:"education/computer-science/algorithms/algo/levenshtein-distance",title:"Levenshtein Distance",description:"Levenshtein Distance",source:"@site/docs/education/01-computer-science/10-algorithms/04-algo/levenshtein-distance.mdx",sourceDirName:"education/01-computer-science/10-algorithms/04-algo",slug:"/education/computer-science/algorithms/algo/levenshtein-distance",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/levenshtein-distance",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/levenshtein-distance.mdx",tags:[],version:"current",frontMatter:{title:"Levenshtein Distance",description:"Levenshtein Distance",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Least Common Multiple (LCM)",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/least-common-multiple"},next:{title:"Linear Search",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/linear-search"}},g={},v=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function b(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,t.jsxs)(r.A,{queryString:"primary",children:[(0,t.jsx)(l.A,{value:"definition",label:"Definition",children:(0,t.jsx)(e.p,{children:"The Levenshtein Distance Algorithm is a dynamic programming technique used to measure the similarity between two strings by calculating the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform one string into another"})}),(0,t.jsx)(l.A,{value:"how",label:"Explanation",children:(0,t.jsx)(e.p,{children:"The Levenshtein Distance Algorithm works by constructing a matrix where each cell represents the cost of transforming a substring of one string into a substring of another. It iterates through each cell in the matrix, calculating the minimum cost based on the previous cell values and the current characters being compared. The final value in the bottom-right cell of the matrix represents the Levenshtein distance between the two strings"})}),(0,t.jsx)(l.A,{value:"guidance",label:"Guidance",children:(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Create a grid (matrix) ",(0,t.jsx)(e.code,{children:"M"})," with dimensions (",(0,t.jsx)(e.code,{children:"[m+1][n+1]"}),"), where ",(0,t.jsx)(e.code,{children:"m"})," and ",(0,t.jsx)(e.code,{children:"n"})," are the lengths of the 2 string"]}),"\n",(0,t.jsxs)(e.li,{children:["Fill the first row and column of the matrix with values from ",(0,t.jsx)(e.code,{children:"0"})," to ",(0,t.jsx)(e.code,{children:"m"})," and ",(0,t.jsx)(e.code,{children:"0"})," to ",(0,t.jsx)(e.code,{children:"n"})," respectively, representing transformation costs"]}),"\n",(0,t.jsxs)(e.li,{children:["Iterate through each cell ",(0,t.jsx)(e.code,{children:"[i, j]"})," of the matrix, starting from ",(0,t.jsx)(e.code,{children:"[1, 1]"})]}),"\n",(0,t.jsxs)(e.li,{children:["Calculate costs for 3 operations, where ",(0,t.jsx)(e.code,{children:"cost"})," is ",(0,t.jsx)(e.code,{children:"0"})," if characters at ",(0,t.jsx)(e.code,{children:"[i, j]"})," match, ",(0,t.jsx)(e.code,{children:"1"})," otherwise","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["insertion: ",(0,t.jsx)(e.code,{children:"M[i][j-1] + 1"})]}),"\n",(0,t.jsxs)(e.li,{children:["deletion: ",(0,t.jsx)(e.code,{children:"M[i-1][j] + 1"})]}),"\n",(0,t.jsxs)(e.li,{children:["substitution: ",(0,t.jsx)(e.code,{children:"M[i-1][j-1] + cost"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["Set ",(0,t.jsx)(e.code,{children:"M[i][j]"})," to the minimum of the calculated costs"]}),"\n",(0,t.jsxs)(e.li,{children:["The value at ",(0,t.jsx)(e.code,{children:"M[m][n]"})," represents the Levenshtein distance, indicating the minimum number of edits required to transform one string into the other"]}),"\n"]})}),(0,t.jsx)(l.A,{value:"tips",label:"Tips",children:(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"utilize memoization or tabulation to optimize the algorithm's performance, especially when dealing with large strings"}),"\n",(0,t.jsx)(e.li,{children:"consider space optimization techniques such as only storing the last two rows of the matrix to reduce memory usage"}),"\n",(0,t.jsx)(e.li,{children:"leverage bitwise operations or other optimizations when calculating the costs to further enhance efficiency"}),"\n"]})})]}),"\n",(0,t.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,t.jsxs)(r.A,{queryString:"primary",children:[(0,t.jsx)(l.A,{value:"practice",label:"Practice",children:(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"levenshteinDistance(str1, str2):\n  m = length(str1)\n  n = length(str2)\n  matrix = new matrix[m+1][n+1]\n\n  // Initialize first row and column\n  for i from 0 to m:\n    matrix[i][0] = i\n  for j from 0 to n:\n    matrix[0][j] = j\n\n  // Fill the matrix\n  for i from 1 to m:\n    for j from 1 to n:\n      cost = 0 if str1[i-1] == str2[j-1] else 1\n      insertion = matrix[i][j-1] + 1\n      deletion = matrix[i-1][j] + 1\n      substitution = matrix[i-1][j-1] + cost\n      matrix[i][j] = min(insertion, deletion, substitution)\n\n  return matrix[m][n]\n"})})}),(0,t.jsx)(l.A,{value:"solution",label:"Solution",children:(0,t.jsxs)(r.A,{queryString:"code",children:[(0,t.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,t.jsx)(c.A,{language:"go",children:a})}),(0,t.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,t.jsx)(c.A,{language:"java",children:o})}),(0,t.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,t.jsx)(c.A,{language:"js",children:d})}),(0,t.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,t.jsx)(c.A,{language:"kotlin",children:h})}),(0,t.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,t.jsx)(c.A,{language:"python",children:j})}),(0,t.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,t.jsx)(c.A,{language:"rust",children:m})}),(0,t.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,t.jsx)(c.A,{language:"ts",children:u})})]})})]})]})}function y(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(b,{...n})}):b(n)}}}]);