"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[4179],{97982:(n,t,i)=>{i.r(t),i.d(t,{assets:()=>g,contentTitle:()=>p,default:()=>w,frontMatter:()=>h,metadata:()=>y,toc:()=>x});var e=i(86070),r=i(27468),u=i(20301),b=i(35379),o=i(81895);const s="package main\n\nfunc getBit(number, bitPosition int) int {\n    return (number >> bitPosition) & 1\n}\n\nfunc setBit(number, bitPosition int) int {\n    return number | (1 << bitPosition)\n}\n\nfunc clearBit(number, bitPosition int) int {\n    return number &^ (1 << bitPosition)\n}\n\nfunc updateBit(number, bitPosition, bitValue int) int {\n    mask := ^(1 << bitPosition)\n    return (number & mask) | (bitValue << bitPosition)\n}\n\nfunc isEven(number int) bool {\n    return (number & 1) == 0\n}\n\nfunc isPositive(number int) bool {\n    return number >= 0 && (number & 0x80000000) == 0\n}\n\nfunc multiplyByTwo(number int) int {\n    return number << 1\n}\n\nfunc divideByTwo(number int) int {\n    return number >> 1\n}\n\nfunc switchSign(number int) int {\n    return ^number + 1\n}\n\nfunc multiply(a, b int) int {\n    if b == 0 {\n        return 0\n    }\n    if b > 0 {\n        return a + multiply(a, b-1)\n    }\n    if b < 0 {\n        return -multiply(a, -b)\n    }\n    return 0\n}\n\nfunc multiplyUnsigned(x, y int) int {\n    var result int\n    for y > 0 {\n        if y&1 == 1 {\n            result += x\n        }\n        x <<= 1\n        y >>= 1\n    }\n    return result\n}\n\nfunc countSetBits(number int) int {\n    var count int\n    for number != 0 {\n        count += number & 1\n        number >>= 1\n    }\n    return count\n}\n\nfunc bitsDiff(a, b int) int {\n    var count int\n    diff := a ^ b\n    for diff != 0 {\n        count += diff & 1\n        diff >>= 1\n    }\n    return count\n}\n\nfunc bitLength(number int) int {\n    var count int\n    for number != 0 {\n        count++\n        number >>= 1\n    }\n    return count\n}\n\nfunc isPowerOfTwo(number int) bool {\n    return number != 0 && (number&(number-1)) == 0\n}\n\nfunc fullAdder(a, b int) int {\n    var carry, result, i int\n    for a != 0 || b != 0 || carry != 0 {\n        bitA := a & 1\n        bitB := b & 1\n        sum := bitA ^ bitB ^ carry\n        result |= sum << i\n        carry = (bitA & bitB) | (bitA & carry) | (bitB & carry)\n        a >>= 1\n        b >>= 1\n        i++\n    }\n    return result\n}\n",l="public class BitOperations {\n\n  public static int getBit(int number, int bitPosition) {\n    return (number >> bitPosition) & 1;\n  }\n\n  public static int setBit(int number, int bitPosition) {\n    return number | (1 << bitPosition);\n  }\n\n  public static int clearBit(int number, int bitPosition) {\n    return number & ~(1 << bitPosition);\n  }\n\n  public static int updateBit(int number, int bitPosition, int bitValue) {\n    int mask = ~(1 << bitPosition);\n    return (number & mask) | (bitValue << bitPosition);\n  }\n\n  public static boolean isEven(int number) {\n    return (number & 1) == 0;\n  }\n\n  public static boolean isPositive(int number) {\n    return number >= 0 && (number & 0x80000000) == 0;\n  }\n\n  public static int multiplyByTwo(int number) {\n    return number << 1;\n  }\n\n  public static int divideByTwo(int number) {\n    return number >> 1;\n  }\n\n  public static int switchSign(int number) {\n    return ~number + 1;\n  }\n\n  public static int multiply(int a, int b) {\n    if (b == 0) {\n      return 0;\n    }\n    if (b > 0) {\n      return a + multiply(a, b - 1);\n    }\n    if (b < 0) {\n      return -multiply(a, -b);\n    }\n    return 0;\n  }\n\n  public static int multiplyUnsigned(int x, int y) {\n    int result = 0;\n    while (y > 0) {\n      if ((y & 1) == 1) {\n        result += x;\n      }\n      x <<= 1;\n      y >>= 1;\n    }\n    return result;\n  }\n\n  public static int countSetBits(int number) {\n    int count = 0;\n    while (number != 0) {\n      count += number & 1;\n      number >>= 1;\n    }\n    return count;\n  }\n\n  public static int bitsDiff(int a, int b) {\n    int count = 0;\n    int diff = a ^ b;\n    while (diff != 0) {\n      count += diff & 1;\n      diff >>= 1;\n    }\n    return count;\n  }\n\n  public static int bitLength(int number) {\n    int count = 0;\n    while (number != 0) {\n      count++;\n      number >>= 1;\n    }\n    return count;\n  }\n\n  public static boolean isPowerOfTwo(int number) {\n    return number != 0 && (number & (number - 1)) == 0;\n  }\n\n  public static int fullAdder(int a, int b) {\n    int carry = 0;\n    int result = 0;\n    int i = 0;\n    while (a != 0 || b != 0 || carry != 0) {\n      int bitA = a & 1;\n      int bitB = b & 1;\n      int sum = bitA ^ bitB ^ carry;\n      result |= sum << i;\n      carry = (bitA & bitB) | (bitA & carry) | (bitB & carry);\n      a >>= 1;\n      b >>= 1;\n      i++;\n    }\n    return result;\n  }\n}\n",a="function getBit(number, bitPosition) {\n  return (number >> bitPosition) & 1;\n}\n\nfunction setBit(number, bitPosition) {\n  return number | (1 << bitPosition);\n}\n\nfunction clearBit(number, bitPosition) {\n  return number & ~(1 << bitPosition);\n}\n\nfunction updateBit(number, bitPosition, bitValue) {\n  const mask = ~(1 << bitPosition);\n  return (number & mask) | (bitValue << bitPosition);\n}\n\nfunction isEven(number) {\n  return (number & 1) === 0;\n}\n\nfunction isPositive(number) {\n  return number >= 0 && (number & 0x80000000) === 0;\n}\n\nfunction multiplyByTwo(number) {\n  return number << 1;\n}\n\nfunction divideByTwo(number) {\n  return number >> 1;\n}\n\nfunction switchSign(number) {\n  return ~number + 1;\n}\n\nfunction multiply(a, b) {\n  if (b === 0) {\n    return 0;\n  }\n  if (b > 0) {\n    return a + multiply(a, b - 1);\n  }\n  if (b < 0) {\n    return -multiply(a, -b);\n  }\n}\n\nfunction multiplyUnsigned(x, y) {\n  let result = 0;\n  while (y > 0) {\n    if (y & 1) {\n      result += x;\n    }\n    x <<= 1;\n    y >>= 1;\n  }\n  return result;\n}\n\nfunction countSetBits(number) {\n  let count = 0;\n  while (number) {\n    count += number & 1;\n    number >>= 1;\n  }\n  return count;\n}\n\nfunction bitsDiff(a, b) {\n  let count = 0;\n  let diff = a ^ b;\n  while (diff) {\n    count += diff & 1;\n    diff >>= 1;\n  }\n  return count;\n}\n\nfunction bitLength(number) {\n  let count = 0;\n  while (number) {\n    count++;\n    number >>= 1;\n  }\n  return count;\n}\n\nfunction isPowerOfTwo(number) {\n  return number !== 0 && (number & (number - 1)) === 0;\n}\n\nfunction fullAdder(a, b) {\n  let carry = 0;\n  let result = 0;\n  let i = 0;\n  while (a !== 0 || b !== 0 || carry !== 0) {\n    const bitA = a & 1;\n    const bitB = b & 1;\n    const sum = bitA ^ bitB ^ carry;\n    result |= sum << i;\n    carry = (bitA & bitB) | (bitA & carry) | (bitB & carry);\n    a >>= 1;\n    b >>= 1;\n    i++;\n  }\n  return result;\n}\n",m="fun getBit(number: Int, bitPosition: Int): Int {\n    return (number shr bitPosition) and 1\n}\n\nfun setBit(number: Int, bitPosition: Int): Int {\n    return number or (1 shl bitPosition)\n}\n\nfun clearBit(number: Int, bitPosition: Int): Int {\n    return number and (1 shl bitPosition).inv()\n}\n\nfun updateBit(number: Int, bitPosition: Int, bitValue: Int): Int {\n    val mask = (1 shl bitPosition).inv()\n    return (number and mask) or (bitValue shl bitPosition)\n}\n\nfun isEven(number: Int): Boolean {\n    return (number and 1) == 0\n}\n\nfun isPositive(number: Int): Boolean {\n    return number >= 0 && (number and 0x80000000.inv()) == 0\n}\n\nfun multiplyByTwo(number: Int): Int {\n    return number shl 1\n}\n\nfun divideByTwo(number: Int): Int {\n    return number shr 1\n}\n\nfun switchSign(number: Int): Int {\n    return number.inv() + 1\n}\n\nfun multiply(a: Int, b: Int): Int {\n    return when {\n        b == 0 -> 0\n        b > 0 -> a + multiply(a, b - 1)\n        else -> -multiply(a, -b)\n    }\n}\n\nfun multiplyUnsigned(x: Int, y: Int): Int {\n    var result = 0\n    var x = x\n    var y = y\n    while (y > 0) {\n        if (y and 1 == 1) {\n            result += x\n        }\n        x = x shl 1\n        y = y shr 1\n    }\n    return result\n}\n\nfun countSetBits(number: Int): Int {\n    var count = 0\n    var number = number\n    while (number != 0) {\n        count += number and 1\n        number = number shr 1\n    }\n    return count\n}\n\nfun bitsDiff(a: Int, b: Int): Int {\n    var count = 0\n    var diff = a xor b\n    while (diff != 0) {\n        count += diff and 1\n        diff = diff shr 1\n    }\n    return count\n}\n\nfun bitLength(number: Int): Int {\n    var count = 0\n    var number = number\n    while (number != 0) {\n        count++\n        number = number shr 1\n    }\n    return count\n}\n\nfun isPowerOfTwo(number: Int): Boolean {\n    return number != 0 && (number and (number - 1)) == 0\n}\n\nfun fullAdder(a: Int, b: Int): Int {\n    var carry = 0\n    var result = 0\n    var i = 0\n    var a = a\n    var b = b\n    while (a != 0 || b != 0 || carry != 0) {\n        val bitA = a and 1\n        val bitB = b and 1\n        val sum = bitA xor bitB xor carry\n        result = result or (sum shl i)\n        carry = (bitA and bitB) or (bitA and carry) or (bitB and carry)\n        a = a shr 1\n        b = b shr 1\n        i++\n    }\n    return result\n}\n",c="def get_bit(number, bit_position):\n    return (number >> bit_position) & 1\n\ndef set_bit(number, bit_position):\n    return number | (1 << bit_position)\n\ndef clear_bit(number, bit_position):\n    return number & ~(1 << bit_position)\n\ndef update_bit(number, bit_position, bit_value):\n    mask = ~(1 << bit_position)\n    return (number & mask) | (bit_value << bit_position)\n\ndef is_even(number):\n    return (number & 1) == 0\n\ndef is_positive(number):\n    return number >= 0 and (number & 0x80000000) == 0\n\ndef multiply_by_two(number):\n    return number << 1\n\ndef divide_by_two(number):\n    return number >> 1\n\ndef switch_sign(number):\n    return ~number + 1\n\ndef multiply(a, b):\n    if b == 0:\n        return 0\n    if b > 0:\n        return a + multiply(a, b - 1)\n    if b < 0:\n        return -multiply(a, -b)\n\ndef multiply_unsigned(x, y):\n    result = 0\n    while y > 0:\n        if y & 1:\n            result += x\n        x <<= 1\n        y >>= 1\n    return result\n\ndef count_set_bits(number):\n    count = 0\n    while number:\n        count += number & 1\n        number >>= 1\n    return count\n\ndef bits_diff(a, b):\n    count = 0\n    diff = a ^ b\n    while diff:\n        count += diff & 1\n        diff >>= 1\n    return count\n\ndef bit_length(number):\n    count = 0\n    while number:\n        count += 1\n        number >>= 1\n    return count\n\ndef is_power_of_two(number):\n    return number != 0 and (number & (number - 1)) == 0\n\ndef full_adder(a, b):\n    carry = 0\n    result = 0\n    i = 0\n    while a != 0 or b != 0 or carry != 0:\n        bit_a = a & 1\n        bit_b = b & 1\n        sum = bit_a ^ bit_b ^ carry\n        result |= sum << i\n        carry = (bit_a & bit_b) | (bit_a & carry) | (bit_b & carry)\n        a >>= 1\n        b >>= 1\n        i += 1\n    return result\n",f="fn get_bit(number: i32, bit_position: i32) -> i32 {\n    (number >> bit_position) & 1\n}\n\nfn set_bit(number: i32, bit_position: i32) -> i32 {\n    number | (1 << bit_position)\n}\n\nfn clear_bit(number: i32, bit_position: i32) -> i32 {\n    number & !(1 << bit_position)\n}\n\nfn update_bit(number: i32, bit_position: i32, bit_value: i32) -> i32 {\n    let mask = !(1 << bit_position);\n    (number & mask) | (bit_value << bit_position)\n}\n\nfn is_even(number: i32) -> bool {\n    (number & 1) == 0\n}\n\nfn is_positive(number: i32) -> bool {\n    number >= 0 && (number & 0x80000000) == 0\n}\n\nfn multiply_by_two(number: i32) -> i32 {\n    number << 1\n}\n\nfn divide_by_two(number: i32) -> i32 {\n    number >> 1\n}\n\nfn switch_sign(number: i32) -> i32 {\n    !number + 1\n}\n\nfn multiply(a: i32, b: i32) -> i32 {\n    match b {\n        0 => 0,\n        _ if b > 0 => a + multiply(a, b - 1),\n        _ => -multiply(a, -b),\n    }\n}\n\nfn multiply_unsigned(x: i32, y: i32) -> i32 {\n    let mut result = 0;\n    let mut x = x;\n    let mut y = y;\n    while y > 0 {\n        if y & 1 == 1 {\n            result += x;\n        }\n        x <<= 1;\n        y >>= 1;\n    }\n    result\n}\n\nfn count_set_bits(mut number: i32) -> i32 {\n    let mut count = 0;\n    while number != 0 {\n        count += number & 1;\n        number >>= 1;\n    }\n    count\n}\n\nfn bits_diff(a: i32, b: i32) -> i32 {\n    let mut count = 0;\n    let mut diff = a ^ b;\n    while diff != 0 {\n        count += diff & 1;\n        diff >>= 1;\n    }\n    count\n}\n\nfn bit_length(mut number: i32) -> i32 {\n    let mut count = 0;\n    while number != 0 {\n        count += 1;\n        number >>= 1;\n    }\n    count\n}\n\nfn is_power_of_two(number: i32) -> bool {\n    number != 0 && (number & (number - 1)) == 0\n}\n\nfn full_adder(a: i32, b: i32) -> i32 {\n    let mut carry = 0;\n    let mut result = 0;\n    let mut i = 0;\n    let mut a = a;\n    let mut b = b;\n    while a != 0 || b != 0 || carry != 0 {\n        let bit_a = a & 1;\n        let bit_b = b & 1;\n        let sum = bit_a ^ bit_b ^ carry;\n        result |= sum << i;\n        carry = (bit_a & bit_b) | (bit_a & carry) | (bit_b & carry);\n        a >>= 1;\n        b >>= 1;\n        i += 1;\n    }\n    result\n}\n",d="function getBit(number: number, bitPosition: number): number {\n  return (number >> bitPosition) & 1;\n}\n\nfunction setBit(number: number, bitPosition: number): number {\n  return number | (1 << bitPosition);\n}\n\nfunction clearBit(number: number, bitPosition: number): number {\n  return number & ~(1 << bitPosition);\n}\n\nfunction updateBit(\n  number: number,\n  bitPosition: number,\n  bitValue: number,\n): number {\n  const mask = ~(1 << bitPosition);\n  return (number & mask) | (bitValue << bitPosition);\n}\n\nfunction isEven(number: number): boolean {\n  return (number & 1) === 0;\n}\n\nfunction isPositive(number: number): boolean {\n  return number >= 0 && (number & 0x80000000) === 0;\n}\n\nfunction multiplyByTwo(number: number): number {\n  return number << 1;\n}\n\nfunction divideByTwo(number: number): number {\n  return number >> 1;\n}\n\nfunction switchSign(number: number): number {\n  return ~number + 1;\n}\n\nfunction multiply(a: number, b: number): number {\n  if (b === 0) {\n    return 0;\n  }\n  if (b > 0) {\n    return a + multiply(a, b - 1);\n  }\n  if (b < 0) {\n    return -multiply(a, -b);\n  }\n  return 0;\n}\n\nfunction multiplyUnsigned(x: number, y: number): number {\n  let result = 0;\n  while (y > 0) {\n    if (y & 1) {\n      result += x;\n    }\n    x <<= 1;\n    y >>= 1;\n  }\n  return result;\n}\n\nfunction countSetBits(number: number): number {\n  let count = 0;\n  while (number) {\n    count += number & 1;\n    number >>= 1;\n  }\n  return count;\n}\n\nfunction bitsDiff(a: number, b: number): number {\n  let count = 0;\n  let diff = a ^ b;\n  while (diff) {\n    count += diff & 1;\n    diff >>= 1;\n  }\n  return count;\n}\n\nfunction bitLength(number: number): number {\n  let count = 0;\n  while (number) {\n    count++;\n    number >>= 1;\n  }\n  return count;\n}\n\nfunction isPowerOfTwo(number: number): boolean {\n  return number !== 0 && (number & (number - 1)) === 0;\n}\n\nfunction fullAdder(a: number, b: number): number {\n  let carry = 0;\n  let result = 0;\n  let i = 0;\n  while (a !== 0 || b !== 0 || carry !== 0) {\n    const bitA = a & 1;\n    const bitB = b & 1;\n    const sum = bitA ^ bitB ^ carry;\n    result |= sum << i;\n    carry = (bitA & bitB) | (bitA & carry) | (bitB & carry);\n    a >>= 1;\n    b >>= 1;\n    i++;\n  }\n  return result;\n}\n",h={title:"Bit Manipulation",description:"Bit Manipulation",hide_table_of_contents:!0},p=void 0,y={id:"education/computer-science/algorithms/algo/bit-manipulation",title:"Bit Manipulation",description:"Bit Manipulation",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/bit-manipulation.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/bit-manipulation",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/bit-manipulation",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/bit-manipulation.mdx",tags:[],version:"current",frontMatter:{title:"Bit Manipulation",description:"Bit Manipulation",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Binary Search",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/binary-search"},next:{title:"Breadth-First Search (BFS)",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/breadth-first-search"}},g={},x=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function _(n){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(t.h2,{id:"definition",children:"Definition"}),"\n",(0,e.jsxs)(u.A,{queryString:"primary",children:[(0,e.jsx)(b.A,{value:"definition",label:"Definition",children:(0,e.jsx)(t.p,{children:"It involves manipulating individual bits within a binary representation of data. This algorithm aims to efficiently perform operations like setting, clearing, toggling, or checking the status of specific bits within binary numbers"})}),(0,e.jsx)(b.A,{value:"how",label:"Explanation",children:(0,e.jsx)(t.p,{children:"The algorithm leverages bitwise operators to perform operations directly on individual bits of binary numbers"})}),(0,e.jsx)(b.A,{value:"guidance",label:"Guidance",children:(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["Setting a Bit","\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["to set a specific bit at position pos in an integer num, use the OR operator with a bitmask where only the desired bit is set to 1","\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsx)(t.li,{children:(0,e.jsx)(t.code,{children:"num |= (1 << pos)"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["Clearing a Bit","\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["to clear a specific bit at position pos in an integer num, use the AND operator with a bitmask where only the desired bit is set to 0","\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsx)(t.li,{children:(0,e.jsx)(t.code,{children:"num &= ~(1 << pos)"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["Toggling a Bit","\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["to toggle a specific bit at position pos in an integer num, use the XOR operator with a bitmask where only the desired bit is set to 1","\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsx)(t.li,{children:(0,e.jsx)(t.code,{children:"num ^= (1 << pos)"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,e.jsxs)(t.li,{children:["Checking the Status of a Bit","\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:["to check if a specific bit at position pos in an integer num is set, use the AND operator with a bitmask where only the desired bit is set to 1","\n",(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsxs)(t.li,{children:[(0,e.jsx)(t.code,{children:"(num & (1 << pos)) != 0"})," will return true if the bit is set, false otherwise"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})}),(0,e.jsx)(b.A,{value:"tips",label:"Tips",children:(0,e.jsxs)(t.ul,{children:["\n",(0,e.jsx)(t.li,{children:"be mindful of integer overflow when shifting bits"}),"\n",(0,e.jsx)(t.li,{children:"ensure to use unsigned integers to avoid issues with signed bit manipulation"}),"\n"]})})]}),"\n",(0,e.jsx)(t.h2,{id:"practice",children:"Practice"}),"\n",(0,e.jsxs)(u.A,{queryString:"primary",children:[(0,e.jsx)(b.A,{value:"practice",label:"Practice",children:(0,e.jsx)(t.pre,{children:(0,e.jsx)(t.code,{className:"language-python",children:"// Setting a bit at position pos in num\nsetBit(num, pos):\n  return num | (1 << pos)\n\n// Clearing a bit at position pos in num\nclearBit(num, pos):\n  return num & ~(1 << pos)\n\n// Toggling a bit at position pos in num\ntoggleBit(num, pos):\n  return num ^ (1 << pos)\n\n// Checking if a bit at position pos in num is set\nisBitSet(num, pos):\n  return (num & (1 << pos)) != 0\n"})})}),(0,e.jsx)(b.A,{value:"solution",label:"Solution",children:(0,e.jsxs)(u.A,{queryString:"code",children:[(0,e.jsx)(b.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,e.jsx)(o.A,{language:"go",children:s})}),(0,e.jsx)(b.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,e.jsx)(o.A,{language:"java",children:l})}),(0,e.jsx)(b.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,e.jsx)(o.A,{language:"js",children:a})}),(0,e.jsx)(b.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,e.jsx)(o.A,{language:"kotlin",children:m})}),(0,e.jsx)(b.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,e.jsx)(o.A,{language:"python",children:c})}),(0,e.jsx)(b.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,e.jsx)(o.A,{language:"rust",children:f})}),(0,e.jsx)(b.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,e.jsx)(o.A,{language:"ts",children:d})})]})})]})]})}function w(n={}){const{wrapper:t}={...(0,r.R)(),...n.components};return t?(0,e.jsx)(t,{...n,children:(0,e.jsx)(_,{...n})}):_(n)}}}]);