"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[8718],{48489:(n,r,e)=>{e.r(r),e.d(r,{assets:()=>I,contentTitle:()=>h,default:()=>g,frontMatter:()=>b,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"education/computer-science/algorithms/algo/maximum-subarray","title":"Maximum Subarray","description":"Maximum Subarray","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/maximum-subarray.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/maximum-subarray","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/maximum-subarray","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/maximum-subarray.mdx","tags":[],"version":"current","frontMatter":{"title":"Maximum Subarray","description":"Maximum Subarray","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Matrices","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/matrices"},"next":{"title":"Merge Sort","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/merge-sort"}}');var a=e(86070),u=e(15658),i=e(33407),m=e(33903),s=e(68171);const x='package main\n\nimport (\n\t"math"\n)\n\nfunc BfMaximumSubarray(inputArray []int) []int {\n\tmaxSubarrayStartIndex := 0\n\tmaxSubarrayLength := 0\n\tvar maxSubarraySum *int\n\n\tfor startIndex := 0; startIndex < len(inputArray); startIndex++ {\n\t\tsubarraySum := 0\n\t\tfor arrLength := 1; arrLength <= len(inputArray)-startIndex; arrLength++ {\n\t\t\tsubarraySum += inputArray[startIndex+(arrLength-1)]\n\t\t\tif maxSubarraySum == nil || subarraySum > *maxSubarraySum {\n\t\t\t\tmaxSubarraySum = &subarraySum\n\t\t\t\tmaxSubarrayStartIndex = startIndex\n\t\t\t\tmaxSubarrayLength = arrLength\n\t\t\t}\n\t\t}\n\t}\n\n\treturn inputArray[maxSubarrayStartIndex : maxSubarrayStartIndex+maxSubarrayLength]\n}\n\nfunc DcMaximumSubarraySum(inputArray []int) int {\n\tvar solveRecursively func(int, bool) int\n\tsolveRecursively = func(elementIndex int, mustPick bool) int {\n\t\tif elementIndex >= len(inputArray) {\n\t\t\tif mustPick {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\treturn math.MinInt32\n\t\t}\n\t\treturn int(math.Max(\n\t\t\tfloat64(inputArray[elementIndex]+solveRecursively(elementIndex+1, true)),\n\t\t\tfloat64(solveRecursively(elementIndex+1, false)),\n\t\t))\n\t}\n\n\treturn solveRecursively(0, false)\n}\n\nfunc DpMaximumSubarray(inputArray []int) []int {\n\tmaxSum := math.Inf(-1)\n\tcurrentSum := 0.0\n\n\tmaxStartIndex := 0\n\tmaxEndIndex := len(inputArray) - 1\n\tcurrentStartIndex := 0\n\n\tfor currentIndex, currentNumber := range inputArray {\n\t\tcurrentSum += float64(currentNumber)\n\n\t\tif maxSum < currentSum {\n\t\t\tmaxSum = currentSum\n\t\t\tmaxStartIndex = currentStartIndex\n\t\t\tmaxEndIndex = currentIndex\n\t\t}\n\n\t\tif currentSum < 0 {\n\t\t\tcurrentSum = 0\n\t\t\tcurrentStartIndex = currentIndex + 1\n\t\t}\n\t}\n\n\treturn inputArray[maxStartIndex : maxEndIndex+1]\n}\n',l="import java.util.Arrays;\n\npublic class MaximumSubarray {\n\n  public static int[] bfMaximumSubarray(int[] inputArray) {\n    int maxSubarrayStartIndex = 0;\n    int maxSubarrayLength = 0;\n    int maxSubarraySum = Integer.MIN_VALUE;\n\n    for (int startIndex = 0; startIndex < inputArray.length; startIndex++) {\n      int subarraySum = 0;\n      for (int arrLength = 1; arrLength <= inputArray.length - startIndex; arrLength++) {\n        subarraySum += inputArray[startIndex + (arrLength - 1)];\n        if (maxSubarraySum == Integer.MIN_VALUE || subarraySum > maxSubarraySum) {\n          maxSubarraySum = subarraySum;\n          maxSubarrayStartIndex = startIndex;\n          maxSubarrayLength = arrLength;\n        }\n      }\n    }\n\n    return Arrays.copyOfRange(inputArray, maxSubarrayStartIndex, maxSubarrayStartIndex + maxSubarrayLength);\n  }\n\n  public static int dcMaximumSubarraySum(int[] inputArray) {\n    return solveRecursively(inputArray, 0, false);\n  }\n\n  private static int solveRecursively(int[] inputArray, int elementIndex, boolean mustPick) {\n    if (elementIndex >= inputArray.length) {\n      return mustPick ? 0 : Integer.MIN_VALUE;\n    }\n    return Math.max(\n        inputArray[elementIndex] + solveRecursively(inputArray, elementIndex + 1, true),\n        mustPick ? 0 : solveRecursively(inputArray, elementIndex + 1, false)\n    );\n  }\n\n  public static int[] dpMaximumSubarray(int[] inputArray) {\n    int maxSum = Integer.MIN_VALUE;\n    int currentSum = 0;\n\n    int maxStartIndex = 0;\n    int maxEndIndex = inputArray.length - 1;\n    int currentStartIndex = 0;\n\n    for (int currentIndex = 0; currentIndex < inputArray.length; currentIndex++) {\n      currentSum += inputArray[currentIndex];\n\n      if (maxSum < currentSum) {\n        maxSum = currentSum;\n        maxStartIndex = currentStartIndex;\n        maxEndIndex = currentIndex;\n      }\n\n      if (currentSum < 0) {\n        currentSum = 0;\n        currentStartIndex = currentIndex + 1;\n      }\n    }\n\n    return Arrays.copyOfRange(inputArray, maxStartIndex, maxEndIndex + 1);\n  }\n}\n",c="function bfMaximumSubarray(inputArray) {\n  let maxSubarrayStartIndex = 0;\n  let maxSubarrayLength = 0;\n  let maxSubarraySum = null;\n\n  for (let startIndex = 0; startIndex < inputArray.length; startIndex += 1) {\n    let subarraySum = 0;\n    for (\n      let arrLength = 1;\n      arrLength <= inputArray.length - startIndex;\n      arrLength += 1\n    ) {\n      subarraySum += inputArray[startIndex + (arrLength - 1)];\n      if (maxSubarraySum === null || subarraySum > maxSubarraySum) {\n        maxSubarraySum = subarraySum;\n        maxSubarrayStartIndex = startIndex;\n        maxSubarrayLength = arrLength;\n      }\n    }\n  }\n\n  return inputArray.slice(\n    maxSubarrayStartIndex,\n    maxSubarrayStartIndex + maxSubarrayLength,\n  );\n}\n\nfunction dcMaximumSubarraySum(inputArray) {\n  function solveRecursively(elementIndex, mustPick) {\n    if (elementIndex >= inputArray.length) {\n      return mustPick ? 0 : -Infinity;\n    }\n    return Math.max(\n      inputArray[elementIndex] + solveRecursively(elementIndex + 1, true),\n      mustPick ? 0 : solveRecursively(elementIndex + 1, false),\n    );\n  }\n\n  return solveRecursively(0, false);\n}\n\nfunction dpMaximumSubarray(inputArray) {\n  let maxSum = -Infinity;\n  let currentSum = 0;\n\n  let maxStartIndex = 0;\n  let maxEndIndex = inputArray.length - 1;\n  let currentStartIndex = 0;\n\n  inputArray.forEach((currentNumber, currentIndex) => {\n    currentSum += currentNumber;\n\n    if (maxSum < currentSum) {\n      maxSum = currentSum;\n      maxStartIndex = currentStartIndex;\n      maxEndIndex = currentIndex;\n    }\n\n    if (currentSum < 0) {\n      currentSum = 0;\n      currentStartIndex = currentIndex + 1;\n    }\n  });\n\n  return inputArray.slice(maxStartIndex, maxEndIndex + 1);\n}\n",d="fun bfMaximumSubarray(inputArray: IntArray): IntArray {\n    var maxSubarrayStartIndex = 0\n    var maxSubarrayLength = 0\n    var maxSubarraySum: Int? = null\n\n    for (startIndex in inputArray.indices) {\n        var subarraySum = 0\n        for (arrLength in 1..inputArray.size - startIndex) {\n            subarraySum += inputArray[startIndex + (arrLength - 1)]\n            if (maxSubarraySum == null || subarraySum > maxSubarraySum!!) {\n                maxSubarraySum = subarraySum\n                maxSubarrayStartIndex = startIndex\n                maxSubarrayLength = arrLength\n            }\n        }\n    }\n\n    return inputArray.sliceArray(maxSubarrayStartIndex until maxSubarrayStartIndex + maxSubarrayLength)\n}\n\nfun dcMaximumSubarraySum(inputArray: IntArray): Int {\n    fun solveRecursively(elementIndex: Int, mustPick: Boolean): Int {\n        if (elementIndex >= inputArray.size) {\n            return if (mustPick) 0 else Int.MIN_VALUE\n        }\n        return Math.max(\n                inputArray[elementIndex] + solveRecursively(elementIndex + 1, true),\n                if (mustPick) 0 else solveRecursively(elementIndex + 1, false)\n        )\n    }\n\n    return solveRecursively(0, false)\n}\n\nfun dpMaximumSubarray(inputArray: IntArray): IntArray {\n    var maxSum = Int.MIN_VALUE\n    var currentSum = 0\n\n    var maxStartIndex = 0\n    var maxEndIndex = inputArray.size - 1\n    var currentStartIndex = 0\n\n    inputArray.forEachIndexed { currentIndex, currentNumber ->\n        currentSum += currentNumber\n\n        if (maxSum < currentSum) {\n            maxSum = currentSum\n            maxStartIndex = currentStartIndex\n            maxEndIndex = currentIndex\n        }\n\n        if (currentSum < 0) {\n            currentSum = 0\n            currentStartIndex = currentIndex + 1\n        }\n    }\n\n    return inputArray.sliceArray(maxStartIndex..maxEndIndex)\n}\n",y="def bfMaximumSubarray(inputArray):\n    maxSubarrayStartIndex = 0\n    maxSubarrayLength = 0\n    maxSubarraySum = None\n\n    for startIndex in range(len(inputArray)):\n        subarraySum = 0\n        for arrLength in range(1, len(inputArray) - startIndex + 1):\n            subarraySum += inputArray[startIndex + (arrLength - 1)]\n            if maxSubarraySum is None or subarraySum > maxSubarraySum:\n                maxSubarraySum = subarraySum\n                maxSubarrayStartIndex = startIndex\n                maxSubarrayLength = arrLength\n\n    return inputArray[maxSubarrayStartIndex:maxSubarrayStartIndex + maxSubarrayLength]\n\ndef dcMaximumSubarraySum(inputArray):\n    def solveRecursively(elementIndex, mustPick):\n        if elementIndex >= len(inputArray):\n            return 0 if mustPick else float('-inf')\n        return max(\n            inputArray[elementIndex] + solveRecursively(elementIndex + 1, True),\n            0 if mustPick else solveRecursively(elementIndex + 1, False)\n        )\n\n    return solveRecursively(0, False)\n\ndef dpMaximumSubarray(inputArray):\n    maxSum = float('-inf')\n    currentSum = 0\n\n    maxStartIndex = 0\n    maxEndIndex = len(inputArray) - 1\n    currentStartIndex = 0\n\n    for currentIndex, currentNumber in enumerate(inputArray):\n        currentSum += currentNumber\n\n        if maxSum < currentSum:\n            maxSum = currentSum\n            maxStartIndex = currentStartIndex\n            maxEndIndex = currentIndex\n\n        if currentSum < 0:\n            currentSum = 0\n            currentStartIndex = currentIndex + 1\n\n    return inputArray[maxStartIndex:maxEndIndex + 1]\n",S="fn bf_maximum_subarray(input_array: &[i32]) -> Vec<i32> {\n    let mut max_subarray_start_index = 0;\n    let mut max_subarray_length = 0;\n    let mut max_subarray_sum: Option<i32> = None;\n\n    for start_index in 0..input_array.len() {\n        let mut subarray_sum = 0;\n        for arr_length in 1..=input_array.len() - start_index {\n            subarray_sum += input_array[start_index + (arr_length - 1)];\n            if max_subarray_sum.is_none() || subarray_sum > max_subarray_sum.unwrap() {\n                max_subarray_sum = Some(subarray_sum);\n                max_subarray_start_index = start_index;\n                max_subarray_length = arr_length;\n            }\n        }\n    }\n\n    input_array[max_subarray_start_index..max_subarray_start_index + max_subarray_length].to_vec()\n}\n\nfn dc_maximum_subarray_sum(input_array: &[i32]) -> i32 {\n    fn solve_recursively(input_array: &[i32], element_index: usize, must_pick: bool) -> i32 {\n        if element_index >= input_array.len() {\n            if must_pick {\n                0\n            } else {\n                i32::MIN\n            }\n        } else {\n            i32::max(\n                input_array[element_index] + solve_recursively(input_array, element_index + 1, true),\n                if must_pick {\n                    0\n                } else {\n                    solve_recursively(input_array, element_index + 1, false)\n                },\n            )\n        }\n    }\n\n    solve_recursively(input_array, 0, false)\n}\n\nfn dp_maximum_subarray(input_array: &[i32]) -> Vec<i32> {\n    let mut max_sum = i32::MIN;\n    let mut current_sum = 0;\n\n    let mut max_start_index = 0;\n    let mut max_end_index = input_array.len() - 1;\n    let mut current_start_index = 0;\n\n    for (current_index, &current_number) in input_array.iter().enumerate() {\n        current_sum += current_number;\n\n        if max_sum < current_sum {\n            max_sum = current_sum;\n            max_start_index = current_start_index;\n            max_end_index = current_index;\n        }\n\n        if current_sum < 0 {\n            current_sum = 0;\n            current_start_index = current_index + 1;\n        }\n    }\n\n    input_array[max_start_index..=max_end_index].to_vec()\n}\n",o="function bfMaximumSubarray(inputArray: number[]): number[] {\n  let maxSubarrayStartIndex = 0;\n  let maxSubarrayLength = 0;\n  let maxSubarraySum: number | null = null;\n\n  for (let startIndex = 0; startIndex < inputArray.length; startIndex += 1) {\n    let subarraySum = 0;\n    for (\n      let arrLength = 1;\n      arrLength <= inputArray.length - startIndex;\n      arrLength += 1\n    ) {\n      subarraySum += inputArray[startIndex + (arrLength - 1)];\n      if (maxSubarraySum === null || subarraySum > maxSubarraySum) {\n        maxSubarraySum = subarraySum;\n        maxSubarrayStartIndex = startIndex;\n        maxSubarrayLength = arrLength;\n      }\n    }\n  }\n\n  return inputArray.slice(\n    maxSubarrayStartIndex,\n    maxSubarrayStartIndex + maxSubarrayLength,\n  );\n}\n\nfunction dcMaximumSubarraySum(inputArray: number[]): number {\n  function solveRecursively(elementIndex: number, mustPick: boolean): number {\n    if (elementIndex >= inputArray.length) {\n      return mustPick ? 0 : -Infinity;\n    }\n    return Math.max(\n      inputArray[elementIndex] + solveRecursively(elementIndex + 1, true),\n      mustPick ? 0 : solveRecursively(elementIndex + 1, false),\n    );\n  }\n\n  return solveRecursively(0, false);\n}\n\nfunction dpMaximumSubarray(inputArray: number[]): number[] {\n  let maxSum = -Infinity;\n  let currentSum = 0;\n\n  let maxStartIndex = 0;\n  let maxEndIndex = inputArray.length - 1;\n  let currentStartIndex = 0;\n\n  inputArray.forEach((currentNumber, currentIndex) => {\n    currentSum += currentNumber;\n\n    if (maxSum < currentSum) {\n      maxSum = currentSum;\n      maxStartIndex = currentStartIndex;\n      maxEndIndex = currentIndex;\n    }\n\n    if (currentSum < 0) {\n      currentSum = 0;\n      currentStartIndex = currentIndex + 1;\n    }\n  });\n\n  return inputArray.slice(maxStartIndex, maxEndIndex + 1);\n}\n",b={title:"Maximum Subarray",description:"Maximum Subarray",hide_table_of_contents:!0},h=void 0,I={},p=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function f(n){const r={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,u.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.h2,{id:"definition",children:"Definition"}),"\n",(0,a.jsxs)(i.A,{queryString:"primary",children:[(0,a.jsx)(m.A,{value:"definition",label:"Definition",children:(0,a.jsx)(r.p,{children:"The Maximum Subarray Algorithm is a method used to find the contiguous subarray within a one-dimensional array of numbers which has the largest sum"})}),(0,a.jsx)(m.A,{value:"how",label:"Explanation",children:(0,a.jsx)(r.p,{children:"Iterate through the array, keeping track of the current sum of the subarray and the maximum sum found so far. It updates these values as it traverses the array, ensuring that the current sum is either extended by the next element or reset to the next element itself, whichever is greater. At each step, it also compares the current sum with the maximum sum found so far and updates the maximum sum accordingly. By the end of the iteration, the algorithm returns the maximum sum found and the corresponding subarray"})}),(0,a.jsx)(m.A,{value:"guidance",label:"Guidance",children:(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["Initialize variables: ",(0,a.jsx)(r.code,{children:"max_sum"})," = ",(0,a.jsx)(r.code,{children:"current_sum"})," = ",(0,a.jsx)(r.code,{children:"array[0]"})]}),"\n",(0,a.jsx)(r.li,{children:"Iterate through the array starting from the second element"}),"\n",(0,a.jsxs)(r.li,{children:["For each element","\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["Update ",(0,a.jsx)(r.code,{children:"current_sum"})," to be the maximum of the current element or the sum of the current element and the previous ",(0,a.jsx)(r.code,{children:"current_sum"})]}),"\n",(0,a.jsxs)(r.li,{children:["Update ",(0,a.jsx)(r.code,{children:"max_sum"})," to be the maximum of ",(0,a.jsx)(r.code,{children:"max_sum"})," and ",(0,a.jsx)(r.code,{children:"current_sum"})]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["After iterating through the array, return ",(0,a.jsx)(r.code,{children:"max_sum"})]}),"\n"]})}),(0,a.jsx)(m.A,{value:"tips",label:"Tips",children:(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"utilize Kadane's Algorithm for an optimized solution"}),"\n",(0,a.jsx)(r.li,{children:"focus on keeping track of the maximum sum and the current sum efficiently to minimize space complexity"}),"\n"]})})]}),"\n",(0,a.jsx)(r.h2,{id:"practice",children:"Practice"}),"\n",(0,a.jsxs)(i.A,{queryString:"primary",children:[(0,a.jsx)(m.A,{value:"practice",label:"Practice",children:(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-python",children:"maxSubarray(array):\n  max_sum = current_sum = array[0]  // Initialize variables\n  for i from 1 to length(array)-1:   // Iterate through the array\n    current_sum = max(array[i], current_sum + array[i]) // Update current sum\n    max_sum = max(max_sum, current_sum)  // Update max sum\n  return max_sum  // Return the maximum sum found\n"})})}),(0,a.jsx)(m.A,{value:"solution",label:"Solution",children:(0,a.jsxs)(i.A,{queryString:"code",children:[(0,a.jsx)(m.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,a.jsx)(s.A,{language:"go",children:x})}),(0,a.jsx)(m.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,a.jsx)(s.A,{language:"java",children:l})}),(0,a.jsx)(m.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,a.jsx)(s.A,{language:"js",children:c})}),(0,a.jsx)(m.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,a.jsx)(s.A,{language:"kotlin",children:d})}),(0,a.jsx)(m.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,a.jsx)(s.A,{language:"python",children:y})}),(0,a.jsx)(m.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,a.jsx)(s.A,{language:"rust",children:S})}),(0,a.jsx)(m.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,a.jsx)(s.A,{language:"ts",children:o})})]})})]})]})}function g(n={}){const{wrapper:r}={...(0,u.R)(),...n.components};return r?(0,a.jsx)(r,{...n,children:(0,a.jsx)(f,{...n})}):f(n)}}}]);