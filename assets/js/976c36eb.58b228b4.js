"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[5140],{76898:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>j,frontMatter:()=>c,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"education/tech-stack/frontend/graphql/Basics","title":"Basics","description":"GraphQL Basics","source":"@site/docs/education/02-tech-stack/02-frontend/02-graphql/01-Basics.mdx","sourceDirName":"education/02-tech-stack/02-frontend/02-graphql","slug":"/education/tech-stack/frontend/graphql/Basics","permalink":"/tech-labs/docs/education/tech-stack/frontend/graphql/Basics","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/02-tech-stack/02-frontend/02-graphql/01-Basics.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Basics","description":"GraphQL Basics","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"GraphQL","permalink":"/tech-labs/docs/category/graphql"},"next":{"title":"Backend","permalink":"/tech-labs/docs/category/backend"}}');var r=i(86070),t=i(15658),d=i(52421),l=i(74610),a=i(75458);const c={title:"Basics",description:"GraphQL Basics",hide_table_of_contents:!0},o=void 0,h={},u=[];function x(e){const n={code:"code",img:"img",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(d.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"schema",label:"Schema",children:(0,r.jsxs)(d.A,{queryString:"secondary",children:[(0,r.jsxs)(l.A,{value:"overview",label:"Overview",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"GraphQL"})," is a query language for APIs and a runtime for executing those queries. It allows clients to request exactly the data they need, making it more efficient and flexible compared to traditional REST APIs. It's not tied to any specific database or storage engine and supports reading, writing, and subscribing to data changes, enabling real-time updates."]}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"GraphQL Schema"}),": blueprint that defines the structure of the data in a GraphQL API, including types, queries, mutations, and subscriptions. It specifies how clients can interact with the data."]}),(0,r.jsx)(n.p,{children:"GraphQL services can be written in any language, and there are various approaches to defining types in a schema:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"might require you to construct schema types, fields, and resolver functions using the same programming language as the GraphQL implementation"}),"\n",(0,r.jsx)(n.li,{children:"will allow you to define types and fields using the schema definition language (SDL) and write resolver functions separately"}),"\n",(0,r.jsx)(n.li,{children:"will let you write and annotate resolver functions, inferring the schema from them"}),"\n",(0,r.jsx)(n.li,{children:"may infer both types and resolver functions based on underlying data sources"}),"\n"]}),(0,r.jsx)("h3",{children:"Benefits"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Schema Design"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"schema-first Development. Design the GraphQL schema first using SDL (Schema Definition Language) to ensure a clear API contract before implementation"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type Definitions"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"use Query, Mutation, and Subscription root types for operations"}),"\n",(0,r.jsx)(n.li,{children:"define reusable input and object types for consistent and modular schema components"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scalability"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"language Agnostic. Not tied to any specific database or storage engine"}),"\n",(0,r.jsx)(n.li,{children:"modularize the schema using type extensions and federated architecture for microservices"}),"\n",(0,r.jsx)(n.li,{children:"enforce Apollo Federation for distributed schemas"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Versioning Strategy"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["adopt schema deprecation strategies using ",(0,r.jsx)(n.code,{children:"@deprecated"})," directives"]}),"\n",(0,r.jsx)(n.li,{children:"maintain backward compatibility while evolving the schema iteratively"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance Optimization"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Fetching - process of retrieving specific data from a server or database. GraphQL can fetch from multiple sources in a single query and it eliminates the over-fetching and under-fetching dilemma","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Over-Fetching"}),": occurs when clients receive more data than needed that leads to increased network traffic with resource wastage and longer response times"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Under-Fetching"}),": occurs when insufficient data is provided for tasks that leads to inadequate information for decision-making, data inconsistencies, increased latency, and user frustration"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"define precise field-level resolvers to minimize N+1 query problems"}),"\n",(0,r.jsxs)(n.li,{children:["use ",(0,r.jsx)(n.code,{children:"DataLoader"})," to batch and cache backend data-fetching for optimized resolver performance"]}),"\n",(0,r.jsx)(n.li,{children:"implement query complexity analysis to restrict overly complex queries"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Developer Experience"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"provide a comprehensive, auto-generated GraphQL schema documentation using tools like GraphiQL"}),"\n",(0,r.jsx)(n.li,{children:"implement linting rules for schema and query validation"}),"\n",(0,r.jsx)(n.li,{children:"use a type-safe approach by integrating GraphQL with TypeScript"}),"\n"]}),"\n"]}),"\n"]})]}),(0,r.jsxs)(l.A,{value:"type-modifiers",label:"Type Modifiers",children:[(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Modifier"}),(0,r.jsx)("th",{children:"Definition"}),(0,r.jsx)("th",{children:"Example"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Non-Null"})}),(0,r.jsx)("td",{children:"Indicates the field is required"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{2}",children:"type Character {\n    name: String!\n}\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"List"})}),(0,r.jsx)("td",{children:(0,r.jsx)(n.p,{children:"Indicates that a field can return a list of values. A list can contain zero or more items of the specified type"})}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{3,5,7}",children:"type User {\n  # return a list that can be null and contains null items\n  friends: [User]\n  # return a list that can be null but contains non-null items\n  followers: [User!]\n  # return a non-null list that contains non-null items\n  following: [User!]!\n}\n"})})})]})]})]}),(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"List Variant"}),(0,r.jsx)("th",{children:(0,r.jsx)(n.code,{children:"[1, 2]"})}),(0,r.jsx)("th",{children:(0,r.jsx)(n.code,{children:"[]"})}),(0,r.jsx)("th",{children:(0,r.jsx)(n.code,{children:"null"})}),(0,r.jsx)("th",{children:(0,r.jsx)(n.code,{children:"[1, null]"})}),(0,r.jsx)("th",{children:(0,r.jsx)(n.code,{children:"[[1], [2,3]]"})}),(0,r.jsx)("th",{children:(0,r.jsx)(n.code,{children:"[[]]"})}),(0,r.jsx)("th",{children:(0,r.jsx)(n.code,{children:"[[1], null]"})}),(0,r.jsx)("th",{children:(0,r.jsx)(n.code,{children:"[[null]]"})})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:(0,r.jsx)(n.code,{children:"[Int]"})})}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:(0,r.jsx)(n.code,{children:"[Int!]"})})}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:(0,r.jsx)(n.code,{children:"[Int]!"})})}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:(0,r.jsx)(n.code,{children:"[Int!]!"})})}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:(0,r.jsx)(n.code,{children:"[[Int]]"})})}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:(0,r.jsx)(n.code,{children:"[[Int!]]"})})}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u274c"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:(0,r.jsx)(n.code,{children:"[[Int!]!]"})})}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:(0,r.jsx)(n.code,{children:"[Int!]!]!"})})}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u2705"}),(0,r.jsx)("td",{children:"\u274c"}),(0,r.jsx)("td",{children:"\u274c"})]})]})]})]}),(0,r.jsx)(l.A,{value:"structure-and-types",label:"Structure & Types",attributes:{className:"tabs__vertical"},children:(0,r.jsxs)("table",{class:"text_vertical",children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Type"}),(0,r.jsx)("th",{children:"Definition"}),(0,r.jsx)("th",{children:"Example"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Object"})}),(0,r.jsx)("td",{children:"GraphQL Object type, indicating it has fields. Most schema types will be Object types"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{1}",children:"type Character {\n  name: String!\n}\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Build-In Scalar Type"})}),(0,r.jsx)("td",{children:(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:"Int"}),": A signed 32\u2010bit integer"]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:"Float"}),": A signed double-precision floating-point value"]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:"String"}),": A UTF\u20108 character sequence"]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:"Boolean"}),": true or false"]}),(0,r.jsxs)("li",{children:[(0,r.jsx)("b",{children:"ID"}),": unique identifier used to re-fetch an object or as a cache key. Although it is serialized like a String, defining it as an ID indicates that it is not meant to be human-readable"]})]})}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{2,3}",children:"type Character {\n  name: String!\n  id: ID!\n}\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Custom Scalar Type"})}),(0,r.jsx)("td",{children:"User-defined data type that extends built-in scalars to represent specific formats, allowing for serialization and deserialization of complex types like dates or URLs"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"scalar Date\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Enum"})}),(0,r.jsx)("td",{children:"Scalar type that can take a limited set of predefined values, helping to enforce data constraints in a GraphQL API"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{1}",children:"enum Month {\n  JANUARY\n  FEBRUARY\n  MARCH\n}\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Input Object"})}),(0,r.jsx)("td",{children:"Custom type that defines fields for input parameters in queries or mutations, enabling structured transmission of complex data"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{1}",children:"input CreateUserInput {\n  username: String!\n  email: String!\n  password: String!\n}\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Interface"})}),(0,r.jsx)("td",{children:"Abstract type that defines fields for multiple object types to implement, allowing for shared fields and enabling queries across different types through a common interface"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{1}",children:"interface Character {\n  id: ID!\n  name: String!\n}\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Union"})}),(0,r.jsx)("td",{children:"Type that can represent one of several different object types, allowing for more flexible responses without requiring shared fields among the types"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{13}",children:"type Book {\n  id: ID!\n  title: String!\n  author: String!\n}\n\ntype Movie {\n  id: ID!\n  title: String!\n  director: String!\n}\n\nunion Media = Book | Movie\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Build-In Directives"})}),(0,r.jsx)("td",{children:"Directives may be provided in a specific syntactic order which may have semantic interpretation"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{13}",children:'directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\ndirective @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\ndirective @specifiedBy(url: String!) on SCALAR\ndirective @deprecated(\n  reason: String = "No longer supported"\n) on FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION | ENUM_VALUE\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Custom Directives"})}),(0,r.jsx)("td",{children:"User-defined annotations that can be applied to fields or fragments in a GraphQL schema to modify their behavior"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"directive @auth(role: String) on FIELD_DEFINITION\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Alias"})}),(0,r.jsx)("td",{children:"Allows clients to rename the result of a field in a query, enabling clients to fetch the same field multiple times with different parameters"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{5,6}",children:"{\n  user(id: 4) {\n    id\n    name\n    smallPic: profilePic(size: 64)\n    bigPic: profilePic(size: 1024)\n  }\n}\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Fragments"})}),(0,r.jsx)("td",{children:"Reusable units of a GraphQL query that allow clients to define a set of fields that can be included in multiple queries. Fragments help reduce duplication and improve query organization"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Fragments\nfragment userFields on User {\n  id\n  name\n  email\n}\n\nquery {\n  user(id: "1") {\n    ...userFields\n  }\n  user(id: "2") {\n    ...userFields\n  }\n}\n\n# Inline fragments\nquery {\n  animals {\n    ... on Dog {\n      id\n      name\n      bark\n    }\n    ... on Cat {\n      id\n      name\n      meow\n    }\n  }\n}\n\n# Type Conditions: fragment should only be applied to a specific type or interface\ninterface Animal {\n  id: ID!\n  name: String!\n}\n\ntype Dog implements Animal {\n  id: ID!\n  name: String!\n  bark: String!\n}\n\ntype Cat implements Animal {\n  id: ID!\n  name: String!\n  meow: String!\n}\n\nquery {\n  animals {\n    ... on Dog {\n      id\n      name\n      bark\n    }\n    ... on Cat {\n      id\n      name\n      meow\n    }\n  }\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Query"})}),(0,r.jsx)("td",{children:"Read operation in GraphQL that allows clients to request specific data from the server. Queries specify the shape of the response by defining the fields to retrieve"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'query {\n  user(id: "1") {\n    name\n    email\n  }\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Mutation"})}),(0,r.jsx)("td",{children:"Write operation in GraphQL that allows clients to modify server-side data. Mutations can create, update, or delete data and typically return the modified data"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'mutation {\n  createUser(name: "Joe", email: "joe@doe.com") {\n    id\n    name\n  }\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Subscription"})}),(0,r.jsx)("td",{children:"Real-time operation in GraphQL that allows clients to receive updates from the server when specific events occur. Subscriptions enable clients to listen for changes to data"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"subscription {\n  userUpdated {\n    id\n    name\n  }\n}\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Top-Level Queries"})}),(0,r.jsx)("td",{children:"Queries should be well-defined and self-contained, with a focus on clear entry points"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{1}",children:"type Query {\n    user(input: UserInput!): UserConnection\n}\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Entity Relationships"})}),(0,r.jsx)("td",{children:"Use relationships to define nested data"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{5,8}",children:"type User {\n    id: ID!\n    name: String!\n    email: String!\n    orders: [Order!]!\n}\n\ntype Order {\n    id: ID!\n    total: Float!\n    createdAt: String!\n    user: User!\n}\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Deeply Nested Structures"})}),(0,r.jsx)("td",{children:"Limit the depth and use fragments to handle complexity"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{4,10}",children:"type Product {\n    id: ID!\n    name: String!\n    category: Category!\n}\n\ntype Category {\n    id: ID!\n    name: String!\n    subCategories: [Category!]!\n}\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Descriptions"})}),(0,r.jsx)("td",{children:"Comments that can be added to schema definitions to provide additional context or documentation for fields, types, or directives"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'"This is a 1-line Descriptions"\n\n"""\nThis is a multi-line Descriptions\n"""\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Comments"})}),(0,r.jsx)("td",{children:"Used to annotate the schema or queries for clarity and documentation purposes"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"# This is a 1-line comment\n"})})})]})]})]})}),(0,r.jsxs)(l.A,{value:"pagination",label:"Pagination",children:[(0,r.jsx)(n.p,{children:"Pagination in GraphQL is done via standardized pagination model (cursor-based) using Connections"}),(0,r.jsx)("h3",{children:"Pagination Algorithm"}),(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Server applies cursors (",(0,r.jsx)(n.code,{children:"before"}),", ",(0,r.jsx)(n.code,{children:"after"}),") to filter ",(0,r.jsx)(n.code,{children:"edges"})]}),"\n",(0,r.jsx)(n.li,{children:"Fetch all relevant records"}),"\n",(0,r.jsxs)(n.li,{children:["Slice the records based on indices (",(0,r.jsx)(n.code,{children:"first"}),", ",(0,r.jsx)(n.code,{children:"last"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:["Create ",(0,r.jsx)(n.code,{children:"edges"}),". For each record in the sliced list, create an edge object that includes the cursor (encoded identifier) and the node (the record itself)"]}),"\n",(0,r.jsxs)(n.li,{children:["Determine ",(0,r.jsx)(n.code,{children:"pageInfo"}),". Check for additional records after the current slice to set ",(0,r.jsx)(n.code,{children:"hasNextPage"})," and, if they exist, calculate the ",(0,r.jsx)(n.code,{children:"endCursor"})," for the last record in the current slice"]}),"\n",(0,r.jsxs)(n.li,{children:["Create a ",(0,r.jsx)(n.code,{children:"Connection"})," object that includes ",(0,r.jsx)(n.code,{children:"edges"})," and ",(0,r.jsx)(n.code,{children:"pageInfo"})]}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'{\n  user {\n    id\n    name\n    """\n    Slicing is done with the `first` argument to followers (get first 10 followers)\n    Pagination is achieved using the `after` argument with friends (passed a cursor to request friends following that cursor)\n    """\n    followers(first: 10, after: "opaqueCursor") {\n      """\n      For each edge, requested a cursor, an opaque string used for pagination with the `after` argument\n      """\n      edges {\n        cursor\n        node {\n          id\n          name\n        }\n      }\n      pageInfo {\n        """\n        Requested hasNextPage to determine if more edges are available or if we\'ve reached the end of the connection\n        """\n        hasNextPage\n      }\n    }\n  }\n}\n'})}),(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Edges to Return"}),(0,r.jsx)("th",{children:"Apply Cursors to Edges"})]})}),(0,r.jsx)("tbody",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"EdgesToReturn(allEdges, before, after, first, last)\n    edges = ApplyCursorsToEdges(allEdges, before, after)\n\n    if first is set:\n        if first < 0: throw error\n        # If the edges list has more elements than `first`,\n        # it truncates to the `first` elements; otherwise, it remains unchanged\n        edges = edges[0:first] if length(edges) > first\n\n    if last is set:\n        if last < 0: throw error\n        # If the edges list has more elements than `last`,\n        # it retains only the `last` elements; otherwise, it remains unchanged\n        edges = edges[length(edges) - last:length(edges)] if length(edges) > last\n\n    return edges\n"})})}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"ApplyCursorsToEdges(allEdges, before, after):\n    edges = allEdges\n\n    if after is set:\n        afterEdge = findEdgeByCursor(edges, after)\n        if afterEdge exists:\n            edges = removeBeforeAndIncluding(edges, afterEdge)\n\n    if before is set:\n        beforeEdge = findEdgeByCursor(edges, before)\n        if beforeEdge exists:\n            edges = removeAfterAndIncluding(edges, beforeEdge)\n\n    return edges\n"})})})]})})]}),(0,r.jsx)("h3",{children:"Structure"}),(0,r.jsx)(a.A,{type:"info",children:(0,r.jsxs)(n.p,{children:["Including both ",(0,r.jsx)(n.code,{children:"first"})," and ",(0,r.jsx)(n.code,{children:"last"})," is strongly discouraged due to potential confusion in queries and results"]})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"type Query {\n  users(input: UserInput): UserConnection!\n}\n\ninput UserInput {\n  pagination: PaginationInput\n}\n\ninput PaginationInput {\n  first: Int\n  after: String\n  last: Int\n  before: String\n}\n\ntype UserConnection {\n  edges: [UserEdge]!\n  pageInfo: PageInfo!\n}\n\ntype PageInfo @shareable {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n  endCursor: String\n}\n\ntype UserEdge {\n  cursor: String!\n  node: User!\n}\n\ntype User {\n  id: ID!\n  name: String!\n}\n"})}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reserved Types"}),": GraphQL server must reserve specific types and names to support the pagination model of connections","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Any object ending in ",(0,r.jsx)(n.code,{children:"Connection"})]}),"\n",(0,r.jsxs)(n.li,{children:["An object named ",(0,r.jsx)(n.code,{children:"PageInfo"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Connection Types"}),": Any type ending in ",(0,r.jsx)(n.code,{children:"Connection"})," is classified as a Connection Type. Connection types must be an ",(0,r.jsx)(n.strong,{children:"Object"}),". Must include fields named ",(0,r.jsx)(n.code,{children:"edges"})," and ",(0,r.jsx)(n.code,{children:"pageInfo"}),". They may also have additional fields as determined by the schema designer","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Edges"}),": Connection Type must include a field called ",(0,r.jsx)(n.code,{children:"edges"}),", which returns a list type wrapping an edge type"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"PageInfo"}),": Connection Type must include a field called ",(0,r.jsx)(n.code,{children:"pageInfo"}),", which returns a non-null ",(0,r.jsx)(n.strong,{children:"PageInfo"})," object"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Edge Types"}),": List returned by a connection type's edges field and must be an ",(0,r.jsx)(n.strong,{children:"Object"}),". Must include fields named ",(0,r.jsx)(n.code,{children:"node"})," and ",(0,r.jsx)(n.code,{children:"cursor"}),". They may also have additional fields as determined by the schema designer","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node"}),": Must have a ",(0,r.jsx)(n.code,{children:"node"})," field that returns a Scalar, Enum, Object, Interface, Union, or a Non-Null wrapper of those types, but not a list"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cursor"}),": Must have a ",(0,r.jsx)(n.code,{children:"cursor"})," field that returns a type serializing as a String. This can be a String, a Non-Null String, a custom scalar that serializes as a String, or a Non-Null wrapper around such a custom scalar"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Arguments"}),": Field that returns a Connection Type must include forward pagination arguments, backward pagination arguments, or both. These arguments enable the client to slice the set of edges before it is returned","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Forward pagination arguments"}),": Provide a non-negative integer ",(0,r.jsx)(n.code,{children:"first"})," and a cursor ",(0,r.jsx)(n.code,{children:"after"})," to return edges after the specified cursor, with a maximum of ",(0,r.jsx)(n.code,{children:"first"})," edges"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backward pagination arguments"}),": Provide a non-negative integer ",(0,r.jsx)(n.code,{children:"last"})," and a cursor ",(0,r.jsx)(n.code,{children:"before"})," to return edges before the specified cursor, with a maximum of ",(0,r.jsx)(n.code,{children:"last"})," edges"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Edge Order"}),": Order the edges based on business logic and additional arguments, but the ordering must remain consistent across pages, ensuring that when using ",(0,r.jsx)(n.code,{children:"first/after"}),", the edge closest to the cursor comes first, while with ",(0,r.jsx)(n.code,{children:"last/before"}),", it comes last"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"PageInfo"}),": Provides metadata about the current page of results. Must include ",(0,r.jsx)(n.code,{children:"hasPreviousPage"})," and ",(0,r.jsx)(n.code,{children:"hasNextPage"})," as non-null booleans, and ",(0,r.jsx)(n.code,{children:"startCursor"})," and ",(0,r.jsx)(n.code,{children:"endCursor"})," as opaque strings. ",(0,r.jsx)(n.code,{children:"startCursor"})," and ",(0,r.jsx)(n.code,{children:"endCursor"})," may be null if there are no results","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"hasPreviousPage"}),": Non-null boolean that indicates if there are more edges before the current page","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"last/before"}),": ",(0,r.jsx)(n.code,{children:"true"})," if prior edges exist"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"first/after"}),": optionally ",(0,r.jsx)(n.code,{children:"true"})," if edges before ",(0,r.jsx)(n.code,{children:"after"})," exist"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"hasNextPage"}),": Non-null boolean that indicates if there are more edges after the current page","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"first/after"}),": ",(0,r.jsx)(n.code,{children:"true"})," if more edges exist"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"last/before"}),": optionally ",(0,r.jsx)(n.code,{children:"true"})," if edges after ",(0,r.jsx)(n.code,{children:"before"})," exist"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"startCursor"}),":Cursors"," of first and last nodes in edges. Opaque strings (nullable if no results)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"endCursor"}),": Cursors of first and last nodes in edges. Opaque strings (nullable if no results)"]}),"\n"]}),"\n"]}),"\n"]})]})]})}),(0,r.jsx)(l.A,{value:"federated-schemas",label:"Federated Schemas",children:(0,r.jsxs)(d.A,{queryString:"secondary",children:[(0,r.jsx)(l.A,{value:"gateway-vs-router",label:"Gateway vs Router",attributes:{className:"tabs__vertical"},children:(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Aspect"}),(0,r.jsx)("th",{children:"Apollo Gateway"}),(0,r.jsx)("th",{children:"Apollo Router"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Visualization"})}),(0,r.jsx)("td",{children:(0,r.jsx)(n.mermaid,{value:'xychart-beta\n    title "Exponential"\n    x-axis "Requests per second" [0, 500, 1000, 1500, 2000, 2500, 3000, ..., 16000]\n    y-axis "p95 latency (ms)" 10 --\x3e 90\n    bar [50, 50, 60, 70, 90]\n    line [50, 50, 60, 70, 90]'})}),(0,r.jsx)("td",{children:(0,r.jsx)(n.mermaid,{value:'xychart-beta\n    title "Linear"\n    x-axis "Requests per second" [0, 500, 1000, 1500, 2000, 2500, 3000, ..., 16000]\n    y-axis "p95 latency (ms)" 10 --\x3e 90\n    bar [20, 20, 20, 20, 20, 20, 20, 20, 20]\n    line [20, 20, 20, 20, 20, 20, 20, 20, 20]'})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Language"})}),(0,r.jsx)("td",{children:"Node.js (JavaScript)"}),(0,r.jsx)("td",{children:"Rust"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Latency"})}),(0,r.jsx)("td",{children:"Higher latency, especially in scenarios with complex queries"}),(0,r.jsx)("td",{children:"Lower latency due to optimized query execution and multi-threaded design"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Scalability"})}),(0,r.jsx)("td",{children:"Scales effectively, but with potential bottlenecks in very high-load scenarios"}),(0,r.jsx)("td",{children:"Highly scalable, leveraging Rust\u2019s ability to manage resources efficiently under heavy traffic"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Memory Usage"})}),(0,r.jsx)("td",{children:"Comparatively higher memory footprint due to Node.js overhead"}),(0,r.jsx)("td",{children:"Lower memory usage due to Rust\u2019s fine-grained memory management"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Customization"})}),(0,r.jsx)("td",{children:"High level of customization using JavaScript/Node.js plugins"}),(0,r.jsx)("td",{children:"Customization via Apollo Router extensions, written in Rust or using predefined features"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Federation Version Compatibility"})}),(0,r.jsx)("td",{children:"Apollo Federation 1 and 2"}),(0,r.jsx)("td",{children:"Optimized for Apollo Federation 2, but also compatible with Federation 1"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Concurrency Model"})}),(0,r.jsx)("td",{children:"Single-threaded, event-driven (Node.js)"}),(0,r.jsx)("td",{children:"Multi-threaded by default, leveraging Rust\u2019s concurrency model for better utilization of CPU resources"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Resource Efficiency"})}),(0,r.jsx)("td",{children:"Moderate resource efficiency, subject to Node.js limitations"}),(0,r.jsx)("td",{children:"High resource efficiency, using Rust\u2019s optimized resource management"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Use Case"})}),(0,r.jsx)("td",{children:"Ideal for applications with moderate performance needs and developers familiar with JavaScript"}),(0,r.jsx)("td",{children:"Best for high-performance scenarios, large-scale federations, or teams requiring extremely low latency"})]})]})]})}),(0,r.jsx)(l.A,{value:"federation-versions",label:"Federation Versions",children:(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Aspect"}),(0,r.jsx)("th",{children:"Apollo Federation Version 1"}),(0,r.jsx)("th",{children:"Apollo Federation Version 2"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Core Architecture"})}),(0,r.jsx)("td",{children:"Built on GraphQL schema stitching with a focus on declarative ownership of types across services"}),(0,r.jsx)("td",{children:"Refined architecture with improvements in query planning, security, and extensibility"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Schema Composition"})}),(0,r.jsxs)("td",{children:["Centralized schema composed using ",(0,r.jsx)(n.code,{children:"@key"}),", ",(0,r.jsx)(n.code,{children:"@extends"}),", and other directives"]}),(0,r.jsx)("td",{children:"Enhanced schema composition with streamlined support for type extensions and directives"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Directive Support"})}),(0,r.jsxs)("td",{children:["Core directives: ",(0,r.jsx)(n.code,{children:"@key"}),", ",(0,r.jsx)(n.code,{children:"@extends"}),", ",(0,r.jsx)(n.code,{children:"@external"}),", ",(0,r.jsx)(n.code,{children:"@provides"}),", ",(0,r.jsx)(n.code,{children:"@requires"})]}),(0,r.jsx)("td",{children:"Expanded directive set for better flexibility; supports the same directives with optimized handling"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Supergraph Schema"})}),(0,r.jsx)("td",{children:"Not explicitly defined; relies on schema stitching to create a unified API gateway"}),(0,r.jsx)("td",{children:"Introduces the Supergraph Schema, a declarative representation of the federated schema, enhancing visibility and management"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Gateway Implementation"})}),(0,r.jsx)("td",{children:"Uses Apollo Gateway to execute federated queries by delegating to subgraphs"}),(0,r.jsx)("td",{children:"Upgraded Apollo Gateway supports Supergraph Schema, advanced query planning, and additional federation features"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Query Planning"})}),(0,r.jsx)("td",{children:"Basic query planner that routes subqueries based on ownership of types and fields"}),(0,r.jsx)("td",{children:"Enhanced query planner with more efficient routing, reduced network overhead, and support for shared ownership scenarios"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Type Ownership"})}),(0,r.jsx)("td",{children:"Types are owned by individual subgraphs; conflicts resolved during composition"}),(0,r.jsx)("td",{children:"Improved support for shared ownership, providing more granular control over type definitions"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Error Handling"})}),(0,r.jsx)("td",{children:"Errors are propagated to the client with limited granularity"}),(0,r.jsx)("td",{children:"Improved error propagation with clearer differentiation between subgraph-level and gateway-level issues"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Security Enhancements"})}),(0,r.jsx)("td",{children:"Basic security measures, such as authentication and authorization at the gateway level"}),(0,r.jsx)("td",{children:"Built-in authz and authn hooks, improved validation of schema boundaries, and enhanced cross-subgraph communication security"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Performance"})}),(0,r.jsx)("td",{children:"Good performance, but query planning could introduce noticeable overhead for complex schemas"}),(0,r.jsx)("td",{children:"Significant performance improvements due to an optimized query planner and reduced round-trip overheads"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Backward Compatibility"})}),(0,r.jsx)("td",{children:"Not forward-compatible with Apollo Federation 2"}),(0,r.jsx)("td",{children:"Backward-compatible with Federation 1 schemas; includes a migration path for upgrading"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Subgraph Support"})}),(0,r.jsx)("td",{children:"Basic support for subgraph APIs with ownership and dependency definitions"}),(0,r.jsx)("td",{children:"More flexible subgraph support, including enhanced debugging, versioning, and validation tools"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Multi-Version Subgraph Support"})}),(0,r.jsx)("td",{children:"Limited support; requires careful schema management"}),(0,r.jsx)("td",{children:"Full multi-version support, making it easier to manage versioned APIs across subgraphs"})]})]})]})}),(0,r.jsx)(l.A,{value:"graph-types",label:"Graph Types",children:(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Aspect"}),(0,r.jsx)("th",{children:"Monograph"}),(0,r.jsx)("th",{children:"Supergraph"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Visualization"})}),(0,r.jsx)("td",{children:(0,r.jsx)(n.mermaid,{value:"    graph LR\n\n    subgraph Clients\n        direction LR\n\n        API(API)\n        Mobile(Mobile)\n        Web(Web)\n    end\n\n    subgraph Monograph\n        direction LR\n\n        graphQL(GraphQL Server)\n    end\n\n    Clients --\x3e graphQL"})}),(0,r.jsx)("td",{children:(0,r.jsx)(n.mermaid,{value:"    graph LR\n\n    subgraph Clients\n        direction LR\n\n        API(API)\n        Mobile(Mobile)\n        Web(Web)\n    end\n\n    subgraph Supergraph\n        direction LR\n\n        router{{Router}}\n\n        product(Product Subgraph)\n        users(Users Subgraph)\n    end\n\n    Clients --\x3e router\n    router --\x3e|sub-query| product & users"})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Definition"})}),(0,r.jsx)("td",{children:"Graph that represents a single domain, team, or service"}),(0,r.jsx)("td",{children:"Federated graph that unifies multiple monographs under a single API schema"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Architecture Style"})}),(0,r.jsx)("td",{children:"Typically decentralized, focusing on individual domain responsibilities"}),(0,r.jsx)("td",{children:"Centralized or federated with a unified schema and gateway"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Scalability"})}),(0,r.jsx)("td",{children:"Scales horizontally within the specific domain"}),(0,r.jsx)("td",{children:"Scales across domains by delegating queries to appropriate subgraphs"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Implementation Complexity"})}),(0,r.jsx)("td",{children:"Relatively simple; involves defining schemas and resolvers for one domain"}),(0,r.jsx)("td",{children:"High; involves federation, schema stitching, and cross-team collaboration"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Data Ownership"})}),(0,r.jsx)("td",{children:"Clear ownership, as each graph is tied to a single team or service"}),(0,r.jsx)("td",{children:"Ownership is distributed across teams but unified under shared governance"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Team Collaboration"})}),(0,r.jsx)("td",{children:"Limited to the domain team"}),(0,r.jsx)("td",{children:"Requires cross-domain collaboration and clear ownership agreements"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Query Execution"})}),(0,r.jsx)("td",{children:"Queries are resolved locally within the monograph"}),(0,r.jsx)("td",{children:"Queries are resolved across multiple subgraphs and federated"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Use Cases"})}),(0,r.jsx)("td",{children:"Isolated domains (e.g., User Management, Inventory, Orders)"}),(0,r.jsx)("td",{children:"Enterprise-wide APIs (e.g., unified e-commerce, connected healthcare)"})]})]})]})}),(0,r.jsx)(l.A,{value:"apollo-graphos-architecture",label:"Apollo GraphOS",children:(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:i(14678).A+"",width:"2346",height:"707"})})}),(0,r.jsxs)(l.A,{value:"namespace",label:"Namespace",children:[(0,r.jsx)(a.A,{type:"info",children:(0,r.jsx)(n.p,{children:"While the current approach works in a GraphQL server, it fails to meet the spec requirement that field resolutions, except for top-level mutations, must be side effect-free and idempotent. It is recommended that GraphQL mutations be defined at the root level for serial execution in line with the specification. Currently, the only way to group related mutations is through field naming conventions and careful ordering, as there is no spec-compliant solution for managing numerous fields on the root mutation type"})}),(0,r.jsx)("h3",{children:"Query: Root-Level Operation Fields"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"# Define all query fields for User objects in a UsersQueries namespace\ntype UsersQueries {\n  all: [User!]!\n}\n\n# Define all query fields for Comment objects in a CommentsQueries namespace\ntype CommentsQueries {\n  byUser(user: ID!): [Comment!]!\n}\n\n# Add a single root-level namespace-type which wraps other queries\ntype Query {\n  users: UsersQueries!\n  comments: CommentsQueries!\n}\n\n# Fetch all users\nquery FetchAllUsers {\n  users {\n    all {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n"})}),(0,r.jsx)("h3",{children:"Mutation: Root-Level Operation Fields"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"# Define all mutation fields for User objects in a UsersMutations namespace\ntype UsersMutations {\n  create(profile: UserProfileInput!): User!\n  block(id: ID!): User!\n}\n\n# Define all mutation fields for Comment objects in a CommentsMutations namespace\ntype CommentsMutations {\n  create(comment: CommentInput!): Comment!\n  delete(id: ID!): Comment!\n}\n\n# Add a single root-level namespace-type which wraps other mutations\ntype Mutation {\n  users: UsersMutations!\n  comments: CommentsMutations!\n}\n\n# Create a new user and return it\nmutation CreateNewUser($userProfile: UserProfileInput!) {\n  users {\n    create(profile: $userProfile) {\n      id\n      firstName\n      lastName\n    }\n  }\n}\n"})}),(0,r.jsx)("h3",{children:"Serial Mutations"}),(0,r.jsx)(n.p,{children:"Root-level Mutation fields must be resolved serially to prevent simultaneous interactions with the same data, avoiding race conditions"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"mutation Transaction {\n  user {\n    success\n  }\n  # `payment` field resolves only after `user`,\n  # and won't resolve if `user` encounters an error\n  payment {\n    success\n  }\n}\n"})}),(0,r.jsx)(n.p,{children:"With namespaces, mutation fields that modify data are no longer root-level fields, allowing them to be resolved in parallel. To ensure transactional consistency use saga orchestrator in your mutation resolvers"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"mutation ParallelMutations (\n  $createInput: CreateReviewInput!\n  $deleteInput: DeleteReviewInput!\n) {\n  reviews {\n    create(input: $createInput) {\n      success\n    }\n\n    # resolved in parallel with `create`\n    delete(input: $deleteInput) {\n      success\n    }\n  }\n}\n"})}),(0,r.jsx)(n.p,{children:"To ensure serial execution in a specific operation, you can use client-side aliases to create two root fields that resolve serially"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:"mutation SerialMutations(\n  $createInput: CreateReviewInput!\n  $deleteInput: DeleteReviewInput!\n) {\n  createReviews: reviews {\n    create(input: $createInput) {\n      success\n    }\n  }\n\n  # resolved serially after `createReviews` is resolved\n  deletedReviews: reviews {\n    delete(input: $deleteInput) {\n      success\n    }\n  }\n}\n"})})]}),(0,r.jsx)(l.A,{value:"apq-pql",label:"APQ & PQL",children:(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Aspect"}),(0,r.jsx)("th",{children:"Automatic Persisted Query (APQ)"}),(0,r.jsx)("th",{children:"Registered Persisted Query (RPQ)"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Visualization"})}),(0,r.jsx)("td",{children:(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n\nparticipant client as Client App\nparticipant server as Apollo Server\n\nclient ->> server: Sends SHA-256 hash of query string to execute\nNote over server: Fails to find persisted query string\nserver ->> client: Responds with error\nclient ->> server: Sends both query string AND hash\nNote over server: Persists query string and hash\nserver ->> client: Executes query and returns result\nNote over client: Time passes\nclient ->> server: Sends SHA-256 hash of query string to execute\nNote over server: Finds persisted query string\nserver ->> client: Executes query and returns result"})}),(0,r.jsx)("td",{children:(0,r.jsx)(n.mermaid,{value:"graph LR\n\nsubgraph Supergraph\n    direction LR\n\n    subgraph Router\n        direction LR\n        router{{Graph Router}}\n        pql[[PQL]]\n\n        router <--\x3e pql\n    end\n\n    subgraph Subgraphs\n        direction LR\n\n        users(Users Subgraph)\n        product(Product Subgraph)\n    end\n\n    Router ----\x3e|Router executes<br/>registered operations| Subgraphs\n    Subgraphs -...->|Router blocks<br/>unregistered operations| Router\nend\n\nsubgraph apps[First-party apps]\n    direction LR\n\n    web(Web Client)\n    mobile(Mobile Client)\nend\n\napps --\x3e|Registered operations<br/>#40;build time#41;| Router\napps --\x3e|Register<br/>trusted operations<br/>#40;at runtime#41;| pql"})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Definition"})}),(0,r.jsx)("td",{children:"Query strings cached on the server side with a unique identifier (SHA-256 hash)"}),(0,r.jsx)("td",{children:"Pre-registered queries stored in a persisted query list (PQL) and identified by a unique ID"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Performance"})}),(0,r.jsx)("td",{children:"Reduces request sizes by sending identifiers instead of full query strings"}),(0,r.jsx)("td",{children:"Shares APQ's performance benefits and includes query plan cache warm-ups for even faster performance"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Registration"})}),(0,r.jsx)("td",{children:"Queries are registered at runtime; the server must receive the query string at least once"}),(0,r.jsx)("td",{children:"Queries are registered at build-time, allowing immediate execution using their PQL-specified ID"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Safelisting"})}),(0,r.jsx)("td",{children:"Does not provide safelisting capabilities as the cache is populated dynamically"}),(0,r.jsx)("td",{children:"Enables safelisting by rejecting operations not present in the PQL, enhancing security"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Flexibility"})}),(0,r.jsx)("td",{children:"Offers more flexibility as new queries can be added on the fly"}),(0,r.jsx)("td",{children:"Less flexible as changes to queries require updating the PQL at build time"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Security"})}),(0,r.jsx)("td",{children:"Less secure as it accepts any query that is sent at least once"}),(0,r.jsx)("td",{children:"More secure as it only accepts pre-registered queries, preventing malicious requests"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Use Case"})}),(0,r.jsx)("td",{children:"Suitable for improving network performance for large query strings without additional security concerns"}),(0,r.jsx)("td",{children:"Ideal for applications that require both performance optimization and enhanced security measures"})]})]})]})}),(0,r.jsxs)(l.A,{value:"federated-entities",label:"Federated Entities",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Entity"}),": Resolves fields across multiple subgraphs, where each subgraph contributes unique fields and resolves only its own; only object types can be entities, and each contributing subgraph must define a reference resolver"]}),(0,r.jsx)("h3",{children:"Keys"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Keys (best to use non-nullable fields) must uniquely identify the entity and can be a combination of one or more fields"}),"\n",(0,r.jsx)(n.li,{children:"Cannot include fields that return a union, interface, or fields that take arguments"}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",metastring:"{2,9}",children:'# Products Subgraph\ntype Product @key(fields: "upc") {\n  upc: ID!\n  name: String!\n  price: Int\n}\n\n# Reviews Subgraph\ntype Product @key(fields: "productUpc") {\n  productUpc: ID!\n  rating: Int!\n}\n'})}),(0,r.jsx)("h3",{children:"Key Variants"}),(0,r.jsxs)("table",{class:"text_vertical",children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Aspect"}),(0,r.jsx)("th",{children:"Definition"}),(0,r.jsx)("th",{children:"Example"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsxs)("b",{children:["Compound ",(0,r.jsx)(n.code,{children:"@keys"})]})}),(0,r.jsx)("td",{children:"Combine multiple fields to uniquely identify an entity"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type User @key(fields: "username domain") {\n  username: String!\n  domain: String!\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsxs)("b",{children:["Nested Fields in Compound ",(0,r.jsx)(n.code,{children:"@keys"})]})}),(0,r.jsx)("td",{children:"Nested fields can be used in compound keys"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type User @key(fields: "id organization { id }") {\n  id: ID!\n  organization: Organization!\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsxs)("b",{children:["Multiple ",(0,r.jsx)(n.code,{children:"@keys"})]})}),(0,r.jsxs)("td",{children:["Define multiple ",(0,r.jsx)(n.code,{children:"@keys"})," when different subgraphs interact with different fields"]}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type Product @key(fields: "id") @key(fields: "sku") {\n  id: ID!\n  sku: String!\n  name: String!\n  price: Int\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Referencing Entities with Multiple Keys"})}),(0,r.jsxs)("td",{children:["Subgraphs can reference an entity using any ",(0,r.jsx)(n.code,{children:"@key"})," fields"]}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type Product @key(fields: "id", resolvable: false) {\n  id: ID!\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsxs)("b",{children:["Differing ",(0,r.jsx)(n.code,{children:"@keys"})," Across Subgraphs"]})}),(0,r.jsxs)("td",{children:["Different subgraphs can use different ",(0,r.jsx)(n.code,{children:"@keys"})," for the same entity"]}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Products subgraph\ntype Product @key(fields: "sku") @key(fields: "upc") {\n  sku: ID!\n  upc: String!\n  name: String!\n  price: Int\n}\n\n# Inventory subgraph\ntype Product @key(fields: "upc") {\n  upc: String!\n  inStock: Boolean!\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Merging Entities"})}),(0,r.jsxs)("td",{children:["Entities must share at least one field in their ",(0,r.jsx)(n.code,{children:"@key"})," selection set to merge"]}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Products subgraph\ntype Product @key(fields: "sku") {\n  sku: ID!\n  name: String!\n  price: Int\n}\n\n# Inventory subgraph\ntype Product @key(fields: "upc") {\n  upc: String!\n  inStock: Boolean!\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsxs)("b",{children:["Operations with Differing ",(0,r.jsx)(n.code,{children:"@keys"})]})}),(0,r.jsx)("td",{children:"Differing keys affect which fields can be resolved from each subgraph"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Products Subgraph\ntype Product @key(fields: "sku") {\n    sku: ID!\n    upc: String!\n    name: String!\n    price: Int\n}\n\n# Inventory Subgraph\ntype Product @key(fields: "upc") {\n    upc: String!\n    inStock: Boolean!\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Query Resolution"})}),(0,r.jsx)("td",{children:"Queries in the Products subgraph can resolve all product fields, while queries in the Inventory subgraph can only resolve fields from the Products subgraph if both share a key"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Products subgraph\ntype Product @key(fields: "sku") @key(fields: "upc") {\n  sku: ID!\n  upc: String!\n  name: String!\n  price: Int\n}\n\n# Inventory subgraph\ntype Product @key(fields: "upc") {\n  upc: String!\n  inStock: Boolean!\n}\n'})})})]})]})]}),(0,r.jsx)("h3",{children:"Contribute Fields"}),(0,r.jsx)(n.p,{children:"Subgraphs in a federated GraphQL architecture can contribute to and reference fields from shared entities."}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Router Processing of Computed Fields"}),": When a query requests a computed field, the router queries the relevant subgraph for required fields, then for the computed field, and finally passes the required fields to the resolver."]}),(0,r.jsxs)("table",{class:"text_vertical",children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Aspect"}),(0,r.jsx)("th",{children:"Definition"}),(0,r.jsx)("th",{children:"Example"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Contributing Entity Fields"})}),(0,r.jsx)("td",{children:"Multiple subgraphs can contribute different fields to an entity"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Each subgraph must define a reference resolver for contributed fields\n\n# Products subgraph\ntype Product @key(fields: "id") {\n  id: ID!\n  name: String!\n  price: Int\n}\n\n# Inventory subgraph\ntype Product @key(fields: "id") {\n  id: ID!\n  inStock: Boolean!\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Contributing Computed Entity Fields"})}),(0,r.jsx)("td",{children:"Subgraphs can define fields computed from other entity fields"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Shipping subgraph\ntype Product @key(fields: "id") {\n  id: ID!\n  # @external marks fields that exist but cannot be resolved by the current subgraph\n  size: Int @external\n  weight: Int @external\n  # @requires indicates required fields from other subgraphs\n  shippingEstimate: String @requires(fields: "size weight")\n}\n\n# Products subgraph\ntype Product @key(fields: "id") {\n  id: ID!\n  name: String!\n  price: Int\n  size: Int\n  weight: Int\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsxs)("b",{children:["sing ",(0,r.jsx)(n.code,{children:"@requires"})," with Object Subfields"]})}),(0,r.jsx)("td",{children:"Specify subfields required from an object type"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type Product @key(fields: "id") {\n  id: ID!\n  dimensions: ProductDimensions @external\n  shippingEstimate: String @requires(fields: "dimensions { size weight }")\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsxs)("b",{children:["Using ",(0,r.jsx)(n.code,{children:"@requires"})," with Fields that Take Arguments"]})}),(0,r.jsxs)("td",{children:[(0,r.jsx)(n.code,{children:"@requires"})," can include fields with arguments"]}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type Product @key(fields: "id") {\n  id: ID!\n  weight(units: String): Int @external\n  # The router provides specified argument values,\n  # requiring static values for non-nullable arguments\n  shippingEstimate: String @requires(fields: "weight(units:\\"KG\\")")\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:"Referencing an Entity Without Contributing Fields"})}),(0,r.jsx)("td",{children:"Subgraphs can reference an entity without contributing fields"}),(0,r.jsxs)("td",{children:[(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Products subgraph\ntype Product @key(fields: "id") {\n  id: ID!\n  name: String!\n  price: Int\n}\n\n# Reviews subgraph\ntype Review {\n  product: Product!\n  score: Int!\n}\n'})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'\n# To reference the Product entity, add a stub definition\ntype Review {\n  product: Product!\n  score: Int!\n}\n\n# Stub definition includes only the @key fields\n# and indicates that no reference resolver is defined\ntype Product @key(fields: "id", resolvable: false) {\n  id: ID!\n}\n'})})]})]})]}),(0,r.jsx)("h3",{children:"Resolve another subgraph's fields"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resolving the Same Entity Field from Different Subgraphs"}),": By default, only one subgraph resolves each field in the supergraph schema, except for entity ",(0,r.jsx)(n.code,{children:"@key"})," fields; however, multiple subgraphs can resolve the same field if they share access to a common data store"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enabling Multiple Subgraphs to Resolve the Same Field"}),": Use the ",(0,r.jsx)(n.code,{children:"@shareable"})," directive to allow multiple subgraphs to resolve a specific entity field, and the ",(0,r.jsx)(n.code,{children:"@provides"})," directive to indicate that a field can be resolved by a subgraph only from certain query paths"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Choosing the Right Directive"}),": Use ",(0,r.jsx)(n.code,{children:"@shareable"})," if the subgraph can always resolve the field, and ",(0,r.jsx)(n.code,{children:"@provides"})," if the subgraph can resolve the field only under certain conditions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ensuring Resolver Consistency"}),": When multiple subgraphs resolve a field, ensure that each resolver behaves identically to avoid inconsistent results, watching for common inconsistencies such as different default return values and varying error handling in the same scenarios"]}),"\n"]}),(0,r.jsxs)("table",{class:"text_vertical",children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Directive"}),(0,r.jsx)("th",{children:"Description"}),(0,r.jsx)("th",{children:"Example"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:(0,r.jsx)(n.code,{children:"@shareable"})})}),(0,r.jsxs)("td",{children:["Allows multiple subgraphs to resolve a field; if a field is marked as ",(0,r.jsx)(n.code,{children:"@shareable"})," in any subgraph, it must also be marked as ",(0,r.jsx)(n.code,{children:"@shareable"})," or ",(0,r.jsx)(n.code,{children:"@external"})," in all subgraphs that define it"]}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Products subgraph\ntype Product @key(fields: "id") {\n  id: ID!\n  name: String! @shareable\n  price: Int\n}\n\n# Inventory subgraph\ntype Product @key(fields: "id") {\n  id: ID!\n  name: String! @shareable\n  inStock: Boolean!\n}\n'})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("b",{children:(0,r.jsx)(n.code,{children:"@provides"})})}),(0,r.jsxs)("td",{children:[(0,r.jsx)(n.p,{children:"Indicates that a field can be resolved by a subgraph at a specific query path"}),(0,r.jsx)(n.p,{children:"Rules:"}),(0,r.jsxs)("ul",{children:[(0,r.jsxs)("li",{children:["if a subgraph uses ",(0,r.jsx)(n.code,{children:"@provides"})," for a field, it must also mark that field as ",(0,r.jsx)(n.code,{children:"@external"})," and not as ",(0,r.jsx)(n.code,{children:"@shareable"})]}),(0,r.jsxs)("li",{children:[(0,r.jsx)(n.code,{children:"@shareable"})," field can always be resolved, negating the need for ",(0,r.jsx)(n.code,{children:"@provides"})]}),(0,r.jsxs)("li",{children:["all subgraphs defining a field in a ",(0,r.jsx)(n.code,{children:"@provides"})," directive must mark that field as ",(0,r.jsx)(n.code,{children:"@shareable"})," or ",(0,r.jsx)(n.code,{children:"@external"})]})]})]}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Inventory subgraph\ntype InStockCount {\n  # `@provides` indicates that the subgraph\n  # can resolve the field when certain conditions are met\n  product: Product! @provides(fields: "name")\n  quantity: Int!\n}\n\ntype Product @key(fields: "id") {\n  id: ID!\n  # `@external` indicates that the subgraph\n  # cannot resolve the field independently\n  name: String! @external\n  inStock: Boolean!\n}\n'})})})]})]})]}),(0,r.jsx)("h3",{children:"Entity Interfaces"}),(0,r.jsx)(n.p,{children:"Rules:"}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Interface Definition"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Must include at least one ",(0,r.jsx)(n.code,{children:"@key"})," directive"]}),"\n",(0,r.jsx)(n.li,{children:"Subgraph that owns all entities implementing the interface"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"@interfaceObject"})," Definitions"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Must reference an existing interface with ",(0,r.jsx)(n.code,{children:"@key"})]}),"\n",(0,r.jsx)(n.li,{children:"Cannot define the interface as an object type in the same subgraph"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resolvers"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reference Resolver"}),": Needed for entity interfaces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Field Resolvers"}),": Required for new fields in object types"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"@interfaceObject"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Prevents maintenance issues by allowing subgraphs to generically add fields without needing to redefine entities"}),"\n",(0,r.jsx)(n.li,{children:"Avoids composition errors when new entities are added"}),"\n"]}),"\n"]}),"\n"]})]})]}),(0,r.jsxs)(l.A,{value:"migration",label:"Migration",children:[(0,r.jsx)(n.p,{children:"Migrate entity or root fields from one subgraph to another as the supergraph evolves"}),(0,r.jsx)("table",{children:(0,r.jsx)("tbody",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Initial Payments Subgraph\ntype Bill @key(fields: "id") {\n    id: ID!\n    amount: Int!\n    payment: Payment\n}\n\ntype Payment {\n    # ...\n}\n'})})}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'# Target Billing Subgraph\ntype Bill @key(fields: "id") {\n    id: ID!\n    amount: Int!\n}\n'})})})]})})}),(0,r.jsxs)("h3",{children:["Migration Process with ",(0,r.jsx)(n.code,{children:"@override"})]}),(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Import @override Directive"}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'extend schema\n    @link(url: "https://specs.apollo.dev/federation/v2.7",\n       import: ["@key", "@shareable", "@override"])\n'})}),(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:["Update Billing Subgraph. Add the ",(0,r.jsx)(n.code,{children:"amount"})," field with ",(0,r.jsx)(n.code,{children:"@override"})]}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type Bill @key(fields: "id") {\n    id: ID!\n    amount: Int! @override(from: "Payments")\n}\n'})}),(0,r.jsxs)(n.ol,{start:"3",children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Publish Updated Billing Schema. The router resolves ",(0,r.jsx)(n.code,{children:"Bill.amount"})," from the Billing subgraph while still resolving ",(0,r.jsx)(n.code,{children:"Bill.payment"})," from Payments"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Remove Field from Payments Subgraph"}),"\n"]}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type Bill @key(fields: "id") {\n    id: ID!\n    payment: Payment\n}\n'})}),(0,r.jsxs)(n.ol,{start:"5",children:["\n",(0,r.jsxs)(n.li,{children:["Update Billing Subgraph. Remove the ",(0,r.jsx)(n.code,{children:"@override"})," directive"]}),"\n"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-graphql",children:'type Bill @key(fields: "id") {\n    id: ID!\n    amount: Int!\n}\n'})})]})]})}),(0,r.jsx)(l.A,{value:"best-practices",label:"Best Practices",children:(0,r.jsxs)(d.A,{queryString:"secondary",children:[(0,r.jsx)(l.A,{value:"core-principles",label:"Core Principles",attributes:{className:"tabs__vertical"},children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Clear Naming Conventions"}),": adopt consistent naming conventions like ",(0,r.jsx)(n.code,{children:"camelCase"})," for fields and ",(0,r.jsx)(n.code,{children:"PascalCase"})," for types to make the schema self-documenting and easy to follow"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Keep the Schema Simple"}),": start with a basic schema and evolve it as needed. Over-engineering from the start can lead to unnecessary complexity"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Utilize Interfaces and Unions"}),": these allow for the representation of shared features and the combination of different types, providing flexibility in the schema design"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Versioning"}),": GraphQL takes a strong opinion on avoiding versioning by providing the tools for the continuous evolution of a GraphQL schema. This means new capabilities can be added without creating breaking changes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nullability"}),": properly use nullability to indicate whether a field can be null. This helps with the predictability and reliability of the API responses"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Abstract Types"}),": Use abstract types like interfaces and unions to model shared characteristics between entities"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Caching"}),": Implement caching mechanisms for frequently accessed data to reduce server load and improve response times"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Object Types"}),": Define object types to represent data entities with well-defined properties"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Input Object Types"}),": Use input object types to structure data for mutations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complex Data Structures"}),": Define object types for complex data structures"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom Scalars"}),": Define custom scalar types for specialized data formats to improve type safety and expressiveness"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Entity Identification"}),": Ensure each entity has a unique identifier, typically an ID field"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enums"}),": Employ enums for defining finite sets of possible values"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Field-Level Resolution"}),": Implement field-level resolvers to optimize data fetching and avoid over-fetching unnecessary data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GraphQL Variables"}),": Use GraphQL variables to avoid query string manipulation to improve cache effectiveness and information privacy"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type Extensions"}),": Utilize GraphQL type extensions to add additional fields or functionality to existing types without modifying their original definition"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Language Agnostic"}),": The schema should be independent of programming language"]}),"\n"]})}),(0,r.jsx)(l.A,{value:"performance",label:"Performance",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Batching"}),": Consider server-side batching to improve performance by fetching related data in a single request"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Pagination"}),": Implement cursor-based pagination for large datasets to improve query performance and reduce memory overhead"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Discovery"}),": Consider using a registry or service mesh for dynamic discovery"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimized Resolvers"}),": Write efficient resolver functions to minimize data fetching latency and optimize query execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Query Complexity Analysis"}),": Perform query complexity analysis to prevent costly or inefficient queries from impacting system performance"]}),"\n"]})}),(0,r.jsx)(l.A,{value:"nesting-in-graphql-schemas",label:"Nesting in GraphQL Schemas",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limit Depth of Nesting"}),": deeply nested queries can lead to performance issues. It's important to limit the depth of nesting to what is necessary for the application's functionality"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Batch Loading"}),": to prevent the N+1 problem, where multiple nested queries cause a cascade of database calls, use batch loading techniques like DataLoader to batch requests to the database"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Designing for Clarity"}),": when nesting, ensure that the structure is clear and logical. The relationships between types should be intuitive, allowing developers to easily understand the schema and build queries"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Federated Schemas"}),": for complex schemas it can be used to combine multiple schemas into one. This allows for a modular approach to schema design, where each module can be developed independently and then stitched together"]}),"\n"]})}),(0,r.jsx)(l.A,{value:"design-principles",label:"Design Principles",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Schema Definition Language (SDL)"}),": Utilize GraphQL SDL (Schema Definition Language) to define types, queries, mutations, and subscriptions with clear and concise naming conventions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flat Structure Preference"}),": minimize deep nesting by promoting a flat schema structure where possible. This reduces complexity and improves performance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simplicity"}),": Schema should be designed with both simplicity and flexibility in mind. It should be easy to understand and navigate, avoiding overly complex or deeply nested structures that can become difficult to maintain"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Entity Normalization"}),": break down complex entities into smaller, normalized types to allow reuse and easier resolution. Use references (IDs) and separate queries for resolving deeply nested data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pagination and Limits"}),": implement pagination (edges and nodes) for nested lists to prevent overwhelming the server"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Avoid N+1 Problem"}),": design resolvers with batching mechanisms (e.g., ",(0,r.jsx)(n.code,{children:"DataLoader"}),") to mitigate N+1 query issues in nested relationships"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Handling and Partial Responses"}),": ensure the schema can handle errors gracefully, especially in nested cases, by leveraging GraphQL\u2019s error format for partial responses"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Client-Driven Design"}),": Focus on the specific needs of client applications. Prioritize functionality used by multiple clients, but avoid bloating the schema with features for a single client"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Demand-Oriented"}),": Add functionalities gradually based on client requirements to lean and efficient schema"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Evolvable Schema"}),": Design for future growth. Consider potential use cases and data needs that may arise"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Demand Oriented (abstract)"}),": Design demand-oriented schemas by shifting to a common graph for simplified client data access via GraphQL, ensuring schemas are abstract and not tightly coupled to specific clients or services, despite GraphQL's client-driven design not guaranteeing usability"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prioritize Client Needs"}),": Consult client teams early in the API design process, conducting ongoing research to adapt to evolving requirements, and engaging them in defining data needs and ideal data shapes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Avoid Service Implementation Details"}),": Prevent schema design from being influenced by backing services, using federation to express natural relationships between types, and refraining from exposing unnecessary fields and implementation details in the schema"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enhance Schema Expressiveness"}),": Convey meaning about nodes and relationships, standardizing naming and formatting conventions across services, and ensuring consistent pagination experiences throughout the graph"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Design Fields for Specific Use Cases"}),": Create single-purpose fields for clarity, utilizing finer-grained mutations and queries to avoid ambiguity, and thoroughly documenting types, fields, and arguments for transparency"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Document Schema Effectively"}),": Treat documentation as a first-class feature in GraphQL, using SDL-supported description syntax for clarity, and establishing standards and governance for consistency"]}),"\n"]})}),(0,r.jsx)(l.A,{value:"security",label:"Security",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transport Layer Security"}),": Implement TLS (Transport Layer Security) for secure communication over the network"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Authentication and Authorization"}),": Implement authentication and authorization mechanisms to ensure secure access to the GraphQL API"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Depth limiting"}),": Restrict the maximum number of nested levels in queries. It helps prevent denial-of-service (DoS) attacks and excessive resource consumption by rejecting overly complex queries, ensuring better performance and resource management for the server"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Breadth Limiting"})," restricts the number of fields requested at a single level in a GraphQL query"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Batch Limiting"})," controls the number of operations sent in a single request to prevent server overload"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rate Limiting"}),": Implement rate limiting to prevent abuse and ensure proper usage of the GraphQL API"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Handling"}),": Define a consistent error handling strategy to provide meaningful error messages to clients"]}),"\n"]})}),(0,r.jsx)(l.A,{value:"federation",label:"Federation",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Automatic Persisted Queries (APQ)"}),": Use APQ to improve query performance by caching queries and responses"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Registered Persisted Query (RPQ)"}),": Accepts pre-registered queries, preventing malicious requests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Federated Supergraph"}),": Leverage tools like Apollo Router for simplified federation setup and management"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Federation"}),": Align subgraphs with business domains for ownership and maintainability"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Gateway Configuration"}),": Use GraphQL Gateway to orchestrate requests across federated services"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Modular Schema"}),": Encourage a modular approach to schema design, where each domain or microservice defines its own GraphQL schema"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Schema Stitching"}),": Foster collaboration between teams to align on a unified graph schema that reflects the entire organization's data model"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Configuration"}),": Configure each service to participate in the federation, including endpoint URLs and schemas"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Discovery"}),": Implement a robust service discovery mechanism for the federation gateway to locate subgraphs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Service Implementation"}),": Develop individual GraphQL services responsible for serving specific types or subsets of types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Subgraphs"}),": Define clear boundaries between subgraphs to avoid overlap and conflicts"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type Definitions"}),": Define entity types and their relationships in each service's GraphQL schema"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"@external"})," Directive"]}),": Mark fields from other services as external using ",(0,r.jsx)(n.code,{children:"@external"})," directive"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"@key"})," Directive"]}),": Annotate entity fields with ",(0,r.jsx)(n.code,{children:"@key"})," directive to declare them as federation keys"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"@requires"})," and ",(0,r.jsx)(n.code,{children:"@provides"})," Directives"]}),": Specify field dependencies using these directives to enable automatic query planning"]}),"\n"]})})]})})]})}function j(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(x,{...e})}):x(e)}},75458:(e,n,i)=>{i.d(n,{A:()=>D});var s=i(30758),r=i(86070);function t(e){const{mdxAdmonitionTitle:n,rest:i}=function(e){const n=s.Children.toArray(e),i=n.find((e=>s.isValidElement(e)&&"mdxAdmonitionTitle"===e.type)),t=n.filter((e=>e!==i)),d=i?.props.children;return{mdxAdmonitionTitle:d,rest:t.length>0?(0,r.jsx)(r.Fragment,{children:t}):null}}(e.children),t=e.title??n;return{...e,...t&&{title:t},children:i}}var d=i(13526),l=i(31369),a=i(47336);const c={admonition:"admonition_EiNP",admonitionHeading:"admonitionHeading_onse",admonitionIcon:"admonitionIcon_JG59",admonitionContent:"admonitionContent_RGuD"};function o(e){let{type:n,className:i,children:s}=e;return(0,r.jsx)("div",{className:(0,d.A)(a.G.common.admonition,a.G.common.admonitionType(n),c.admonition,i),children:s})}function h(e){let{icon:n,title:i}=e;return(0,r.jsxs)("div",{className:c.admonitionHeading,children:[(0,r.jsx)("span",{className:c.admonitionIcon,children:n}),i]})}function u(e){let{children:n}=e;return n?(0,r.jsx)("div",{className:c.admonitionContent,children:n}):null}function x(e){const{type:n,icon:i,title:s,children:t,className:d}=e;return(0,r.jsxs)(o,{type:n,className:d,children:[s||i?(0,r.jsx)(h,{title:s,icon:i}):null,(0,r.jsx)(u,{children:t})]})}function j(e){return(0,r.jsx)("svg",{viewBox:"0 0 14 16",...e,children:(0,r.jsx)("path",{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})})}const p={icon:(0,r.jsx)(j,{}),title:(0,r.jsx)(l.A,{id:"theme.admonition.note",description:"The default label used for the Note admonition (:::note)",children:"note"})};function g(e){return(0,r.jsx)(x,{...p,...e,className:(0,d.A)("alert alert--secondary",e.className),children:e.children})}function m(e){return(0,r.jsx)("svg",{viewBox:"0 0 12 16",...e,children:(0,r.jsx)("path",{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})})}const f={icon:(0,r.jsx)(m,{}),title:(0,r.jsx)(l.A,{id:"theme.admonition.tip",description:"The default label used for the Tip admonition (:::tip)",children:"tip"})};function y(e){return(0,r.jsx)(x,{...f,...e,className:(0,d.A)("alert alert--success",e.className),children:e.children})}function b(e){return(0,r.jsx)("svg",{viewBox:"0 0 14 16",...e,children:(0,r.jsx)("path",{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})})}const v={icon:(0,r.jsx)(b,{}),title:(0,r.jsx)(l.A,{id:"theme.admonition.info",description:"The default label used for the Info admonition (:::info)",children:"info"})};function w(e){return(0,r.jsx)(x,{...v,...e,className:(0,d.A)("alert alert--info",e.className),children:e.children})}function I(e){return(0,r.jsx)("svg",{viewBox:"0 0 16 16",...e,children:(0,r.jsx)("path",{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})})}const S={icon:(0,r.jsx)(I,{}),title:(0,r.jsx)(l.A,{id:"theme.admonition.warning",description:"The default label used for the Warning admonition (:::warning)",children:"warning"})};function q(e){return(0,r.jsx)("svg",{viewBox:"0 0 12 16",...e,children:(0,r.jsx)("path",{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"})})}const A={icon:(0,r.jsx)(q,{}),title:(0,r.jsx)(l.A,{id:"theme.admonition.danger",description:"The default label used for the Danger admonition (:::danger)",children:"danger"})};const N={icon:(0,r.jsx)(I,{}),title:(0,r.jsx)(l.A,{id:"theme.admonition.caution",description:"The default label used for the Caution admonition (:::caution)",children:"caution"})};const P={...{note:g,tip:y,info:w,warning:function(e){return(0,r.jsx)(x,{...S,...e,className:(0,d.A)("alert alert--warning",e.className),children:e.children})},danger:function(e){return(0,r.jsx)(x,{...A,...e,className:(0,d.A)("alert alert--danger",e.className),children:e.children})}},...{secondary:e=>(0,r.jsx)(g,{title:"secondary",...e}),important:e=>(0,r.jsx)(w,{title:"important",...e}),success:e=>(0,r.jsx)(y,{title:"success",...e}),caution:function(e){return(0,r.jsx)(x,{...N,...e,className:(0,d.A)("alert alert--warning",e.className),children:e.children})}}};function D(e){const n=t(e),i=(s=n.type,P[s]||(console.warn(`No admonition component found for admonition type "${s}". Using Info as fallback.`),P.info));var s;return(0,r.jsx)(i,{...n})}},14678:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/apollo-graphos-266e56a222e392565b7444432a8396d2.svg"}}]);