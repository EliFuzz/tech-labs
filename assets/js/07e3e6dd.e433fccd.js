"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[8533],{31137:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>b,contentTitle:()=>d,default:()=>k,frontMatter:()=>x,metadata:()=>g,toc:()=>j});var i=e(86070),r=e(27468),a=e(78826),l=e(28437),s=e(41634);const p="package main\n\nfunc buildTable(pattern string) []int {\n    table := make([]int, len(pattern))\n    table[0] = 0\n    prefix := 0\n\n    for i := 1; i < len(pattern); i++ {\n        for prefix > 0 && pattern[i] != pattern[prefix] {\n            prefix = table[prefix-1]\n        }\n        if pattern[i] == pattern[prefix] {\n            prefix++\n        }\n        table[i] = prefix\n    }\n\n    return table\n}\n\nfunc kmpSearch(text string, pattern string) []int {\n    table := buildTable(pattern)\n    matches := make([]int, 0)\n\n    j := 0\n    for i := 0; i < len(text); i++ {\n        for j > 0 && text[i] != pattern[j] {\n            j = table[j-1]\n        }\n        if text[i] == pattern[j] {\n            j++\n        }\n        if j == len(pattern) {\n            matches = append(matches, i-len(pattern)+1)\n            j = table[j-1]\n        }\n    }\n\n    return matches\n}\n",c="import java.util.ArrayList;\nimport java.util.List;\n\npublic class KMP {\n\n  public static int[] buildTable(String pattern) {\n    int[] table = new int[pattern.length()];\n    int prefix = 0;\n\n    for (int i = 1; i < pattern.length(); i++) {\n      while (prefix > 0 && pattern.charAt(i) != pattern.charAt(prefix)) {\n        prefix = table[prefix - 1];\n      }\n      if (pattern.charAt(i) == pattern.charAt(prefix)) {\n        prefix++;\n      }\n      table[i] = prefix;\n    }\n\n    return table;\n  }\n\n  public static List<Integer> kmpSearch(String text, String pattern) {\n    int[] table = buildTable(pattern);\n    List<Integer> matches = new ArrayList<>();\n    int j = 0;\n\n    for (int i = 0; i < text.length(); i++) {\n      while (j > 0 && text.charAt(i) != pattern.charAt(j)) {\n        j = table[j - 1];\n      }\n      if (text.charAt(i) == pattern.charAt(j)) {\n        j++;\n      }\n      if (j == pattern.length()) {\n        matches.add(i - pattern.length() + 1);\n        j = table[j - 1];\n      }\n    }\n\n    return matches;\n  }\n}\n",h="function buildTable(pattern) {\n  const table = new Array(pattern.length).fill(0);\n  let prefix = 0;\n\n  for (let i = 1; i < pattern.length; i++) {\n    while (prefix > 0 && pattern[i] !== pattern[prefix]) {\n      prefix = table[prefix - 1];\n    }\n    if (pattern[i] === pattern[prefix]) {\n      prefix++;\n    }\n    table[i] = prefix;\n  }\n\n  return table;\n}\n\nfunction kmpSearch(text, pattern) {\n  const table = buildTable(pattern);\n  const matches = [];\n  let j = 0;\n\n  for (let i = 0; i < text.length; i++) {\n    while (j > 0 && text[i] !== pattern[j]) {\n      j = table[j - 1];\n    }\n    if (text[i] === pattern[j]) {\n      j++;\n    }\n    if (j === pattern.length) {\n      matches.push(i - pattern.length + 1);\n      j = table[j - 1];\n    }\n  }\n\n  return matches;\n}\n",o="fun buildTable(pattern: String): IntArray {\n    val table = IntArray(pattern.length)\n    var prefix = 0\n\n    for (i in 1 until pattern.length) {\n        while (prefix > 0 && pattern[i] != pattern[prefix]) {\n            prefix = table[prefix - 1]\n        }\n        if (pattern[i] == pattern[prefix]) {\n            prefix++\n        }\n        table[i] = prefix\n    }\n\n    return table\n}\n\nfun kmpSearch(text: String, pattern: String): List<Int> {\n    val table = buildTable(pattern)\n    val matches = mutableListOf<Int>()\n    var j = 0\n\n    for (i in text.indices) {\n        while (j > 0 && text[i] != pattern[j]) {\n            j = table[j - 1]\n        }\n        if (text[i] == pattern[j]) {\n            j++\n        }\n        if (j == pattern.length) {\n            matches.add(i - pattern.length + 1)\n            j = table[j - 1]\n        }\n    }\n\n    return matches\n}\n",u="def build_table(pattern):\n    table = [0] * len(pattern)\n    prefix = 0\n\n    for i in range(1, len(pattern)):\n        while prefix > 0 and pattern[i] != pattern[prefix]:\n            prefix = table[prefix - 1]\n        if pattern[i] == pattern[prefix]:\n            prefix += 1\n        table[i] = prefix\n\n    return table\n\ndef kmp_search(text, pattern):\n    table = build_table(pattern)\n    matches = []\n    j = 0\n\n    for i in range(len(text)):\n        while j > 0 and text[i] != pattern[j]:\n            j = table[j - 1]\n        if text[i] == pattern[j]:\n            j += 1\n        if j == len(pattern):\n            matches.append(i - len(pattern) + 1)\n            j = table[j - 1]\n\n    return matches\n",f="fn build_table(pattern: &str) -> Vec<usize> {\n    let mut table = vec![0; pattern.len()];\n    let mut prefix = 0;\n\n    for (i, c) in pattern.chars().enumerate().skip(1) {\n        while prefix > 0 && c != pattern.chars().nth(prefix).unwrap() {\n            prefix = table[prefix - 1];\n        }\n        if c == pattern.chars().nth(prefix).unwrap() {\n            prefix += 1;\n        }\n        table[i] = prefix;\n    }\n\n    table\n}\n\nfn kmp_search(text: &str, pattern: &str) -> Vec<usize> {\n    let table = build_table(pattern);\n    let mut matches = vec![];\n    let mut j = 0;\n\n    for (i, c) in text.chars().enumerate() {\n        while j > 0 && c != pattern.chars().nth(j).unwrap() {\n            j = table[j - 1];\n        }\n        if c == pattern.chars().nth(j).unwrap() {\n            j += 1;\n        }\n        if j == pattern.len() {\n            matches.push(i - pattern.len() + 1);\n            j = table[j - 1];\n        }\n    }\n\n    matches\n}\n",m="function buildTable(pattern: string): number[] {\n  const table: number[] = new Array(pattern.length).fill(0);\n  let prefix = 0;\n\n  for (let i = 1; i < pattern.length; i++) {\n    while (prefix > 0 && pattern[i] !== pattern[prefix]) {\n      prefix = table[prefix - 1];\n    }\n    if (pattern[i] === pattern[prefix]) {\n      prefix++;\n    }\n    table[i] = prefix;\n  }\n\n  return table;\n}\n\nfunction kmpSearch(text: string, pattern: string): number[] {\n  const table = buildTable(pattern);\n  const matches: number[] = [];\n  let j = 0;\n\n  for (let i = 0; i < text.length; i++) {\n    while (j > 0 && text[i] !== pattern[j]) {\n      j = table[j - 1];\n    }\n    if (text[i] === pattern[j]) {\n      j++;\n    }\n    if (j === pattern.length) {\n      matches.push(i - pattern.length + 1);\n      j = table[j - 1];\n    }\n  }\n\n  return matches;\n}\n",x={title:"Knuth\u2013Morris\u2013Pratt Algorithm (KMP Algorithm)",description:"Knuth\u2013Morris\u2013Pratt Algorithm (KMP Algorithm)",hide_table_of_contents:!0},d=void 0,g={id:"education/computer-science/algorithms/algo/knuth\u2013morris\u2013pratt-algorithm",title:"Knuth\u2013Morris\u2013Pratt Algorithm (KMP Algorithm)",description:"Knuth\u2013Morris\u2013Pratt Algorithm (KMP Algorithm)",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/knuth\u2013morris\u2013pratt-algorithm.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/knuth\u2013morris\u2013pratt-algorithm",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/knuth\u2013morris\u2013pratt-algorithm",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/knuth\u2013morris\u2013pratt-algorithm.mdx",tags:[],version:"current",frontMatter:{title:"Knuth\u2013Morris\u2013Pratt Algorithm (KMP Algorithm)",description:"Knuth\u2013Morris\u2013Pratt Algorithm (KMP Algorithm)",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Knight's Tour",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/knights-tour"},next:{title:"Kruskal's Algorithm",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/kruskals-algorithm"}},b={},j=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function A(t){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(a.A,{queryString:"primary",children:[(0,i.jsx)(l.A,{value:"definition",label:"Definition",children:(0,i.jsx)(n.p,{children:"The Knuth\u2013Morris\u2013Pratt (KMP) Algorithm is a string searching algorithm that efficiently finds occurrences of a pattern within a text. It does so by utilizing information from previously matched characters to avoid unnecessary comparisons"})}),(0,i.jsx)(l.A,{value:"how",label:"Explanation",children:(0,i.jsx)(n.p,{children:'The KMP Algorithm works by precomputing a partial match table, also known as the "failure function" or "prefix function," for the pattern. This table enables the algorithm to determine the maximum length of a proper suffix of the pattern that matches a prefix of the pattern. During the matching process, the algorithm utilizes this information to efficiently skip unnecessary comparisons'})}),(0,i.jsx)(l.A,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Construct the partial match table for the pattern"}),"\n",(0,i.jsxs)(n.li,{children:["Initialize two pointers: one for the text (",(0,i.jsx)(n.code,{children:"i"}),") and one for the pattern (",(0,i.jsx)(n.code,{children:"j"}),") at the beginning of their respective strings"]}),"\n",(0,i.jsxs)(n.li,{children:["Iterate through the text while the text pointer is less than its length","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Compare characters at the text and pattern pointers"}),"\n",(0,i.jsx)(n.li,{children:"If the characters match, increment both pointers"}),"\n",(0,i.jsx)(n.li,{children:"If the characters don't match and the pattern pointer is not at the beginning, update the pattern pointer using information from the partial match table"}),"\n",(0,i.jsx)(n.li,{children:"If the characters don't match and the pattern pointer is at the beginning, move only the text pointer forward"}),"\n",(0,i.jsx)(n.li,{children:"Repeat steps until a match is found or the end of the text is reached"}),"\n"]}),"\n"]}),"\n"]})}),(0,i.jsx)(l.A,{value:"tips",label:"Tips",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"utilize the partial match table to efficiently determine the next comparison position in the pattern"}),"\n",(0,i.jsx)(n.li,{children:"avoid unnecessary backtracking by utilizing the information from the partial match table"}),"\n"]})})]}),"\n",(0,i.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(a.A,{queryString:"primary",children:[(0,i.jsx)(l.A,{value:"practice",label:"Practice",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'computePrefixFunction(pattern):\n  m = length of pattern\n  prefixFunction[m]\n  prefixFunction[0] = 0\n  k = 0\n  for q from 2 to m:\n    while k > 0 and pattern[k+1] \u2260 pattern[q]:\n      k = prefixFunction[k]\n    if pattern[k+1] == pattern[q]:\n      k = k + 1\n    prefixFunction[q] = k\n  return prefixFunction\n\nsearchKMP(text, pattern):\n  n = length of text\n  m = length of pattern\n  prefixFunction = computePrefixFunction(pattern)\n  q = 0\n  for i from 1 to n:\n    while q > 0 and pattern[q+1] \u2260 text[i]:\n      q = prefixFunction[q]\n    if pattern[q+1] == text[i]:\n      q = q + 1\n    if q == m:\n      print "Pattern occurs with shift" i - m\n      q = prefixFunction[q]\n'})})}),(0,i.jsx)(l.A,{value:"solution",label:"Solution",children:(0,i.jsxs)(a.A,{queryString:"code",children:[(0,i.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(s.A,{language:"go",children:p})}),(0,i.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(s.A,{language:"java",children:c})}),(0,i.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(s.A,{language:"js",children:h})}),(0,i.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(s.A,{language:"kotlin",children:o})}),(0,i.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(s.A,{language:"python",children:u})}),(0,i.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(s.A,{language:"rust",children:f})}),(0,i.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(s.A,{language:"ts",children:m})})]})})]})]})}function k(t={}){const{wrapper:n}={...(0,r.R)(),...t.components};return n?(0,i.jsx)(n,{...t,children:(0,i.jsx)(A,{...t})}):A(t)}}}]);