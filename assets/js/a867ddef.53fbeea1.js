"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[540],{15516:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>w,contentTitle:()=>v,default:()=>b,frontMatter:()=>m,metadata:()=>f,toc:()=>j});var i=t(86070),s=t(25710),a=t(98459),r=t(37515),d=t(18792);const o='package main\n\nimport (\n    "container/heap"\n)\n\ntype Edge struct {\n    node   int\n    weight int\n}\n\ntype Graph struct {\n    numNodes int\n    adjList  map[int][]Edge\n}\n\nfunc NewGraph(numNodes int) *Graph {\n    return &Graph{\n        numNodes: numNodes,\n        adjList:  make(map[int][]Edge),\n    }\n}\n\nfunc (g *Graph) AddEdge(u, v, weight int) {\n    g.adjList[u] = append(g.adjList[u], Edge{node: v, weight: weight})\n    g.adjList[v] = append(g.adjList[v], Edge{node: u, weight: weight})\n}\n\nfunc PrimMST(g *Graph) int {\n    visited := make(map[int]bool)\n    pq := make(PriorityQueue, 0)\n    startNode := 0\n\n    heap.Push(&pq, &Item{node: startNode, weight: 0})\n\n    minCost := 0\n\n    for pq.Len() > 0 {\n        item := heap.Pop(&pq).(*Item)\n        u := item.node\n\n        if visited[u] {\n            continue\n        }\n\n        visited[u] = true\n        minCost += item.weight\n\n        for _, edge := range g.adjList[u] {\n            v := edge.node\n            weight := edge.weight\n            if !visited[v] {\n                heap.Push(&pq, &Item{node: v, weight: weight})\n            }\n        }\n    }\n    return minCost\n}\n\ntype Item struct {\n    node   int\n    weight int\n}\n\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    return pq[i].weight < pq[j].weight\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n    pq[i], pq[j] = pq[j], pq[i]\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    item := x.(*Item)\n    *pq = append(*pq, item)\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    item := old[n-1]\n    *pq = old[0 : n-1]\n    return item\n}\n',l="import java.util.*;\n\nclass Edge {\n\n  int node;\n  int weight;\n\n  public Edge(int node, int weight) {\n    this.node = node;\n    this.weight = weight;\n  }\n}\n\nclass Graph {\n\n  int numNodes;\n  Map<Integer, List<Edge>> adjList;\n\n  public Graph(int numNodes) {\n    this.numNodes = numNodes;\n    this.adjList = new HashMap<>();\n    for (int i = 0; i < numNodes; i++) {\n      adjList.put(i, new ArrayList<>());\n    }\n  }\n\n  public void addEdge(int u, int v, int weight) {\n    adjList.get(u).add(new Edge(v, weight));\n    adjList.get(v).add(new Edge(u, weight));\n  }\n}\n\npublic class PrimAlgorithm {\n\n  public static int primMST(Graph graph) {\n    boolean[] visited = new boolean[graph.numNodes];\n    PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.weight));\n    int startNode = 0;\n\n    pq.offer(new Edge(startNode, 0));\n\n    int minCost = 0;\n\n    while (!pq.isEmpty()) {\n      Edge edge = pq.poll();\n      int u = edge.node;\n\n      if (visited[u]) {\n        continue;\n      }\n\n      visited[u] = true;\n      minCost += edge.weight;\n\n      for (Edge adjacent : graph.adjList.get(u)) {\n        int v = adjacent.node;\n        int weight = adjacent.weight;\n\n        if (!visited[v]) {\n          pq.offer(new Edge(v, weight));\n        }\n      }\n    }\n    return minCost;\n  }\n}\n",u="class PriorityQueue {\n  constructor() {\n    this.queue = [];\n  }\n\n  enqueue(element) {\n    this.queue.push(element);\n    this.queue.sort((a, b) => a[1] - b[1]);\n  }\n\n  dequeue() {\n    return this.queue.shift();\n  }\n\n  isEmpty() {\n    return this.queue.length === 0;\n  }\n}\n\nclass Graph {\n  constructor(numNodes) {\n    this.numNodes = numNodes;\n    this.adjList = new Map();\n    for (let i = 0; i < numNodes; i++) {\n      this.adjList.set(i, []);\n    }\n  }\n\n  addEdge(u, v, weight) {\n    this.adjList.get(u).push({ node: v, weight });\n    this.adjList.get(v).push({ node: u, weight });\n  }\n}\n\nfunction primMST(graph) {\n  const visited = new Array(graph.numNodes).fill(false);\n  const pq = new PriorityQueue();\n  const startNode = 0;\n\n  pq.enqueue([startNode, 0]);\n\n  let minCost = 0;\n\n  while (!pq.isEmpty()) {\n    const [u, weight] = pq.dequeue();\n\n    if (visited[u]) {\n      continue;\n    }\n\n    visited[u] = true;\n    minCost += weight;\n\n    for (const { node, weight } of graph.adjList.get(u)) {\n      if (!visited[node]) {\n        pq.enqueue([node, weight]);\n      }\n    }\n  }\n  return minCost;\n}\n",h="import java.util.*\n\nclass Edge(val node: Int, val weight: Int)\n\nclass Graph(val numNodes: Int) {\n    val adjList = mutableMapOf<Int, MutableList<Edge>>()\n\n    init {\n        for (i in 0 until numNodes) {\n            adjList[i] = mutableListOf()\n        }\n    }\n\n    fun addEdge(u: Int, v: Int, weight: Int) {\n        adjList[u]?.add(Edge(v, weight))\n        adjList[v]?.add(Edge(u, weight))\n    }\n}\n\nfun primMST(graph: Graph): Int {\n    val visited = BooleanArray(graph.numNodes)\n    val pq = PriorityQueue<Pair<Int, Int>>(compareBy { it.second })\n    val startNode = 0\n\n    pq.offer(Pair(startNode, 0))\n\n    var minCost = 0\n\n    while (pq.isNotEmpty()) {\n        val (u, weight) = pq.poll()\n\n        if (visited[u]) {\n            continue\n        }\n\n        visited[u] = true\n        minCost += weight\n\n        graph.adjList[u]?.forEach { (v, weight) ->\n            if (!visited[v]) {\n                pq.offer(Pair(v, weight))\n            }\n        }\n    }\n    return minCost\n}\n",c="import heapq\n\nclass Graph:\n    def __init__(self, numNodes):\n        self.numNodes = numNodes\n        self.adjList = [[] for _ in range(numNodes)]\n\n    def addEdge(self, u, v, weight):\n        self.adjList[u].append((v, weight))\n        self.adjList[v].append((u, weight))\n\ndef primMST(graph):\n    visited = [False] * graph.numNodes\n    pq = [(0, 0)]\n    minCost = 0\n\n    while pq:\n        weight, u = heapq.heappop(pq)\n\n        if visited[u]:\n            continue\n\n        visited[u] = True\n        minCost += weight\n\n        for v, w in graph.adjList[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v))\n\n    return minCost\n",p="use std::collections::BinaryHeap;\nuse std::cmp::Ordering;\n\n#[derive(Clone, Copy, Eq, PartialEq)]\nstruct Edge {\n    node: usize,\n    weight: usize,\n}\n\nimpl Ord for Edge {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.weight.cmp(&self.weight)\n    }\n}\n\nimpl PartialOrd for Edge {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nstruct Graph {\n    num_nodes: usize,\n    adj_list: Vec<Vec<Edge>>,\n}\n\nimpl Graph {\n    fn new(num_nodes: usize) -> Self {\n        Graph {\n            num_nodes,\n            adj_list: vec![Vec::new(); num_nodes],\n        }\n    }\n\n    fn add_edge(&mut self, u: usize, v: usize, weight: usize) {\n        self.adj_list[u].push(Edge { node: v, weight });\n        self.adj_list[v].push(Edge { node: u, weight });\n    }\n}\n\nfn prim_mst(graph: &Graph) -> usize {\n    let mut visited = vec![false; graph.num_nodes];\n    let mut pq = BinaryHeap::new();\n    let start_node = 0;\n\n    pq.push(Edge { node: start_node, weight: 0 });\n    \n    let mut min_cost = 0;\n\n    while let Some(Edge { node: u, weight }) = pq.pop() {\n        if visited[u] {\n            continue;\n        }\n\n        visited[u] = true;\n        min_cost += weight;\n\n        for &Edge { node: v, weight } in &graph.adj_list[u] {\n            if !visited[v] {\n                pq.push(Edge { node: v, weight });\n            }\n        }\n    }\n    min_cost\n}\n",g="class Edge {\n  constructor(\n    public node: number,\n    public weight: number,\n  ) {}\n}\n\nclass Graph {\n  numNodes: number;\n  adjList: Map<number, Edge[]>;\n\n  constructor(numNodes: number) {\n    this.numNodes = numNodes;\n    this.adjList = new Map<number, Edge[]>();\n    for (let i = 0; i < numNodes; i++) {\n      this.adjList.set(i, []);\n    }\n  }\n\n  addEdge(u: number, v: number, weight: number) {\n    this.adjList.get(u)?.push(new Edge(v, weight));\n    this.adjList.get(v)?.push(new Edge(u, weight));\n  }\n}\n\nfunction primMST(graph: Graph): number {\n  const visited: boolean[] = new Array(graph.numNodes).fill(false);\n  const pq: [number, number][] = [];\n  const startNode = 0;\n\n  pq.push([0, startNode]);\n\n  let minCost = 0;\n\n  while (pq.length > 0) {\n    const [weight, u] = pq.shift()!;\n\n    if (visited[u]) {\n      continue;\n    }\n\n    visited[u] = true;\n\n    minCost += weight;\n\n    for (const edge of graph.adjList.get(u)!) {\n      const { node: v, weight } = edge;\n      if (!visited[v]) {\n        pq.push([weight, v]);\n      }\n    }\n    pq.sort((a, b) => a[0] - b[0]);\n  }\n  return minCost;\n}\n",m={title:"Prim's Algorithm",description:"Prim's Algorithm",hide_table_of_contents:!0},v=void 0,f={id:"education/computer-science/algorithms/algo/prims-algorithm",title:"Prim's Algorithm",description:"Prim's Algorithm",source:"@site/docs/education/01-computer-science/10-algorithms/04-algo/prims-algorithm.mdx",sourceDirName:"education/01-computer-science/10-algorithms/04-algo",slug:"/education/computer-science/algorithms/algo/prims-algorithm",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/prims-algorithm",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/prims-algorithm.mdx",tags:[],version:"current",frontMatter:{title:"Prim's Algorithm",description:"Prim's Algorithm",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Prime Factors",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/prime-factors"},next:{title:"Quicksort",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/quicksort"}},w={},j=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function q(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(a.A,{queryString:"primary",children:[(0,i.jsx)(r.A,{value:"definition",label:"Definition",children:(0,i.jsx)(e.p,{children:"Prim's Algorithm is a greedy algorithm used to find the minimum spanning tree of a connected, undirected graph. It operates by selecting the smallest edge connected to the current minimum spanning tree and adding it to the tree, repeating this process until all vertices are included"})}),(0,i.jsx)(r.A,{value:"how",label:"Explanation",children:(0,i.jsx)(e.p,{children:"Beginning with an arbitrary vertex, the algorithm grows the minimum spanning tree one vertex at a time. At each step, it selects the smallest edge that connects a vertex in the tree to a vertex outside of it, ensuring that the tree remains connected. This process continues until all vertices are included in the tree, resulting in a minimum spanning tree that spans all vertices with the smallest possible total edge weight"})}),(0,i.jsx)(r.A,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Choose an arbitrary starting vertex to begin the minimum spanning tree"}),"\n",(0,i.jsxs)(e.li,{children:["Mark this vertex as visited or add it to the minimum spanning tree","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"find the smallest edge connected to any vertex in the minimum spanning tree that leads to an unvisited vertex"}),"\n",(0,i.jsx)(e.li,{children:"add this edge to the minimum spanning tree"}),"\n",(0,i.jsx)(e.li,{children:"mark the newly reached vertex as visited"}),"\n",(0,i.jsx)(e.li,{children:"repeat steps until all vertices are included in the minimum spanning tree"}),"\n"]}),"\n"]}),"\n"]})}),(0,i.jsx)(r.A,{value:"tips",label:"Tips",children:(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"keep track of visited vertices to avoid cycles and ensure connectivity"}),"\n",(0,i.jsx)(e.li,{children:"utilize a priority queue or heap data structure to efficiently find the smallest edge at each step"}),"\n",(0,i.jsx)(e.li,{children:"ensure that the graph is connected; if not, handle disconnected components separately or consider using a different algorithm"}),"\n"]})})]}),"\n",(0,i.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(a.A,{queryString:"primary",children:[(0,i.jsx)(r.A,{value:"practice",label:"Practice",children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"Prim(Graph, start_vertex):\n    initialize an empty set called MST (minimum spanning tree)\n    initialize a priority queue called pq\n    initialize a boolean array called visited to track visited vertices\n    add start_vertex to pq with priority 0\n    while pq is not empty:\n        vertex = pq.extract_min()\n        if vertex is not visited:\n            add vertex to MST\n            mark vertex as visited\n            for each neighbor of vertex:\n                if neighbor is not visited:\n                    add edge(vertex, neighbor) to pq with priority equal to edge weight\n    return MST\n"})})}),(0,i.jsx)(r.A,{value:"solution",label:"Solution",children:(0,i.jsxs)(a.A,{queryString:"code",children:[(0,i.jsx)(r.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(d.A,{language:"go",children:o})}),(0,i.jsx)(r.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(d.A,{language:"java",children:l})}),(0,i.jsx)(r.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(d.A,{language:"js",children:u})}),(0,i.jsx)(r.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(d.A,{language:"kotlin",children:h})}),(0,i.jsx)(r.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(d.A,{language:"python",children:c})}),(0,i.jsx)(r.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(d.A,{language:"rust",children:p})}),(0,i.jsx)(r.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(d.A,{language:"ts",children:g})})]})})]})]})}function b(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(q,{...n})}):q(n)}}}]);