"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[9085],{71666:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>j,contentTitle:()=>p,default:()=>_,frontMatter:()=>w,metadata:()=>f,toc:()=>x});var i=n(86070),a=n(25710),l=n(98459),r=n(37515),s=n(18792);const c='package main\n\nimport (\n\t"math/rand"\n)\n\ntype WeightedItem struct {\n\tItem   interface{}\n\tWeight int\n}\n\nfunc weightedRandom(items []WeightedItem) interface{} {\n\ttotalWeight := 0\n\tfor _, item := range items {\n\t\ttotalWeight += item.Weight\n\t}\n\n\trandomWeight := rand.Intn(totalWeight)\n\n\tfor _, item := range items {\n\t\tif randomWeight < item.Weight {\n\t\t\treturn item.Item\n\t\t}\n\t\trandomWeight -= item.Weight\n\t}\n\n\treturn nil\n}\n',h="import java.util.*;\n\nclass WeightedItem<T> {\n\n  T item;\n  int weight;\n\n  WeightedItem(T item, int weight) {\n    this.item = item;\n    this.weight = weight;\n  }\n}\n\npublic class WeightedRandom {\n\n  public static <T> T weightedRandom(List<WeightedItem<T>> items) {\n    int totalWeight = items.stream().mapToInt(item -> item.weight).sum();\n    Random random = new Random();\n    int randomWeight = random.nextInt(totalWeight);\n\n    for (WeightedItem<T> item : items) {\n      if (randomWeight < item.weight) {\n        return item.item;\n      }\n      randomWeight -= item.weight;\n    }\n\n    return null;\n  }\n}\n",o="function weightedRandom(items) {\n  const totalWeight = items.reduce((acc, item) => acc + item.weight, 0);\n  let randomWeight = Math.floor(Math.random() * totalWeight);\n\n  for (const item of items) {\n    if (randomWeight < item.weight) {\n      return item.item;\n    }\n    randomWeight -= item.weight;\n  }\n\n  return null;\n}\n",m="import kotlin.random.Random\n\ndata class WeightedItem<T>(val item: T, val weight: Int)\n\nfun <T> weightedRandom(items: List<WeightedItem<T>>): T? {\n    val totalWeight = items.sumBy { it.weight }\n    val randomWeight = Random.nextInt(totalWeight)\n\n    var cumulativeWeight = 0\n    for (item in items) {\n        cumulativeWeight += item.weight\n        if (randomWeight < cumulativeWeight) {\n            return item.item\n        }\n    }\n    return null\n}\n",d="import random\n\nclass WeightedItem:\n    def __init__(self, item, weight):\n        self.item = item\n        self.weight = weight\n\ndef weighted_random(items):\n    total_weight = sum(item.weight for item in items)\n    random_weight = random.randint(0, total_weight - 1)\n\n    cumulative_weight = 0\n    for item in items:\n        cumulative_weight += item.weight\n        if random_weight < cumulative_weight:\n            return item.item\n",g="use rand::Rng;\n\n#[derive(Debug)]\nstruct WeightedItem<T> {\n    item: T,\n    weight: u32,\n}\n\nfn weighted_random<T>(items: &[WeightedItem<T>]) -> Option<&T> {\n    let total_weight: u32 = items.iter().map(|item| item.weight).sum();\n    let mut rng = rand::thread_rng();\n    let random_weight: u32 = rng.gen_range(0..total_weight);\n\n    let mut cumulative_weight = 0;\n    for item in items {\n        cumulative_weight += item.weight;\n        if random_weight < cumulative_weight {\n            return Some(&item.item);\n        }\n    }\n    None\n}\n",u="class WeightedItem<T> {\n  constructor(\n    public item: T,\n    public weight: number,\n  ) {}\n}\n\nfunction weightedRandom<T>(items: WeightedItem<T>[]): T | null {\n  const totalWeight = items.reduce((acc, item) => acc + item.weight, 0);\n  const randomWeight = Math.floor(Math.random() * totalWeight);\n\n  let cumulativeWeight = 0;\n  for (const item of items) {\n    cumulativeWeight += item.weight;\n    if (randomWeight < cumulativeWeight) {\n      return item.item;\n    }\n  }\n\n  return null;\n}\n",w={title:"Weighted Random",description:"Weighted Random",hide_table_of_contents:!0},p=void 0,f={id:"education/computer-science/algorithms/algo/weighted-random",title:"Weighted Random",description:"Weighted Random",source:"@site/docs/education/01-computer-science/10-algorithms/04-algo/weighted-random.mdx",sourceDirName:"education/01-computer-science/10-algorithms/04-algo",slug:"/education/computer-science/algorithms/algo/weighted-random",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/weighted-random",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/weighted-random.mdx",tags:[],version:"current",frontMatter:{title:"Weighted Random",description:"Weighted Random",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Unique Paths",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/unique-paths"},next:{title:"Z Algorithm",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/z-algorithm"}},j={},x=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function v(e){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(l.A,{queryString:"primary",children:[(0,i.jsx)(r.A,{value:"definition",label:"Definition",children:(0,i.jsx)(t.p,{children:"The Weighted Random Algorithm is a method used to select elements randomly from a collection, with each element having a weighted probability of being chosen. This algorithm is commonly employed in scenarios where certain elements are more likely to be selected than others based on their assigned weights"})}),(0,i.jsxs)(r.A,{value:"how",label:"Explanation",children:[(0,i.jsx)(t.p,{children:"It operates in 3 main phases:"}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"preprocessing"}),"\n",(0,i.jsx)(t.li,{children:"selection"}),"\n",(0,i.jsx)(t.li,{children:"updating cumulative weights (optionally)"}),"\n"]}),(0,i.jsx)(t.p,{children:"During preprocessing, cumulative weights for each element are computed by summing up the weights of all preceding elements in the collection. In the selection phase, a random number within the range of total weight sums is generated, and the algorithm iterates through the collection to find the first element whose cumulative weight surpasses this generated number, which is then returned as the selected element. Optionally, if the weights of elements dynamically change, the algorithm can update cumulative weights to reflect these changes"})]}),(0,i.jsx)(r.A,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Preprocessing","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"start with an empty cumulative weight variable"}),"\n",(0,i.jsx)(t.li,{children:"traverse the collection"}),"\n",(0,i.jsx)(t.li,{children:"for each element, add its weight to the cumulative weight"}),"\n",(0,i.jsx)(t.li,{children:"store cumulative weight for each element"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Selection","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"generate a random number between 0 and the total sum of weights"}),"\n",(0,i.jsx)(t.li,{children:"initialize a variable to store the cumulative weight"}),"\n",(0,i.jsx)(t.li,{children:"traverse the collection"}),"\n",(0,i.jsx)(t.li,{children:"for each element, check if the cumulative weight exceeds the generated random number"}),"\n",(0,i.jsx)(t.li,{children:"if found, return the element"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Updating cumulative weights (Optional)","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"whenever weights change"}),"\n",(0,i.jsx)(t.li,{children:"recalculate cumulative weights following the preprocessing steps"}),"\n"]}),"\n"]}),"\n"]})}),(0,i.jsx)(r.A,{value:"tips",label:"Tips",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"ensure that the weights of items accurately reflect their importance or priority"}),"\n",(0,i.jsx)(t.li,{children:"consider using an efficient data structure to store the items and their weights, such as a dictionary or a tuple"}),"\n"]})})]}),"\n",(0,i.jsx)(t.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(l.A,{queryString:"primary",children:[(0,i.jsx)(r.A,{value:"practice",label:"Practice",children:(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"weighted_random(collection):\n  cum_weights = calculate_cumulative_weights(collection)\n  random_num = generate_random_number(0, total_sum(cum_weights))\n  return select_element(collection, cum_weights, random_num)\n\ncalculate_cumulative_weights(collection):\n  cum_weights = []\n  cum_weight = 0\n  for each element in collection:\n    cum_weight += element.weight\n    cum_weights.append(cum_weight)\n  return cum_weights\n\nselect_element(collection, cum_weights, random_num):\n  for i from 0 to length(collection) - 1:\n    if random_num < cum_weights[i]:\n      return collection[i]\n"})})}),(0,i.jsx)(r.A,{value:"solution",label:"Solution",children:(0,i.jsxs)(l.A,{queryString:"code",children:[(0,i.jsx)(r.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(s.A,{language:"go",children:c})}),(0,i.jsx)(r.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(s.A,{language:"java",children:h})}),(0,i.jsx)(r.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(s.A,{language:"js",children:o})}),(0,i.jsx)(r.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(s.A,{language:"kotlin",children:m})}),(0,i.jsx)(r.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(s.A,{language:"python",children:d})}),(0,i.jsx)(r.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(s.A,{language:"rust",children:g})}),(0,i.jsx)(r.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(s.A,{language:"ts",children:u})})]})})]})]})}function _(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(v,{...e})}):v(e)}}}]);