"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[7057],{89208:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>b,contentTitle:()=>f,default:()=>y,frontMatter:()=>v,metadata:()=>i,toc:()=>j});const i=JSON.parse('{"id":"education/computer-science/algorithms/algo/travelling-salesman-problem","title":"Travelling Salesman Problem","description":"Travelling Salesman Problem","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/travelling-salesman-problem.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/travelling-salesman-problem","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/travelling-salesman-problem","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/travelling-salesman-problem.mdx","tags":[],"version":"current","frontMatter":{"title":"Travelling Salesman Problem","description":"Travelling Salesman Problem","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Tower of Hanoi","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/tower-of-hanoi"},"next":{"title":"Unique Paths","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/unique-paths"}}');var r=t(86070),a=t(15658),s=t(33407),c=t(33903),l=t(68171);const o='package main\n\nimport (\n    "math"\n)\n\nfunc tsp(graph [][]int, visited []bool, current, n, count, cost, ans int) int {\n    if count == n && graph[current][0] > 0 {\n        ans = int(math.Min(float64(ans), float64(cost+graph[current][0])))\n        return ans\n    }\n\n    for i := 0; i < n; i++ {\n        if !visited[i] && graph[current][i] > 0 {\n            visited[i] = true\n            ans = tsp(graph, visited, i, n, count+1, cost+graph[current][i], ans)\n            visited[i] = false\n        }\n    }\n    return ans\n}\n',u="import java.util.Arrays;\n\npublic class TSP {\n\n  static int tsp(int[][] graph, boolean[] visited, int current, int n, int count, int cost, int ans) {\n    if (count == n && graph[current][0] > 0) {\n      ans = Math.min(ans, cost + graph[current][0]);\n      return ans;\n    }\n\n    for (int i = 0; i < n; i++) {\n      if (!visited[i] && graph[current][i] > 0) {\n        visited[i] = true;\n        ans = tsp(graph, visited, i, n, count + 1, cost + graph[current][i], ans);\n        visited[i] = false;\n      }\n    }\n    return ans;\n  }\n}\n",h="function tsp(graph, visited, current, n, count, cost, ans) {\n  if (count === n && graph[current][0] > 0) {\n    ans = Math.min(ans, cost + graph[current][0]);\n    return ans;\n  }\n\n  for (let i = 0; i < n; i++) {\n    if (!visited[i] && graph[current][i] > 0) {\n      visited[i] = true;\n      ans = tsp(graph, visited, i, n, count + 1, cost + graph[current][i], ans);\n      visited[i] = false;\n    }\n  }\n  return ans;\n}\n",d="fun tsp(graph: Array<IntArray>, visited: BooleanArray, current: Int, n: Int, count: Int, cost: Int, ans: Int): Int {\n    if (count == n && graph[current][0] > 0) {\n        return minOf(ans, cost + graph[current][0])\n    }\n\n    var newAns = ans\n    for (i in 0 until n) {\n        if (!visited[i] && graph[current][i] > 0) {\n            visited[i] = true\n            newAns = tsp(graph, visited, i, n, count + 1, cost + graph[current][i], newAns)\n            visited[i] = false\n        }\n    }\n    return newAns\n}\n",p="def tsp(graph, visited, current, n, count, cost, ans):\n    if count == n and graph[current][0] > 0:\n        return min(ans, cost + graph[current][0])\n\n    for i in range(n):\n        if not visited[i] and graph[current][i] > 0:\n            visited[i] = True\n            ans = tsp(graph, visited, i, n, count + 1, cost + graph[current][i], ans)\n            visited[i] = False\n    return ans\n",g="use std::cmp;\n\nfn tsp(graph: &Vec<Vec<i32>>, visited: &mut Vec<bool>, current: usize, n: usize, count: usize, cost: i32, ans: i32) -> i32 {\n    if count == n && graph[current][0] > 0 {\n        return cmp::min(ans, cost + graph[current][0]);\n    }\n\n    let mut new_ans = ans;\n    for i in 0..n {\n        if !visited[i] && graph[current][i] > 0 {\n            visited[i] = true;\n            new_ans = tsp(graph, visited, i, n, count + 1, cost + graph[current][i], new_ans);\n            visited[i] = false;\n        }\n    }\n    new_ans\n}\n",m="function tsp(\n  graph: number[][],\n  visited: boolean[],\n  current: number,\n  n: number,\n  count: number,\n  cost: number,\n  ans: number,\n): number {\n  if (count === n && graph[current][0] > 0) {\n    return Math.min(ans, cost + graph[current][0]);\n  }\n\n  let newAns = ans;\n  for (let i = 0; i < n; i++) {\n    if (!visited[i] && graph[current][i] > 0) {\n      visited[i] = true;\n      newAns = tsp(\n        graph,\n        visited,\n        i,\n        n,\n        count + 1,\n        cost + graph[current][i],\n        newAns,\n      );\n      visited[i] = false;\n    }\n  }\n  return newAns;\n}\n",v={title:"Travelling Salesman Problem",description:"Travelling Salesman Problem",hide_table_of_contents:!0},f=void 0,b={},j=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function x(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(s.A,{queryString:"primary",children:[(0,r.jsx)(c.A,{value:"definition",label:"Definition",children:(0,r.jsx)(e.p,{children:"The Travelling Salesman Problem (TSP) is a classic problem in computer science and operations research where the objective is to find the shortest possible route that visits a given set of cities and returns to the original city. It's an NP-hard problem, meaning there is no known polynomial-time solution for large inputs. However, there are several approaches and algorithms to approximate the solution"})}),(0,r.jsx)(c.A,{value:"how",label:"Explanation",children:(0,r.jsx)(e.p,{children:"Works by exhaustively evaluating all possible routes or by using heuristics to find an approximate solution. One common approach is the brute-force method, where all possible permutations of city visits are generated and the shortest route is selected. Another popular approach is the nearest neighbor algorithm, where the salesman starts at a random city and repeatedly visits the nearest unvisited city until all cities are visited"})}),(0,r.jsx)(c.A,{value:"guidance",label:"Guidance",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Start at any city","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"choose the nearest unvisited city to the current city"}),"\n",(0,r.jsx)(e.li,{children:"add the selected city to the route"}),"\n",(0,r.jsx)(e.li,{children:"repeat steps until all cities are visited"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.li,{children:"Once all cities are visited, return to the starting city to complete the route"}),"\n"]})}),(0,r.jsx)(c.A,{value:"tips",label:"Tips",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"implementing memoization techniques can significantly improve the performance of the brute-force approach by avoiding redundant calculations"}),"\n",(0,r.jsx)(e.li,{children:"using dynamic programming, particularly in cases where subproblems overlap, can help optimize the solution"}),"\n",(0,r.jsx)(e.li,{children:"experiment with different heuristics, such as the nearest insertion or farthest insertion algorithms, to find a good balance between accuracy and efficiency"}),"\n"]})})]}),"\n",(0,r.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(s.A,{queryString:"primary",children:[(0,r.jsx)(c.A,{value:"practice",label:"Practice",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"tsp_brute_force(graph, current_city, visited_cities):\n  if all cities visited:\n    return distance from current_city to starting_city\n  else:\n    min_distance = INFINITY\n    for each city in graph:\n      if city not in visited_cities:\n        distance = tsp_brute_force(graph, city, visited_cities + [city])\n        min_distance = min(min_distance, distance + distance from current_city to city)\n    return min_distance\n"})})}),(0,r.jsx)(c.A,{value:"solution",label:"Solution",children:(0,r.jsxs)(s.A,{queryString:"code",children:[(0,r.jsx)(c.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(l.A,{language:"go",children:o})}),(0,r.jsx)(c.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(l.A,{language:"java",children:u})}),(0,r.jsx)(c.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(l.A,{language:"js",children:h})}),(0,r.jsx)(c.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(l.A,{language:"kotlin",children:d})}),(0,r.jsx)(c.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(l.A,{language:"python",children:p})}),(0,r.jsx)(c.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(l.A,{language:"rust",children:g})}),(0,r.jsx)(c.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(l.A,{language:"ts",children:m})})]})})]})]})}function y(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(x,{...n})}):x(n)}}}]);