"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[4078],{38514:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>g,contentTitle:()=>y,default:()=>I,frontMatter:()=>m,metadata:()=>t,toc:()=>_});const t=JSON.parse('{"id":"education/computer-science/data-structures/basic/priority-queue","title":"Priority Queue","description":"Priority Queue Data Structure","source":"@site/docs/education/01-computer-science/09-data-structures/02-basic/08-priority-queue.mdx","sourceDirName":"education/01-computer-science/09-data-structures/02-basic","slug":"/education/computer-science/data-structures/basic/priority-queue","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/priority-queue","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/08-priority-queue.mdx","tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"title":"Priority Queue","description":"Priority Queue Data Structure","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Heap","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/heap"},"next":{"title":"Trie","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/trie"}}');var r=i(86070),a=i(15658),s=i(33407),l=i(33903),d=i(68171);const h='package main\n\nimport "container/heap"\n\ntype Item struct {\n\tValue    interface{}\n\tPriority int\n}\n\ntype PriorityQueue []*Item\n\nfunc (pq PriorityQueue) Len() int {\n\treturn len(pq)\n}\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n\treturn pq[i].Priority < pq[j].Priority\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n\titem := x.(*Item)\n\t*pq = append(*pq, item)\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\titem := old[n-1]\n\t*pq = old[0 : n-1]\n\treturn item\n}\n\nfunc NewPriorityQueue() *PriorityQueue {\n\tpq := make(PriorityQueue, 0)\n\theap.Init(&pq)\n\treturn &pq\n}\n\nfunc (pq *PriorityQueue) Enqueue(value interface{}, priority int) {\n\theap.Push(pq, &Item{Value: value, Priority: priority})\n}\n\nfunc (pq *PriorityQueue) Dequeue() interface{} {\n\tif pq.Len() == 0 {\n\t\treturn nil\n\t}\n\treturn heap.Pop(pq).(*Item).Value\n}\n\nfunc (pq *PriorityQueue) Peek() interface{} {\n\tif pq.Len() == 0 {\n\t\treturn nil\n\t}\n\treturn (pq[0]).Value\n}\n\nfunc (pq *PriorityQueue) ChangePriority(value interface{}, newPriority int) {\n\tfor i := 0; i < pq.Len(); i++ {\n\t\tif pq[i].Value == value {\n\t\t\tpq[i].Priority = newPriority\n\t\t\theap.Fix(pq, i)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (pq *PriorityQueue) FindByValue(value interface{}) interface{} {\n\tfor i := 0; i < pq.Len(); i++ {\n\t\tif pq[i].Value == value {\n\t\t\treturn pq[i].Value\n\t\t}\n\t}\n\treturn nil\n}\n',p="import java.util.*;\n\nclass PriorityQueue<T> {\n\n  private List<Pair<T, Integer>> heap = new ArrayList<>();\n\n  public void enqueue(T item, int priority) {\n    heap.add(new Pair<>(item, priority));\n    heapifyUp();\n  }\n\n  public T dequeue() {\n    if (heap.isEmpty()) {\n      return null;\n    }\n    T highestPriorityItem = heap.get(0).getKey();\n    heap.set(0, heap.get(heap.size() - 1));\n    heap.remove(heap.size() - 1);\n    heapifyDown();\n    return highestPriorityItem;\n  }\n\n  public T peek() {\n    if (heap.isEmpty()) {\n      return null;\n    }\n    return heap.get(0).getKey();\n  }\n\n  public void changePriority(T item, int newPriority) {\n    int index = findIndexByItem(item);\n    if (index != -1) {\n      heap.set(index, new Pair<>(item, newPriority));\n      heapifyUp(index);\n    }\n  }\n\n  public T findByValue(T item) {\n    int index = findIndexByItem(item);\n    if (index != -1) {\n      return heap.get(index).getKey();\n    }\n    return null;\n  }\n\n  private void heapifyUp(int index) {\n    if (index == 0) {\n      return;\n    }\n    int parentIndex = (index - 1) / 2;\n    if (heap.get(parentIndex).getValue() < heap.get(index).getValue()) {\n      swap(heap, parentIndex, index);\n      heapifyUp(parentIndex);\n    }\n  }\n\n  private void heapifyDown() {\n    int index = 0;\n    while (index < heap.size()) {\n      int leftChildIndex = 2 * index + 1;\n      int rightChildIndex = 2 * index + 2;\n      int smallestIndex = findSmallestIndex(leftChildIndex, rightChildIndex);\n      if (smallestIndex == -1) {\n        break;\n      }\n      swap(heap, index, smallestIndex);\n      index = smallestIndex;\n    }\n  }\n\n  private void swap(List<Pair<T, Integer>> list, int i, int j) {\n    Pair<T, Integer> temp = list.get(i);\n    list.set(i, list.get(j));\n    list.set(j, temp);\n  }\n\n  private int findIndexByItem(T item) {\n    for (int i = 0; i < heap.size(); i++) {\n      if (heap.get(i).getKey().equals(item)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  private int findSmallestIndex(int leftChildIndex, int rightChildIndex) {\n    if (leftChildIndex >= heap.size()) {\n      return -1;\n    }\n    if (rightChildIndex >= heap.size()) {\n      return leftChildIndex;\n    }\n    int leftPriority = heap.get(leftChildIndex).getValue();\n    int rightPriority = heap.get(rightChildIndex).getValue();\n    return leftPriority < rightPriority ? leftChildIndex : rightChildIndex;\n  }\n}\n",u="class PriorityQueue {\n  constructor() {\n    this.heap = [];\n  }\n\n  enqueue(item, priority) {\n    this.heap.push([item, priority]);\n    this.heapifyUp();\n  }\n\n  dequeue() {\n    if (this.heap.length === 0) {\n      return null;\n    }\n    const highestPriorityItem = this.heap[0][0];\n    this.heap[0] = this.heap[this.heap.length - 1];\n    this.heap.pop();\n    this.heapifyDown();\n    return highestPriorityItem;\n  }\n\n  peek() {\n    if (this.heap.length === 0) {\n      return null;\n    }\n    return this.heap[0][0];\n  }\n\n  changePriority(item, newPriority) {\n    const index = this.findIndexByItem(item);\n    if (index !== -1) {\n      this.heap[index][1] = newPriority;\n      this.heapifyUp(index);\n    }\n  }\n\n  findByValue(item) {\n    const index = this.findIndexByItem(item);\n    if (index !== -1) {\n      return this.heap[index][0];\n    }\n    return null;\n  }\n\n  heapifyUp(index = this.heap.length - 1) {\n    if (index === 0) {\n      return;\n    }\n    const parentIndex = Math.floor((index - 1) / 2);\n    if (this.heap[parentIndex][1] < this.heap[index][1]) {\n      this.swap(this.heap, parentIndex, index);\n      this.heapifyUp(parentIndex);\n    }\n  }\n\n  heapifyDown() {\n    let index = 0;\n    while (index < this.heap.length) {\n      const leftChildIndex = 2 * index + 1;\n      const rightChildIndex = 2 * index + 2;\n      const smallestIndex = this.findSmallestIndex(\n        leftChildIndex,\n        rightChildIndex,\n      );\n      if (smallestIndex === -1) {\n        break;\n      }\n      this.swap(this.heap, index, smallestIndex);\n      index = smallestIndex;\n    }\n  }\n\n  swap(list, i, j) {\n    const temp = list[i];\n    list[i] = list[j];\n    list[j] = temp;\n  }\n\n  findIndexByItem(item) {\n    for (let i = 0; i < this.heap.length; i++) {\n      if (this.heap[i][0] === item) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  findSmallestIndex(leftChildIndex, rightChildIndex) {\n    if (leftChildIndex >= this.heap.length) {\n      return -1;\n    }\n    if (rightChildIndex >= this.heap.length) {\n      return leftChildIndex;\n    }\n    const leftPriority = this.heap[leftChildIndex][1];\n    const rightPriority = this.heap[rightChildIndex][1];\n    return leftPriority < rightPriority ? leftChildIndex : rightChildIndex;\n  }\n}\n",o="class PriorityQueue<T> {\n    private val heap: MutableList<Pair<T, Int>> = mutableListOf()\n\n    fun enqueue(item: T, priority: Int) {\n        heap.add(Pair(item, priority))\n        heapifyUp()\n    }\n\n    fun dequeue(): T? {\n        if (heap.isEmpty()) {\n            return null\n        }\n        val highestPriorityItem = heap[0].first\n        heap[0] = heap.last()\n        heap.removeAt(heap.lastIndex)\n        heapifyDown()\n        return highestPriorityItem\n    }\n\n    fun peek(): T? {\n        return if (heap.isEmpty()) {\n            null\n        } else {\n            heap[0].first\n        }\n    }\n\n    fun changePriority(item: T, newPriority: Int) {\n        val index = heap.indexOfFirst { it.first == item }\n        if (index != -1) {\n            heap[index] = Pair(item, newPriority)\n            heapifyUp(index)\n        }\n    }\n\n    fun findByValue(item: T): T? {\n        val index = heap.indexOfFirst { it.first == item }\n        return if (index != -1) {\n            heap[index].first\n        } else {\n            null\n        }\n    }\n\n    private fun heapifyUp(index: Int = heap.lastIndex) {\n        if (index == 0) {\n            return\n        }\n        val parentIndex = (index - 1) / 2\n        if (heap[parentIndex].second < heap[index].second) {\n            swap(heap, parentIndex, index)\n            heapifyUp(parentIndex)\n        }\n    }\n\n    private fun heapifyDown() {\n        var index = 0\n        while (index < heap.size) {\n            val leftChildIndex = 2 * index + 1\n            val rightChildIndex = 2 * index + 2\n            val smallestIndex = when {\n                leftChildIndex < heap.size && heap[leftChildIndex].second < heap[index].second -> leftChildIndex\n                rightChildIndex < heap.size && heap[rightChildIndex].second < heap[index].second -> rightChildIndex\n                else -> break\n            }\n            swap(heap, index, smallestIndex)\n            index = smallestIndex\n        }\n    }\n\n    private fun swap(list: MutableList<Pair<T, Int>>, i: Int, j: Int) {\n        val temp = list[i]\n        list[i] = list[j]\n        list[j] = temp\n    }\n}\n",x="class PriorityQueue:\n    def __init__(self):\n        self.heap = []\n\n    def enqueue(self, item, priority):\n        self.heap.append((priority, item))\n        self._heapify_up()\n\n    def dequeue(self):\n        if not self.heap:\n            return None\n        highest_priority_item = self.heap[0][1]\n        self.heap[0] = self.heap[-1]\n        self.heap.pop()\n        self._heapify_down()\n        return highest_priority_item\n\n    def peek(self):\n        if not self.heap:\n            return None\n        return self.heap[0][1]\n\n    def change_priority(self, item, new_priority):\n        for i, (priority, value) in enumerate(self.heap):\n            if value == item:\n                self.heap[i] = (new_priority, item)\n                self._heapify_up(i)\n                break\n\n    def find_by_value(self, item):\n        for priority, value in self.heap:\n            if value == item:\n                return value\n        return None\n\n    def _heapify_up(self, index=None):\n        if index is None:\n            index = len(self.heap) - 1\n        if index == 0:\n            return\n        parent_index = (index - 1) // 2\n        if self.heap[parent_index][0] < self.heap[index][0]:\n            self.heap[parent_index], self.heap[index] = self.heap[index], self.heap[parent_index]\n            self._heapify_up(parent_index)\n\n    def _heapify_down(self):\n        index = 0\n        while index < len(self.heap):\n            left_child_index = 2 * index + 1\n            right_child_index = 2 * index + 2\n            smallest_index = index\n            if left_child_index < len(self.heap) and self.heap[left_child_index][0] < self.heap[smallest_index][0]:\n                smallest_index = left_child_index\n            if right_child_index < len(self.heap) and self.heap[right_child_index][0] < self.heap[smallest_index][0]:\n                smallest_index = right_child_index\n            if smallest_index == index:\n                break\n            self.heap[index], self.heap[smallest_index] = self.heap[smallest_index], self.heap[index]\n            index = smallest_index\n",c="use std::cmp::Ordering;\n\nstruct PriorityQueue<T> {\n    heap: Vec<(T, i32)>,\n}\n\nimpl<T> PriorityQueue<T> {\n    fn new() -> Self {\n        PriorityQueue { heap: Vec::new() }\n    }\n\n    fn enqueue(&mut self, item: T, priority: i32) {\n        self.heap.push((item, priority));\n        self.heapify_up();\n    }\n\n    fn dequeue(&mut self) -> Option<T> {\n        if self.heap.is_empty() {\n            return None;\n        }\n        let highest_priority_item = self.heap.swap_remove(0).0;\n        self.heapify_down();\n        Some(highest_priority_item)\n    }\n\n    fn peek(&self) -> Option<&T> {\n        self.heap.get(0).map(|(item, _)| item)\n    }\n\n    fn change_priority(&mut self, item: T, new_priority: i32) {\n        if let Some(index) = self.heap.iter().position(|(existing_item, _)| existing_item == &item) {\n            self.heap[index] = (item, new_priority);\n            self.heapify_up(index);\n        }\n    }\n\n    fn find_by_value(&self, item: &T) -> Option<&T> {\n        self.heap.iter().find_map(|(existing_item, _)| {\n            if existing_item == item {\n                Some(existing_item)\n            } else {\n                None\n            }\n        })\n    }\n\n    fn heapify_up(&mut self, mut index: usize) {\n        while index > 0 {\n            let parent_index = (index - 1) / 2;\n            if self.heap[parent_index].1 < self.heap[index].1 {\n                self.heap.swap(parent_index, index);\n                index = parent_index;\n            } else {\n                break;\n            }\n        }\n    }\n\n    fn heapify_down(&mut self) {\n        let mut index = 0;\n        while let Some(left_child_index) = 2 * index + 1 < self.heap.len().then(|| 2 * index + 1) {\n            let right_child_index = 2 * index + 2;\n            let smallest_index = match right_child_index < self.heap.len().then(|| right_child_index) {\n                Some(right_index) if self.heap[right_index].1 > self.heap[left_child_index].1 => right_index,\n                _ => left_child_index,\n            };\n            if self.heap[smallest_index].1 > self.heap[index].1 {\n                self.heap.swap(index, smallest_index);\n                index = smallest_index;\n            } else {\n                break;\n            }\n        }\n    }\n}\n",f="class PriorityQueue<T> {\n  private heap: Array<[T, number]> = [];\n\n  enqueue(item: T, priority: number): void {\n    this.heap.push([item, priority]);\n    this.heapifyUp();\n  }\n\n  dequeue(): T | null {\n    if (this.heap.length === 0) {\n      return null;\n    }\n    const highestPriorityItem: T = this.heap[0][0];\n    this.heap[0] = this.heap.pop()!;\n    this.heapifyDown();\n    return highestPriorityItem;\n  }\n\n  peek(): T | null {\n    return this.heap.length === 0 ? null : this.heap[0][0];\n  }\n\n  changePriority(item: T, newPriority: number): void {\n    const index = this.heap.findIndex(\n      ([existingItem, _]) => existingItem === item,\n    );\n    if (index !== -1) {\n      this.heap[index] = [item, newPriority];\n      this.heapifyUp(index);\n    }\n  }\n\n  findByValue(item: T): T | null {\n    const index = this.heap.findIndex(\n      ([existingItem, _]) => existingItem === item,\n    );\n    return index !== -1 ? this.heap[index][0] : null;\n  }\n\n  private heapifyUp(index: number = this.heap.length - 1): void {\n    if (index === 0) {\n      return;\n    }\n    const parentIndex = Math.floor((index - 1) / 2);\n    if (this.heap[parentIndex][1] < this.heap[index][1]) {\n      this.swap(parentIndex, index);\n      this.heapifyUp(parentIndex);\n    }\n  }\n\n  private heapifyDown(): void {\n    let index = 0;\n    while (index < this.heap.length) {\n      const leftChildIndex = 2 * index + 1;\n      const rightChildIndex = 2 * index + 2;\n      const smallestIndex =\n        leftChildIndex < this.heap.length &&\n        this.heap[leftChildIndex][1] < this.heap[index][1]\n          ? leftChildIndex\n          : rightChildIndex < this.heap.length &&\n              this.heap[rightChildIndex][1] < this.heap[index][1]\n            ? rightChildIndex\n            : -1;\n\n      if (smallestIndex !== -1) {\n        this.swap(index, smallestIndex);\n        index = smallestIndex;\n      } else {\n        break;\n      }\n    }\n  }\n\n  private swap(i: number, j: number): void {\n    const temp = this.heap[i];\n    this.heap[i] = this.heap[j];\n    this.heap[j] = temp;\n  }\n}\n",m={title:"Priority Queue",description:"Priority Queue Data Structure",hide_table_of_contents:!0},y=void 0,g={},_=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function j(e){const n={code:"code",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:i(71256).A+""})}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsxs)("thead",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Space"}),(0,r.jsx)("th",{colspan:"6",children:"Time"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{}),(0,r.jsx)("th",{children:"Access"}),(0,r.jsx)("th",{children:"Lookup"}),(0,r.jsx)("th",{children:"Insertion"}),(0,r.jsx)("th",{children:"Deletion"})]})]}),(0,r.jsx)("tbody",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"fair",children:"O(n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"fair",children:"O(n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"fair",children:"O(n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"excellent",children:"O(1)"})})]})})]}),"\n",(0,r.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(s.A,{queryString:"primary",children:[(0,r.jsxs)(l.A,{value:"short",label:"Short",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Priority Queue"})," is a data structure that allows elements to be inserted and removed based on their priority."]}),(0,r.jsxs)(t,{children:[(0,r.jsx)("summary",{children:"Simplified"}),(0,r.jsx)(n.p,{children:"You're planning your day with a list of tasks: grocery shopping, work meeting, gym, cooking dinner, and reading a book. However, not all tasks are equally important. Some tasks are urgent and need\nto be done first, while others can wait."}),(0,r.jsx)(n.p,{children:'In this scenario, a "Priority Queue" is like a smart to-do list. It helps you manage your tasks based on their importance or urgency. The task with the highest priority (like a work meeting) gets\nto be at the front of the queue, meaning it should be done first. Once that task is completed, it\'s removed from the queue, and the next highest priority task (like grocery shopping) moves to the\nfront.'})]})]}),(0,r.jsxs)(l.A,{value:"detailed",label:"Detailed",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Priority Queue"}),' is a specialized data structure. It functions like a regular queue or stack, but each element also has an associated "priority". Elements with higher priority are processed\nbefore those with lower priority. If elements share the same priority, they\'re handled in their queue order.']}),(0,r.jsx)(n.p,{children:"Priority queues and heaps are often mentioned together, but they're not the same. A priority queue is an abstract concept, like a list or a map, and can be implemented in various ways, including\nusing a heap or an unordered array."})]})]}),"\n",(0,r.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(s.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"practice",label:"Practice",children:(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Aspect"}),(0,r.jsx)("th",{children:"Pseudo Code"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Heapify Up"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"heapify_up(index):\n  if index == 0:\n    return\n  parent_index = (index - 1) / 2\n  if heap[parent_index].value < heap[index].value:\n    swap(heap, parent_index, index)\n  heapify_up(parent_index)\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Heapify Down"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"heapify_down():\n  index = 0\n  while index < heap.size:\n    left_child_index=2 * index + 1\n    right_child_index = 2 * index + 2\n    smallest_index = -1\n    if heap.size > left_child_index and heap[left_child_index].value < heap[index].value:\n      smallest_index = left_child_index\n    else if heap.size > right_child_index and heap[right_child_index].value < heap[index].value:\n      smallest_index = right_child_index\n    else:\n      break\n    swap(heap, index, smallest_index)\n    index = smallest_index\n\n  method swap(list, i, j):\n    temp = list[i]\n    list[i] = list[j]\n    list[j] = temp\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Enqueue"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"enqueue(item, priority):\n  heap.add(Pair(item, priority))\n  heapify_up(heap.last_index)\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Dequeue"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"dequeue():\n  if heap == \xf8:\n    return \xf8\n  highest_priority_item = heap[0].key\n  heap[0] = heap.last()\n  heap.remove_at(heap.last_index)\n  heapify_down()\n  return highest_priority_item\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Peek"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"peek():\n  if heap == \xf8:\n    return \xf8\n  else:\n    return heap[0].key\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Change Priority"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"change_priority(item, new_priority):\n  index = heap.find_index(item)\n  if index != -1:\n    heap[index] = Pair(item, new_priority)\n    heapify_up(index)\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Find by Value"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"find_by_value(item: T): T?:\n  index = heap.find_index(item)\n  if index != -1:\n    return heap[index].key\n  else:\n    return \xf8\n"})})})]})]})]})}),(0,r.jsx)(l.A,{value:"solution",label:"Solution",children:(0,r.jsxs)(s.A,{queryString:"code",children:[(0,r.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(d.A,{language:"go",children:h})}),(0,r.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(d.A,{language:"java",children:p})}),(0,r.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(d.A,{language:"js",children:u})}),(0,r.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(d.A,{language:"kotlin",children:o})}),(0,r.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(d.A,{language:"python",children:x})}),(0,r.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(d.A,{language:"rust",children:c})}),(0,r.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(d.A,{language:"ts",children:f})})]})})]})]})}function I(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(j,{...e})}):j(e)}},71256:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/priorityQueue-9c5e1662d2046d2b29c5f0aefbbfdab8.svg"}}]);