"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[8127],{13769:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>N,contentTitle:()=>C,default:()=>R,frontMatter:()=>p,metadata:()=>g,toc:()=>b});var t=r(11527),l=r(88672),o=r(29140),c=r(52360),i=r(52296);const d='package main\n\ntype Color string\n\nconst (\n\tRED   Color = "RED"\n\tBLACK Color = "BLACK"\n)\n\ntype Node struct {\n\tKey        int\n\tColor      Color\n\tLeftChild  *Node\n\tRightChild *Node\n\tParent     *Node\n}\n\ntype RedBlackTree struct {\n\tRoot *Node\n}\n\nfunc NewNode(key int, color Color, left, right, parent *Node) *Node {\n\treturn &Node{\n\t\tKey:        key,\n\t\tColor:      color,\n\t\tLeftChild:  left,\n\t\tRightChild: right,\n\t\tParent:     parent,\n\t}\n}\n\nfunc NewRedBlackTree() *RedBlackTree {\n\treturn &RedBlackTree{}\n}\n\nfunc (tree *RedBlackTree) InsertRBTree(key int) {\n\tnewNode := NewNode(key, RED, nil, nil, nil)\n\tvar uncle *Node\n\tcurrentNode := tree.Root\n\n\tfor currentNode != nil {\n\t\tuncle = currentNode\n\t\tif newNode.Key < currentNode.Key {\n\t\t\tcurrentNode = currentNode.LeftChild\n\t\t} else {\n\t\t\tcurrentNode = currentNode.RightChild\n\t\t}\n\t}\n\n\tnewNode.Parent = uncle\n\tif uncle == nil {\n\t\ttree.Root = newNode\n\t} else if newNode.Key < uncle.Key {\n\t\tuncle.LeftChild = newNode\n\t} else {\n\t\tuncle.RightChild = newNode\n\t}\n\n\ttree.insertFixup(newNode)\n\ttree.Root.Color = BLACK\n}\n\nfunc (tree *RedBlackTree) leftRotate(currentNode *Node) {\n\tuncle := currentNode.RightChild\n\tcurrentNode.RightChild = uncle.LeftChild\n\tif uncle.LeftChild != nil {\n\t\tuncle.LeftChild.Parent = currentNode\n\t}\n\tuncle.Parent = currentNode.Parent\n\n\tif currentNode.Parent == nil {\n\t\ttree.Root = uncle\n\t} else if currentNode == currentNode.Parent.LeftChild {\n\t\tcurrentNode.Parent.LeftChild = uncle\n\t} else {\n\t\tcurrentNode.Parent.RightChild = uncle\n\t}\n\n\tuncle.LeftChild = currentNode\n\tcurrentNode.Parent = uncle\n}\n\nfunc (tree *RedBlackTree) rightRotate(uncle *Node) {\n\tcurrentNode := uncle.LeftChild\n\tuncle.LeftChild = currentNode.RightChild\n\tif currentNode.RightChild != nil {\n\t\tcurrentNode.RightChild.Parent = uncle\n\t}\n\tcurrentNode.Parent = uncle.Parent\n\n\tif uncle.Parent == nil {\n\t\ttree.Root = currentNode\n\t} else if uncle == uncle.Parent.LeftChild {\n\t\tuncle.Parent.LeftChild = currentNode\n\t} else {\n\t\tuncle.Parent.RightChild = currentNode\n\t}\n\n\tcurrentNode.RightChild = uncle\n\tuncle.Parent = currentNode\n}\n\nfunc (tree *RedBlackTree) insertFixup(newNode *Node) {\n\tcurrent := newNode\n\tfor current != nil && current.Parent != nil && current.Parent.Color == RED {\n\t\tif current.Parent == current.Parent.Parent.LeftChild {\n\t\t\ty := current.Parent.Parent.RightChild\n\t\t\tif y != nil && y.Color == RED {\n\t\t\t\tcurrent.Parent.Color = BLACK\n\t\t\t\ty.Color = BLACK\n\t\t\t\tcurrent.Parent.Parent.Color = RED\n\t\t\t\tcurrent = current.Parent.Parent\n\t\t\t} else {\n\t\t\t\tif current == current.Parent.RightChild {\n\t\t\t\t\tcurrent = current.Parent\n\t\t\t\t\ttree.leftRotate(current)\n\t\t\t\t}\n\t\t\t\tcurrent.Parent.Color = BLACK\n\t\t\t\tcurrent.Parent.Parent.Color = RED\n\t\t\t\ttree.rightRotate(current.Parent.Parent)\n\t\t\t}\n\t\t} else {\n\t\t\ty := current.Parent.Parent.LeftChild\n\t\t\tif y != nil && y.Color == RED {\n\t\t\t\tcurrent.Parent.Color = BLACK\n\t\t\t\ty.Color = BLACK\n\t\t\t\tcurrent.Parent.Parent.Color = RED\n\t\t\t\tcurrent = current.Parent.Parent\n\t\t\t} else {\n\t\t\t\tif current == current.Parent.LeftChild {\n\t\t\t\t\tcurrent = current.Parent\n\t\t\t\t\ttree.rightRotate(current)\n\t\t\t\t}\n\t\t\t\tcurrent.Parent.Color = BLACK\n\t\t\t\tcurrent.Parent.Parent.Color = RED\n\t\t\t\ttree.leftRotate(current.Parent.Parent)\n\t\t\t}\n\t\t}\n\t}\n\ttree.Root.Color = BLACK\n}\n\nfunc (tree *RedBlackTree) DeleteRBTree(key int) {\n\tnodeToDelete := tree.search(tree.Root, key)\n\tif nodeToDelete == nil {\n\t\treturn\n\t}\n\n\tsuccessor := nodeToDelete\n\tsuccessorOriginalColor := successor.Color\n\tvar successorChild *Node\n\n\tif nodeToDelete.LeftChild == nil {\n\t\tsuccessorChild = nodeToDelete.RightChild\n\t\ttree.transplant(nodeToDelete, nodeToDelete.RightChild)\n\t} else if nodeToDelete.RightChild == nil {\n\t\tsuccessorChild = nodeToDelete.LeftChild\n\t\ttree.transplant(nodeToDelete, nodeToDelete.LeftChild)\n\t} else {\n\t\tsuccessor = tree.findMinNode(nodeToDelete.RightChild)\n\t\tsuccessorOriginalColor = successor.Color\n\t\tsuccessorChild = successor.RightChild\n\n\t\tif successor.Parent == nodeToDelete {\n\t\t\tif successorChild != nil {\n\t\t\t\tsuccessorChild.Parent = successor\n\t\t\t}\n\t\t} else {\n\t\t\ttree.transplant(successor, successor.RightChild)\n\t\t\tsuccessor.RightChild = nodeToDelete.RightChild\n\t\t\tif successor.RightChild != nil {\n\t\t\t\tsuccessor.RightChild.Parent = successor\n\t\t\t}\n\t\t}\n\n\t\ttree.transplant(nodeToDelete, successor)\n\t\tsuccessor.LeftChild = nodeToDelete.LeftChild\n\t\tif successor.LeftChild != nil {\n\t\t\tsuccessor.LeftChild.Parent = successor\n\t\t}\n\t\tsuccessor.Color = nodeToDelete.Color\n\t}\n\n\tif successorOriginalColor == BLACK {\n\t\ttree.deleteFixup(successorChild)\n\t}\n}\n\nfunc (tree *RedBlackTree) search(root *Node, key int) *Node {\n\tcurrent := root\n\tfor current != nil && current.Key != key {\n\t\tif key < current.Key {\n\t\t\tcurrent = current.LeftChild\n\t\t} else {\n\t\t\tcurrent = current.RightChild\n\t\t}\n\t}\n\treturn current\n}\n\nfunc (tree *RedBlackTree) findMinNode(node *Node) *Node {\n\tcurrent := node\n\tfor current.LeftChild != nil {\n\t\tcurrent = current.LeftChild\n\t}\n\treturn current\n}\n\nfunc (tree *RedBlackTree) transplant(parent, child *Node) {\n\tif parent.Parent == nil {\n\t\ttree.Root = child\n\t} else if parent == parent.Parent.LeftChild {\n\t\tparent.Parent.LeftChild = child\n\t} else {\n\t\tparent.Parent.RightChild = child\n\t}\n\n\tif child != nil {\n\t\tchild.Parent = parent.Parent\n\t}\n}\n\nfunc (tree *RedBlackTree) deleteFixup(currentNode *Node) {\n\tcurrent := currentNode\n\tfor current != tree.Root && (current == nil || current.Color == BLACK) {\n\t\tif current == current.Parent.LeftChild {\n\t\t\tcurrentSibling := current.Parent.RightChild\n\t\t\tif currentSibling != nil && currentSibling.Color == RED {\n\t\t\t\tcurrentSibling.Color = BLACK\n\t\t\t\tcurrent.Parent.Color = RED\n\t\t\t\ttree.leftRotate(current.Parent)\n\t\t\t\tcurrentSibling = current.Parent.RightChild\n\t\t\t}\n\t\t\tif (currentSibling.LeftChild == nil || currentSibling.LeftChild.Color == BLACK) &&\n\t\t\t\t(currentSibling.RightChild == nil || currentSibling.RightChild.Color == BLACK) {\n\t\t\t\tcurrentSibling.Color = RED\n\t\t\t\tcurrent = current.Parent\n\t\t\t} else {\n\t\t\t\tif currentSibling.RightChild == nil || currentSibling.RightChild.Color == BLACK {\n\t\t\t\t\tcurrentSibling.LeftChild.Color = BLACK\n\t\t\t\t\tcurrentSibling.Color = RED\n\t\t\t\t\ttree.rightRotate(currentSibling)\n\t\t\t\t\tcurrentSibling = current.Parent.RightChild\n\t\t\t\t}\n\t\t\t\tcurrentSibling.Color = current.Parent.Color\n\t\t\t\tcurrent.Parent.Color = BLACK\n\t\t\t\tcurrentSibling.RightChild.Color = BLACK\n\t\t\t\ttree.leftRotate(current.Parent)\n\n\t\t\t\tcurrent = tree.Root\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentSibling := current.Parent.LeftChild\n\t\t\tif currentSibling != nil && currentSibling.Color == RED {\n\t\t\t\tcurrentSibling.Color = BLACK\n\t\t\t\tcurrent.Parent.Color = RED\n\t\t\t\ttree.rightRotate(current.Parent)\n\t\t\t\tcurrentSibling = current.Parent.LeftChild\n\t\t\t}\n\t\t\tif (currentSibling.RightChild == nil || currentSibling.RightChild.Color == BLACK) &&\n\t\t\t\t(currentSibling.LeftChild == nil || currentSibling.LeftChild.Color == BLACK) {\n\t\t\t\tcurrentSibling.Color = RED\n\t\t\t\tcurrent = current.Parent\n\t\t\t} else {\n\t\t\t\tif currentSibling.LeftChild == nil || currentSibling.LeftChild.Color == BLACK {\n\t\t\t\t\tcurrentSibling.RightChild.Color = BLACK\n\t\t\t\t\tcurrentSibling.Color = RED\n\t\t\t\t\ttree.leftRotate(currentSibling)\n\t\t\t\t\tcurrentSibling = current.Parent.LeftChild\n\t\t\t\t}\n\t\t\t\tcurrentSibling.Color = current.Parent.Color\n\t\t\t\tcurrent.Parent.Color = BLACK\n\t\t\t\tcurrentSibling.LeftChild.Color = BLACK\n\t\t\t\ttree.rightRotate(current.Parent)\n\n\t\t\t\tcurrent = tree.Root\n\t\t\t}\n\t\t}\n\t}\n\tif current != nil {\n\t\tcurrent.Color = BLACK\n\t}\n}\n\nfunc inOrderTraversal(node *Node) {\n\tif node != nil {\n\t\tinOrderTraversal(node.LeftChild)\n\t\tfmt.Printf("Key: %d, Color: %s\\n", node.Key, node.Color)\n\t\tinOrderTraversal(node.RightChild)\n\t}\n}\n',u='public class RedBlackTree {\n\n  enum Color {\n    RED,\n    BLACK\n  }\n\n  public static class Node {\n\n    int key;\n    String color;\n    Node leftChild;\n    Node rightChild;\n    Node parent;\n\n    public Node(int key, String color) {\n      this.key = key;\n      this.color = color;\n    }\n  }\n\n  private Node root;\n\n  public void insertRBTree(int key) {\n    Node newNode = new Node(key, Color.RED.toString());\n    Node uncle = null;\n    Node currentNode = root;\n\n    while (currentNode != null) {\n      uncle = currentNode;\n      if (newNode.key < currentNode.key) {\n        currentNode = currentNode.leftChild;\n      } else {\n        currentNode = currentNode.rightChild;\n      }\n    }\n\n    newNode.parent = uncle;\n    if (uncle == null) {\n      root = newNode;\n    } else if (newNode.key < uncle.key) {\n      uncle.leftChild = newNode;\n    } else {\n      uncle.rightChild = newNode;\n    }\n\n    insertFixup(newNode);\n    root.color = Color.BLACK.toString();\n  }\n\n  private void leftRotate(Node currentNode) {\n    Node uncle = currentNode.rightChild;\n    currentNode.rightChild = uncle != null ? uncle.leftChild : null;\n    if (uncle != null && uncle.leftChild != null) {\n      uncle.leftChild.parent = currentNode;\n    }\n    if (uncle != null) {\n      uncle.parent = currentNode.parent;\n    }\n\n    if (currentNode.parent == null) {\n      root = uncle;\n    } else if (currentNode == currentNode.parent.leftChild) {\n      currentNode.parent.leftChild = uncle;\n    } else {\n      currentNode.parent.rightChild = uncle;\n    }\n\n    if (uncle != null) {\n      uncle.leftChild = currentNode;\n    }\n    currentNode.parent = uncle;\n  }\n\n  private void rightRotate(Node uncle) {\n    Node currentNode = uncle.leftChild;\n    uncle.leftChild = currentNode != null ? currentNode.rightChild : null;\n    if (currentNode != null && currentNode.rightChild != null) {\n      currentNode.rightChild.parent = uncle;\n    }\n    if (currentNode != null) {\n      currentNode.parent = uncle.parent;\n    }\n\n    if (uncle.parent == null) {\n      root = currentNode;\n    } else if (uncle == uncle.parent.leftChild) {\n      uncle.parent.leftChild = currentNode;\n    } else {\n      uncle.parent.rightChild = currentNode;\n    }\n\n    if (currentNode != null) {\n      currentNode.rightChild = uncle;\n    }\n    uncle.parent = currentNode;\n  }\n\n  private void insertFixup(Node newNode) {\n    Node current = newNode;\n    while (current != null && current.parent != null && current.parent.color.equals(Color.RED.toString())) {\n      if (current.parent == current.parent.parent.leftChild) {\n        Node y = current.parent.parent.rightChild;\n        if (y != null && y.color.equals(Color.RED.toString())) {\n          current.parent.color = Color.BLACK.toString();\n          y.color = Color.BLACK.toString();\n          current.parent.parent.color = Color.RED.toString();\n          current = current.parent.parent;\n        } else {\n          if (current == current.parent.rightChild) {\n            current = current.parent;\n            leftRotate(current);\n          }\n          current.parent.color = Color.BLACK.toString();\n          current.parent.parent.color = Color.RED.toString();\n          rightRotate(current.parent.parent);\n        }\n      } else {\n        Node y = current.parent.parent.leftChild;\n        if (y != null && y.color.equals(Color.RED.toString())) {\n          current.parent.color = Color.BLACK.toString();\n          y.color = Color.BLACK.toString();\n          current.parent.parent.color = Color.RED.toString();\n          current = current.parent.parent;\n        } else {\n          if (current == current.parent.leftChild) {\n            current = current.parent;\n            rightRotate(current);\n          }\n          current.parent.color = Color.BLACK.toString();\n          current.parent.parent.color = Color.RED.toString();\n          leftRotate(current.parent.parent);\n        }\n      }\n    }\n    root.color = Color.BLACK.toString();\n  }\n\n  public void deleteRBTree(int key) {\n    Node nodeToDelete = search(root, key);\n    if (nodeToDelete == null) {\n      return;\n    }\n\n    Node successor = nodeToDelete;\n    String successorOriginalColor = successor.color;\n    Node successorChild;\n\n    if (nodeToDelete.leftChild == null) {\n      successorChild = nodeToDelete.rightChild;\n      transplant(nodeToDelete, nodeToDelete.rightChild);\n    } else if (nodeToDelete.rightChild == null) {\n      successorChild = nodeToDelete.leftChild;\n      transplant(nodeToDelete, nodeToDelete.leftChild);\n    } else {\n      successor = findMinNode(nodeToDelete.rightChild);\n      successorOriginalColor = successor.color;\n      successorChild = successor.rightChild;\n\n      if (successor.parent == nodeToDelete) {\n        if (successorChild != null) {\n          successorChild.parent = successor;\n        }\n      } else {\n        transplant(successor, successor.rightChild);\n        successor.rightChild = nodeToDelete.rightChild;\n        if (successor.rightChild != null) {\n          successor.rightChild.parent = successor;\n        }\n      }\n\n      transplant(nodeToDelete, successor);\n      successor.leftChild = nodeToDelete.leftChild;\n      if (successor.leftChild != null) {\n        successor.leftChild.parent = successor;\n      }\n      successor.color = nodeToDelete.color;\n    }\n\n    if (successorOriginalColor.equals(Color.BLACK.toString())) {\n      deleteFixup(successorChild);\n    }\n  }\n\n  private Node search(Node root, int key) {\n    Node current = root;\n    while (current != null && current.key != key) {\n      while (current != null && current.key != key) {\n        if (key < current.key) {\n          current = current.leftChild;\n        } else {\n          current = current.rightChild;\n        }\n      }\n      return current;\n    }\n\n    private Node findMinNode (Node node) {\n      Node current = node;\n      while (current.leftChild != null) {\n        current = current.leftChild;\n      }\n      return current;\n    }\n\n    private void transplant (Node parent, Node child) {\n      if (parent.parent == null) {\n        root = child;\n      } else if (parent == parent.parent.leftChild) {\n        parent.parent.leftChild = child;\n      } else {\n        parent.parent.rightChild = child;\n      }\n\n      if (child != null) {\n        child.parent = parent.parent;\n      }\n    }\n\n    private void deleteFixup (Node currentNode) {\n      Node current = currentNode;\n      while (current != root && (current == null || current.color.equals(Color.BLACK.toString()))) {\n        if (current == current.parent.leftChild) {\n          Node currentSibling = current.parent.rightChild;\n          if (currentSibling != null && currentSibling.color.equals(Color.RED.toString())) {\n            currentSibling.color = Color.BLACK.toString();\n            current.parent.color = Color.RED.toString();\n            leftRotate(current.parent);\n            currentSibling = current.parent.rightChild;\n          }\n          if ((currentSibling == null || currentSibling.leftChild == null || currentSibling.leftChild.color.equals(Color.BLACK.toString())) &&\n              (currentSibling == null || currentSibling.rightChild == null || currentSibling.rightChild.color.equals(Color.BLACK.toString()))) {\n            if (currentSibling != null) {\n              currentSibling.color = Color.RED.toString();\n            }\n            current = current.parent;\n          } else {\n            if (currentSibling.rightChild == null || currentSibling.rightChild.color.equals(Color.BLACK.toString())) {\n              if (currentSibling.leftChild != null) {\n                currentSibling.leftChild.color = Color.BLACK.toString();\n              }\n              if (currentSibling != null) {\n                currentSibling.color = Color.RED.toString();\n              }\n              rightRotate(currentSibling);\n              currentSibling = current.parent.rightChild;\n            }\n            if (currentSibling != null) {\n              currentSibling.color = current.parent.color;\n            }\n            if (current.parent != null) {\n              current.parent.color = Color.BLACK.toString();\n            }\n            if (currentSibling.rightChild != null) {\n              currentSibling.rightChild.color = Color.BLACK.toString();\n            }\n            leftRotate(current.parent);\n\n            current = root;\n          }\n        } else {\n          Node currentSibling = current.parent.leftChild;\n          if (currentSibling != null && currentSibling.color.equals(Color.RED.toString())) {\n            currentSibling.color = Color.BLACK.toString();\n            current.parent.color = Color.RED.toString();\n            rightRotate(current.parent);\n            currentSibling = current.parent.leftChild;\n          }\n          if ((currentSibling == null || currentSibling.rightChild == null || currentSibling.rightChild.color.equals(Color.BLACK.toString())) &&\n              (currentSibling == null || currentSibling.leftChild == null || currentSibling.leftChild.color.equals(Color.BLACK.toString()))) {\n            if (currentSibling != null) {\n              currentSibling.color = Color.RED.toString();\n            }\n            current = current.parent;\n          } else {\n            if (currentSibling.leftChild == null || currentSibling.leftChild.color.equals(Color.BLACK.toString())) {\n              if (currentSibling.rightChild != null) {\n                currentSibling.rightChild.color = Color.BLACK.toString();\n              }\n              if (currentSibling != null) {\n                currentSibling.color = Color.RED.toString();\n              }\n              leftRotate(currentSibling);\n              currentSibling = current.parent.leftChild;\n            }\n            if (currentSibling != null) {\n              currentSibling.color = current.parent.color;\n            }\n            if (current.parent != null) {\n              current.parent.color = Color.BLACK.toString();\n            }\n            if (currentSibling.leftChild != null) {\n              currentSibling.leftChild.color = Color.BLACK.toString();\n            }\n            rightRotate(current.parent);\n            current = root;\n          }\n        }\n      }\n      if (current != null) {\n        current.color = Color.BLACK.toString();\n      }\n    }\n\n    private static void inOrderTraversal (Node node) {\n      if (node != null) {\n        inOrderTraversal(node.leftChild);\n        System.out.printf("Key: %d, Color: %s\\n", node.key, node.color);\n        inOrderTraversal(node.rightChild);\n      }\n    }\n  }\n}\n',s="",a="class RedBlackTree {\n    enum class Color {\n        RED,\n        BLACK\n    }\n\n    data class Node(var key: Int, var color: String, var leftChild: Node? = null, var rightChild: Node? = null, var parent: Node? = null)\n\n    var root: Node? = null\n\n    fun insertRBTree(key: Int) {\n        val newNode = Node(key, RED)\n        var uncle: Node? = null\n        var currentNode = root\n\n        while (currentNode != null) {\n            uncle = currentNode\n            if (newNode.key < currentNode.key) {\n                currentNode = currentNode.leftChild\n            } else {\n                currentNode = currentNode.rightChild\n            }\n        }\n\n        newNode.parent = uncle\n        if (uncle == null) {\n            root = newNode\n        } else if (newNode.key < uncle.key) {\n            uncle.leftChild = newNode\n        } else {\n            uncle.rightChild = newNode\n        }\n\n        insertFixup(newNode)\n        root?.color = BLACK\n    }\n\n    private fun leftRotate(currentNode: Node) {\n        val uncle = currentNode.rightChild\n        currentNode.rightChild = uncle?.leftChild\n        uncle?.leftChild?.parent = currentNode\n        uncle?.parent = currentNode.parent\n\n        if (currentNode.parent == null) {\n            root = uncle\n        } else if (currentNode == currentNode.parent?.leftChild) {\n            currentNode.parent?.leftChild = uncle\n        } else {\n            currentNode.parent?.rightChild = uncle\n        }\n\n        uncle?.leftChild = currentNode\n        currentNode.parent = uncle\n    }\n\n    private fun rightRotate(uncle: Node) {\n        val currentNode = uncle.leftChild\n        uncle.leftChild = currentNode?.rightChild\n        currentNode?.rightChild?.parent = uncle\n        currentNode?.parent = uncle.parent\n\n        if (uncle.parent == null) {\n            root = currentNode\n        } else if (uncle == uncle.parent?.leftChild) {\n            uncle.parent?.leftChild = currentNode\n        } else {\n            uncle.parent?.rightChild = currentNode\n        }\n\n        currentNode?.rightChild = uncle\n        uncle.parent = currentNode\n    }\n\n    private fun insertFixup(newNode: Node?) {\n        var current = newNode\n        while (current?.parent != null && current.parent?.color == RED) {\n            if (current.parent == current.parent?.parent?.leftChild) {\n                val y = current.parent?.parent?.rightChild\n                if (y != null && y.color == RED) {\n                    current.parent?.color = BLACK\n                    y.color = BLACK\n                    current.parent?.parent?.color = RED\n                    current = current.parent?.parent\n                } else {\n                    if (current == current.parent?.rightChild) {\n                        current = current.parent\n                        leftRotate(current)\n                    }\n                    current.parent?.color = BLACK\n                    current.parent?.parent?.color = RED\n                    rightRotate(current.parent?.parent!!)\n                }\n            } else {\n                val y = current.parent?.parent?.leftChild\n                if (y != null && y.color == RED) {\n                    current.parent?.color = BLACK\n                    y.color = BLACK\n                    current.parent?.parent?.color = RED\n                    current = current.parent?.parent\n                } else {\n                    if (current == current.parent?.leftChild) {\n                        current = current.parent\n                        rightRotate(current)\n                    }\n                    current.parent?.color = BLACK\n                    current.parent?.parent?.color = RED\n                    leftRotate(current.parent?.parent!!)\n                }\n            }\n        }\n        root?.color = BLACK\n    }\n\n    fun deleteRBTree(key: Int) {\n        val nodeToDelete = search(root, key)\n        if (nodeToDelete == null) {\n            return\n        }\n\n        var successor = nodeToDelete\n        var successorOriginalColor = successor.color\n        val successorChild: Node?\n\n        if (nodeToDelete.leftChild == null) {\n            successorChild = nodeToDelete.rightChild\n            transplant(nodeToDelete, nodeToDelete.rightChild)\n        } else if (nodeToDelete.rightChild == null) {\n            successorChild = nodeToDelete.leftChild\n            transplant(nodeToDelete, nodeToDelete.leftChild)\n        } else {\n            successor = findMinNode(nodeToDelete.rightChild!!)\n            successorOriginalColor = successor.color\n            successorChild = successor.rightChild\n\n            if (successor.parent == nodeToDelete) {\n                successorChild?.parent = successor\n            } else {\n                transplant(successor, successor.rightChild)\n                successor.rightChild = nodeToDelete.rightChild\n                successor.rightChild?.parent = successor\n            }\n\n            transplant(nodeToDelete, successor)\n            successor.leftChild = nodeToDelete.leftChild\n            successor.leftChild?.parent = successor\n            successor.color = nodeToDelete.color\n        }\n\n        if (successorOriginalColor == BLACK) {\n            deleteFixup(successorChild)\n        }\n    }\n\n    private fun search(root: Node?, key: Int): Node? {\n        var current = root\n        while (current != null && current.key != key) {\n            if (key < current.key) {\n                current = current.leftChild\n            } else {\n                current = current.rightChild\n            }\n        }\n        return current\n    }\n\n    private fun findMinNode(node: Node): Node {\n        var current = node\n        while (current.leftChild != null) {\n            current = current.leftChild!!\n        }\n        return current\n    }\n\n    private fun transplant(parent: Node, child: Node?) {\n        if (parent.parent == null) {\n            root = child\n        } else if (parent == parent.parent?.leftChild) {\n            parent.parent?.leftChild = child\n        } else {\n            parent.parent?.rightChild = child\n        }\n\n        child?.parent = parent.parent\n    }\n\n    private fun deleteFixup(currentNode: Node?) {\n        var current = currentNode\n        while (current != root && (current == null || current.color == BLACK)) {\n            if (current == current?.parent?.leftChild) {\n                var currentNodeSibling = current.parent?.rightChild\n                if (currentNodeSibling?.color == RED) {\n                    currentNodeSibling.color = BLACK\n                    current.parent?.color = RED\n                    leftRotate(current.parent!!)\n                    currentNodeSibling = current.parent?.rightChild\n                }\n                if ((currentNodeSibling?.leftChild == null || currentNodeSibling.leftChild?.color == BLACK) &&\n                        (currentNodeSibling.rightChild == null || currentNodeSibling.rightChild?.color == BLACK)\n                ) {\n                    currentNodeSibling.color = RED\n                    current = current.parent\n                } else {\n                    if (currentNodeSibling.rightChild == null || currentNodeSibling.rightChild?.color == BLACK) {\n                        currentNodeSibling.leftChild?.color = BLACK\n                        currentNodeSibling.color = RED\n                        rightRotate(currentNodeSibling)\n                        currentNodeSibling = current.parent?.rightChild\n                    }\n                    currentNodeSibling?.color = current.parent?.color\n                    current.parent?.color = BLACK\n                    currentNodeSibling?.rightChild?.color = BLACK\n                    leftRotate(tree, currentNode.parent!!)\n\n                    current = root\n                }\n            } else {\n                var currentNodeSibling = current.parent?.leftChild\n                if (currentNodeSibling?.color == RED) {\n                    currentNodeSibling.color = BLACK\n                    current.parent?.color = RED\n                    rightRotate(current.parent!!)\n                    currentNodeSibling = current.parent?.leftChild\n                }\n                if ((currentNodeSibling?.rightChild == null || currentNodeSibling.rightChild?.color == BLACK) &&\n                        (currentNodeSibling.leftChild == null || currentNodeSibling.leftChild?.color == BLACK)\n                ) {\n                    currentNodeSibling.color = RED\n                    current = current.parent\n                } else {\n                    if (currentNodeSibling.leftChild == null || currentNodeSibling.leftChild?.color == BLACK) {\n                        currentNodeSibling.rightChild?.color = BLACK\n                        currentNodeSibling.color = RED\n                        leftRotate(currentNodeSibling)\n                        currentNodeSibling = current.parent?.leftChild\n                    }\n                    currentNodeSibling?.color = current.parent?.color\n                    current.parent?.color = BLACK\n                    currentNodeSibling?.leftChild?.color = BLACK\n                    rightRotate(tree, currentNode.parent!!)\n                    current = root\n                }\n            }\n        }\n        current?.color = BLACK\n    }\n}\n",h='class RedBlackTree:\n    class Color:\n        RED = "RED"\n        BLACK = "BLACK"\n\n    class Node:\n        def __init__(self, key, color, left_child=None, right_child=None, parent=None):\n            self.key = key\n            self.color = color\n            self.left_child = left_child\n            self.right_child = right_child\n            self.parent = parent\n\n    def __init__(self):\n        self.root = None\n\n    def insert_rb_tree(self, key):\n        new_node = self.Node(key, self.Color.RED)\n        uncle = None\n        current_node = self.root\n\n        while current_node is not None:\n            uncle = current_node\n            if new_node.key < current_node.key:\n                current_node = current_node.left_child\n            else:\n                current_node = current_node.right_child\n\n        new_node.parent = uncle\n        if uncle is None:\n            self.root = new_node\n        elif new_node.key < uncle.key:\n            uncle.left_child = new_node\n        else:\n            uncle.right_child = new_node\n\n        self._insert_fixup(new_node)\n        if self.root is not None:\n            self.root.color = self.Color.BLACK\n\n    def _left_rotate(self, current_node):\n        uncle = current_node.right_child\n        current_node.right_child = uncle.left_child\n        if uncle.left_child:\n            uncle.left_child.parent = current_node\n        uncle.parent = current_node.parent\n\n        if current_node.parent is None:\n            self.root = uncle\n        elif current_node == current_node.parent.left_child:\n            current_node.parent.left_child = uncle\n        else:\n            current_node.parent.right_child = uncle\n\n        uncle.left_child = current_node\n        current_node.parent = uncle\n\n    def _right_rotate(self, uncle):\n        current_node = uncle.left_child\n        uncle.left_child = current_node.right_child\n        if current_node.right_child:\n            current_node.right_child.parent = uncle\n        current_node.parent = uncle.parent\n\n        if uncle.parent is None:\n            self.root = current_node\n        elif uncle == uncle.parent.left_child:\n            uncle.parent.left_child = current_node\n        else:\n            uncle.parent.right_child = current_node\n\n        current_node.right_child = uncle\n        uncle.parent = current_node\n\n    def _insert_fixup(self, new_node):\n        current = new_node\n        while current.parent is not None and current.parent.color == self.Color.RED:\n            if current.parent == current.parent.parent.left_child:\n                y = current.parent.parent.right_child\n                if y and y.color == self.Color.RED:\n                    current.parent.color = self.Color.BLACK\n                    y.color = self.Color.BLACK\n                    current.parent.parent.color = self.Color.RED\n                    current = current.parent.parent\n                else:\n                    if current == current.parent.right_child:\n                        current = current.parent\n                        self._left_rotate(current)\n                    current.parent.color = self.Color.BLACK\n                    current.parent.parent.color = self.Color.RED\n                    self._right_rotate(current.parent.parent)\n            else:\n                y = current.parent.parent.left_child\n                if y and y.color == self.Color.RED:\n                    current.parent.color = self.Color.BLACK\n                    y.color = self.Color.BLACK\n                    current.parent.parent.color = self.Color.RED\n                    current = current.parent.parent\n                else:\n                    if current == current.parent.left_child:\n                        current = current.parent\n                        self._right_rotate(current)\n                    current.parent.color = self.Color.BLACK\n                    current.parent.parent.color = self.Color.RED\n                    self._left_rotate(current.parent.parent)\n\n        if self.root:\n            self.root.color = self.Color.BLACK\n\n    def delete_rb_tree(self, key):\n        node_to_delete = self._search(self.root, key)\n        if node_to_delete is None:\n            return\n\n        successor = node_to_delete\n        successor_original_color = successor.color\n        successor_child = None\n\n        if node_to_delete.left_child is None:\n            successor_child = node_to_delete.right_child\n            self._transplant(node_to_delete, node_to_delete.right_child)\n        elif node_to_delete.right_child is None:\n            successor_child = node_to_delete.left_child\n            self._transplant(node_to_delete, node_to_delete.left_child)\n        else:\n            successor = self._find_min_node(node_to_delete.right_child)\n            successor_original_color = successor.color\n            successor_child = successor.right_child\n\n            if successor.parent == node_to_delete:\n                if successor_child:\n                    successor_child.parent = successor\n            else:\n                self._transplant(successor, successor.right_child)\n                successor.right_child = node_to_delete.right_child\n                if successor.right_child:\n                    successor.right_child.parent = successor\n\n            self._transplant(node_to_delete, successor)\n            successor.left_child = node_to_delete.left_child\n            if successor.left_child:\n                successor.left_child.parent = successor\n            successor.color = node_to_delete.color\n\n        if successor_original_color == self.Color.BLACK:\n            self._delete_fixup(successor_child)\n\n    def _search(self, root, key):\n        current = root\n        while current and current.key != key:\n            if key < current.key:\n                current = current.left_child\n            else:\n                current = current.right_child\n        return current\n\n    def _find_min_node(self, node):\n        current = node\n        while current.left_child:\n            current = current.left_child\n        return current\n\n    def _transplant(self, parent, child):\n        if not parent.parent:\n            self.root = child\n        elif parent == parent.parent.left_child:\n            parent.parent.left_child = child\n        else:\n            parent.parent.right_child = child\n\n        if child:\n            child.parent = parent.parent\n\n    def _delete_fixup(self, current_node):\n        current = current_node\n        while current != self.root and (not current or current.color == self.Color.BLACK):\n            if current == current.parent.left_child:\n                current_sibling = current.parent.right_child\n                if current_sibling and current_sibling.color == self.Color.RED:\n                    current_sibling.color = self.Color.BLACK\n                    current.parent.color = self.Color.RED\n                    self._left_rotate(current.parent)\n                    current_sibling = current.parent.right_child\n\n                if (not current_sibling.left_child or current_sibling.left_child.color == self.Color.BLACK) and \\\n                        (not current_sibling.right_child or current_sibling.right_child.color == self.Color.BLACK):\n                    if current_sibling:\n                        current_sibling.color = self.Color.RED\n\n                    current = current.parent\n                else:\n                    if not current_sibling.right_child or current_sibling.right_child.color == self.Color.BLACK:\n                        if current_sibling.left_child:\n                            current_sibling.left_child.color = self.Color.BLACK\n                        if current_sibling:\n                            current_sibling.color = self.Color.RED\n                        self._right_rotate(current_sibling)\n                        current_sibling = current.parent.right_child\n\n                    if current_sibling:\n                        current_sibling.color = current.parent.color\n                    if current.parent:\n                        current.parent.color = self.Color.BLACK\n                    if current_sibling.right_child:\n                        current_sibling.right_child.color = self.Color.BLACK\n\n                    self._left_rotate(current.parent)\n                    current = self.root\n            else:\n                current_sibling = current.parent.left_child\n                if current_sibling and current_sibling.color == self.Color.RED:\n                    current_sibling.color = self.Color.BLACK\n                    current.parent.color = self.Color.RED\n                    self._right_rotate(current.parent)\n                    current_sibling = current.parent.left_child\n\n                if (not current_sibling.right_child or current_sibling.right_child.color == self.Color.BLACK) and (not current_sibling.left_child or current_sibling.left_child.color == self.Color.BLACK):\n                    if current_sibling:\n                        current_sibling.color = self.Color.RED\n                    current = current.parent\n                else:\n                    if not current_sibling.left_child or current_sibling.left_child.color == self.Color.BLACK:\n                        if current_sibling.right_child:\n                            current_sibling.right_child.color = self.Color.BLACK\n                        if current_sibling:\n                            current_sibling.color = self.Color.RED\n\n                        self._left_rotate(current_sibling)\n                        current_sibling = current.parent.left_child\n                    if current_sibling:\n                        current_sibling.color = current.parent.color\n                    if current.parent:\n                        current.parent.color = self.Color.BLACK\n                    if current_sibling.left_child:\n                        current_sibling.left_child.color = self.Color.BLACK\n\n                    self._right_rotate(current.parent)\n                    current = self.root\n        if current:\n            current.color = self.Color.BLACK\n',f="use std::cmp::Ord;\n\nstruct RedBlackTree {\n    enum Color {\n        RED,\n        BLACK,\n    }\n\n    struct Node {\n        key: i32,\n        color: Color,\n        left_child: Option<Box<Node>>,\n        right_child: Option<Box<Node>>,\n        parent: Option<Box<Node>>,\n    }\n\n    impl Node {\n        fn new(key: i32, color: Color) -> Self {\n            Node {\n                key,\n                color,\n                left_child: None,\n                right_child: None,\n                parent: None,\n            }\n        }\n    }\n\n    impl RedBlackTree {\n        root: Option<Box<Node>>,\n\n        fn insert_rb_tree(&mut self, key: i32) {\n            let new_node = Box::new(Node::new(key, Color::RED));\n            let mut uncle: Option<Box<Node>> = None;\n            let mut current_node = &mut self.root;\n\n            while let Some(current) = current_node {\n                uncle = Some(current);\n                if new_node.key < current.key {\n                    current_node = &mut current.left_child;\n                } else {\n                    current_node = &mut current.right_child;\n                }\n            }\n\n            new_node.parent = uncle;\n            if uncle.is_none() {\n                self.root = Some(new_node);\n            } else if new_node.key < uncle.unwrap().key {\n                uncle.unwrap().left_child = Some(new_node);\n            } else {\n                uncle.unwrap().right_child = Some(new_node);\n            }\n\n            self.insert_fixup(Some(new_node));\n            self.root.as_mut().map(|r| r.color = Color::BLACK);\n        }\n\n        fn left_rotate(&mut self, current_node: &mut Node) {\n            let mut uncle = current_node.right_child.take();\n            if let Some(ref mut uncle) = uncle {\n                current_node.right_child = uncle.left_child.take();\n                if let Some(left_child) = &mut uncle.left_child {\n                    left_child.parent = Some(Box::new(current_node));\n                }\n                uncle.parent = current_node.parent.take();\n\n                if current_node.parent.is_none() {\n                    self.root = Some(uncle);\n                } else if let Some(parent) = &mut current_node.parent {\n                    if current_node.key < parent.key {\n                        parent.left_child = Some(uncle);\n                    } else {\n                        parent.right_child = Some(uncle);\n                    }\n                }\n\n                uncle.left_child = Some(Box::new(current_node));\n                current_node.parent = Some(uncle);\n            }\n        }\n\n        fn right_rotate(&mut self, uncle: &mut Node) {\n            let mut current_node = uncle.left_child.take();\n            if let Some(ref mut current_node) = current_node {\n                uncle.left_child = current_node.right_child.take();\n                if let Some(right_child) = &mut current_node.right_child {\n                    right_child.parent = Some(Box::new(uncle));\n                }\n                current_node.parent = uncle.parent.take();\n\n                if uncle.parent.is_none() {\n                    self.root = current_node;\n                } else if let Some(parent) = &mut uncle.parent {\n                    if uncle.key < parent.key {\n                        parent.left_child = current_node;\n                    } else {\n                        parent.right_child = current_node;\n                    }\n                }\n\n                current_node.right_child = Some(Box::new(uncle));\n                uncle.parent = current_node;\n            }\n        }\n\n        fn insert_fixup(&mut self, new_node: Option<Box<Node>>) {\n            let mut current = new_node;\n            while let Some(ref mut current_node) = current {\n                if let Some(ref parent) = current_node.parent {\n                    if parent.color == Color::RED {\n                        if parent == parent.parent.as_ref().and_then(|p| p.left_child.as_ref()) {\n                            let y = parent.parent.as_ref().and_then(|p| p.right_child.as_ref());\n                            if let Some(y) = y {\n                                if y.color == Color::RED {\n                                    parent.color = Color::BLACK;\n                                    y.color = Color::BLACK;\n                                    parent.parent.as_mut().map(|p| p.color = Color::RED);\n                                    current = parent.parent;\n                                } else {\n                                    if current_node == parent.right_child.as_ref().and_then(|p| Some(p)) {\n                                        current = Some(Box::new(parent));\n                                        self.left_rotate(current_node);\n                                    }\n                                    parent.color = Color::BLACK;\n                                    parent.parent.as_mut().map(|p| p.color = Color::RED);\n                                    self.right_rotate(parent.parent.as_mut().and_then(|p| Some(p)).unwrap());\n                                }\n                            }\n                        } else {\n                            let y = parent.parent.as_ref().and_then(|p| p.left_child.as_ref());\n                            if let Some(y) = y {\n                                if y.color == Color::RED {\n                                    parent.color = Color::BLACK;\n                                    y.color = Color::BLACK;\n                                    parent.parent.as_mut().map(|p| p.color = Color::RED);\n                                    current = parent.parent;\n                                } else {\n                                    if current_node == parent.left_child.as_ref().and_then(|p| Some(p)) {\n                                        current = Some(Box::new(parent));\n                                        self.right_rotate(current_node);\n                                    }\n                                    parent.color = Color::BLACK;\n                                    parent.parent.as_mut().map(|p| p.color = Color::RED);\n                                    self.left_rotate(parent.parent.as_mut().and_then(|p| Some(p)).unwrap());\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        fn delete_rb_tree(&mut self, key: i32) {\n            let node_to_delete = self.search(&self.root, key);\n            if node_to_delete.is_none() {\n                return;\n            }\n\n            let mut successor = node_to_delete.unwrap();\n            let successor_original_color = successor.color;\n            let mut successor_child: Option<Box<Node>>;\n\n            if successor.left_child.is_none() {\n                successor_child = successor.right_child.take();\n                self.transplant(&successor, successor.right_child.as_mut());\n            } else if successor.right_child.is_none() {\n                successor_child = successor.left_child.take();\n                self.transplant(&successor, successor.left_child.as_mut());\n            } else {\n                let min_node = self.find_min_node(successor.right_child.as_ref().and_then(|r| Some(r)));\n                successor_original_color = min_node.color;\n                successor_child = min_node.right_child.take();\n\n                if let Some(ref parent) = min_node.parent {\n                    if min_node.parent == &successor {\n                        successor_child.as_mut().map(|child| child.parent = Some(Box::new(min_node)));\n                    } else {\n                        self.transplant(min_node.as_ref().and_then(|m| Some(m)), min_node.right_child.as_mut());\n                        min_node.right_child = successor.right_child.take();\n                        min_node.right_child.as_mut().map(|right| right.parent = Some(Box::new(min_node)));\n                    }\n                    self.transplant(&successor, Some(Box::new(min_node)));\n                    min_node.left_child = successor.left_child.take();\n                    min_node.left_child.as_mut().map(|left| left.parent = Some(Box::new(min_node)));\n                    min_node.color = successor.color;\n                }\n\n                if successor_original_color == Color::BLACK {\n                    self.delete_fixup(&successor_child);\n                }\n            }\n        }\n\n        fn search(&self, root: &Option<Box<Node>>, key: i32) -> Option<Box<Node>> {\n            let mut current = root;\n            while let Some(node) = current {\n                if key < node.key {\n                   current = &node.left_child;\n               } else if key > node.key {\n                   current = &node.right_child;\n               } else {\n                   return Some(Box::new(node.clone()));\n               }\n           }\n           None\n       }\n\n       fn find_min_node(&self, mut node: Option<&Box<Node>>) -> &Box<Node> {\n           while let Some(n) = node {\n               node = n.left_child.as_ref();\n           }\n           node.unwrap()\n       }\n\n       fn transplant(&mut self, parent: &Node, child: Option<&mut Box<Node>>) {\n           if parent.parent.is_none() {\n               self.root = child.map(|c| c.clone());\n           } else if let Some(parent_ref) = parent.parent.as_mut() {\n               if parent == parent_ref.left_child.as_ref().map(|left| left.as_ref()) {\n                   parent_ref.left_child = child.map(|c| c.clone());\n               } else {\n                   parent_ref.right_child = child.map(|c| c.clone());\n               }\n           }\n\n           child.map(|c| c.parent = parent.parent.clone());\n       }\n\n       fn delete_fixup(&mut self, mut current_node: &Option<Box<Node>>) {\n           while let Some(ref mut current) = *current_node {\n               if current == &self.root.unwrap() {\n                   break;\n               }\n\n               let mut current_sibling = current.parent.as_ref().and_then(|p| {\n                   if current == p.left_child.as_ref().map(|left| left.as_ref()) {\n                       p.right_child.as_ref().map(|right| right.as_ref())\n                   } else {\n                       p.left_child.as_ref().map(|left| left.as_ref())\n                   }\n               });\n\n               if let Some(ref mut sibling) = current_sibling {\n                   if sibling.color == Color::RED {\n                       sibling.color = Color::BLACK;\n                       current.parent.as_mut().map(|p| p.color = Color::RED);\n\n                       if current == current.parent.as_ref().and_then(|p| p.left_child.as_ref().map(|left| left.as_ref())) {\n                           self.left_rotate(current.parent.as_mut().unwrap());\n                           current_sibling = current.parent.as_ref().and_then(|p| p.right_child.as_ref().map(|right| right.as_ref()));\n                       } else {\n                           self.right_rotate(current.parent.as_mut().unwrap());\n                           current_sibling = current.parent.as_ref().and_then(|p| p.left_child.as_ref().map(|left| left.as_ref()));\n                       }\n                   }\n\n                   if let (Some(ref left_child), Some(ref right_child)) =\n                       (sibling.left_child.as_ref(), sibling.right_child.as_ref())\n                   {\n                       if left_child.color == Color::BLACK && right_child.color == Color::BLACK {\n                           sibling.color = Color::RED;\n                           current_node = &current.parent;\n                       } else {\n                           if current == current.parent.as_ref().and_then(|p| p.left_child.as_ref().map(|left| left.as_ref())) &&\n                               right_child.color == Color::BLACK\n                           {\n                               left_child.color = Color::BLACK;\n                               sibling.color = Color::RED;\n                               self.right_rotate(sibling.as_mut().unwrap());\n                               current_sibling = current.parent.as_ref().and_then(|p| p.right_child.as_ref().map(|right| right.as_ref()));\n                           } else if current == current.parent.as_ref().and_then(|p| p.right_child.as_ref().map(|right| right.as_ref())) &&\n                               left_child.color == Color::BLACK\n                           {\n                               right_child.color = Color::BLACK;\n                               sibling.color = Color::RED;\n                               self.left_rotate(sibling.as_mut().unwrap());\n                               current_sibling = current.parent.as_ref().and_then(|p| p.left_child.as_ref().map(|left| left.as_ref()));\n                           }\n\n                           if let Some(ref mut sibling) = current_sibling {\n                               sibling.color = current.parent.as_ref().map(|p| p.color).unwrap();\n                               current.parent.as_mut().map(|p| p.color = Color::BLACK);\n                               if current == current.parent.as_ref().and_then(|p| p.left_child.as_ref().map(|left| left.as_ref())) {\n                                   right_child.color = Color::BLACK;\n                                   self.left_rotate(current.parent.as_mut().unwrap());\n                               } else {\n                                   left_child.color = Color::BLACK;\n                                   self.right_rotate(current.parent.as_mut().unwrap());\n                               }\n                           }\n\n                           current_node = &self.root;\n                       }\n                   }\n               }\n           }\n\n           if let Some(ref mut current) = *current_node {\n               current.color = Color::BLACK;\n           }\n       }\n   }\n}\n",_="class RedBlackTree {\n  enum Color {\n    RED,\n    BLACK\n  }\n\n  class Node {\n    key: number;\n    color: string;\n    leftChild: Node | null;\n    rightChild: Node | null;\n    parent: Node | null;\n\n    constructor(key: number, color: string, leftChild: Node | null = null, rightChild: Node | null = null, parent: Node | null = null) {\n      this.key = key;\n      this.color = color;\n      this.leftChild = leftChild;\n      this.rightChild = rightChild;\n      this.parent = parent;\n    }\n  }\n\n  root: Node | null = null;\n\n  insertRBTree(key: number): void {\n    const newNode = new Node(key, Color.RED);\n    let uncle: Node | null = null;\n  let currentNode: Node | null = this.root;\n\n  while (currentNode !== null) {\n    uncle = currentNode;\n    if (newNode.key < currentNode.key) {\n      currentNode = currentNode.leftChild;\n    } else {\n      currentNode = currentNode.rightChild;\n    }\n  }\n\n  newNode.parent = uncle;\n  if (uncle === null) {\n    this.root = newNode;\n  } else if (newNode.key < uncle.key) {\n    uncle.leftChild = newNode;\n  } else {\n    uncle.rightChild = newNode;\n  }\n\n  this.insertFixup(newNode);\n  if (this.root !== null) {\n    this.root.color = Color.BLACK;\n  }\n  }\n\n  private leftRotate(currentNode: Node): void {\n    const uncle = currentNode.rightChild;\n    if (uncle !== null) {\n    currentNode.rightChild = uncle.leftChild;\n    if (uncle.leftChild !== null) {\n      uncle.leftChild.parent = currentNode;\n    }\n    uncle.parent = currentNode.parent;\n\n    if (currentNode.parent === null) {\n      this.root = uncle;\n    } else if (currentNode === currentNode.parent.leftChild) {\n      currentNode.parent.leftChild = uncle;\n    } else {\n      currentNode.parent.rightChild = uncle;\n    }\n\n    uncle.leftChild = currentNode;\n    currentNode.parent = uncle;\n  }\n  }\n\n  private rightRotate(uncle: Node): void {\n    const currentNode = uncle.leftChild;\n    if (currentNode !== null) {\n    uncle.leftChild = currentNode.rightChild;\n    if (currentNode.rightChild !== null) {\n      currentNode.rightChild.parent = uncle;\n    }\n    currentNode.parent = uncle.parent;\n\n    if (uncle.parent === null) {\n      this.root = currentNode;\n    } else if (uncle === uncle.parent.leftChild) {\n      uncle.parent.leftChild = currentNode;\n    } else {\n      uncle.parent.rightChild = currentNode;\n    }\n\n    currentNode.rightChild = uncle;\n    uncle.parent = currentNode;\n  }\n  }\n\n  private insertFixup(newNode: Node | null): void {\n    let current = newNode;\n    while (current?.parent !== null && current.parent.color === Color.RED) {\n    if (current.parent === current.parent.parent?.leftChild) {\n      const y = current.parent.parent?.rightChild;\n      if (y !== null && y.color === Color.RED) {\n        current.parent.color = Color.BLACK;\n        y.color = Color.BLACK;\n        if (current.parent.parent !== null) {\n          current.parent.parent.color = Color.RED;\n        }\n        current = current.parent.parent;\n      } else {\n        if (current === current.parent.rightChild) {\n          current = current.parent;\n          this.leftRotate(current);\n        }\n        if (current.parent !== null) {\n          current.parent.color = Color.BLACK;\n        }\n        if (current.parent?.parent !== null) {\n          current.parent.parent.color = Color.RED;\n          this.rightRotate(current.parent.parent);\n        }\n      }\n    } else {\n      const y = current.parent.parent?.leftChild;\n      if (y !== null && y.color === Color.RED) {\n        current.parent.color = Color.BLACK;\n        y.color = Color.BLACK;\n        if (current.parent.parent !== null) {\n          current.parent.parent.color = Color.RED;\n        }\n        current = current.parent.parent;\n      } else {\n        if (current === current.parent.leftChild) {\n          current = current.parent;\n          this.rightRotate(current);\n        }\n        if (current.parent !== null) {\n          current.parent.color = Color.BLACK;\n        }\n        if (current.parent?.parent !== null) {\n          current.parent.parent.color = Color.RED;\n          this.leftRotate(current.parent.parent);\n        }\n      }\n    }\n  }\n  if (this.root !== null) {\n    this.root.color = Color.BLACK;\n  }\n  }\n\n  deleteRBTree(key: number): void {\n    const nodeToDelete = this.search(this.root, key);\n    if (nodeToDelete === null) {\n    return;\n  }\n\n  let successor = nodeToDelete;\n  let successorOriginalColor = successor.color;\n  let successorChild: Node | null;\n\n  if (nodeToDelete.leftChild === null) {\n    successorChild = nodeToDelete.rightChild;\n    this.transplant(nodeToDelete, nodeToDelete.rightChild);\n  } else if (nodeToDelete.rightChild === null) {\n    successorChild = nodeToDelete.leftChild;\n    this.transplant(nodeToDelete, nodeToDelete.leftChild);\n  } else {\n    successor = this.findMinNode(nodeToDelete.rightChild);\n    successorOriginalColor = successor.color;\n    successorChild = successor.rightChild;\n\n    if (successor.parent === nodeToDelete) {\n      if (successorChild !== null) {\n        successorChild.parent = successor;\n      }\n    } else {\n      this.transplant(successor, successor.rightChild);\n      if (successor.rightChild !== null) {\n        successor.rightChild.parent = successor;\n      }\n      successor.rightChild = nodeToDelete.rightChild;\n      if (successor.rightChild !== null) {\n        successor.rightChild.parent = successor;\n      }\n    }\n\n    this.transplant(nodeToDelete, successor);\n    successor.leftChild = nodeToDelete.leftChild;\n    if (successor.leftChild !== null) {\n      successor.leftChild.parent = successor;\n    }\n    successor.color = nodeToDelete.color;\n  }\n\n  if (successorOriginalColor === Color.BLACK) {\n    this.deleteFixup(successorChild);\n  }\n  }\n\n  private search(root: Node | null, key: number): Node | null {\n    let current = root;\n    while (current !== null && current.key !== key) {\n      if (key < current.key) {\n        current = current.leftChild;\n      } else {\n        current = current.rightChild;\n      }\n    }\n    return current;\n  }\n\n  private findMinNode(node: Node): Node {\n    let current = node;\n    while (current.leftChild !== null) {\n      current = current.leftChild;\n    }\n    return current;\n  }\n\n  private transplant(parent: Node, child: Node | null): void {\n    if (parent.parent === null) {\n    this.root = child;\n  } else if (parent === parent.parent.leftChild) {\n    parent.parent.leftChild = child;\n  } else {\n    parent.parent.rightChild = child;\n  }\n\n  if (child !== null) {\n    child.parent = parent.parent;\n  }\n  }\n\n  private deleteFixup(currentNode: Node | null): void {\n    let current = currentNode;\n    while (current !== this.root && (current === null || current.color === Color.BLACK)) {\n      if (current === current?.parent?.leftChild) {\n        let currentNodeSibling = current.parent?.rightChild;\n        if (currentNodeSibling?.color === Color.RED) {\n          currentNodeSibling.color = Color.BLACK;\n          if (current.parent !== null) {\n            current.parent.color = Color.RED;\n          }\n          if (current.parent !== null) {\n            this.leftRotate(current.parent);\n          }\n          currentNodeSibling = current.parent?.rightChild;\n        }\n        if (\n            (currentNodeSibling?.leftChild === null || currentNodeSibling.leftChild.color === Color.BLACK) &&\n            (currentNodeSibling.rightChild === null || currentNodeSibling.rightChild.color === Color.BLACK)\n        ) {\n          if (currentNodeSibling !== null) {\n            currentNodeSibling.color = Color.RED;\n          }\n          current = current.parent;\n        } else {\n          if (currentNodeSibling?.rightChild === null || currentNodeSibling.rightChild.color === Color.BLACK) {\n            if (currentNodeSibling?.leftChild !== null) {\n              currentNodeSibling.leftChild.color = Color.BLACK;\n            }\n            if (currentNodeSibling !== null) {\n              currentNodeSibling.color = Color.RED;\n            }\n            if (current.parent !== null) {\n              this.rightRotate(current.parent);\n            }\n            currentNodeSibling = current.parent?.rightChild;\n          }\n          if (currentNodeSibling !== null) {\n            currentNodeSibling.color = current.parent?.color || Color.BLACK;\n          }\n          if (current.parent !== null) {\n            current.parent.color = Color.BLACK;\n          }\n          if (currentNodeSibling?.rightChild !== null) {\n            currentNodeSibling.rightChild.color = Color.BLACK;\n          }\n          if (current.parent !== null) {\n            this.leftRotate(current.parent);\n          }\n          current = this.root;\n        }\n      } else {\n        let currentNodeSibling = current.parent?.leftChild;\n        if (currentNodeSibling?.color === Color.RED) {\n          currentNodeSibling.color = Color.BLACK;\n          if (current.parent !== null) {\n            current.parent.color = Color.RED;\n          }\n          if (current.parent !== null) {\n            this.rightRotate(current.parent);\n          }\n          currentNodeSibling = current.parent?.leftChild;\n        }\n        if (\n            (currentNodeSibling?.rightChild === null || currentNodeSibling.rightChild.color === Color.BLACK) &&\n            (currentNodeSibling.leftChild === null || currentNodeSibling.leftChild.color === Color.BLACK)\n        ) {\n          if (currentNodeSibling !== null) {\n            currentNodeSibling.color = Color.RED;\n          }\n          current = current.parent;\n        } else {\n          if (currentNodeSibling?.leftChild === null || currentNodeSibling.leftChild.color === Color.BLACK) {\n            if (currentNodeSibling?.rightChild !== null) {\n              currentNodeSibling.rightChild.color = Color.BLACK;\n            }\n            if (currentNodeSibling !== null) {\n              currentNodeSibling.color = Color.RED;\n            }\n            if (current.parent !== null) {\n              this.leftRotate(current.parent);\n            }\n            currentNodeSibling = current.parent?.leftChild;\n          }\n          if (currentNodeSibling !== null) {\n            currentNodeSibling.color = current.parent?.color || Color.BLACK;\n          }\n          if (current.parent !== null) {\n            current.parent.color = Color.BLACK;\n          }\n          if (currentNodeSibling?.leftChild !== null) {\n            currentNodeSibling.leftChild.color = Color.BLACK;\n          }\n          if (current.parent !== null) {\n            this.rightRotate(current.parent);\n          }\n          current = this.root;\n        }\n    }\n  }\n  if (current !== null) {\n    current.color = Color.BLACK;\n  }\n  }\n}\n",p={title:"Red-Black Tree",description:"Red-Black Tree Data Structure",hide_table_of_contents:!0},C=void 0,g={id:"education/computer-science/data-structures/basic/red\u2013black-tree",title:"Red-Black Tree",description:"Red-Black Tree Data Structure",source:"@site/docs/education/01-computer-science/09-data-structures/02-basic/12-red\u2013black-tree.mdx",sourceDirName:"education/01-computer-science/09-data-structures/02-basic",slug:"/education/computer-science/data-structures/basic/red\u2013black-tree",permalink:"/docs/education/computer-science/data-structures/basic/red\u2013black-tree",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/12-red\u2013black-tree.mdx",tags:[],version:"current",sidebarPosition:12,frontMatter:{title:"Red-Black Tree",description:"Red-Black Tree Data Structure",hide_table_of_contents:!0},sidebar:"education",previous:{title:"AVL Tree",permalink:"/docs/education/computer-science/data-structures/basic/avl-tree"},next:{title:"Segment Tree",permalink:"/docs/education/computer-science/data-structures/basic/segment-tree"}},N={},b=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function S(n){const e={admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:r(47885).Z+""})}),"\n",(0,t.jsxs)("table",{children:[(0,t.jsxs)("thead",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Space"}),(0,t.jsx)("th",{colspan:"4",children:"Time"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{}),(0,t.jsx)("th",{children:"Access"}),(0,t.jsx)("th",{children:"Lookup"}),(0,t.jsx)("th",{children:"Insertion"}),(0,t.jsx)("th",{children:"Deletion"})]})]}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"fair",children:"O(n)"})}),(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"good",children:"O(log n)"})}),(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"good",children:"O(log n)"})}),(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"good",children:"O(log n)"})}),(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"good",children:"O(log n)"})})]})})]}),"\n",(0,t.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,t.jsxs)(o.Z,{children:[(0,t.jsxs)(c.Z,{value:"short",label:"Short",children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Red-Black Tree"})," is a type of self-balancing binary search tree that ensures the MAX height of any node is logarithmic and that no path from the root to any leaf node has more than a given\nnumber (usually 2) consecutive red nodes."]}),(0,t.jsx)(e.admonition,{title:"Simplified",type:"note",children:(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Red-Black Tree"})," is like a family tree with specific rules about the color of hats (red or black) each person wears. These rules ensure the tree remains balanced, which makes searching for a\nperson (or data) efficient."]})})]}),(0,t.jsxs)(c.Z,{value:"detailed",label:"Detailed",children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Red-Black Tree"})," is a self-balancing binary search tree. Each node has an extra bit, interpreted as the color (red or black), which helps keep the tree balanced during insertions and deletions."]}),(0,t.jsx)(e.p,{children:"The tree is painted in a way that satisfies certain properties, ensuring it remains approximately balanced. When the tree is modified, it's rearranged and repainted to restore these properties."}),(0,t.jsxs)(e.p,{children:["While the balancing isn't perfect, it guarantees search, insertion, and deletion operations in ",(0,t.jsx)(e.code,{children:"O(log n)"})," time."]}),(0,t.jsx)(e.p,{children:"A red-black tree must satisfy these conditions:"}),(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Each node is either red or black"}),"\n",(0,t.jsx)(e.li,{children:"The root is black"}),"\n",(0,t.jsx)(e.li,{children:"All leaves (\xf8) are black"}),"\n",(0,t.jsx)(e.li,{children:"If a node is red, its children are black"}),"\n",(0,t.jsx)(e.li,{children:"Every path from a node to any of its descendant \xf8 nodes contains the same number of black nodes"}),"\n"]}),(0,t.jsx)(e.p,{children:"These constraints ensure that the path from the root to the farthest leaf is no more than twice as long as the path to the nearest leaf, making the tree roughly height-balanced. This allows\nred-black trees to be efficient in the worst case, unlike ordinary binary search trees."})]})]}),"\n",(0,t.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,t.jsxs)(o.Z,{children:[(0,t.jsx)(c.Z,{value:"practice",label:"Practice",children:(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Aspect"}),(0,t.jsx)("th",{children:"Pseudo Code"})]})}),(0,t.jsxs)("tbody",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"Insertion"}),(0,t.jsx)("td",{children:(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"insert_rbtree(tree, key):\n  new_node = create_node(key)\n  uncle = \xf8\n  current_node = tree.root\n  while current_node != \xf8:\n    uncle = current_node\n    if new_node.key < current_node.key:\n      current_node = current_node.left_child\n    else:\n      current_node = current_node.right_child\n  new_node.parent = uncle\n  if uncle == \xf8:\n    tree.root = new_node\n  elif new_node.key < uncle.key:\n    uncle.left_child = new_node\n  else:\n    uncle.right_child = new_node\n\n  insert_fixup(tree, new_node)\n  tree.root.color = BLACK # Ensure the root is always black\n\ncreate_node(key):\n  node = new Node()\n  node.key = key\n  node.color = RED\n  node.left_child = \xf8\n  node.right_child = \xf8\n  node.parent = \xf8\n  return node\n\nleft_rotate(tree, current_node):\n  uncle = current_node.right_child\n  current_node.right_child = uncle.left_child\n  if uncle.left_child != \xf8:\n    uncle.left_child.parent = current_node\n  uncle.parent = current_node.parent\n  if current_node.parent == \xf8:\n    tree.root = uncle\n  elif current_node == current_node.parent.left_child:\n    current_node.parent.left_child = uncle\n  else:\n    current_node.parent.right_child = uncle\n  uncle.left_child = current_node\n  current_node.parent = uncle\n\nright_rotate(tree, uncle):\n  current_node = uncle.left_child\n  uncle.left_child = current_node.right_child\n  if current_node.right_child != \xf8:\n    current_node.right_child.parent = uncle\n  current_node.parent = uncle.parent\n  if uncle.parent == \xf8:\n    tree.root = current_node\n  elif uncle == uncle.parent.left_child:\n    uncle.parent.left_child = current_node\n  else:\n    uncle.parent.right_child = current_node\n  current_node.right_child = uncle\n  uncle.parent = current_node\n\ninsert_fixup(tree, new_node):\n  while new_node.parent != \xf8 and new_node.parent.color == RED:\n    if new_node.parent == new_node.parent.parent.left_child:\n      grand_parent_child = new_node.parent.parent.right_child\n      if grand_parent_child != \xf8 and grand_parent_child.color == RED:\n        new_node.parent.color = BLACK\n        grand_parent_child.color = BLACK\n        new_node.parent.parent.color = RED\n        new_node = new_node.parent.parent\n      else:\n        if new_node == new_node.parent.right_child:\n          new_node = new_node.parent\n          left_rotate(tree, new_node)\n        new_node.parent.color = BLACK\n        new_node.parent.parent.color = RED\n        right_rotate(tree, new_node.parent.parent)\n    else:\n      grand_parent_child = new_node.parent.parent.left_child\n      if grand_parent_child != \xf8 and grand_parent_child.color == RED:\n        new_node.parent.color = BLACK\n        grand_parent_child.color = BLACK\n        new_node.parent.parent.color = RED\n        new_node = new_node.parent.parent\n      else:\n        if new_node == new_node.parent.left_child:\n          new_node = new_node.parent\n          right_rotate(tree, new_node)\n        new_node.parent.color = BLACK\n        new_node.parent.parent.color = RED\n        left_rotate(tree, new_node.parent.parent)\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"Deletion"}),(0,t.jsx)("td",{children:(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"delete_rbtree(tree, key):\n  node_to_delete = search(tree.root, key)\n  if node_to_delete == \xf8:\n    return\n\n  successor = node_to_delete\n  successor_original_color = successor.color\n  if node_to_delete.left_child == \xf8:\n    successor_child = node_to_delete.right_child\n    transplant(tree, node_to_delete, node_to_delete.right_child)\n  elif node_to_delete.right_child == \xf8:\n    successor_child = node_to_delete.left_child\n    transplant(tree, node_to_delete, node_to_delete.left_child)\n  else:\n    successor = find_min_node(node_to_delete.right_child)\n    successor_original_color = successor.color\n    successor_child = successor.right_child\n    if successor.parent == node_to_delete:\n      successor_child.parent = successor\n    else:\n      transplant(tree, successor, successor.right_child)\n      successor.right_child = node_to_delete.right_child\n      successor.right_child.parent = successor\n    transplant(tree, node_to_delete, successor)\n    successor.left_child = node_to_delete.left_child\n    successor.left_child.parent = successor\n    successor.color = node_to_delete.color\n  if successor_original_color == BLACK:\n    delete_fixup(tree, successor_child)\n\nsearch(root, key):\n  current = root\n  while current != \xf8 and current.key != key:\n    if key < current.key:\n      current = current.left_child\n    else:\n      current = current.right_child\n  return current\n\nfind_min_node(node):\n  while node.left_child != \xf8:\n    node = node.left_child\n  return node\n\ntransplant(tree, parent, child):\n  if parent.parent == \xf8:\n    tree.root = child\n  elif parent == parent.parent.left_child:\n    parent.parent.left_child = child\n  else:\n    parent.parent.right_child = child\n  if child != \xf8:\n    child.parent = parent.parent\n\ndelete_fixup(tree, current_node):\n  while current_node != tree.root and (current_node == \xf8 or current_node.color == BLACK):\n    if current_node == current_node.parent.left_child:\n      current_node_sibling = current_node.parent.right_child\n      if current_node_sibling.color == RED:\n        current_node_sibling.color = BLACK\n        current_node.parent.color = RED\n        left_rotate(tree, current_node.parent)\n        current_node_sibling = current_node.parent.right_child\n      if (current_node_sibling.left_child == \xf8 or current_node_sibling.left_child.color == BLACK) and (current_node_sibling.right_child == \xf8 or current_node_sibling.right_child.color == BLACK):\n        current_node_sibling.color = RED\n        current_node = current_node.parent\n      else:\n        if current_node_sibling.right_child == \xf8 or current_node_sibling.right_child.color == BLACK:\n          current_node_sibling.left_child.color = BLACK\n          current_node_sibling.color = RED\n          right_rotate(tree, current_node_sibling)\n          current_node_sibling = current_node.parent.right_child\n        current_node_sibling.color = current_node.parent.color\n        current_node.parent.color = BLACK\n        current_node_sibling.right_child.color = BLACK\n        left_rotate(tree, current_node.parent)\n        current_node = tree.root\n    else:\n      current_node_sibling = current_node.parent.left_child\n      if current_node_sibling.color == RED:\n        current_node_sibling.color = BLACK\n        current_node.parent.color = RED\n        right_rotate(tree, current_node.parent)\n        current_node_sibling = current_node.parent.left_child\n      if (current_node_sibling.right_child == \xf8 or current_node_sibling.right_child.color == BLACK) and (current_node_sibling.left_child == \xf8 or current_node_sibling.left_child.color == BLACK):\n        current_node_sibling.color = RED\n        current_node = current_node.parent\n      else:\n        if current_node_sibling.left_child == \xf8 or current_node_sibling.left_child.color == BLACK:\n          current_node_sibling.right_child.color = BLACK\n          current_node_sibling.color = RED\n          left_rotate(tree, current_node_sibling)\n          current_node_sibling = current_node.parent.left_child\n        current_node_sibling.color = current_node.parent.color\n        current_node.parent.color = BLACK\n        current_node_sibling.left_child.color = BLACK\n        right_rotate(tree, current_node.parent)\n        current_node = tree.root\n"})})})]})]})]})}),(0,t.jsx)(c.Z,{value:"solution",label:"Solution",children:(0,t.jsxs)(o.Z,{queryString:"code",children:[(0,t.jsx)(c.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,t.jsx)(i.Z,{language:"go",children:d})}),(0,t.jsx)(c.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,t.jsx)(i.Z,{language:"java",children:u})}),(0,t.jsx)(c.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,t.jsx)(i.Z,{language:"js",children:s})}),(0,t.jsx)(c.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,t.jsx)(i.Z,{language:"kotlin",children:a})}),(0,t.jsx)(c.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,t.jsx)(i.Z,{language:"python",children:h})}),(0,t.jsx)(c.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,t.jsx)(i.Z,{language:"rust",children:f})}),(0,t.jsx)(c.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,t.jsx)(i.Z,{language:"ts",children:_})})]})})]})]})}function R(n={}){const{wrapper:e}={...(0,l.a)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(S,{...n})}):S(n)}},47885:(n,e,r)=>{r.d(e,{Z:()=>t});const t=r.p+"assets/images/redBlackTree-d7df48e2f01027815124775b09018226.svg"}}]);