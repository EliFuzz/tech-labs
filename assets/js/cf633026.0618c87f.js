"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[4804],{38054:(n,t,i)=>{i.r(t),i.d(t,{assets:()=>v,contentTitle:()=>f,default:()=>S,frontMatter:()=>g,metadata:()=>e,toc:()=>b});const e=JSON.parse('{"id":"education/computer-science/algorithms/algo/radix-sort","title":"Radix Sort","description":"Radix Sort","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/radix-sort.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/radix-sort","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/radix-sort","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/radix-sort.mdx","tags":[],"version":"current","frontMatter":{"title":"Radix Sort","description":"Radix Sort","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Radian & Degree","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/radian-and-degree"},"next":{"title":"Rail Fence Cipher","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/rail-fence-cipher"}}');var r=i(86070),a=i(15658),o=i(52421),c=i(74610),l=i(42953);const s='package main\n\nimport (\n    "strconv"\n)\n\nfunc getMax(arr []int) int {\n    max := arr[0]\n    for _, val := range arr {\n        if val > max {\n            max = val\n        }\n    }\n    return max\n}\n\nfunc countSort(arr []int, exp int) {\n    n := len(arr)\n    output := make([]int, n)\n    count := make([]int, 10)\n\n    for i := 0; i < n; i++ {\n        count[(arr[i]/exp)%10]++\n    }\n\n    for i := 1; i < 10; i++ {\n        count[i] += count[i-1]\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        output[count[(arr[i]/exp)%10]-1] = arr[i]\n        count[(arr[i]/exp)%10]--\n    }\n\n    for i := 0; i < n; i++ {\n        arr[i] = output[i]\n    }\n}\n\nfunc radixSort(arr []int) {\n    max := getMax(arr)\n    for exp := 1; max/exp > 0; exp *= 10 {\n        countSort(arr, exp)\n    }\n}\n',u="import java.util.Arrays;\n\npublic class RadixSort {\n\n  public static void radixSort(int[] arr) {\n    int max = getMax(arr);\n    for (int exp = 1; max / exp > 0; exp *= 10) {\n      countSort(arr, exp);\n    }\n  }\n\n  private static void countSort(int[] arr, int exp) {\n    int n = arr.length;\n    int[] output = new int[n];\n    int[] count = new int[10];\n\n    for (int i = 0; i < n; i++) {\n      count[(arr[i] / exp) % 10]++;\n    }\n\n    for (int i = 1; i < 10; i++) {\n      count[i] += count[i - 1];\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n      output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n      count[(arr[i] / exp) % 10]--;\n    }\n\n    System.arraycopy(output, 0, arr, 0, n);\n  }\n\n  private static int getMax(int[] arr) {\n    int max = arr[0];\n    for (int val : arr) {\n      if (val > max) {\n        max = val;\n      }\n    }\n    return max;\n  }\n}\n",x="function getMax(arr) {\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n}\n\nfunction countSort(arr, exp) {\n  const n = arr.length;\n  const output = new Array(n).fill(0);\n  const count = new Array(10).fill(0);\n\n  for (let i = 0; i < n; i++) {\n    count[Math.floor(arr[i] / exp) % 10]++;\n  }\n\n  for (let i = 1; i < 10; i++) {\n    count[i] += count[i - 1];\n  }\n\n  for (let i = n - 1; i >= 0; i--) {\n    output[count[Math.floor(arr[i] / exp) % 10] - 1] = arr[i];\n    count[Math.floor(arr[i] / exp) % 10]--;\n  }\n\n  for (let i = 0; i < n; i++) {\n    arr[i] = output[i];\n  }\n}\n\nfunction radixSort(arr) {\n  const max = getMax(arr);\n  for (let exp = 1; Math.floor(max / exp) > 0; exp *= 10) {\n    countSort(arr, exp);\n  }\n}\n",d="fun getMax(arr: IntArray): Int {\n    var max = arr[0]\n    for (i in 1 until arr.size) {\n        if (arr[i] > max) {\n            max = arr[i]\n        }\n    }\n    return max\n}\n\nfun countSort(arr: IntArray, exp: Int) {\n    val n = arr.size\n    val output = IntArray(n)\n    val count = IntArray(10)\n\n    for (i in 0 until n) {\n        count[arr[i] / exp % 10]++\n    }\n\n    for (i in 1 until 10) {\n        count[i] += count[i - 1]\n    }\n\n    for (i in n - 1 downTo 0) {\n        output[count[arr[i] / exp % 10] - 1] = arr[i]\n        count[arr[i] / exp % 10]--\n    }\n\n    output.copyInto(arr)\n}\n\nfun radixSort(arr: IntArray) {\n    val max = getMax(arr)\n    var exp = 1\n    while (max / exp > 0) {\n        countSort(arr, exp)\n        exp *= 10\n    }\n}\n",p="def getMax(arr):\n    max_val = arr[0]\n    for val in arr:\n        if val > max_val:\n            max_val = val\n    return max_val\n\ndef countSort(arr, exp):\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n\n    for i in range(n):\n        count[arr[i] // exp % 10] += 1\n\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n\n    i = n - 1\n    while i >= 0:\n        output[count[arr[i] // exp % 10] - 1] = arr[i]\n        count[arr[i] // exp % 10] -= 1\n        i -= 1\n\n    for i in range(n):\n        arr[i] = output[i]\n\ndef radixSort(arr):\n    max_val = getMax(arr)\n    exp = 1\n    while max_val // exp > 0:\n        countSort(arr, exp)\n        exp *= 10\n",h="fn get_max(arr: &Vec<u32>) -> u32 {\n    let mut max = arr[0];\n    for &val in arr.iter() {\n        if val > max {\n            max = val;\n        }\n    }\n    max\n}\n\nfn count_sort(arr: &mut Vec<u32>, exp: u32) {\n    let n = arr.len();\n    let mut output = vec![0; n];\n    let mut count = vec![0; 10];\n\n    for &val in arr.iter() {\n        count[((val / exp) % 10) as usize] += 1;\n    }\n\n    for i in 1..10 {\n        count[i] += count[i - 1];\n    }\n\n    for &val in arr.iter().rev() {\n        let index = ((val / exp) % 10) as usize;\n        output[count[index] as usize - 1] = val;\n        count[index] -= 1;\n    }\n\n    arr.copy_from_slice(&output);\n}\n\nfn radix_sort(arr: &mut Vec<u32>) {\n    let max = get_max(arr);\n    let mut exp = 1;\n    while max / exp > 0 {\n        count_sort(arr, exp);\n        exp *= 10;\n    }\n}\n",m="function getMax(arr: number[]): number {\n  let max = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n    }\n  }\n  return max;\n}\n\nfunction countSort(arr: number[], exp: number): void {\n  const n = arr.length;\n  const output: number[] = new Array(n).fill(0);\n  const count: number[] = new Array(10).fill(0);\n\n  for (let i = 0; i < n; i++) {\n    count[Math.floor(arr[i] / exp) % 10]++;\n  }\n\n  for (let i = 1; i < 10; i++) {\n    count[i] += count[i - 1];\n  }\n\n  for (let i = n - 1; i >= 0; i--) {\n    output[count[Math.floor(arr[i] / exp) % 10] - 1] = arr[i];\n    count[Math.floor(arr[i] / exp) % 10]--;\n  }\n\n  for (let i = 0; i < n; i++) {\n    arr[i] = output[i];\n  }\n}\n\nfunction radixSort(arr: number[]): void {\n  const max = getMax(arr);\n  let exp = 1;\n  while (Math.floor(max / exp) > 0) {\n    countSort(arr, exp);\n    exp *= 10;\n  }\n}\n",g={title:"Radix Sort",description:"Radix Sort",hide_table_of_contents:!0},f=void 0,v={},b=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function j(n){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(o.A,{queryString:"primary",children:[(0,r.jsx)(c.A,{value:"definition",label:"Definition",children:(0,r.jsx)(t.p,{children:"Radix Sort is a non-comparative sorting algorithm that sorts integers by grouping them based on individual digits or radix (base). It works by iterating through each digit of the numbers, starting from the least significant digit (rightmost) to the most significant digit (leftmost). Radix Sort can be implemented using different approaches like LSD (Least Significant Digit) or MSD (Most Significant Digit)"})}),(0,r.jsx)(c.A,{value:"how",label:"Explanation",children:(0,r.jsx)(t.p,{children:"Radix Sort sorts numbers by placing them into buckets based on the value of their digits at a specific position. It starts from the least significant digit, placing each number into its respective bucket based on that digit. Then, it gathers the numbers from the buckets and repeats the process for the next significant digit until all digits have been considered. This process sorts the numbers effectively, as at each iteration, the numbers are arranged based on increasingly significant digits, leading to the final sorted sequence"})}),(0,r.jsx)(c.A,{value:"guidance",label:"Guidance",children:(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Identify the maximum number of digits in the given list of integers to determine the number of iterations required","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"start from the least significant digit and iterate through each digit position"}),"\n",(0,r.jsx)(t.li,{children:"for each iteration, create buckets for each digit (0-9)"}),"\n",(0,r.jsx)(t.li,{children:"iterate through the list of integers and place each number into the corresponding bucket based on the digit at the current position"}),"\n",(0,r.jsx)(t.li,{children:"gather the numbers from the buckets in the order they were placed and overwrite the original list with the sorted sequence"}),"\n",(0,r.jsx)(t.li,{children:"repeat steps for each digit position until all digits have been considered"}),"\n"]}),"\n"]}),"\n"]})}),(0,r.jsx)(c.A,{value:"tips",label:"Tips",children:(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"ensure proper handling of negative numbers and zero-padding to maintain the significance of digits"}),"\n",(0,r.jsx)(t.li,{children:"choose the appropriate approach (LSD or MSD) based on the characteristics of the data to optimize performance"}),"\n",(0,r.jsx)(t.li,{children:"implement efficient bucketing and gathering strategies to minimize overhead"}),"\n",(0,r.jsx)(t.li,{children:"consider the range of integers in the input data to optimize bucket sizes and reduce memory consumption"}),"\n"]})})]}),"\n",(0,r.jsx)(t.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(o.A,{queryString:"primary",children:[(0,r.jsx)(c.A,{value:"practice",label:"Practice",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"radix_sort(arr):\n  max_digit = getMax(arr)\n  exp = 1\n  while max_digit // exp > 0:\n    counting_sort(arr, exp)\n    exp *= 10\n\ncounting_sort(arr, exp):\n  n = len(arr)\n  output = [0] * n\n  count = [0] * 10\n\n  for i in range(n):\n    index = arr[i] // exp % 10\n    count[index] += 1\n\n  for i in range(1, 10):\n    count[i] += count[i - 1]\n\n  i = n - 1\n  while i >= 0:\n    index = arr[i] // exp % 10\n    output[count[index] - 1] = arr[i]\n    count[index] -= 1\n    i -= 1\n\n  for i in range(n):\n    arr[i] = output[i]\n\ngetMax(arr):\n  max_num = max(arr)\n  max_digit = len(str(max_num))\n  return max_digit\n"})})}),(0,r.jsx)(c.A,{value:"solution",label:"Solution",children:(0,r.jsxs)(o.A,{queryString:"code",children:[(0,r.jsx)(c.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(l.A,{language:"go",children:s})}),(0,r.jsx)(c.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(l.A,{language:"java",children:u})}),(0,r.jsx)(c.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(l.A,{language:"js",children:x})}),(0,r.jsx)(c.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(l.A,{language:"kotlin",children:d})}),(0,r.jsx)(c.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(l.A,{language:"python",children:p})}),(0,r.jsx)(c.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(l.A,{language:"rust",children:h})}),(0,r.jsx)(c.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(l.A,{language:"ts",children:m})})]})})]})]})}function S(n={}){const{wrapper:t}={...(0,a.R)(),...n.components};return t?(0,r.jsx)(t,{...n,children:(0,r.jsx)(j,{...n})}):j(n)}}}]);