"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[355],{68338:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>k,contentTitle:()=>g,default:()=>b,frontMatter:()=>u,metadata:()=>m,toc:()=>j});var i=t(86070),s=t(25710),r=t(98459),a=t(37515),o=t(18792);const l="package main\n\ntype Graph struct {\n    vertices int\n    edges    [][]int\n}\n\nfunc NewGraph(vertices int) *Graph {\n    return &Graph{\n        vertices: vertices,\n        edges:    make([][]int, vertices),\n    }\n}\n\nfunc (g *Graph) AddEdge(u, v int) {\n    g.edges[u] = append(g.edges[u], v)\n}\n\nfunc (g *Graph) dfsUtil(vertex int, visited []bool, stack *Stack) {\n    visited[vertex] = true\n    for _, adj := range g.edges[vertex] {\n        if !visited[adj] {\n            g.dfsUtil(adj, visited, stack)\n        }\n    }\n    stack.Push(vertex)\n}\n\nfunc (g *Graph) getTranspose() *Graph {\n    transpose := NewGraph(g.vertices)\n    for i := 0; i < g.vertices; i++ {\n        for _, adj := range g.edges[i] {\n            transpose.AddEdge(adj, i)\n        }\n    }\n    return transpose\n}\n\nfunc (g *Graph) fillOrder(vertex int, visited []bool, stack *Stack) {\n    visited[vertex] = true\n    for _, adj := range g.edges[vertex] {\n        if !visited[adj] {\n            g.fillOrder(adj, visited, stack)\n        }\n    }\n    stack.Push(vertex)\n}\n\nfunc (g *Graph) Kosaraju() {\n    stack := NewStack()\n    visited := make([]bool, g.vertices)\n\n    for i := 0; i < g.vertices; i++ {\n        if !visited[i] {\n            g.dfsUtil(i, visited, stack)\n        }\n    }\n\n    transpose := g.getTranspose()\n    for i := range visited {\n        visited[i] = false\n    }\n\n    for !stack.IsEmpty() {\n        vertex := stack.Pop()\n        if !visited[vertex] {\n            var scc []int\n            transpose.fillOrder(vertex, visited, stack)\n            for !stack.IsEmpty() {\n                v := stack.Pop()\n                scc = append(scc, v)\n                visited[v] = true\n            }\n            fmt.Println(scc)\n        }\n    }\n}\n\ntype Stack []int\n\nfunc NewStack() *Stack {\n    return &Stack{}\n}\n\nfunc (s *Stack) Push(value int) {\n    *s = append(*s, value)\n}\n\nfunc (s *Stack) Pop() int {\n    stack := *s\n    top := stack[len(stack)-1]\n    *s = stack[:len(stack)-1]\n    return top\n}\n\nfunc (s *Stack) IsEmpty() bool {\n    return len(*s) == 0\n}\n",d="import java.util.*;\n\nclass Graph {\n\n  private int vertices;\n  private LinkedList<Integer>[] adj;\n\n  Graph(int vertices) {\n    this.vertices = vertices;\n    adj = new LinkedList[vertices];\n    for (int i = 0; i < vertices; ++i) {\n      adj[i] = new LinkedList();\n    }\n  }\n\n  void addEdge(int v, int w) {\n    adj[v].add(w);\n  }\n\n  void dfsUtil(int v, boolean[] visited, Stack<Integer> stack) {\n    visited[v] = true;\n    for (Integer i : adj[v]) {\n      if (!visited[i]) {\n        dfsUtil(i, visited, stack);\n      }\n    }\n    stack.push(v);\n  }\n\n  Graph getTranspose() {\n    Graph g = new Graph(vertices);\n    for (int v = 0; v < vertices; v++) {\n      for (Integer i : adj[v]) {\n        g.addEdge(i, v);\n      }\n    }\n    return g;\n  }\n\n  void fillOrder(int v, boolean[] visited, Stack<Integer> stack) {\n    visited[v] = true;\n    for (Integer i : adj[v]) {\n      if (!visited[i]) {\n        fillOrder(i, visited, stack);\n      }\n    }\n    stack.push(v);\n  }\n\n  void printSCCs() {\n    Stack<Integer> stack = new Stack<>();\n\n    boolean[] visited = new boolean[vertices];\n    for (int i = 0; i < vertices; i++) {\n      visited[i] = false;\n    }\n\n    for (int i = 0; i < vertices; i++) {\n      if (!visited[i]) {\n        dfsUtil(i, visited, stack);\n      }\n    }\n\n    Graph transpose = getTranspose();\n\n    for (int i = 0; i < vertices; i++) {\n      visited[i] = false;\n    }\n\n    while (!stack.empty()) {\n      int v = stack.pop();\n      if (!visited[v]) {\n        transpose.fillOrder(v, visited, stack);\n        System.out.println();\n      }\n    }\n  }\n}\n",c="class Graph {\n  constructor(vertices) {\n    this.vertices = vertices;\n    this.adj = new Array(vertices).fill().map(() => []);\n  }\n\n  addEdge(v, w) {\n    this.adj[v].push(w);\n  }\n\n  dfsUtil(v, visited, stack) {\n    visited[v] = true;\n    for (let i of this.adj[v]) {\n      if (!visited[i]) {\n        this.dfsUtil(i, visited, stack);\n      }\n    }\n    stack.push(v);\n  }\n\n  getTranspose() {\n    let g = new Graph(this.vertices);\n    for (let v = 0; v < this.vertices; v++) {\n      for (let i of this.adj[v]) {\n        g.addEdge(i, v);\n      }\n    }\n    return g;\n  }\n\n  fillOrder(v, visited, stack) {\n    visited[v] = true;\n    for (let i of this.adj[v]) {\n      if (!visited[i]) {\n        this.fillOrder(i, visited, stack);\n      }\n    }\n    stack.push(v);\n  }\n\n  printSCCs() {\n    let stack = [];\n\n    let visited = new Array(this.vertices).fill(false);\n    for (let i = 0; i < this.vertices; i++) {\n      if (!visited[i]) {\n        this.dfsUtil(i, visited, stack);\n      }\n    }\n\n    let transpose = this.getTranspose();\n\n    visited = new Array(this.vertices).fill(false);\n\n    while (stack.length !== 0) {\n      let v = stack.pop();\n      if (!visited[v]) {\n        transpose.fillOrder(v, visited, stack);\n        console.log();\n      }\n    }\n  }\n}\n",v="import java.util.*\n\nclass Graph(private val vertices: Int) {\n    private val adj: Array<LinkedList<Int>> = Array(vertices) { LinkedList() }\n\n    fun addEdge(v: Int, w: Int) {\n        adj[v].add(w)\n    }\n\n    private fun dfsUtil(v: Int, visited: BooleanArray, stack: Stack<Int>) {\n        visited[v] = true\n        for (i in adj[v]) {\n            if (!visited[i]) {\n                dfsUtil(i, visited, stack)\n            }\n        }\n        stack.push(v)\n    }\n\n    private fun getTranspose(): Graph {\n        val g = Graph(vertices)\n        for (v in 0 until vertices) {\n            for (i in adj[v]) {\n                g.addEdge(i, v)\n            }\n        }\n        return g\n    }\n\n    private fun fillOrder(v: Int, visited: BooleanArray, stack: Stack<Int>) {\n        visited[v] = true\n        for (i in adj[v]) {\n            if (!visited[i]) {\n                fillOrder(i, visited, stack)\n            }\n        }\n        stack.push(v)\n    }\n\n    fun printSCCs() {\n        val stack = Stack<Int>()\n\n        val visited = BooleanArray(vertices)\n        for (i in 0 until vertices) {\n            visited[i] = false\n        }\n\n        for (i in 0 until vertices) {\n            if (!visited[i]) {\n                dfsUtil(i, visited, stack)\n            }\n        }\n\n        val transpose = getTranspose()\n\n        for (i in 0 until vertices) {\n            visited[i] = false\n        }\n\n        while (!stack.isEmpty()) {\n            val v = stack.pop()\n            if (!visited[v]) {\n                transpose.fillOrder(v, visited, stack)\n                println()\n            }\n        }\n    }\n}\n",h="from collections import defaultdict\n\nclass Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append(v)\n\n    def dfsUtil(self, v, visited, stack):\n        visited[v] = True\n        for i in self.graph[v]:\n            if not visited[i]:\n                self.dfsUtil(i, visited, stack)\n        stack.append(v)\n\n    def getTranspose(self):\n        g = Graph(self.V)\n        for i in self.graph:\n            for j in self.graph[i]:\n                g.addEdge(j, i)\n        return g\n\n    def fillOrder(self, v, visited, stack):\n        visited[v] = True\n        for i in self.graph[v]:\n            if not visited[i]:\n                self.fillOrder(i, visited, stack)\n        stack.append(v)\n\n    def printSCCs(self):\n        stack = []\n        visited = [False] * self.V\n        for i in range(self.V):\n            if not visited[i]:\n                self.dfsUtil(i, visited, stack)\n        gr = self.getTranspose()\n        visited = [False] * self.V\n        while stack:\n            i = stack.pop()\n            if not visited[i]:\n                gr.fillOrder(i, visited, [])\n                print()\n",p="use std::collections::LinkedList;\nuse std::collections::VecDeque;\n\nstruct Graph {\n    vertices: usize,\n    adj: Vec<LinkedList<usize>>,\n}\n\nimpl Graph {\n    fn new(vertices: usize) -> Graph {\n        Graph {\n            vertices,\n            adj: vec![LinkedList::new(); vertices],\n        }\n    }\n\n    fn add_edge(&mut self, v: usize, w: usize) {\n        self.adj[v].push_back(w);\n    }\n\n    fn dfs_util(&self, v: usize, visited: &mut Vec<bool>, stack: &mut Vec<usize>) {\n        visited[v] = true;\n        for i in &self.adj[v] {\n            if !visited[*i] {\n                self.dfs_util(*i, visited, stack);\n            }\n        }\n        stack.push(v);\n    }\n\n    fn get_transpose(&self) -> Graph {\n        let mut g = Graph::new(self.vertices);\n        for v in 0..self.vertices {\n            for i in &self.adj[v] {\n                g.add_edge(*i, v);\n            }\n        }\n        g\n    }\n\n    fn fill_order(&self, v: usize, visited: &mut Vec<bool>, stack: &mut Vec<usize>) {\n        visited[v] = true;\n        for i in &self.adj[v] {\n            if !visited[*i] {\n                self.fill_order(*i, visited, stack);\n            }\n        }\n        stack.push(v);\n    }\n\n    fn print_sccs(&self) {\n        let mut stack: Vec<usize> = Vec::new();\n        let mut visited: Vec<bool> = vec![false; self.vertices];\n        for i in 0..self.vertices {\n            if !visited[i] {\n                self.dfs_util(i, &mut visited, &mut stack);\n            }\n        }\n\n        let transpose = self.get_transpose();\n\n        for i in 0..self.vertices {\n            visited[i] = false;\n        }\n\n        while let Some(v) = stack.pop() {\n            if !visited[v] {\n                transpose.fill_order(v, &mut visited, &mut Vec::new());\n                println!();\n            }\n        }\n    }\n}\n",f="class Graph {\n  private vertices: number;\n  private adj: number[][];\n\n  constructor(vertices: number) {\n    this.vertices = vertices;\n    this.adj = Array.from({ length: vertices }, () => []);\n  }\n\n  addEdge(v: number, w: number) {\n    this.adj[v].push(w);\n  }\n\n  dfsUtil(v: number, visited: boolean[], stack: number[]) {\n    visited[v] = true;\n    for (let i of this.adj[v]) {\n      if (!visited[i]) {\n        this.dfsUtil(i, visited, stack);\n      }\n    }\n    stack.push(v);\n  }\n\n  getTranspose(): Graph {\n    let g = new Graph(this.vertices);\n    for (let v = 0; v < this.vertices; v++) {\n      for (let i of this.adj[v]) {\n        g.addEdge(i, v);\n      }\n    }\n    return g;\n  }\n\n  fillOrder(v: number, visited: boolean[], stack: number[]) {\n    visited[v] = true;\n    for (let i of this.adj[v]) {\n      if (!visited[i]) {\n        this.fillOrder(i, visited, stack);\n      }\n    }\n    stack.push(v);\n  }\n\n  printSCCs() {\n    let stack: number[] = [];\n\n    let visited: boolean[] = new Array(this.vertices).fill(false);\n    for (let i = 0; i < this.vertices; i++)\n      if (!visited[i]) this.dfsUtil(i, visited, stack);\n\n    let transpose = this.getTranspose();\n\n    visited = new Array(this.vertices).fill(false);\n\n    while (stack.length !== 0) {\n      let v = stack.pop()!;\n      if (!visited[v]) {\n        transpose.fillOrder(v, visited, stack);\n        console.log();\n      }\n    }\n  }\n}\n",u={title:"Strongly Connected Components - Kosaraju's Algorithm",description:"Strongly Connected Components - Kosaraju's Algorithm",hide_table_of_contents:!0},g=void 0,m={id:"education/computer-science/algorithms/algo/strongly-connected-components-kosarajus-algorithm",title:"Strongly Connected Components - Kosaraju's Algorithm",description:"Strongly Connected Components - Kosaraju's Algorithm",source:"@site/docs/education/01-computer-science/10-algorithms/04-algo/strongly-connected-components-kosarajus-algorithm.mdx",sourceDirName:"education/01-computer-science/10-algorithms/04-algo",slug:"/education/computer-science/algorithms/algo/strongly-connected-components-kosarajus-algorithm",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/strongly-connected-components-kosarajus-algorithm",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/strongly-connected-components-kosarajus-algorithm.mdx",tags:[],version:"current",frontMatter:{title:"Strongly Connected Components - Kosaraju's Algorithm",description:"Strongly Connected Components - Kosaraju's Algorithm",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Straight Traversal",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/straight-traversal"},next:{title:"Topological Sorting",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/topological-sorting"}},k={},j=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function x(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(r.A,{queryString:"primary",children:[(0,i.jsx)(a.A,{value:"definition",label:"Definition",children:(0,i.jsx)(n.p,{children:"Kosaraju's Algorithm is a method used to find strongly connected components (SCCs) within a directed graph. It efficiently identifies groups of vertices where each vertex is reachable from every other vertex within the same group. This algorithm relies on depth-first search (DFS) techniques to traverse the graph twice, first to determine the order of vertices for the second traversal, and then to identify the SCCs"})}),(0,i.jsx)(a.A,{value:"how",label:"Explanation",children:(0,i.jsx)(n.p,{children:"Operates in 2 main phases. First, it performs a DFS on the given graph to determine the order in which vertices should be processed. Then, it transposes the graph (reverses the direction of all edges) and performs another DFS based on the determined order to identify the strongly connected components"})}),(0,i.jsx)(a.A,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Start with a directed graph represented as an adjacency list or matrix"}),"\n",(0,i.jsx)(n.li,{children:"Perform a DFS traversal on the graph, keeping track of the order in which vertices finish their recursive calls"}),"\n",(0,i.jsx)(n.li,{children:"Reverse the direction of all edges in the graph to create a transposed graph"}),"\n",(0,i.jsx)(n.li,{children:"Perform another DFS traversal on the transposed graph, using the order obtained from the first traversal"}),"\n",(0,i.jsx)(n.li,{children:"Each tree in the DFS forest of the transposed graph represents a strongly connected component"}),"\n"]})}),(0,i.jsx)(a.A,{value:"tips",label:"Tips",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ensure proper implementation of the DFS algorithm with appropriate data structures (such as stacks or recursion)"}),"\n",(0,i.jsx)(n.li,{children:"pay attention to the order of vertices obtained in the first traversal as it determines the sequence for the second traversal"}),"\n",(0,i.jsx)(n.li,{children:"utilize efficient data structures for tracking visited vertices and storing the SCCs"}),"\n"]})})]}),"\n",(0,i.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(r.A,{queryString:"primary",children:[(0,i.jsx)(a.A,{value:"practice",label:"Practice",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"kosaraju(graph):\n    order = [] # to store the order of vertices\n    visited = set() # set to keep track of visited vertices\n\n    # Phase 1: Perform DFS to determine the order of vertices\n    for each vertex in graph:\n        if vertex not in visited:\n            DFS(graph, vertex, visited, order)\n\n    # Transpose the graph\n    transposed_graph = transpose(graph)\n\n    # Phase 2: Perform DFS on the transposed graph in the determined order\n    visited.clear()\n    SCCs = []\n    while order is not empty:\n        vertex = order.pop()\n        if vertex not in visited:\n            SCC = []\n            DFS(transposed_graph, vertex, visited, SCC)\n            SCCs.append(SCC)\n\n    return SCCs\n\nDFS(graph, vertex, visited, result):\n    visited.add(vertex)\n    for neighbor in graph[vertex]:\n        if neighbor not in visited:\n            DFS(graph, neighbor, visited, result)\n    result.append(vertex)\n\ntranspose(graph):\n    transposed_graph = {}\n    for vertex in graph:\n        transposed_graph[vertex] = []\n    for vertex in graph:\n        for neighbor in graph[vertex]:\n            transposed_graph[neighbor].append(vertex)\n    return transposed_graph\n"})})}),(0,i.jsx)(a.A,{value:"solution",label:"Solution",children:(0,i.jsxs)(r.A,{queryString:"code",children:[(0,i.jsx)(a.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(o.A,{language:"go",children:l})}),(0,i.jsx)(a.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(o.A,{language:"java",children:d})}),(0,i.jsx)(a.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(o.A,{language:"js",children:c})}),(0,i.jsx)(a.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(o.A,{language:"kotlin",children:v})}),(0,i.jsx)(a.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(o.A,{language:"python",children:h})}),(0,i.jsx)(a.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(o.A,{language:"rust",children:p})}),(0,i.jsx)(a.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(o.A,{language:"ts",children:f})})]})})]})]})}function b(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(x,{...e})}):x(e)}}}]);