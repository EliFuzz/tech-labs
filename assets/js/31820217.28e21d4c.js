"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[932],{27211:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>x,contentTitle:()=>f,default:()=>S,frontMatter:()=>I,metadata:()=>b,toc:()=>g});var a=l(11527),t=l(88672),i=l(29140),c=l(52360),r=l(52296);const s='function shape(m) {\n  const shapes = [];\n  let dimension = m;\n  while (dimension && Array.isArray(dimension)) {\n    shapes.push(dimension.length);\n    dimension = (dimension.length && [...dimension][0]) || null;\n  }\n  return shapes;\n}\n\nfunc validateType(m [][]int) error {\n\tif m == nil || len(m) == 0 || len(m[0]) == 0 {\n\t\treturn errors.New("Invalid matrix format")\n\t}\n\treturn nil\n}\n\nfunc validate2D(m [][]int) error {\n\tif err := validateType(m); err != nil {\n\t\treturn err\n\t}\n\tif len(m) != 2 {\n\t\treturn errors.New("Matrix is not of 2D shape")\n\t}\n\treturn nil\n}\n\nfunction validateSameShape(a, b) {\n  validateType(a);\n  validateType(b);\n\n  const aShape = shape(a);\n  const bShape = shape(b);\n\n  if (aShape.length !== bShape.length) {\n    throw new Error("Matrices have different dimensions");\n  }\n\n  while (aShape.length && bShape.length) {\n    if (aShape.pop() !== bShape.pop()) {\n      throw new Error("Matrices have different shapes");\n    }\n  }\n}\n\nfunction generate(mShape, fill) {\n  const generateRecursively = (recShape, recIndices) => {\n    if (recShape.length === 1) {\n      return Array(recShape[0])\n        .fill(null)\n        .map((cellValue, cellIndex) => fill([...recIndices, cellIndex]));\n    }\n    const m = [];\n    for (let i = 0; i < recShape[0]; i += 1) {\n      m.push(generateRecursively(recShape.slice(1), [...recIndices, i]));\n    }\n    return m;\n  };\n\n  return generateRecursively(mShape, []);\n}\n\nfunction zeros(mShape) {\n  return generate(mShape, () => 0);\n}\n\nconst dot = (a, b) => {\n  validate2D(a);\n  validate2D(b);\n\n  const aShape = shape(a);\n  const bShape = shape(b);\n  if (aShape[1] !== bShape[0]) {\n    throw new Error("Matrices have incompatible shape for multiplication");\n  }\n\n  const outputShape = [aShape[0], bShape[1]];\n  const c = zeros(outputShape);\n\n  for (let bCol = 0; bCol < b[0].length; bCol += 1) {\n    for (let aRow = 0; aRow < a.length; aRow += 1) {\n      let cellSum = 0;\n      for (let aCol = 0; aCol < a[aRow].length; aCol += 1) {\n        cellSum += a[aRow][aCol] * b[aCol][bCol];\n      }\n      c[aRow][bCol] = cellSum;\n    }\n  }\n\n  return c;\n};\n\nfunction walk(m, visit) {\n  const recWalk = (recM, cellIndices) => {\n    const recMShape = shape(recM);\n\n    if (recMShape.length === 1) {\n      for (let i = 0; i < recM.length; i += 1) {\n        visit([...cellIndices, i], recM[i]);\n      }\n    }\n    for (let i = 0; i < recM.length; i += 1) {\n      recWalk(recM[i], [...cellIndices, i]);\n    }\n  };\n\n  recWalk(m, []);\n}\n\nfunction getCellAtIndex(m, cellIndices) {\n  let cell = m[cellIndices[0]];\n  for (let dimIdx = 1; dimIdx < cellIndices.length - 1; dimIdx += 1) {\n    cell = cell[cellIndices[dimIdx]];\n  }\n  return cell[cellIndices[cellIndices.length - 1]];\n}\n\nconst updateCellAtIndex = (m, cellIndices, cellValue) => {\n  let cell = m[cellIndices[0]];\n  for (let dimIdx = 1; dimIdx < cellIndices.length - 1; dimIdx += 1) {\n    cell = cell[cellIndices[dimIdx]];\n  }\n  cell[cellIndices[cellIndices.length - 1]] = cellValue;\n};\n\nfunction add(a, b) {\n  validateSameShape(a, b);\n  const result = zeros(shape(a));\n\n  walk(a, (cellIndices, cellValue) => {\n    updateCellAtIndex(result, cellIndices, cellValue);\n  });\n\n  walk(b, (cellIndices, cellValue) => {\n    const currentCellValue = getCellAtIndex(result, cellIndices);\n    updateCellAtIndex(result, cellIndices, currentCellValue + cellValue);\n  });\n\n  return result;\n}\n\nfunction mul(a, b) {\n  validateSameShape(a, b);\n  const result = zeros(shape(a));\n\n  walk(a, (cellIndices, cellValue) => {\n    updateCellAtIndex(result, cellIndices, cellValue);\n  });\n\n  walk(b, (cellIndices, cellValue) => {\n    const currentCellValue = getCellAtIndex(result, cellIndices);\n    updateCellAtIndex(result, cellIndices, currentCellValue * cellValue);\n  });\n\n  return result;\n}\n\nfunction sub(a, b) {\n  validateSameShape(a, b);\n  const result = zeros(shape(a));\n\n  walk(a, (cellIndices, cellValue) => {\n    updateCellAtIndex(result, cellIndices, cellValue);\n  });\n\n  walk(b, (cellIndices, cellValue) => {\n    const currentCellValue = getCellAtIndex(result, cellIndices);\n    updateCellAtIndex(result, cellIndices, currentCellValue - cellValue);\n  });\n\n  return result;\n}\n',d='import java.util.ArrayList;\nimport java.util.List;\n\npublic class MatrixOperations {\n\n  public static List<Integer> shape(Object m) {\n    List<Integer> shapes = new ArrayList<>();\n    Object dimension = m;\n    while (dimension != null && dimension instanceof Object[]) {\n      shapes.add(((Object[]) dimension).length);\n      dimension = (((Object[]) dimension).length > 0) ? ((Object[]) dimension)[0] : null;\n    }\n    return shapes;\n  }\n\n  public static void validateType(Object[] m) {\n    if (m == null || m.length == 0 || !(m[0] instanceof Object[])) {\n      throw new IllegalArgumentException("Invalid matrix format");\n    }\n  }\n\n  public static void validate2D(Object[] m) {\n    validateType(m);\n    int[] aShape = shape(m);\n    if (aShape.length != 2) {\n      throw new IllegalArgumentException("Matrix is not of 2D shape");\n    }\n  }\n\n  public static void validateSameShape(Object a, Object b) {\n    validateType(a);\n    validateType(b);\n\n    List<Integer> aShape = shape(a);\n    List<Integer> bShape = shape(b);\n\n    if (aShape.size() != bShape.size()) {\n      throw new IllegalArgumentException("Matrices have different dimensions");\n    }\n\n    while (!aShape.isEmpty() && !bShape.isEmpty()) {\n      if (!aShape.remove(aShape.size() - 1).equals(bShape.remove(bShape.size() - 1))) {\n        throw new IllegalArgumentException("Matrices have different shapes");\n      }\n    }\n  }\n\n  public static Object generate(List<Integer> mShape, FillFunction fill) {\n    return generateRecursively(mShape, new ArrayList<>(), fill);\n  }\n\n  private static Object generateRecursively(List<Integer> recShape, List<Integer> recIndices, FillFunction fill) {\n    if (recShape.size() == 1) {\n      Object[] array = new Object[recShape.get(0)];\n      for (int i = 0; i < recShape.get(0); i++) {\n        array[i] = fill.apply(recIndices, i);\n      }\n      return array;\n    }\n\n    List<Object> m = new ArrayList<>();\n    for (int i = 0; i < recShape.get(0); i++) {\n      m.add(generateRecursively(new ArrayList<>(recShape.subList(1, recShape.size())), appendToList(recIndices, i), fill));\n    }\n    return m.toArray();\n  }\n\n  private static List<Integer> appendToList(List<Integer> list, Integer element) {\n    List<Integer> newList = new ArrayList<>(list);\n    newList.add(element);\n    return newList;\n  }\n\n  public static Object zeros(List<Integer> mShape) {\n    return generate(mShape, (indices, cellIndex) -> 0);\n  }\n\n  public static Object dot(Object a, Object b) {\n    validate2D(a);\n    validate2D(b);\n\n    List<Integer> aShape = shape(a);\n    List<Integer> bShape = shape(b);\n    if (!aShape.get(1).equals(bShape.get(0))) {\n      throw new IllegalArgumentException("Matrices have incompatible shape for multiplication");\n    }\n\n    List<Integer> outputShape = new ArrayList<>();\n    outputShape.add(aShape.get(0));\n    outputShape.add(bShape.get(1));\n    Object c = zeros(outputShape);\n\n    for (int bCol = 0; bCol < ((Object[]) b)[0].length; bCol++) {\n      for (int aRow = 0; aRow < ((Object[]) a).length; aRow++) {\n        int cellSum = 0;\n        for (int aCol = 0; aCol < ((Object[]) a)[aRow].length; aCol++) {\n          cellSum += (int) (((Object[]) a)[aRow][aCol]) * ((int[][]) b)[aCol][bCol];\n        }\n        ((int[][]) c)[aRow][bCol] = cellSum;\n      }\n    }\n    return c;\n  }\n\n  public static void walk(Object m, VisitFunction visit) {\n    recWalk(m, new ArrayList<>(), visit);\n  }\n\n  private static void recWalk(Object recM, List<Integer> cellIndices, VisitFunction visit) {\n    List<Integer> recMShape = shape(recM);\n\n    if (recMShape.size() == 1) {\n      for (int i = 0; i < ((Object[]) recM).length; i++) {\n        visit.apply(appendToList(cellIndices, i), ((Object[]) recM)[i]);\n      }\n    }\n\n    for (int i = 0; i < ((Object[]) recM).length; i++) {\n      recWalk(((Object[]) recM)[i], appendToList(cellIndices, i), visit);\n    }\n  }\n\n  public static Object getCellAtIndex(Object m, List<Integer> cellIndices) {\n    Object cell = ((Object[]) m)[cellIndices.get(0)];\n    for (int dimIdx = 1; dimIdx < cellIndices.size() - 1; dimIdx++) {\n      cell = ((Object[]) cell)[cellIndices.get(dimIdx)];\n    }\n    return ((Object[]) cell)[cellIndices.get(cellIndices.size() - 1)];\n  }\n\n  public static void updateCellAtIndex(Object m, List<Integer> cellIndices, Object cellValue) {\n    Object cell = ((Object[]) m)[cellIndices.get(0)];\n    for (int dimIdx = 1; dimIdx < cellIndices.size() - 1; dimIdx++) {\n      cell = ((Object[]) cell)[cellIndices.get(dimIdx)];\n    }\n    ((Object[]) cell)[cellIndices.get(cellIndices.size() - 1)] = cellValue;\n  }\n\n  public static Object add(Object a, Object b) {\n    validateSameShape(a, b);\n    Object result = zeros(shape(a));\n\n    walk(a, (cellIndices, cellValue) -> {\n      updateCellAtIndex(result, cellIndices, cellValue);\n    });\n\n    walk(b, (cellIndices, cellValue) -> {\n      Object currentCellValue = getCellAtIndex(result, cellIndices);\n      updateCellAtIndex(result, cellIndices, (int) currentCellValue + (int) cellValue);\n    });\n\n    return result;\n  }\n\n  public static Object mul(Object a, Object b) {\n    validateSameShape(a, b);\n    Object result = zeros(shape(a));\n\n    walk(a, (cellIndices, cellValue) -> {\n      updateCellAtIndex(result, cellIndices, cellValue);\n    });\n\n    walk(b, (cellIndices, cellValue) -> {\n      Object currentCellValue = getCellAtIndex(result, cellIndices);\n      updateCellAtIndex(result, cellIndices, (int) currentCellValue * (int) cellValue);\n    });\n\n    return result;\n  }\n\n  public static Object sub(Object a, Object b) {\n    validateSameShape(a, b);\n    Object result = zeros(shape(a));\n\n    walk(a, (cellIndices, cellValue) -> {\n      updateCellAtIndex(result, cellIndices, cellValue);\n    });\n\n    walk(b, (cellIndices, cellValue) -> {\n      Object currentCellValue = getCellAtIndex(result, cellIndices);\n      updateCellAtIndex(result, cellIndices, (int) currentCellValue - (int) cellValue);\n    });\n\n    return result;\n  }\n\n  private static void validateType(Object matrix) {\n    if (!(matrix instanceof Object[])) {\n      throw new IllegalArgumentException("Input is not a matrix");\n    }\n  }\n\n  private static void validate2D(Object matrix) {\n    if (!(matrix instanceof Object[]) || !(((Object[]) matrix)[0] instanceof Object[])) {\n      throw new IllegalArgumentException("Input is not a 2D matrix");\n    }\n  }\n\n  interface FillFunction {\n\n    Object apply(List<Integer> indices, int cellIndex);\n  }\n\n  interface VisitFunction {\n\n    void apply(List<Integer> cellIndices, Object cellValue);\n  }\n}\n',u='function shape(m) {\n  const shapes = [];\n  let dimension = m;\n  while (dimension && Array.isArray(dimension)) {\n    shapes.push(dimension.length);\n    dimension = (dimension.length && [...dimension][0]) || null;\n  }\n  return shapes;\n}\n\nfunction validateType(m) {\n  if (!m || !Array.isArray(m) || !Array.isArray(m[0])) {\n    throw new Error("Invalid matrix format");\n  }\n}\n\nfunction validate2D(m) {\n  validateType(m);\n  const aShape = shape(m);\n  if (aShape.length !== 2) {\n    throw new Error("Matrix is not of 2D shape");\n  }\n}\n\nfunction validateSameShape(a, b) {\n  validateType(a);\n  validateType(b);\n\n  const aShape = shape(a);\n  const bShape = shape(b);\n\n  if (aShape.length !== bShape.length) {\n    throw new Error("Matrices have different dimensions");\n  }\n\n  while (aShape.length && bShape.length) {\n    if (aShape.pop() !== bShape.pop()) {\n      throw new Error("Matrices have different shapes");\n    }\n  }\n}\n\nfunction generate(mShape, fill) {\n  const generateRecursively = (recShape, recIndices) => {\n    if (recShape.length === 1) {\n      return Array(recShape[0])\n        .fill(null)\n        .map((cellValue, cellIndex) => fill([...recIndices, cellIndex]));\n    }\n    const m = [];\n    for (let i = 0; i < recShape[0]; i += 1) {\n      m.push(generateRecursively(recShape.slice(1), [...recIndices, i]));\n    }\n    return m;\n  };\n\n  return generateRecursively(mShape, []);\n}\n\nfunction zeros(mShape) {\n  return generate(mShape, () => 0);\n}\n\nconst dot = (a, b) => {\n  validate2D(a);\n  validate2D(b);\n\n  const aShape = shape(a);\n  const bShape = shape(b);\n  if (aShape[1] !== bShape[0]) {\n    throw new Error("Matrices have incompatible shape for multiplication");\n  }\n\n  const outputShape = [aShape[0], bShape[1]];\n  const c = zeros(outputShape);\n\n  for (let bCol = 0; bCol < b[0].length; bCol += 1) {\n    for (let aRow = 0; aRow < a.length; aRow += 1) {\n      let cellSum = 0;\n      for (let aCol = 0; aCol < a[aRow].length; aCol += 1) {\n        cellSum += a[aRow][aCol] * b[aCol][bCol];\n      }\n      c[aRow][bCol] = cellSum;\n    }\n  }\n\n  return c;\n};\n\nfunction walk(m, visit) {\n  const recWalk = (recM, cellIndices) => {\n    const recMShape = shape(recM);\n\n    if (recMShape.length === 1) {\n      for (let i = 0; i < recM.length; i += 1) {\n        visit([...cellIndices, i], recM[i]);\n      }\n    }\n    for (let i = 0; i < recM.length; i += 1) {\n      recWalk(recM[i], [...cellIndices, i]);\n    }\n  };\n\n  recWalk(m, []);\n}\n\nfunction getCellAtIndex(m, cellIndices) {\n  let cell = m[cellIndices[0]];\n  for (let dimIdx = 1; dimIdx < cellIndices.length - 1; dimIdx += 1) {\n    cell = cell[cellIndices[dimIdx]];\n  }\n  return cell[cellIndices[cellIndices.length - 1]];\n}\n\nconst updateCellAtIndex = (m, cellIndices, cellValue) => {\n  let cell = m[cellIndices[0]];\n  for (let dimIdx = 1; dimIdx < cellIndices.length - 1; dimIdx += 1) {\n    cell = cell[cellIndices[dimIdx]];\n  }\n  cell[cellIndices[cellIndices.length - 1]] = cellValue;\n};\n\nfunction add(a, b) {\n  validateSameShape(a, b);\n  const result = zeros(shape(a));\n\n  walk(a, (cellIndices, cellValue) => {\n    updateCellAtIndex(result, cellIndices, cellValue);\n  });\n\n  walk(b, (cellIndices, cellValue) => {\n    const currentCellValue = getCellAtIndex(result, cellIndices);\n    updateCellAtIndex(result, cellIndices, currentCellValue + cellValue);\n  });\n\n  return result;\n}\n\nfunction mul(a, b) {\n  validateSameShape(a, b);\n  const result = zeros(shape(a));\n\n  walk(a, (cellIndices, cellValue) => {\n    updateCellAtIndex(result, cellIndices, cellValue);\n  });\n\n  walk(b, (cellIndices, cellValue) => {\n    const currentCellValue = getCellAtIndex(result, cellIndices);\n    updateCellAtIndex(result, cellIndices, currentCellValue * cellValue);\n  });\n\n  return result;\n}\n\nfunction sub(a, b) {\n  validateSameShape(a, b);\n  const result = zeros(shape(a));\n\n  walk(a, (cellIndices, cellValue) => {\n    updateCellAtIndex(result, cellIndices, cellValue);\n  });\n\n  walk(b, (cellIndices, cellValue) => {\n    const currentCellValue = getCellAtIndex(result, cellIndices);\n    updateCellAtIndex(result, cellIndices, currentCellValue - cellValue);\n  });\n\n  return result;\n}\n',o='import kotlin.math.pow\n\nfun shape(m: Any): List<Int> {\n    val shapes = mutableListOf<Int>()\n    var dimension: Any? = m\n    while (dimension != null && dimension is Array<*>) {\n        shapes.add((dimension as Array<*>).size)\n        dimension = if ((dimension as Array<*>).isNotEmpty()) (dimension as Array<*>)[0] else null\n    }\n    return shapes\n}\n\nfun validateType(m: Array<*>?) {\n    if (m == null || !m.isArray() || !m[0].isArray()) {\n        throw IllegalArgumentException("Invalid matrix format")\n    }\n}\n\nfun validate2D(m: Array<*>) {\n    validateType(m)\n    val aShape = shape(m)\n    if (aShape.size != 2) {\n        throw IllegalArgumentException("Matrix is not of 2D shape")\n    }\n}\n\nfun validateSameShape(a: Any, b: Any) {\n    validateType(a)\n    validateType(b)\n\n    val aShape = shape(a)\n    val bShape = shape(b)\n\n    if (aShape.size != bShape.size) {\n        throw IllegalArgumentException("Matrices have different dimensions")\n    }\n\n    while (aShape.isNotEmpty() && bShape.isNotEmpty()) {\n        if (aShape.removeAt(aShape.size - 1) != bShape.removeAt(bShape.size - 1)) {\n            throw IllegalArgumentException("Matrices have different shapes")\n        }\n    }\n}\n\nfun generate(mShape: List<Int>, fill: (List<Int>) -> Any): Any {\n    fun generateRecursively(recShape: List<Int>, recIndices: List<Int>): Any {\n        return if (recShape.size == 1) {\n            Array(recShape[0]) { cellIndex ->\n                fill(recIndices + cellIndex)\n            }\n        } else {\n            val m = mutableListOf<Any>()\n            for (i in 0 until recShape[0]) {\n                m.add(generateRecursively(recShape.slice(1 until recShape.size), recIndices + i))\n            }\n            m.toTypedArray()\n        }\n    }\n\n    return generateRecursively(mShape, emptyList())\n}\n\nfun zeros(mShape: List<Int>): Any {\n    return generate(mShape) { 0 }\n}\n\nfun dot(a: Any, b: Any): Any {\n    validate2D(a)\n    validate2D(b)\n\n    val aShape = shape(a)\n    val bShape = shape(b)\n    if (aShape[1] != bShape[0]) {\n        throw IllegalArgumentException("Matrices have incompatible shape for multiplication")\n    }\n\n    val outputShape = listOf(aShape[0], bShape[1])\n    val c = zeros(outputShape)\n\n    for (bCol in 0 until (b as Array<*>)[0].size) {\n        for (aRow in (a as Array<*>).indices) {\n            var cellSum = 0\n            for (aCol in (a[aRow] as Array<*>).indices) {\n                cellSum += (a[aRow] as Array<*>)[aCol] as Int * (b[aCol] as IntArray)[bCol]\n            }\n            (c as Array<*>)[aRow][bCol] = cellSum\n        }\n    }\n\n    return c\n}\n\nfun walk(m: Any, visit: (List<Int>, Any) -> Unit) {\n    fun recWalk(recM: Any, cellIndices: List<Int>) {\n        val recMShape = shape(recM)\n\n        if (recMShape.size == 1) {\n            for (i in (recM as Array<*>).indices) {\n                visit(cellIndices + i, recM[i]!!)\n            }\n        }\n        for (i in (recM as Array<*>).indices) {\n            recWalk(recM[i]!!, cellIndices + i)\n        }\n    }\n\n    recWalk(m, emptyList())\n}\n\nfun getCellAtIndex(m: Any, cellIndices: List<Int>): Any {\n    var cell: Any = (m as Array<*>)[cellIndices[0]]!!\n    for (dimIdx in 1 until cellIndices.size - 1) {\n        cell = (cell as Array<*>)[cellIndices[dimIdx]]!!\n    }\n    return (cell as Array<*>)[cellIndices.last()]!!\n}\n\nfun updateCellAtIndex(m: Any, cellIndices: List<Int>, cellValue: Any) {\n    var cell: Any = (m as Array<*>)[cellIndices[0]]!!\n    for (dimIdx in 1 until cellIndices.size - 1) {\n        cell = (cell as Array<*>)[cellIndices[dimIdx]]!!\n    }\n    (cell as Array<*>)[cellIndices.last()] = cellValue\n}\n\nfun add(a: Any, b: Any): Any {\n    validateSameShape(a, b)\n    val result = zeros(shape(a))\n\n    walk(a) { cellIndices, cellValue ->\n        updateCellAtIndex(result, cellIndices, cellValue)\n    }\n\n    walk(b) { cellIndices, cellValue ->\n        val currentCellValue = getCellAtIndex(result, cellIndices) as Int\n        updateCellAtIndex(result, cellIndices, currentCellValue + cellValue as Int)\n    }\n\n    return result\n}\n\nfun mul(a: Any, b: Any): Any {\n    validateSameShape(a, b)\n    val result = zeros(shape(a))\n\n    walk(a) { cellIndices, cellValue ->\n        updateCellAtIndex(result, cellIndices, cellValue)\n    }\n\n    walk(b) { cellIndices, cellValue ->\n        val currentCellValue = getCellAtIndex(result, cellIndices) as Int\n        updateCellAtIndex(result, cellIndices, currentCellValue * cellValue as Int)\n    }\n\n    return result\n}\n\nfun sub(a: Any, b: Any): Any {\n    validateSameShape(a, b)\n    val result = zeros(shape(a))\n\n    walk(a) { cellIndices, cellValue ->\n        updateCellAtIndex(result, cellIndices, cellValue)\n    }\n\n    walk(b) { cellIndices, cellValue ->\n        val currentCellValue = getCellAtIndex(result, cellIndices) as Int\n        updateCellAtIndex(result, cellIndices, currentCellValue - cellValue as Int)\n    }\n\n    return result\n}\n\nprivate fun validateType(matrix: Any) {\n    if (matrix !is Array<*>) {\n        throw IllegalArgumentException("Input is not a matrix")\n    }\n}\n\nprivate fun validate2D(matrix: Any) {\n    if (!(matrix is Array<*>) || !(matrix[0] is Array<*>)) {\n        throw IllegalArgumentException("Input is not a 2D matrix")\n    }\n}\n',m='def shape(m):\n    shapes = []\n    dimension = m\n    while dimension and isinstance(dimension, list):\n        shapes.append(len(dimension))\n        dimension = dimension[0] if len(dimension) else None\n    return shapes\n\ndef validate_type(m):\n    if m is None or not isinstance(m, list) or not isinstance(m[0], list):\n        raise ValueError("Invalid matrix format")\n\n\ndef validate_2d(m):\n    validate_type(m)\n    a_shape = shape(m)\n    if len(a_shape) != 2:\n        raise ValueError("Matrix is not of 2D shape")\n\ndef validateSameShape(a, b):\n    validateType(a)\n    validateType(b)\n\n    aShape = shape(a)\n    bShape = shape(b)\n\n    if len(aShape) != len(bShape):\n        raise ValueError("Matrices have different dimensions")\n\n    while aShape and bShape:\n        if aShape.pop() != bShape.pop():\n            raise ValueError("Matrices have different shapes")\n\n\ndef generate(mShape, fill):\n    def generateRecursively(recShape, recIndices):\n        if len(recShape) == 1:\n            return [fill(recIndices + [cellIndex]) for cellIndex in range(recShape[0])]\n        m = []\n        for i in range(recShape[0]):\n            m.append(generateRecursively(recShape[1:], recIndices + [i]))\n        return m\n\n    return generateRecursively(mShape, [])\n\n\ndef zeros(mShape):\n    return generate(mShape, lambda _: 0)\n\n\ndef dot(a, b):\n    validate2D(a)\n    validate2D(b)\n\n    aShape = shape(a)\n    bShape = shape(b)\n    if aShape[1] != bShape[0]:\n        raise ValueError("Matrices have incompatible shape for multiplication")\n\n    outputShape = [aShape[0], bShape[1]]\n    c = zeros(outputShape)\n\n    for bCol in range(len(b[0])):\n        for aRow in range(len(a)):\n            cellSum = 0\n            for aCol in range(len(a[aRow])):\n                cellSum += a[aRow][aCol] * b[aCol][bCol]\n            c[aRow][bCol] = cellSum\n\n    return c\n\n\ndef walk(m, visit):\n    def recWalk(recM, cellIndices):\n        recMShape = shape(recM)\n\n        if len(recMShape) == 1:\n            for i in range(len(recM)):\n                visit(cellIndices + [i], recM[i])\n        for i in range(len(recM)):\n            recWalk(recM[i], cellIndices + [i])\n\n    recWalk(m, [])\n\n\ndef getCellAtIndex(m, cellIndices):\n    cell = m[cellIndices[0]]\n    for dimIdx in range(1, len(cellIndices) - 1):\n        cell = cell[cellIndices[dimIdx]]\n    return cell[cellIndices[-1]]\n\n\ndef updateCellAtIndex(m, cellIndices, cellValue):\n    cell = m[cellIndices[0]]\n    for dimIdx in range(1, len(cellIndices) - 1):\n        cell = cell[cellIndices[dimIdx]]\n    cell[cellIndices[-1]] = cellValue\n\n\ndef add(a, b):\n    validateSameShape(a, b)\n    result = zeros(shape(a))\n\n    def update(result, cellIndices, cellValue):\n        updateCellAtIndex(result, cellIndices, cellValue)\n\n    walk(a, lambda cellIndices, cellValue: update(result, cellIndices, cellValue))\n    walk(b, lambda cellIndices, cellValue: update(result, cellIndices, cellValue + getCellAtIndex(result, cellIndices)))\n\n    return result\n\n\ndef mul(a, b):\n    validateSameShape(a, b)\n    result = zeros(shape(a))\n\n    def update(result, cellIndices, cellValue):\n        updateCellAtIndex(result, cellIndices, cellValue)\n\n    walk(a, lambda cellIndices, cellValue: update(result, cellIndices, cellValue))\n    walk(b, lambda cellIndices, cellValue: update(result, cellIndices, cellValue * getCellAtIndex(result, cellIndices)))\n\n    return result\n\n\ndef sub(a, b):\n    validateSameShape(a, b)\n    result = zeros(shape(a))\n\n    def update(result, cellIndices, cellValue):\n        updateCellAtIndex(result, cellIndices, cellValue)\n\n    walk(a, lambda cellIndices, cellValue: update(result, cellIndices, cellValue))\n    walk(b, lambda cellIndices, cellValue: update(result, cellIndices, getCellAtIndex(result, cellIndices) - cellValue))\n\n    return result\n',h='use std::error::Error;\n\nfn shape(m: &Vec<Vec<i32>>) -> Vec<usize> {\n    let mut shapes = Vec::new();\n    let mut dimension = m;\n    while let Some(inner) = dimension.first() {\n        shapes.push(inner.len());\n        if let Some(inner_dim) = inner.get(0) {\n            dimension = inner;\n        } else {\n            dimension = &vec![];\n        }\n    }\n    shapes\n}\n\nfn validate_type<T>(m: &Vec<Vec<T>>) {\n    if m.is_empty() || m[0].is_empty() {\n        panic!("Invalid matrix format");\n    }\n}\n\nfn validate_2d<T>(m: &Vec<Vec<T>>) {\n    validate_type(m);\n    let a_shape = shape(m);\n    if a_shape.len() != 2 {\n        panic!("Matrix is not of 2D shape");\n    }\n}\n\nfn validate_same_shape(a: &Vec<Vec<i32>>, b: &Vec<Vec<i32>>) -> Result<(), Box<dyn Error>> {\n    validate_type(a)?;\n    validate_type(b)?;\n\n    let a_shape = shape(a);\n    let b_shape = shape(b);\n\n    if a_shape.len() != b_shape.len() {\n        return Err("Matrices have different dimensions".into());\n    }\n\n    for (a_dim, b_dim) in a_shape.iter().zip(b_shape.iter()) {\n        if a_dim != b_dim {\n            return Err("Matrices have different shapes".into());\n        }\n    }\n\n    Ok(())\n}\n\nfn generate<F>(m_shape: &[usize], fill: F) -> Vec<Vec<i32>>\nwhere\n    F: Fn(Vec<usize>) -> i32,\n{\n    fn generate_recursively<F>(\n        rec_shape: &[usize],\n        rec_indices: Vec<usize>,\n        fill: F,\n    ) -> Vec<Vec<i32>>\n    where\n        F: Fn(Vec<usize>) -> i32,\n    {\n        if rec_shape.len() == 1 {\n            return (0..rec_shape[0])\n                .map(|cell_index| fill([&rec_indices[..], &[cell_index]].concat()))\n                .collect();\n        }\n        let mut m = Vec::new();\n        for i in 0..rec_shape[0] {\n            m.push(generate_recursively(\n                &rec_shape[1..],\n                [&rec_indices[..], &[i]].concat(),\n                &fill,\n            ));\n        }\n        m\n    }\n\n    generate_recursively(m_shape, Vec::new(), fill)\n}\n\nfn zeros(m_shape: &[usize]) -> Vec<Vec<i32>> {\n    generate(m_shape, |_| 0)\n}\n\nfn dot(a: &Vec<Vec<i32>>, b: &Vec<Vec<i32>>) -> Result<Vec<Vec<i32>>, Box<dyn Error>> {\n    validate_2d(a)?;\n    validate_2d(b)?;\n\n    let a_shape = shape(a);\n    let b_shape = shape(b);\n\n    if a_shape[1] != b_shape[0] {\n        return Err("Matrices have incompatible shape for multiplication".into());\n    }\n\n    let output_shape = vec![a_shape[0], b_shape[1]];\n    let c = zeros(&output_shape);\n\n    for b_col in 0..b[0].len() {\n        for a_row in 0..a.len() {\n            let mut cell_sum = 0;\n            for a_col in 0..a[a_row].len() {\n                cell_sum += a[a_row][a_col] * b[a_col][b_col];\n            }\n            c[a_row][b_col] = cell_sum;\n        }\n    }\n\n    Ok(c)\n}\n\nfn walk<F>(m: &Vec<Vec<i32>>, visit: F)\nwhere\n    F: Fn(Vec<usize>, i32),\n{\n    fn rec_walk<F>(rec_m: &Vec<Vec<i32>>, cell_indices: Vec<usize>, visit: F)\n    where\n        F: Fn(Vec<usize>, i32),\n    {\n        let rec_m_shape = shape(rec_m);\n\n        if rec_m_shape.len() == 1 {\n            for i in 0..rec_m.len() {\n                visit([cell_indices.clone(), vec![i]].concat(), rec_m[i][0]);\n            }\n        }\n        for i in 0..rec_m.len() {\n            rec_walk(&rec_m[i], [cell_indices.clone(), vec![i]].concat(), &visit);\n        }\n    }\n\n    rec_walk(m, Vec::new(), visit);\n}\n\nfn get_cell_at_index(m: &Vec<Vec<i32>>, cell_indices: &[usize]) -> i32 {\n    let mut cell = &m[cell_indices[0]];\n    for dim_idx in 1..cell_indices.len() - 1 {\n        cell = &cell[cell_indices[dim_idx]];\n    }\n    cell[cell_indices[cell_indices.len() - 1]]\n}\n\nfn update_cell_at_index(m: &mut Vec<Vec<i32>>, cell_indices: &[usize], cell_value: i32) {\n    let mut cell = &mut m[cell_indices[0]];\n    for dim_idx in 1..cell_indices.len() - 1 {\n        cell = &mut cell[cell_indices[dim_idx]];\n    }\n    cell[cell_indices[cell_indices.len() - 1]] = cell_value;\n}\n\nfn add(a: &Vec<Vec<i32>>, b: &Vec<Vec<i32>>) -> Result<Vec<Vec<i32>>, Box<dyn Error>> {\n    validate_same_shape(a, b)?;\n\n    let mut result = zeros(&shape(a));\n\n    walk(a, |cell_indices, cell_value| {\n        update_cell_at_index(&mut result, &cell_indices, cell_value);\n    });\n\n    walk(b, |cell_indices, cell_value| {\n        let current_cell_value = get_cell_at_index(&result, &cell_indices);\n        update_cell_at_index(&mut result, &cell_indices, current_cell_value + cell_value);\n    });\n\n    Ok(result)\n}\n\nfn mul(a: &Vec<Vec<i32>>, b: &Vec<Vec<i32>>) -> Result<Vec<Vec<i32>>, Box<dyn Error>> {\n    validate_same_shape(a, b)?;\n\n    let mut result = zeros(&shape(a));\n\n    walk(a, |cell_indices, cell_value| {\n        update_cell_at_index(&mut result, &cell_indices, cell_value);\n    });\n\n    walk(b, |cell_indices, cell_value| {\n        let current_cell_value = get_cell_at_index(&result, &cell_indices);\n        update_cell_at_index(&mut result, &cell_indices, current_cell_value * cell_value);\n    });\n\n    Ok(result)\n}\n\nfn sub(a: &Vec<Vec<i32>>, b: &Vec<Vec<i32>>) -> Result<Vec<Vec<i32>>, Box<dyn Error>> {\n    validate_same_shape(a, b)?;\n\n    let mut result = zeros(&shape(a));\n\n    walk(a, |cell_indices, cell_value| {\n        update_cell_at_index(&mut result, &cell_indices, cell_value);\n    });\n\n    walk(b, |cell_indices, cell_value| {\n        let current_cell_value = get_cell_at_index(&result, &cell_indices);\n        update_cell_at_index(&mut result, &cell_indices, current_cell_value - cell_value);\n    });\n\n    Ok(result)\n}\n\nfn validate_type(a: &Vec<Vec<i32>>) -> Result<(), Box<dyn Error>> {\n    if !a.iter().all(|inner| inner.iter().all(|&x| x == 0 || x == 1)) {\n        return Err("Matrix contains invalid elements".into());\n    }\n    Ok(())\n}\n\nfn validate_2d(a: &Vec<Vec<i32>>) -> Result<(), Box<dyn Error>> {\n    if a.iter().any(|inner| inner.len() != a[0].len()) {\n        return Err("Matrix rows have different lengths".into());\n    }\n    Ok(())\n}\n',p='function shape(m: any): number[] {\n  const shapes: number[] = [];\n  let dimension = m;\n  while (dimension && Array.isArray(dimension)) {\n    shapes.push(dimension.length);\n    dimension = (dimension.length && [...dimension][0]) || null;\n  }\n  return shapes;\n}\n\nfunction validateType<T>(m: T[][]): void {\n  if (!m || !Array.isArray(m) || !Array.isArray(m[0])) {\n    throw new Error("Invalid matrix format");\n  }\n}\n\nfunction validate2D<T>(m: T[][]): void {\n  validateType(m);\n  const aShape = shape(m);\n  if (aShape.length !== 2) {\n    throw new Error("Matrix is not of 2D shape");\n  }\n}\n\nfunction validateSameShape(a: any, b: any): void {\n  validateType(a);\n  validateType(b);\n\n  const aShape = shape(a);\n  const bShape = shape(b);\n\n  if (aShape.length !== bShape.length) {\n    throw new Error("Matrices have different dimensions");\n  }\n\n  while (aShape.length && bShape.length) {\n    if (aShape.pop() !== bShape.pop()) {\n      throw new Error("Matrices have different shapes");\n    }\n  }\n}\n\nfunction generate(mShape: number[], fill: () => number): any {\n  const generateRecursively = (\n    recShape: number[],\n    recIndices: number[],\n  ): any => {\n    if (recShape.length === 1) {\n      return Array(recShape[0])\n        .fill(null)\n        .map((cellValue, cellIndex) => fill([...recIndices, cellIndex]));\n    }\n    const m: any[] = [];\n    for (let i = 0; i < recShape[0]; i += 1) {\n      m.push(generateRecursively(recShape.slice(1), [...recIndices, i]));\n    }\n    return m;\n  };\n\n  return generateRecursively(mShape, []);\n}\n\nfunction zeros(mShape: number[]): any {\n  return generate(mShape, () => 0);\n}\n\nconst dot = (a: any, b: any): any => {\n  validate2D(a);\n  validate2D(b);\n\n  const aShape = shape(a);\n  const bShape = shape(b);\n  if (aShape[1] !== bShape[0]) {\n    throw new Error("Matrices have incompatible shape for multiplication");\n  }\n\n  const outputShape = [aShape[0], bShape[1]];\n  const c = zeros(outputShape);\n\n  for (let bCol = 0; bCol < b[0].length; bCol += 1) {\n    for (let aRow = 0; aRow < a.length; aRow += 1) {\n      let cellSum = 0;\n      for (let aCol = 0; aCol < a[aRow].length; aCol += 1) {\n        cellSum += a[aRow][aCol] * b[aCol][bCol];\n      }\n      c[aRow][bCol] = cellSum;\n    }\n  }\n\n  return c;\n};\n\nfunction walk(\n  m: any,\n  visit: (cellIndices: number[], cellValue: number) => void,\n): void {\n  const recWalk = (recM: any, cellIndices: number[]): void => {\n    const recMShape = shape(recM);\n\n    if (recMShape.length === 1) {\n      for (let i = 0; i < recM.length; i += 1) {\n        visit([...cellIndices, i], recM[i]);\n      }\n    }\n    for (let i = 0; i < recM.length; i += 1) {\n      recWalk(recM[i], [...cellIndices, i]);\n    }\n  };\n\n  recWalk(m, []);\n}\n\nfunction getCellAtIndex(m: any, cellIndices: number[]): number {\n  let cell = m[cellIndices[0]];\n  for (let dimIdx = 1; dimIdx < cellIndices.length - 1; dimIdx += 1) {\n    cell = cell[cellIndices[dimIdx]];\n  }\n  return cell[cellIndices[cellIndices.length - 1]];\n}\n\nconst updateCellAtIndex = (\n  m: any,\n  cellIndices: number[],\n  cellValue: number,\n): void => {\n  let cell = m[cellIndices[0]];\n  for (let dimIdx = 1; dimIdx < cellIndices.length - 1; dimIdx += 1) {\n    cell = cell[cellIndices[dimIdx]];\n  }\n  cell[cellIndices[cellIndices.length - 1]] = cellValue;\n};\n\nfunction add(a: any, b: any): any {\n  validateSameShape(a, b);\n  const result = zeros(shape(a));\n\n  walk(a, (cellIndices, cellValue) => {\n    updateCellAtIndex(result, cellIndices, cellValue);\n  });\n\n  walk(b, (cellIndices, cellValue) => {\n    const currentCellValue = getCellAtIndex(result, cellIndices);\n    updateCellAtIndex(result, cellIndices, currentCellValue + cellValue);\n  });\n\n  return result;\n}\n\nfunction mul(a: any, b: any): any {\n  validateSameShape(a, b);\n  const result = zeros(shape(a));\n\n  walk(a, (cellIndices, cellValue) => {\n    updateCellAtIndex(result, cellIndices, cellValue);\n  });\n\n  walk(b, (cellIndices, cellValue) => {\n    const currentCellValue = getCellAtIndex(result, cellIndices);\n    updateCellAtIndex(result, cellIndices, currentCellValue * cellValue);\n  });\n\n  return result;\n}\n\nfunction sub(a: any, b: any): any {\n  validateSameShape(a, b);\n  const result = zeros(shape(a));\n\n  walk(a, (cellIndices, cellValue) => {\n    updateCellAtIndex(result, cellIndices, cellValue);\n  });\n\n  walk(b, (cellIndices, cellValue) => {\n    const currentCellValue = getCellAtIndex(result, cellIndices);\n    updateCellAtIndex(result, cellIndices, currentCellValue - cellValue);\n  });\n\n  return result;\n}\n',I={title:"Matrices",description:"Matrices",hide_table_of_contents:!0},f=void 0,b={id:"education/computer-science/algorithms/algo/matrices",title:"Matrices",description:"Matrices",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/matrices.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/matrices",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/matrices",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/matrices.mdx",tags:[],version:"current",frontMatter:{title:"Matrices",description:"Matrices",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Longest Increasing Subsequence (LIS)",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/longest-increasing-subsequence"},next:{title:"Maximum Subarray",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/maximum-subarray"}},x={},g=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function v(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,a.jsxs)(i.Z,{children:[(0,a.jsx)(c.Z,{value:"definition",label:"Definition",children:(0,a.jsx)(n.p,{children:"The Matrices Algorithm involves operations on matrices, typically for tasks such as multiplication, addition, or finding determinants"})}),(0,a.jsx)(c.Z,{value:"how",label:"Explanation",children:(0,a.jsx)(n.p,{children:"It works by iterating through corresponding elements of matrices, applying the defined operation to each pair, and storing the result in a new matrix. The process may involve nested loops for efficient traversal of matrix elements and appropriate mathematical operations based on the desired outcome"})}),(0,a.jsx)(c.Z,{value:"guidance",label:"Guidance",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Matrix Addition","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Iterate through each element of both matrices"}),"\n",(0,a.jsx)(n.li,{children:"Add corresponding elements and store the result in a new matrix"}),"\n",(0,a.jsx)(n.li,{children:"Ensure matrices have the same dimensions"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["Matrix Multiplication","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Iterate through rows of the first matrix"}),"\n",(0,a.jsx)(n.li,{children:"Iterate through columns of the second matrix"}),"\n",(0,a.jsx)(n.li,{children:"Multiply corresponding elements and sum them up for each resulting element of the new matrix"}),"\n",(0,a.jsx)(n.li,{children:"Ensure the number of columns in the first matrix matches the number of rows in the second matrix"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["Finding Determinant","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Implement the appropriate determinant calculation method (e.g., cofactor expansion, LU decomposition)"}),"\n",(0,a.jsx)(n.li,{children:"Ensure the matrix is square (i.e., same number of rows and columns)"}),"\n",(0,a.jsx)(n.li,{children:"Handle special cases like 2x2 matrices separately for efficiency"}),"\n"]}),"\n"]}),"\n"]})}),(0,a.jsx)(c.Z,{value:"tips",label:"Tips",children:(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"ensure that the dimensions of the matrices are compatible for the intended operation"}),"\n",(0,a.jsx)(n.li,{children:"optimize the algorithm by minimizing unnecessary iterations and operations"}),"\n",(0,a.jsx)(n.li,{children:"implement error handling for invalid operations or incompatible matrix dimensions"}),"\n"]})})]}),"\n",(0,a.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,a.jsxs)(i.Z,{children:[(0,a.jsx)(c.Z,{value:"practice",label:"Practice",children:(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'matrix_addition(matrix1, matrix2):\n  // Check if matrices have the same dimensions\n  if dimensions of matrix1 != dimensions of matrix2:\n    return "Matrices must have the same dimensions"\n  else:\n    // Initialize an empty matrix for the result\n    result_matrix = empty matrix with dimensions of matrix1\n    // Iterate through each element of the matrices\n    for i from 0 to number of rows in matrix1:\n      for j from 0 to number of columns in matrix1:\n        // Add corresponding elements and store the result in the result matrix\n        result_matrix[i][j] = matrix1[i][j] + matrix2[i][j]\n    return result_matrix\n\nmatrix_multiplication(matrix1, matrix2):\n  // Check if matrices can be multiplied (number of columns in matrix1 == number of rows in matrix2)\n  if number of columns in matrix1 != number of rows in matrix2:\n    return "Number of columns in matrix1 must be equal to number of rows in matrix2"\n  else:\n    // Initialize an empty matrix for the result\n    result_matrix = empty matrix with dimensions (rows of matrix1) x (columns of matrix2)\n    // Iterate through each row of matrix1\n    for i from 0 to number of rows in matrix1:\n      // Iterate through each column of matrix2\n      for j from 0 to number of columns in matrix2:\n        // Initialize the sum for the current element of the result matrix\n        sum = 0\n        // Iterate through each column of matrix1 (or each row of matrix2)\n        for k from 0 to number of columns in matrix1:\n          // Multiply corresponding elements and accumulate the sum\n          sum += matrix1[i][k] * matrix2[k][j]\n        // Store the sum as the resulting element in the result matrix\n        result_matrix[i][j] = sum\n    return result_matrix\n\nfind_determinant(matrix):\n  // Check if the matrix is square\n  if number of rows != number of columns:\n    return "Matrix must be square"\n  else if matrix is 2x2:\n    // Calculate determinant for 2x2 matrix using the formula ad - bc\n    return (matrix[0][0] * matrix[1][1]) - (matrix[0][1] * matrix[1][0])\n  else:\n    // Implement determinant calculation method (e.g., cofactor expansion)\n\nfind_determinant(matrix):\n  // Check if the matrix is square\n  if number of rows != number of columns:\n    return "Matrix must be square"\n  else if matrix is 2x2:\n    // Calculate determinant for 2x2 matrix using the formula ad - bc\n    return (matrix[0][0] * matrix[1][1]) - (matrix[0][1] * matrix[1][0])\n  else:\n    // Initialize determinant variable\n    determinant = 0\n    // Iterate through each column of the matrix\n    for col from 0 to number of columns in matrix:\n      // Calculate cofactor (submatrix) for the current element\n      cofactor = submatrix obtained by removing the first row and current column\n      // Calculate the sign of the current element\'s contribution to the determinant\n      sign = (-1)^(row + col)  // Alternating signs for each element\n      // Recursively calculate determinant using cofactor expansion\n      determinant += sign * matrix[0][col] * find_determinant(cofactor)\n    return determinant\n'})})}),(0,a.jsx)(c.Z,{value:"solution",label:"Solution",children:(0,a.jsxs)(i.Z,{queryString:"code",children:[(0,a.jsx)(c.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,a.jsx)(r.Z,{language:"go",children:s})}),(0,a.jsx)(c.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,a.jsx)(r.Z,{language:"java",children:d})}),(0,a.jsx)(c.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,a.jsx)(r.Z,{language:"js",children:u})}),(0,a.jsx)(c.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,a.jsx)(r.Z,{language:"kotlin",children:o})}),(0,a.jsx)(c.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,a.jsx)(r.Z,{language:"python",children:m})}),(0,a.jsx)(c.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,a.jsx)(r.Z,{language:"rust",children:h})}),(0,a.jsx)(c.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,a.jsx)(r.Z,{language:"ts",children:p})})]})})]})]})}function S(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(v,{...e})}):v(e)}}}]);