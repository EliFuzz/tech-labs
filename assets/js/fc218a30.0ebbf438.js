"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[5213],{20534:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>g,contentTitle:()=>p,default:()=>_,frontMatter:()=>m,metadata:()=>f,toc:()=>x});var o=s(11527),t=s(88672),r=s(29140),i=s(52360),a=s(52296);const l="package main\n\nfunc getPossibleMoves(chessboard [][]int, position [2]int) [][2]int {\n\tpossibleMoves := [][2]int{\n\t\t{-1, -2},\n\t\t{-2, -1},\n\t\t{1, -2},\n\t\t{2, -1},\n\t\t{-2, 1},\n\t\t{-1, 2},\n\t\t{1, 2},\n\t\t{2, 1},\n\t}\n\n\tvar moves [][2]int\n\tfor _, move := range possibleMoves {\n\t\tdx, dy := move[0], move[1]\n\t\tx, y := position[0]+dx, position[1]+dy\n\t\tboardSize := len(chessboard)\n\t\tif x >= 0 && y >= 0 && x < boardSize && y < boardSize {\n\t\t\tmoves = append(moves, [2]int{x, y})\n\t\t}\n\t}\n\treturn moves\n}\n\nfunc isMoveAllowed(chessboard [][]int, move [2]int) bool {\n\tx, y := move[0], move[1]\n\treturn chessboard[x][y] != 1\n}\n\nfunc knightTourRecursive(chessboard [][]int, moves [][2]int, totalMoves int) bool {\n\tif len(moves) == totalMoves {\n\t\treturn true\n\t}\n\n\tlastMove := moves[len(moves)-1]\n\tpossibleMoves := getPossibleMoves(chessboard, lastMove)\n\n\tfor _, currentMove := range possibleMoves {\n\t\tif isMoveAllowed(chessboard, currentMove) {\n\t\t\tx, y := currentMove[0], currentMove[1]\n\t\t\tmoves = append(moves, currentMove)\n\t\t\tchessboard[x][y] = 1\n\n\t\t\tif knightTourRecursive(chessboard, moves, totalMoves) {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tmoves = moves[:len(moves)-1]\n\t\t\tchessboard[x][y] = 0\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc knightTour(chessboardSize int) [][2]int {\n\tchessboard := make([][]int, chessboardSize)\n\tfor i := range chessboard {\n\t\tchessboard[i] = make([]int, chessboardSize)\n\t}\n\n\tmoves := [][2]int{{0, 0}}\n\tchessboard[0][0] = 1\n\n\ttotalMoves := chessboardSize * chessboardSize\n\tsolutionWasFound := knightTourRecursive(chessboard, moves, totalMoves)\n\n\tif solutionWasFound {\n\t\treturn moves\n\t}\n\treturn nil\n}\n",c="import java.util.ArrayList;\nimport java.util.List;\n\npublic class KnightTour {\n\n  static List<Pair> getPossibleMoves(int[][] chessboard, Pair position) {\n    int[][] possibleMoves = {\n        {-1, -2},\n        {-2, -1},\n        {1, -2},\n        {2, -1},\n        {-2, 1},\n        {-1, 2},\n        {1, 2},\n        {2, 1}\n    };\n\n    List<Pair> moves = new ArrayList<>();\n    for (int[] move : possibleMoves) {\n      int dx = move[0];\n      int dy = move[1];\n      int x = position.x + dx;\n      int y = position.y + dy;\n      int boardSize = chessboard.length;\n      if (x >= 0 && y >= 0 && x < boardSize && y < boardSize) {\n        moves.add(new Pair(x, y));\n      }\n    }\n    return moves;\n  }\n\n  static boolean isMoveAllowed(int[][] chessboard, Pair move) {\n    int x = move.x;\n    int y = move.y;\n    return chessboard[x][y] != 1;\n  }\n\n  static boolean knightTourRecursive(int[][] chessboard, List<Pair> moves, int totalMoves) {\n    if (moves.size() == totalMoves) {\n      return true;\n    }\n\n    Pair lastMove = moves.get(moves.size() - 1);\n    List<Pair> possibleMoves = getPossibleMoves(chessboard, lastMove);\n\n    for (Pair currentMove : possibleMoves) {\n      if (isMoveAllowed(chessboard, currentMove)) {\n        int x = currentMove.x;\n        int y = currentMove.y;\n        moves.add(currentMove);\n        chessboard[x][y] = 1;\n\n        if (knightTourRecursive(chessboard, moves, totalMoves)) {\n          return true;\n        }\n\n        moves.remove(moves.size() - 1);\n        chessboard[x][y] = 0;\n      }\n    }\n\n    return false;\n  }\n\n  static List<Pair> knightTour(int chessboardSize) {\n    int[][] chessboard = new int[chessboardSize][chessboardSize];\n    List<Pair> moves = new ArrayList<>();\n    moves.add(new Pair(0, 0));\n    chessboard[0][0] = 1;\n\n    int totalMoves = chessboardSize * chessboardSize;\n    boolean solutionWasFound = knightTourRecursive(chessboard, moves, totalMoves);\n\n    if (solutionWasFound) {\n      return moves;\n    }\n    return new ArrayList<>();\n  }\n\n  static class Pair {\n\n    int x, y;\n\n    Pair(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n  }\n}\n",u="function getPossibleMoves(chessboard, position) {\n  const possibleMoves = [\n    [-1, -2],\n    [-2, -1],\n    [1, -2],\n    [2, -1],\n    [-2, 1],\n    [-1, 2],\n    [1, 2],\n    [2, 1],\n  ];\n\n  return possibleMoves\n    .map(([dx, dy]) => [position[0] + dx, position[1] + dy])\n    .filter(([x, y]) => {\n      const boardSize = chessboard.length;\n      return x >= 0 && y >= 0 && x < boardSize && y < boardSize;\n    });\n}\n\nfunction isMoveAllowed(chessboard, move) {\n  const [x, y] = move;\n  return chessboard[x][y] !== 1;\n}\n\nfunction knightTourRecursive(chessboard, moves, totalMoves) {\n  if (moves.length === totalMoves) {\n    return true;\n  }\n\n  const lastMove = moves[moves.length - 1];\n  const possibleMoves = getPossibleMoves(chessboard, lastMove);\n\n  for (const currentMove of possibleMoves) {\n    if (isMoveAllowed(chessboard, currentMove)) {\n      const [x, y] = currentMove;\n      moves.push(currentMove);\n      chessboard[x][y] = 1;\n\n      if (knightTourRecursive(chessboard, moves, totalMoves)) {\n        return true;\n      }\n\n      moves.pop();\n      chessboard[x][y] = 0;\n    }\n  }\n\n  return false;\n}\n\nfunction knightTour(chessboardSize) {\n  const chessboard = Array(chessboardSize)\n    .fill(null)\n    .map(() => Array(chessboardSize).fill(0));\n\n  const moves = [[0, 0]];\n  chessboard[0][0] = 1;\n\n  const totalMoves = chessboardSize * chessboardSize;\n  const solutionWasFound = knightTourRecursive(chessboard, moves, totalMoves);\n\n  return solutionWasFound ? moves : [];\n}\n",d="fun getPossibleMoves(chessboard: Array<IntArray>, position: IntArray): List<IntArray> {\n    val possibleMoves = arrayOf(\n            intArrayOf(-1, -2),\n            intArrayOf(-2, -1),\n            intArrayOf(1, -2),\n            intArrayOf(2, -1),\n            intArrayOf(-2, 1),\n            intArrayOf(-1, 2),\n            intArrayOf(1, 2),\n            intArrayOf(2, 1)\n    )\n\n    val moves = mutableListOf<IntArray>()\n    for ((dx, dy) in possibleMoves) {\n        val x = position[0] + dx\n        val y = position[1] + dy\n        val boardSize = chessboard.size\n        if (x >= 0 && y >= 0 && x < boardSize && y < boardSize) {\n            moves.add(intArrayOf(x, y))\n        }\n    }\n    return moves\n}\n\nfun isMoveAllowed(chessboard: Array<IntArray>, move: IntArray): Boolean {\n    val (x, y) = move\n    return chessboard[x][y] != 1\n}\n\nfun knightTourRecursive(chessboard: Array<IntArray>, moves: MutableList<IntArray>, totalMoves: Int): Boolean {\n    if (moves.size == totalMoves) {\n        return true\n    }\n\n    val lastMove = moves.last()\n    val possibleMoves = getPossibleMoves(chessboard, lastMove)\n\n    for (currentMove in possibleMoves) {\n        if (isMoveAllowed(chessboard, currentMove)) {\n            val (x, y) = currentMove\n            moves.add(currentMove)\n            chessboard[x][y] = 1\n\n            if (knightTourRecursive(chessboard, moves, totalMoves)) {\n                return true\n            }\n\n            moves.removeAt(moves.size - 1)\n            chessboard[x][y] = 0\n        }\n    }\n\n    return false\n}\n\nfun knightTour(chessboardSize: Int): List<IntArray> {\n    val chessboard = Array(chessboardSize) { IntArray(chessboardSize) }\n    val moves = mutableListOf(intArrayOf(0, 0))\n    chessboard[0][0] = 1\n\n    val totalMoves = chessboardSize * chessboardSize\n    val solutionWasFound = knightTourRecursive(chessboard, moves, totalMoves)\n\n    return if (solutionWasFound) moves else emptyList()\n}\n",v="def get_possible_moves(chessboard, position):\n    possible_moves = [\n        (-1, -2),\n        (-2, -1),\n        (1, -2),\n        (2, -1),\n        (-2, 1),\n        (-1, 2),\n        (1, 2),\n        (2, 1),\n    ]\n\n    board_size = len(chessboard)\n    moves = []\n    for dx, dy in possible_moves:\n        x = position[0] + dx\n        y = position[1] + dy\n        if 0 <= x < board_size and 0 <= y < board_size:\n            moves.append((x, y))\n    return moves\n\n\ndef is_move_allowed(chessboard, move):\n    x, y = move\n    return chessboard[x][y] != 1\n\n\ndef knight_tour_recursive(chessboard, moves, total_moves):\n    if len(moves) == total_moves:\n        return True\n\n    last_move = moves[-1]\n    possible_moves = get_possible_moves(chessboard, last_move)\n\n    for current_move in possible_moves:\n        if is_move_allowed(chessboard, current_move):\n            x, y = current_move\n            moves.append(current_move)\n            chessboard[x][y] = 1\n\n            if knight_tour_recursive(chessboard, moves, total_moves):\n                return True\n\n            moves.pop()\n            chessboard[x][y] = 0\n\n    return False\n\n\ndef knight_tour(chessboard_size):\n    chessboard = [[0] * chessboard_size for _ in range(chessboard_size)]\n    moves = [(0, 0)]\n    chessboard[0][0] = 1\n\n    total_moves = chessboard_size * chessboard_size\n    solution_was_found = knight_tour_recursive(chessboard, moves, total_moves)\n\n    return moves if solution_was_found else []\n",h="fn get_possible_moves(chessboard: &Vec<Vec<i32>>, position: &(usize, usize)) -> Vec<(usize, usize)> {\n    let possible_moves = vec![\n        (-1, -2),\n        (-2, -1),\n        (1, -2),\n        (2, -1),\n        (-2, 1),\n        (-1, 2),\n        (1, 2),\n        (2, 1),\n    ];\n\n    let board_size = chessboard.len();\n    let mut moves = Vec::new();\n    for (dx, dy) in possible_moves {\n        let x = position.0 as i32 + dx;\n        let y = position.1 as i32 + dy;\n        if x >= 0 && y >= 0 && x < board_size as i32 && y < board_size as i32 {\n            moves.push((x as usize, y as usize));\n        }\n    }\n    moves\n}\n\nfn is_move_allowed(chessboard: &Vec<Vec<i32>>, move: &(usize, usize)) -> bool {\n    let (x, y) = *move;\n    chessboard[x][y] != 1\n}\n\nfn knight_tour_recursive(chessboard: &mut Vec<Vec<i32>>, moves: &mut Vec<(usize, usize)>, total_moves: usize) -> bool {\n    if moves.len() == total_moves {\n        return true;\n    }\n\n    let last_move = *moves.last().unwrap();\n    let possible_moves = get_possible_moves(chessboard, &last_move);\n\n    for current_move in possible_moves {\n        if is_move_allowed(chessboard, &current_move) {\n            let (x, y) = current_move;\n            moves.push(current_move);\n            chessboard[x][y] = 1;\n\n            if knight_tour_recursive(chessboard, moves, total_moves) {\n                return true;\n            }\n\n            moves.pop();\n            chessboard[x][y] = 0;\n        }\n    }\n\n    false\n}\n\nfn knight_tour(chessboard_size: usize) -> Vec<(usize, usize)> {\n    let mut chessboard = vec![vec![0; chessboard_size]; chessboard_size];\n    let mut moves = vec![(0, 0)];\n    chessboard[0][0] = 1;\n\n    let total_moves = chessboard_size * chessboard_size;\n    let solution_was_found = knight_tour_recursive(&mut chessboard, &mut moves, total_moves);\n\n    if solution_was_found {\n        moves\n    } else {\n        Vec::new()\n    }\n}\n",b="function getPossibleMoves(\n  chessboard: number[][],\n  position: [number, number],\n): [number, number][] {\n  const possibleMoves: [number, number][] = [\n    [-1, -2],\n    [-2, -1],\n    [1, -2],\n    [2, -1],\n    [-2, 1],\n    [-1, 2],\n    [1, 2],\n    [2, 1],\n  ];\n\n  const boardSize = chessboard.length;\n  return possibleMoves\n    .map(([dx, dy]) => [position[0] + dx, position[1] + dy])\n    .filter(([x, y]) => x >= 0 && y >= 0 && x < boardSize && y < boardSize);\n}\n\nfunction isMoveAllowed(\n  chessboard: number[][],\n  move: [number, number],\n): boolean {\n  const [x, y] = move;\n  return chessboard[x][y] !== 1;\n}\n\nfunction knightTourRecursive(\n  chessboard: number[][],\n  moves: [number, number][],\n  totalMoves: number,\n): boolean {\n  if (moves.length === totalMoves) {\n    return true;\n  }\n\n  const lastMove = moves[moves.length - 1];\n  const possibleMoves = getPossibleMoves(chessboard, lastMove);\n\n  for (const currentMove of possibleMoves) {\n    if (isMoveAllowed(chessboard, currentMove)) {\n      const [x, y] = currentMove;\n      moves.push(currentMove);\n      chessboard[x][y] = 1;\n\n      if (knightTourRecursive(chessboard, moves, totalMoves)) {\n        return true;\n      }\n\n      moves.pop();\n      chessboard[x][y] = 0;\n    }\n  }\n\n  return false;\n}\n\nfunction knightTour(chessboardSize: number): [number, number][] {\n  const chessboard: number[][] = Array.from({ length: chessboardSize }, () =>\n    Array(chessboardSize).fill(0),\n  );\n  const moves: [number, number][] = [[0, 0]];\n  chessboard[0][0] = 1;\n\n  const totalMoves = chessboardSize * chessboardSize;\n  const solutionWasFound = knightTourRecursive(chessboard, moves, totalMoves);\n\n  return solutionWasFound ? moves : [];\n}\n",m={title:"Knight's Tour",description:"Knight's Tour",hide_table_of_contents:!0},p=void 0,f={id:"education/computer-science/algorithms/algo/knights-tour",title:"Knight's Tour",description:"Knight's Tour",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/knights-tour.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/knights-tour",permalink:"/docs/education/computer-science/algorithms/algo/knights-tour",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/knights-tour.mdx",tags:[],version:"current",frontMatter:{title:"Knight's Tour",description:"Knight's Tour",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Knapsack Problem",permalink:"/docs/education/computer-science/algorithms/algo/knapsack-problem"},next:{title:"Knuth\u2013Morris\u2013Pratt Algorithm (KMP Algorithm)",permalink:"/docs/education/computer-science/algorithms/algo/knuth\u2013morris\u2013pratt-algorithm"}},g={},x=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function y(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,o.jsxs)(r.Z,{children:[(0,o.jsx)(i.Z,{value:"definition",label:"Definition",children:(0,o.jsx)(n.p,{children:"The Knight's Tour Algorithm is a method used to solve the puzzle of moving a knight chess piece to visit every square on a chessboard exactly once"})}),(0,o.jsx)(i.Z,{value:"how",label:"Explanation",children:(0,o.jsx)(n.p,{children:"Starting with an empty chessboard, positioning the knight arbitrarily on one of its squares. Subsequently, it systematically investigates all feasible moves adhering to the regulations of chess. During each iteration, the algorithm favors moves that lead to unvisited squares. If the knight encounters a situation where no further unvisited squares are accessible, it retraces its steps to the previous position, seeking an alternative path. This iterative process persists until either every square has been visited, signifying a successful tour, or all potential moves have been exhausted, resulting in an unsuccessful attempt"})}),(0,o.jsx)(i.Z,{value:"guidance",label:"Guidance",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Start with an empty chessboard and place the knight on any square"}),"\n",(0,o.jsx)(n.li,{children:"From the current position, calculate all possible moves according to the knight's movement rules"}),"\n",(0,o.jsx)(n.li,{children:"Choose one of the unvisited squares reachable from the current position"}),"\n",(0,o.jsx)(n.li,{children:"Move the knight to the chosen square and mark it as visited"}),"\n",(0,o.jsx)(n.li,{children:"Repeat steps 2-4 until either all squares are visited or there are no more unvisited squares reachable from the current position"}),"\n",(0,o.jsx)(n.li,{children:"If all squares are visited, the algorithm terminates successfully. If not, backtrack to the previous position and choose another unvisited square"}),"\n",(0,o.jsx)(n.li,{children:"Continue backtracking until either a successful tour is found or all possible paths are exhausted"}),"\n"]})}),(0,o.jsx)(i.Z,{value:"tips",label:"Tips",children:(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"prioritize moves that lead to squares with fewer unvisited neighbors to increase the chances of finding a successful tour"}),"\n",(0,o.jsx)(n.li,{children:"implement a data structure to efficiently track visited squares and available moves"}),"\n",(0,o.jsx)(n.li,{children:"consider implementing heuristics or optimizations to improve the algorithm's performance, such as Warnsdorff's rule for selecting the next move"}),"\n"]})})]}),"\n",(0,o.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,o.jsxs)(r.Z,{children:[(0,o.jsx)(i.Z,{value:"practice",label:"Practice",children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'knight_tour(board, row, col, move_count):\n    if move_count == board.size ** 2:\n        return true  // All squares visited, tour complete\n\n    for each possible move from (row, col) as (next_row, next_col):\n        if is_valid_move(board, next_row, next_col):\n            mark_square_as_visited(board, next_row, next_col, move_count)\n            if knight_tour(board, next_row, next_col, move_count + 1):\n                return true  // Successful tour found\n            else:\n                unmark_square(board, next_row, next_col) // Backtrack\n    return false  // No successful tour found\n\ninitialize chessboard\nstart_row, start_col = choose_starting_position(chessboard)\nif knight_tour(chessboard, start_row, start_col, 1):\n    print("Successful tour found")\nelse:\n    print("No tour found")\n'})})}),(0,o.jsx)(i.Z,{value:"solution",label:"Solution",children:(0,o.jsxs)(r.Z,{queryString:"code",children:[(0,o.jsx)(i.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,o.jsx)(a.Z,{language:"go",children:l})}),(0,o.jsx)(i.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,o.jsx)(a.Z,{language:"java",children:c})}),(0,o.jsx)(i.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,o.jsx)(a.Z,{language:"js",children:u})}),(0,o.jsx)(i.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,o.jsx)(a.Z,{language:"kotlin",children:d})}),(0,o.jsx)(i.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,o.jsx)(a.Z,{language:"python",children:v})}),(0,o.jsx)(i.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,o.jsx)(a.Z,{language:"rust",children:h})}),(0,o.jsx)(i.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,o.jsx)(a.Z,{language:"ts",children:b})})]})})]})]})}function _(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(y,{...e})}):y(e)}}}]);