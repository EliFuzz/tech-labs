"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[5585],{38450:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>b,contentTitle:()=>f,default:()=>q,frontMatter:()=>p,metadata:()=>g,toc:()=>S});var s=t(86070),i=t(25710),r=t(98459),l=t(37515),c=t(18792);const a="package main\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc shortestCommonSupersequence(str1, str2 string) string {\n\tm, n := len(str1), len(str2)\n\tdp := make([][]int, m+1)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, n+1)\n\t}\n\n\tfor i := 0; i <= m; i++ {\n\t\tfor j := 0; j <= n; j++ {\n\t\t\tif i == 0 {\n\t\t\t\tdp[i][j] = j\n\t\t\t} else if j == 0 {\n\t\t\t\tdp[i][j] = i\n\t\t\t} else if str1[i-1] == str2[j-1] {\n\t\t\t\tdp[i][j] = dp[i-1][j-1] + 1\n\t\t\t} else {\n\t\t\t\tdp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1])\n\t\t\t}\n\t\t}\n\t}\n\n\t// Reconstruct the shortest common supersequence\n\ti, j := m, n\n\tvar result string\n\tfor i > 0 && j > 0 {\n\t\tif str1[i-1] == str2[j-1] {\n\t\t\tresult = string(str1[i-1]) + result\n\t\t\ti--\n\t\t\tj--\n\t\t} else if dp[i-1][j] < dp[i][j-1] {\n\t\t\tresult = string(str1[i-1]) + result\n\t\t\ti--\n\t\t} else {\n\t\t\tresult = string(str2[j-1]) + result\n\t\t\tj--\n\t\t}\n\t}\n\n\tfor i > 0 {\n\t\tresult = string(str1[i-1]) + result\n\t\ti--\n\t}\n\n\tfor j > 0 {\n\t\tresult = string(str2[j-1]) + result\n\t\tj--\n\t}\n\n\treturn result\n}\n",o="public class ShortestCommonSupersequence {\n\n  public static String shortestCommonSupersequence(String str1, String str2) {\n    int m = str1.length();\n    int n = str2.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n      for (int j = 0; j <= n; j++) {\n        if (i == 0) {\n          dp[i][j] = j;\n        } else if (j == 0) {\n          dp[i][j] = i;\n        } else if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n          dp[i][j] = dp[i - 1][j - 1] + 1;\n        } else {\n          dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1]);\n        }\n      }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    int i = m, j = n;\n    while (i > 0 && j > 0) {\n      if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n        sb.insert(0, str1.charAt(i - 1));\n        i--;\n        j--;\n      } else if (dp[i - 1][j] < dp[i][j - 1]) {\n        sb.insert(0, str1.charAt(i - 1));\n        i--;\n      } else {\n        sb.insert(0, str2.charAt(j - 1));\n        j--;\n      }\n    }\n    while (i > 0) {\n      sb.insert(0, str1.charAt(i - 1));\n      i--;\n    }\n    while (j > 0) {\n      sb.insert(0, str2.charAt(j - 1));\n      j--;\n    }\n    return sb.toString();\n  }\n}\n",u='function shortestCommonSupersequence(str1, str2) {\n  const m = str1.length;\n  const n = str2.length;\n  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n\n  for (let i = 0; i <= m; i++) {\n    for (let j = 0; j <= n; j++) {\n      if (i === 0) {\n        dp[i][j] = j;\n      } else if (j === 0) {\n        dp[i][j] = i;\n      } else if (str1[i - 1] === str2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n      } else {\n        dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n\n  let i = m,\n    j = n;\n  let result = "";\n  while (i > 0 && j > 0) {\n    if (str1[i - 1] === str2[j - 1]) {\n      result = str1[i - 1] + result;\n      i--;\n      j--;\n    } else if (dp[i - 1][j] < dp[i][j - 1]) {\n      result = str1[i - 1] + result;\n      i--;\n    } else {\n      result = str2[j - 1] + result;\n      j--;\n    }\n  }\n  while (i > 0) {\n    result = str1[i - 1] + result;\n    i--;\n  }\n  while (j > 0) {\n    result = str2[j - 1] + result;\n    j--;\n  }\n  return result;\n}\n',h='fun shortestCommonSupersequence(str1: String, str2: String): String {\n    val m = str1.length\n    val n = str2.length\n    val dp = Array(m + 1) { IntArray(n + 1) }\n\n    for (i in 0..m) {\n        for (j in 0..n) {\n            when {\n                i == 0 -> dp[i][j] = j\n                j == 0 -> dp[i][j] = i\n                str1[i - 1] == str2[j - 1] -> dp[i][j] = dp[i - 1][j - 1] + 1\n                else -> dp[i][j] = 1 + minOf(dp[i - 1][j], dp[i][j - 1])\n            }\n        }\n    }\n\n    var i = m\n    var j = n\n    var result = ""\n    while (i > 0 && j > 0) {\n        when {\n            str1[i - 1] == str2[j - 1] -> {\n                result = str1[i - 1] + result\n                i--\n                j--\n            }\n\n            dp[i - 1][j] < dp[i][j - 1] -> {\n                result = str1[i - 1] + result\n                i--\n            }\n\n            else -> {\n                result = str2[j - 1] + result\n                j--\n            }\n        }\n    }\n    while (i > 0) {\n        result = str1[i - 1] + result\n        i--\n    }\n    while (j > 0) {\n        result = str2[j - 1] + result\n        j--\n    }\n    return result\n}\n',j="def shortest_common_supersequence(str1, str2):\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i - 1] == str2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])\n\n    i, j = m, n\n    result = ''\n    while i > 0 and j > 0:\n        if str1[i - 1] == str2[j - 1]:\n            result = str1[i - 1] + result\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] < dp[i][j - 1]:\n            result = str1[i - 1] + result\n            i -= 1\n        else:\n            result = str2[j - 1] + result\n            j -= 1\n    while i > 0:\n        result = str1[i - 1] + result\n        i -= 1\n    while j > 0:\n        result = str2[j - 1] + result\n        j -= 1\n    return result\n",d="fn shortest_common_supersequence(str1: &str, str2: &str) -> String {\n    let m = str1.len();\n    let n = str2.len();\n    let mut dp = vec![vec![0; n + 1]; m + 1];\n\n    for i in 0..=m {\n        for j in 0..=n {\n            if i == 0 {\n                dp[i][j] = j;\n            } else if j == 0 {\n                dp[i][j] = i;\n            } else if str1.chars().nth(i - 1).unwrap() == str2.chars().nth(j - 1).unwrap() {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = 1 + dp[i - 1][j].min(dp[i][j - 1]);\n            }\n        }\n    }\n\n    let (mut i, mut j) = (m, n);\n    let mut result = String::new();\n    while i > 0 && j > 0 {\n        if str1.chars().nth(i - 1).unwrap() == str2.chars().nth(j - 1).unwrap() {\n            result.insert(0, str1.chars().nth(i - 1).unwrap());\n            i -= 1;\n            j -= 1;\n        } else if dp[i - 1][j] < dp[i][j - 1] {\n            result.insert(0, str1.chars().nth(i - 1).unwrap());\n            i -= 1;\n        } else {\n            result.insert(0, str2.chars().nth(j - 1).unwrap());\n            j -= 1;\n        }\n    }\n    while i > 0 {\n        result.insert(0, str1.chars().nth(i - 1).unwrap());\n        i -= 1;\n    }\n    while j > 0 {\n        result.insert(0, str2.chars().nth(j - 1).unwrap());\n        j -= 1;\n    }\n    result\n}\n",m='function shortestCommonSupersequence(str1: string, str2: string): string {\n  const m = str1.length;\n  const n = str2.length;\n  const dp: number[][] = Array.from({ length: m + 1 }, () =>\n    Array(n + 1).fill(0),\n  );\n\n  for (let i = 0; i <= m; i++) {\n    for (let j = 0; j <= n; j++) {\n      if (i === 0) {\n        dp[i][j] = j;\n      } else if (j === 0) {\n        dp[i][j] = i;\n      } else if (str1[i - 1] === str2[j - 1]) {\n        dp[i][j] = dp[i - 1][j - 1] + 1;\n      } else {\n        dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n\n  let i = m,\n    j = n;\n  let result = "";\n  while (i > 0 && j > 0) {\n    if (str1[i - 1] === str2[j - 1]) {\n      result = str1[i - 1] + result;\n      i--;\n      j--;\n    } else if (dp[i - 1][j] < dp[i][j - 1]) {\n      result = str1[i - 1] + result;\n      i--;\n    } else {\n      result = str2[j - 1] + result;\n      j--;\n    }\n  }\n  while (i > 0) {\n    result = str1[i - 1] + result;\n    i--;\n  }\n  while (j > 0) {\n    result = str2[j - 1] + result;\n    j--;\n  }\n  return result;\n}\n',p={title:"Shortest Common Supersequence (SCS)",description:"Shortest Common Supersequence (SCS)",hide_table_of_contents:!0},f=void 0,g={id:"education/computer-science/algorithms/algo/shortest-common-supersequence",title:"Shortest Common Supersequence (SCS)",description:"Shortest Common Supersequence (SCS)",source:"@site/docs/education/01-computer-science/10-algorithms/04-algo/shortest-common-supersequence.mdx",sourceDirName:"education/01-computer-science/10-algorithms/04-algo",slug:"/education/computer-science/algorithms/algo/shortest-common-supersequence",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/shortest-common-supersequence",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/shortest-common-supersequence.mdx",tags:[],version:"current",frontMatter:{title:"Shortest Common Supersequence (SCS)",description:"Shortest Common Supersequence (SCS)",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Shellsort",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/shellsort"},next:{title:"Sieve of Eratosthenes",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/sieve-of-eratosthenes"}},b={},S=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function x(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,s.jsxs)(r.A,{queryString:"primary",children:[(0,s.jsx)(l.A,{value:"definition",label:"Definition",children:(0,s.jsx)(n.p,{children:"The Shortest Common Supersequence (SCS) algorithm finds the shortest supersequence that contains all the given sequences as subsequences. It's a dynamic programming-based approach, commonly used in bioinformatics, data compression, and version control systems. This algorithm efficiently computes the length of the SCS and can also reconstruct the SCS itself"})}),(0,s.jsx)(l.A,{value:"how",label:"Explanation",children:(0,s.jsx)(n.p,{children:"It leverages dynamic programming to find the shortest common supersequence of two given sequences. It involves constructing a table where each cell represents the length of the SCS for subsequences of the original sequences. The algorithm fills this table iteratively by considering three possibilities: extending the supersequence by adding characters from each sequence individually, or if the characters match, extending the supersequence by adding that character once. The final cell of the table holds the length of the SCS. By tracing back through the table, the SCS itself can be reconstructed"})}),(0,s.jsx)(l.A,{value:"guidance",label:"Guidance",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Initialize a 2D table of size ",(0,s.jsx)(n.code,{children:"[m+1][n+1]"})," where m and n are the lengths of the two sequences"]}),"\n",(0,s.jsx)(n.li,{children:"Fill the first row and first column of the table with values representing the lengths of empty subsequences"}),"\n",(0,s.jsxs)(n.li,{children:["Iterate through each cell of the table starting from ",(0,s.jsx)(n.code,{children:"[1,1]"})," to ",(0,s.jsx)(n.code,{children:"[m,n]"})]}),"\n",(0,s.jsxs)(n.li,{children:["For each cell ",(0,s.jsx)(n.code,{children:"[i,j]"}),", if the characters at positions ",(0,s.jsx)(n.code,{children:"i-1"})," and ",(0,s.jsx)(n.code,{children:"j-1"})," in the sequences match, set the value of the current cell to one plus the value of the cell diagonally left-upwards"]}),"\n",(0,s.jsx)(n.li,{children:"If the characters don't match, set the value of the current cell to the maximum of the cell directly above or directly leftwards"}),"\n",(0,s.jsx)(n.li,{children:"The value in the bottom-right cell of the table represents the length of the SCS"}),"\n",(0,s.jsx)(n.li,{children:"Reconstruct the SCS by tracing back through the table, starting from the bottom-right cell, following the rules of movement (diagonal if characters match, otherwise up or left)"}),"\n",(0,s.jsx)(n.li,{children:"Concatenate the characters encountered during the tracing to form the SCS"}),"\n"]})}),(0,s.jsx)(l.A,{value:"tips",label:"Tips",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"utilize memoization or tabulation to optimize the algorithm's time complexity"}),"\n",(0,s.jsx)(n.li,{children:"ensure to handle cases where one sequence is a subsequence of the other efficiently"}),"\n",(0,s.jsx)(n.li,{children:"it's crucial to understand the recurrence relation and base cases for dynamic programming implementation"}),"\n",(0,s.jsx)(n.li,{children:"consider implementing a solution that reconstructs the actual SCS sequence if required"}),"\n"]})})]}),"\n",(0,s.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,s.jsxs)(r.A,{queryString:"primary",children:[(0,s.jsx)(l.A,{value:"practice",label:"Practice",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'shortest_common_supersequence(sequence1, sequence2):\n  m = length(sequence1)\n  n = length(sequence2)\n  table = create_table(m+1, n+1)\n\n  // Step 1: Initialize the table\n  for i from 0 to m:\n    table[i][0] = i\n  for j from 0 to n:\n    table[0][j] = j\n\n  // Step 2: Fill the table\n  for i from 1 to m:\n    for j from 1 to n:\n      if sequence1[i-1] == sequence2[j-1]:\n        table[i][j] = 1 + table[i-1][j-1]\n      else:\n        table[i][j] = max(table[i-1][j], table[i][j-1])\n\n  // Step 3: Reconstruct the SCS\n  scs = ""\n  i = m\n  j = n\n  while i > 0 and j > 0:\n    if sequence1[i-1] == sequence2[j-1]:\n      scs = sequence1[i-1] + scs\n      i = i - 1\n      j = j - 1\n    else:\n      if table[i-1][j] > table[i][j-1]:\n        scs = sequence1[i-1] + scs\n        i = i - 1\n      else:\n        scs = sequence2[j-1] + scs\n        j = j - 1\n\n  // Step 4: Add remaining characters\n  while i > 0:\n    scs = sequence1[i-1] + scs\n    i = i - 1\n  while j > 0:\n    scs = sequence2[j-1] + scs\n    j = j - 1\n\n  return scs\n'})})}),(0,s.jsx)(l.A,{value:"solution",label:"Solution",children:(0,s.jsxs)(r.A,{queryString:"code",children:[(0,s.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,s.jsx)(c.A,{language:"go",children:a})}),(0,s.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,s.jsx)(c.A,{language:"java",children:o})}),(0,s.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,s.jsx)(c.A,{language:"js",children:u})}),(0,s.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,s.jsx)(c.A,{language:"kotlin",children:h})}),(0,s.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,s.jsx)(c.A,{language:"python",children:j})}),(0,s.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,s.jsx)(c.A,{language:"rust",children:d})}),(0,s.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,s.jsx)(c.A,{language:"ts",children:m})})]})})]})]})}function q(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(x,{...e})}):x(e)}}}]);