"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[3884],{55036:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>L,contentTitle:()=>x,default:()=>V,frontMatter:()=>y,metadata:()=>A,toc:()=>m});var r=t(86070),i=t(27468),o=t(20301),h=t(35379),d=t(81895);const l='package main\n\nimport (\n\t"math"\n)\n\ntype AVLNode struct {\n\tKey    int\n\tLeft   *AVLNode\n\tRight  *AVLNode\n\tHeight int\n}\n\ntype AVLTree struct {\n\tRoot *AVLNode\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc height(node *AVLNode) int {\n\tif node == nil {\n\t\treturn 0\n\t}\n\treturn node.Height\n}\n\nfunc (tree *AVLTree) insert(node *AVLNode, key int) *AVLNode {\n\tif node == nil {\n\t\treturn &AVLNode{Key: key}\n\t}\n\n\tif key < node.Key {\n\t\tnode.Left = tree.insert(node.Left, key)\n\t} else if key > node.Key {\n\t\tnode.Right = tree.insert(node.Right, key)\n\t}\n\n\tnode.Height = 1 + max(height(node.Left), height(node.Right))\n\n\treturn tree.rebalance(node)\n}\n\nfunc (tree *AVLTree) rebalance(node *AVLNode) *AVLNode {\n\tbalance := tree.getBalance(node)\n\n\tif balance > 1 {\n\t\tif tree.getBalance(node.Left) < 0 {\n\t\t\tnode.Left = tree.leftRotate(node.Left)\n\t\t}\n\t\treturn tree.rightRotate(node)\n\t}\n\n\tif balance < -1 {\n\t\tif tree.getBalance(node.Right) > 0 {\n\t\t\tnode.Right = tree.rightRotate(node.Right)\n\t\t}\n\t\treturn tree.leftRotate(node)\n\t}\n\n\treturn node\n}\n\nfunc (tree *AVLTree) leftRotate(y *AVLNode) *AVLNode {\n\tx := y.Right\n\tT2 := x.Left\n\n\tx.Left = y\n\ty.Right = T2\n\n\ty.Height = 1 + max(height(y.Left), height(y.Right))\n\tx.Height = 1 + max(height(x.Left), height(x.Right))\n\n\treturn x\n}\n\nfunc (tree *AVLTree) rightRotate(x *AVLNode) *AVLNode {\n\ty := x.Left\n\tT2 := y.Right\n\n\ty.Right = x\n\tx.Left = T2\n\n\tx.Height = 1 + max(height(x.Left), height(x.Right))\n\ty.Height = 1 + max(height(y.Left), height(y.Right))\n\n\treturn y\n}\n\nfunc (tree *AVLTree) height(node *AVLNode) int {\n\tif node == nil {\n\t\treturn 0\n\t}\n\treturn node.Height\n}\n\nfunc (tree *AVLTree) getBalance(node *AVLNode) int {\n\treturn tree.height(node.Left) - tree.height(node.Right)\n}\n\nfunc (tree *AVLTree) search(node *AVLNode, key int) *AVLNode {\n\tif node == nil || key == node.Key {\n\t\treturn node\n\t}\n\tif key < node.Key {\n\t\treturn tree.search(node.Left, key)\n\t}\n\treturn tree.search(node.Right, key)\n}\n\nfunc (tree *AVLTree) findMin(node *AVLNode) *AVLNode {\n\tcurrent := node\n\tfor current.Left != nil {\n\t\tcurrent = current.Left\n\t}\n\treturn current\n}\n\nfunc (tree *AVLTree) findMax(node *AVLNode) *AVLNode {\n\tcurrent := node\n\tfor current.Right != nil {\n\t\tcurrent = current.Right\n\t}\n\treturn current\n}\n\nfunc inorderTraversal(node *AVLNode) {\n\tif node != nil {\n\t\tinorderTraversal(node.Left)\n\t\tfmt.Print(node.Key, " ")\n\t\tinorderTraversal(node.Right)\n\t}\n}\n',a="public class AVLTree {\n\n  private AVLNode root;\n\n  public AVLNode insert(AVLNode node, int key) {\n    if (node == null) {\n      return new AVLNode(key);\n    }\n\n    if (key < node.key) {\n      node.left = insert(node.left, key);\n    } else if (key > node.key) {\n      node.right = insert(node.right, key);\n    }\n\n    node.height = 1 + Math.max(height(node.left), height(node.right));\n\n    return rebalance(node);\n  }\n\n  private AVLNode rebalance(AVLNode node) {\n    int balance = getBalance(node);\n\n    if (balance > 1) {\n      if (getBalance(node.left) < 0) {\n        node.left = leftRotate(node.left);\n      }\n      return rightRotate(node);\n    }\n\n    if (balance < -1) {\n      if (getBalance(node.right) > 0) {\n        node.right = rightRotate(node.right);\n      }\n      return leftRotate(node);\n    }\n\n    return node;\n  }\n\n  private AVLNode leftRotate(AVLNode y) {\n    AVLNode x = y.right;\n    AVLNode T2 = x.left;\n\n    x.left = y;\n    y.right = T2;\n\n    y.height = 1 + Math.max(height(y.left), height(y.right));\n    x.height = 1 + Math.max(height(x.left), height(x.right));\n\n    return x;\n  }\n\n  private AVLNode rightRotate(AVLNode x) {\n    AVLNode y = x.left;\n    AVLNode T2 = y.right;\n\n    y.right = x;\n    x.left = T2;\n\n    x.height = 1 + Math.max(height(x.left), height(x.right));\n    y.height = 1 + Math.max(height(y.left), height(y.right));\n\n    return y;\n  }\n\n  private int height(AVLNode node) {\n    return (node != null) ? node.height : 0;\n  }\n\n  private int getBalance(AVLNode node) {\n    return (node != null) ? height(node.left) - height(node.right) : 0;\n  }\n\n  public AVLNode search(AVLNode node, int key) {\n    if (node == null || key == node.key) {\n      return node;\n    }\n    return (key < node.key) ? search(node.left, key) : search(node.right, key);\n  }\n\n  public AVLNode findMin(AVLNode node) {\n    AVLNode current = node;\n    while (current != null && current.left != null) {\n      current = current.left;\n    }\n    return current;\n  }\n\n  public AVLNode findMax(AVLNode node) {\n    AVLNode current = node;\n    while (current != null && current.right != null) {\n      current = current.right;\n    }\n    return current;\n  }\n\n  public static class AVLNode {\n\n    public int key;\n    public AVLNode left;\n    public AVLNode right;\n    public int height;\n\n    public AVLNode(int key) {\n      this.key = key;\n      this.height = 1;\n    }\n  }\n}\n",s="class AVLTree {\n  static AVLNode = class {\n    constructor(key, left = null, right = null, height = 1) {\n      this.key = key;\n      this.left = left;\n      this.right = right;\n      this.height = height;\n    }\n  };\n\n  constructor() {\n    this.root = null;\n  }\n\n  insert(node, key) {\n    if (node === null) {\n      return new AVLTree.AVLNode(key);\n    }\n\n    if (key < node.key) {\n      node.left = this.insert(node.left, key);\n    } else if (key > node.key) {\n      node.right = this.insert(node.right, key);\n    }\n\n    node.height = 1 + this.max(this.height(node.left), this.height(node.right));\n\n    return this.rebalance(node);\n  }\n\n  rebalance(node) {\n    const balance = this.getBalance(node);\n\n    if (balance > 1) {\n      if (this.getBalance(node.left) < 0) {\n        node.left = this.leftRotate(node.left);\n      }\n      return this.rightRotate(node);\n    }\n\n    if (balance < -1) {\n      if (this.getBalance(node.right) > 0) {\n        node.right = this.rightRotate(node.right);\n      }\n      return this.leftRotate(node);\n    }\n\n    return node || new AVLTree.AVLNode(0);\n  }\n\n  leftRotate(y) {\n    const x = y.right;\n    const T2 = x.left;\n\n    x.left = y;\n    y.right = T2;\n\n    y.height = 1 + this.max(this.height(y.left), this.height(y.right));\n    x.height = 1 + this.max(this.height(x.left), this.height(x.right));\n\n    return x;\n  }\n\n  rightRotate(x) {\n    const y = x.left;\n    const T2 = y.right;\n\n    y.right = x;\n    x.left = T2;\n\n    x.height = 1 + this.max(this.height(x.left), this.height(x.right));\n    y.height = 1 + this.max(this.height(y.left), this.height(y.right));\n\n    return y;\n  }\n\n  height(node) {\n    return node ? node.height : 0;\n  }\n\n  getBalance(node) {\n    return node ? this.height(node.left) - this.height(node.right) : 0;\n  }\n\n  search(node, key) {\n    if (!node || key === node.key) {\n      return node;\n    }\n    return key < node.key\n      ? this.search(node.left, key)\n      : this.search(node.right, key);\n  }\n\n  findMin(node) {\n    let current = node;\n    while (current && current.left) {\n      current = current.left;\n    }\n    return current;\n  }\n\n  findMax(node) {\n    let current = node;\n    while (current && current.right) {\n      current = current.right;\n    }\n    return current;\n  }\n\n  max(a, b) {\n    return a > b ? a : b;\n  }\n}\n",c="class AVLTree {\n    data class AVLNode(var key: Int, var left: AVLNode? = null, var right: AVLNode? = null, var height: Int = 1)\n\n    var root: AVLNode? = null\n\n    fun insert(node: AVLNode?, key: Int): AVLNode {\n        if (node == null) {\n            return AVLNode(key)\n        }\n\n        if (key < node.key) {\n            node.left = insert(node.left, key)\n        } else if (key > node.key) {\n            node.right = insert(node.right, key)\n        } else {\n        }\n\n        node.height = 1 + max(height(node.left), height(node.right))\n\n        return rebalance(node)\n    }\n\n    private fun rebalance(node: AVLNode?): AVLNode {\n        val balance = getBalance(node)\n\n        if (balance > 1) {\n            if (getBalance(node?.left) < 0) {\n                node?.left = leftRotate(node?.left)\n            }\n            return rightRotate(node)\n        }\n\n        if (balance < -1) {\n            if (getBalance(node?.right) > 0) {\n                node?.right = rightRotate(node?.right)\n            }\n            return leftRotate(node)\n        }\n\n        return node ?: AVLNode(0)\n    }\n\n    private fun leftRotate(y: AVLNode?): AVLNode? {\n        val x = y?.right\n        val T2 = x?.left\n\n        x?.left = y\n        y?.right = T2\n\n        y?.height = 1 + max(height(y?.left), height(y?.right))\n        x?.height = 1 + max(height(x?.left), height(x?.right))\n\n        return x\n    }\n\n    private fun rightRotate(x: AVLNode?): AVLNode? {\n        val y = x?.left\n        val T2 = y?.right\n\n        y?.right = x\n        x?.left = T2\n\n        x?.height = 1 + max(height(x?.left), height(x?.right))\n        y?.height = 1 + max(height(y?.left), height(y?.right))\n\n        return y\n    }\n\n    private fun height(node: AVLNode?): Int {\n        return node?.height ?: 0\n    }\n\n    private fun getBalance(node: AVLNode?): Int {\n        return height(node?.left) - height(node?.right)\n    }\n\n    fun search(node: AVLNode?, key: Int): AVLNode? {\n        if (node == null || key == node.key) {\n            return node\n        }\n        return if (key < node.key) {\n            search(node.left, key)\n        } else {\n            search(node.right, key)\n        }\n    }\n\n    fun findMin(node: AVLNode?): AVLNode? {\n        var current = node\n        while (current?.left != null) {\n            current = current.left\n        }\n        return current\n    }\n\n    fun findMax(node: AVLNode?): AVLNode? {\n        var current = node\n        while (current?.right != null) {\n            current = current.right\n        }\n        return current\n    }\n}\n",f="class AVLTree:\n    class AVLNode:\n        def __init__(self, key, left=None, right=None, height=1):\n            self.key = key\n            self.left = left\n            self.right = right\n            self.height = height\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, node, key):\n        if node is None:\n            return self.AVLNode(key)\n\n        if key < node.key:\n            node.left = self.insert(node.left, key)\n        elif key > node.key:\n            node.right = self.insert(node.right, key)\n\n        node.height = 1 + max(self.height(node.left), self.height(node.right))\n\n        return self.rebalance(node)\n\n    def rebalance(self, node):\n        balance = self.get_balance(node)\n\n        if balance > 1:\n            if self.get_balance(node.left) < 0:\n                node.left = self.left_rotate(node.left)\n            return self.right_rotate(node)\n\n        if balance < -1:\n            if self.get_balance(node.right) > 0:\n                node.right = self.right_rotate(node.right)\n            return self.left_rotate(node)\n\n        return node or self.AVLNode(0)\n\n    def left_rotate(self, y):\n        x = y.right\n        T2 = x.left\n\n        x.left = y\n        y.right = T2\n\n        y.height = 1 + max(self.height(y.left), self.height(y.right))\n        x.height = 1 + max(self.height(x.left), self.height(x.right))\n\n        return x\n\n    def right_rotate(self, x):\n        y = x.left\n        T2 = y.right\n\n        y.right = x\n        x.left = T2\n\n        x.height = 1 + max(self.height(x.left), self.height(x.right))\n        y.height = 1 + max(self.height(y.left), self.height(y.right))\n\n        return y\n\n    def height(self, node):\n        return node.height if node else 0\n\n    def get_balance(self, node):\n        return self.height(node.left) - self.height(node.right) if node else 0\n\n    def search(self, node, key):\n        if not node or key == node.key:\n            return node\n        return self.search(node.left, key) if key < node.key else self.search(node.right, key)\n\n    def find_min(self, node):\n        current = node\n        while current and current.left:\n            current = current.left\n        return current\n\n    def find_max(self, node):\n        current = node\n        while current and current.right:\n            current = current.right\n        return current\n",g="use std::cmp::max;\nuse std::mem;\n\n#[derive(Debug)]\nstruct AVLNode {\n    key: i32,\n    left: Option<Box<AVLNode>>,\n    right: Option<Box<AVLNode>>,\n    height: i32,\n}\n\nimpl AVLNode {\n    fn new(key: i32) -> Self {\n        AVLNode {\n            key,\n            left: None,\n            right: None,\n            height: 1,\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct AVLTree {\n    root: Option<Box<AVLNode>>,\n}\n\nimpl AVLTree {\n    pub fn new() -> Self {\n        AVLTree { root: None }\n    }\n\n    pub fn insert(&mut self, node: Option<Box<AVLNode>>, key: i32) -> Option<Box<AVLNode>> {\n        let mut new_node = node.unwrap_or_else(|| Box::new(AVLNode::new(key)));\n\n        if key < new_node.key {\n            new_node.left = self.insert(mem::replace(&mut new_node.left, None), key);\n        } else if key > new_node.key {\n            new_node.right = self.insert(mem::replace(&mut new_node.right, None), key);\n        }\n\n        new_node.height = 1 + max(Self::height(&new_node.left), Self::height(&new_node.right));\n\n        Some(Box::new(self.rebalance(new_node)))\n    }\n\n    fn rebalance(&self, mut node: AVLNode) -> AVLNode {\n        let balance = Self::get_balance(&node);\n\n        if balance > 1 {\n            if Self::get_balance(&node.left) < 0 {\n                node.left = Some(Box::new(self.left_rotate(node.left.take().unwrap())));\n            }\n            return self.right_rotate(node);\n        }\n\n        if balance < -1 {\n            if Self::get_balance(&node.right) > 0 {\n                node.right = Some(Box::new(self.right_rotate(node.right.take().unwrap())));\n            }\n            return self.left_rotate(node);\n        }\n\n        node\n    }\n\n    fn left_rotate(&self, mut y: AVLNode) -> AVLNode {\n        let x = y.right.take().unwrap();\n        let t2 = x.left.take();\n\n        y.right = Some(x);\n        x.left = Some(Box::new(y));\n\n        y.height = 1 + max(Self::height(&y.left), Self::height(&y.right));\n        x.height = 1 + max(Self::height(&x.left), Self::height(&x.right));\n\n        x.into_inner()\n    }\n\n    fn right_rotate(&self, mut x: AVLNode) -> AVLNode {\n        let y = x.left.take().unwrap();\n        let t2 = y.right.take();\n\n        x.left = Some(y);\n        y.right = Some(Box::new(x));\n\n        x.height = 1 + max(Self::height(&x.left), Self::height(&x.right));\n        y.height = 1 + max(Self::height(&y.left), Self::height(&y.right));\n\n        y.into_inner()\n    }\n\n    fn height(node: &Option<Box<AVLNode>>) -> i32 {\n        node.as_ref().map_or(0, |n| n.height)\n    }\n\n    fn get_balance(node: &Option<Box<AVLNode>>) -> i32 {\n        Self::height(&node.as_ref().map(|n| n.left.clone())) - Self::height(&node.as_ref().map(|n| n.right.clone()))\n    }\n\n    pub fn search(&self, node: &Option<Box<AVLNode>>, key: i32) -> Option<Box<AVLNode>> {\n        match node {\n            Some(n) if key == n.key => Some(n.clone()),\n            Some(n) if key < n.key => self.search(&n.left, key),\n            Some(n) => self.search(&n.right, key),\n            _ => None,\n        }\n    }\n\n    pub fn find_min(&self, node: &Option<Box<AVLNode>>) -> Option<Box<AVLNode>> {\n        let mut current = node.as_ref().map(|n| n.clone());\n\n        while let Some(n) = current {\n            current = n.left.as_ref().map(|n| n.clone());\n        }\n\n        current\n    }\n\n    pub fn find_max(&self, node: &Option<Box<AVLNode>>) -> Option<Box<AVLNode>> {\n        let mut current = node.as_ref().map(|n| n.clone());\n\n        while let Some(n) = current {\n            current = n.right.as_ref().map(|n| n.clone());\n        }\n\n        current\n    }\n}\n",u="class AVLTree {\n  data class AVLNode {\n    key: number;\n    left?: AVLNode;\n    right?: AVLNode;\n    height: number;\n\n    constructor(key: number, left?: AVLNode, right?: AVLNode, height: number = 1) {\n      this.key = key;\n      this.left = left;\n      this.right = right;\n      this.height = height;\n    }\n  }\n\n  root: AVLNode | undefined;\n\n  insert(node: AVLNode | undefined, key: number): AVLNode {\n    if (!node) {\n      return new AVLNode(key);\n    }\n\n    if (key < node.key) {\n      node.left = this.insert(node.left, key);\n    } else if (key > node.key) {\n      node.right = this.insert(node.right, key);\n    }\n\n    node.height = 1 + Math.max(this.height(node.left), this.height(node.right));\n\n    return this.rebalance(node);\n  }\n\n  private rebalance(node: AVLNode | undefined): AVLNode {\n    const balance = this.getBalance(node);\n\n    if (balance > 1) {\n      if (this.getBalance(node?.left) < 0) {\n        node?.left = this.leftRotate(node?.left);\n      }\n      return this.rightRotate(node!);\n    }\n\n    if (balance < -1) {\n      if (this.getBalance(node?.right) > 0) {\n        node?.right = this.rightRotate(node?.right);\n      }\n      return this.leftRotate(node!);\n    }\n\n    return node || new AVLNode(0);\n  }\n\n  private leftRotate(y: AVLNode): AVLNode {\n    const x = y.right!;\n    const T2 = x.left;\n\n    x.left = y;\n    y.right = T2;\n\n    y.height = 1 + Math.max(this.height(y.left), this.height(y.right));\n    x.height = 1 + Math.max(this.height(x.left), this.height(x.right));\n\n    return x;\n  }\n\n  private rightRotate(x: AVLNode): AVLNode {\n    const y = x.left!;\n    const T2 = y.right;\n\n    y.right = x;\n    x.left = T2;\n\n    x.height = 1 + Math.max(this.height(x.left), this.height(x.right));\n    y.height = 1 + Math.max(this.height(y.left), this.height(y.right));\n\n    return y;\n  }\n\n  private height(node: AVLNode | undefined): number {\n    return node ? node.height : 0;\n  }\n\n  private getBalance(node: AVLNode | undefined): number {\n    return this.height(node?.left) - this.height(node?.right);\n  }\n\n  search(node: AVLNode | undefined, key: number): AVLNode | undefined {\n    if (!node || key === node.key) {\n      return node;\n    }\n    return key < node.key ? this.search(node.left, key) : this.search(node.right, key);\n  }\n\n  findMin(node: AVLNode | undefined): AVLNode | undefined {\n    let current = node;\n    while (current?.left) {\n      current = current.left;\n    }\n    return current;\n  }\n\n  findMax(node: AVLNode | undefined): AVLNode | undefined {\n    let current = node;\n    while (current?.right) {\n      current = current.right;\n    }\n    return current;\n  }\n}\n",y={title:"AVL Tree",description:"AVL Tree Data Structure",hide_table_of_contents:!0},x=void 0,A={id:"education/computer-science/data-structures/basic/avl-tree",title:"AVL Tree",description:"AVL Tree Data Structure",source:"@site/docs/education/01-computer-science/09-data-structures/02-basic/11-avl-tree.mdx",sourceDirName:"education/01-computer-science/09-data-structures/02-basic",slug:"/education/computer-science/data-structures/basic/avl-tree",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/avl-tree",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/11-avl-tree.mdx",tags:[],version:"current",sidebarPosition:11,frontMatter:{title:"AVL Tree",description:"AVL Tree Data Structure",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Binary Search Tree",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/binary-search-tree"},next:{title:"Red-Black Tree",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/red\u2013black-tree"}},L={},m=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function k(e){const n={code:"code",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components},{Details:y}=n;return y||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(2876).A+""})}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsxs)("thead",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Space"}),(0,r.jsx)("th",{colspan:"4",children:"Time"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{}),(0,r.jsx)("th",{children:"Access"}),(0,r.jsx)("th",{children:"Lookup"}),(0,r.jsx)("th",{children:"Insertion"}),(0,r.jsx)("th",{children:"Deletion"})]})]}),(0,r.jsx)("tbody",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"fair",children:"O(n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"good",children:"O(log n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"good",children:"O(log n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"good",children:"O(log n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"good",children:"O(log n)"})})]})})]}),"\n",(0,r.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(o.A,{queryString:"primary",children:[(0,r.jsxs)(h.A,{value:"short",label:"Short",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"AVL Tree"})," is a self-balancing binary search tree that ensures the heights of its 2 child subtrees differ by at most one."]}),(0,r.jsxs)(y,{children:[(0,r.jsx)("summary",{children:"Simplified"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Binary AVL Tree"})," is like a special bookshelf. It organizes data (like books) in a way that you can quickly find, add, or remove items. Each item can have 2 others next to it, one smaller and\none bigger. The shelf stays balanced by ensuring the difference in the number of items on either side of any item is not more than one."]})]})]}),(0,r.jsx)(h.A,{value:"detailed",label:"Detailed",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"AVL Tree"})," named after inventors Adelson-Velsky and Landis, the first self-balancing binary search tree in computer science, ensures that the heights of 2 child subtrees of any node differ by at\nmost one. If they differ by more than one, the tree is rebalanced. Operations like lookup, insertion, and deletion take ",(0,r.jsx)(n.code,{children:"O(log n)"})," time, where n is the pre-operation node count. Tree rotations may\nbe needed to rebalance after insertions or deletions."]})})]}),"\n",(0,r.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(o.A,{queryString:"primary",children:[(0,r.jsx)(h.A,{value:"practice",label:"Practice",children:(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Aspect"}),(0,r.jsx)("th",{children:"Pseudo Code"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Insertion"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"insert(node, key):\n  if node == \xf8:\n    return createNewNode(key)\n  if key < node.key:\n    node.left = insert(node.left, key)\n  else if key > node.key:\n    node.right = insert(node.right, key)\n  else:\n    return node // Duplicate keys are not allowed\n\n  node.height = 1 + max(height(node.left), height(node.right)) // Update height\n\n  return rebalance(node) // Perform rotations to maintain balance\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Rebalance"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"rebalance(node):\n  balance = get_balance(node)\n\n  if balance > 1: // Left Heavy\n    if get_balance(node.left) < 0: // Left-Right Case\n      node.left = left_rotate(node.left)\n      return right_rotate(node)\n\n  if balance < -1: // Right Heavy\n    if get_balance(node.right) > 0: // Right-Left Case\n      node.right = right_rotate(node.right)\n      return left_rotate(node)\n\n  return node\n\nleft_rotate(y):\n  x = y.right\n  T2 = x.left\n  x.left = y\n  y.right = T2\n  y.height = 1 + max(height(y.left), height(y.right))\n  x.height = 1 + max(height(x.left), height(x.right))\n  return x\n\nright_rotate(x):\n  y = x.left\n  T2 = y.right\n  y.right = x\n  x.left = T2\n  x.height = 1 + max(height(x.left), height(x.right))\n  y.height = 1 + max(height(y.left), height(y.right))\n  return y\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Height"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"height(node):\n  if node == \xf8:\n    return 0\n  return node.height\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Get Balance"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"get_balance(node):\n  if node == \xf8:\n    return 0\n  return height(node.left) - height(node.right)\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Search"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"search(node, key):\n  if node == \xf8 or key == node.key:\n    return node\n  if key < node.key:\n    return search(node.left, key)\n  return search(node.right, key)\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Find MIN"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"find_min(node):\n  while node.left != \xf8:\n    node = node.left\n  return node\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Find MAX"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"find_max(node):\n  while node.right != \xf8:\n    node = node.right\n  return node\n"})})})]})]})]})}),(0,r.jsx)(h.A,{value:"solution",label:"Solution",children:(0,r.jsxs)(o.A,{queryString:"code",children:[(0,r.jsx)(h.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(d.A,{language:"go",children:l})}),(0,r.jsx)(h.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(d.A,{language:"java",children:a})}),(0,r.jsx)(h.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(d.A,{language:"js",children:s})}),(0,r.jsx)(h.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(d.A,{language:"kotlin",children:c})}),(0,r.jsx)(h.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(d.A,{language:"python",children:f})}),(0,r.jsx)(h.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(d.A,{language:"rust",children:g})}),(0,r.jsx)(h.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(d.A,{language:"ts",children:u})})]})})]})]})}function V(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(k,{...e})}):k(e)}},2876:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/avlTree-4a44dea414365e9d7d5f0f41dba5a9e6.svg"}}]);