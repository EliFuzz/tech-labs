"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[6075],{49986:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>l,default:()=>j,frontMatter:()=>a,metadata:()=>c,toc:()=>o});var i=n(11527),r=n(84135),s=n(40521),d=n(74109);const a={title:"Data Management",description:"Data Management  Design Patterns",hide_table_of_contents:!0},l=void 0,c={id:"education/system-design/data-management",title:"Data Management",description:"Data Management  Design Patterns",source:"@site/docs/education/04-system-design/09-data-management.mdx",sourceDirName:"education/04-system-design",slug:"/education/system-design/data-management",permalink:"/tech-labs/docs/education/system-design/data-management",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/04-system-design/09-data-management.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"Data Management",description:"Data Management  Design Patterns",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Traffic Management",permalink:"/tech-labs/docs/education/system-design/traffic-management"},next:{title:"Real World Examples",permalink:"/tech-labs/docs/education/system-design/real-world"}},h={},o=[{value:"CAP Theorem",id:"cap-theorem",level:2},{value:"Data Synchronization &amp; Distribution Mechanisms",id:"data-synchronization--distribution-mechanisms",level:2},{value:"Benefits",id:"benefits",level:3},{value:"Benefits",id:"benefits-1",level:3},{value:"Communication Patterns",id:"communication-patterns",level:2},{value:"Core Concepts",id:"core-concepts",level:3},{value:"Cache",id:"cache",level:2}];function x(e){const t={h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"cap-theorem",children:"CAP Theorem"}),"\n",(0,i.jsxs)(s.Z,{queryString:"primary",children:[(0,i.jsxs)(d.Z,{value:"overview",label:"Overview",children:[(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    c(C)\n    a(A)\n    p(P)\n\n    c --- |CA| a --- |AP| p --- |CP| c\n\n    a ~~~|Pick only 2| a"}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Consistency (C)"}),": Ensures that all nodes in the system have the same data at the same time"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Availability (A)"}),": Ensures that every request gets a response about whether it was successful or failed"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Partition Tolerance (P)"}),": Ensures that the system continues to operate despite network partitions or communication failures"]}),"\n"]})]}),(0,i.jsx)(d.Z,{value:"detailed",label:"Detailed",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{children:"AP (Availability & Partition Tolerance)"}),(0,i.jsx)("th",{children:"CA (Consistency & Availability)"}),(0,i.jsx)("th",{children:"CP (Consistency & Partition Tolerance)"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Visualization"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph TB\n\n    user1(User) <--\x3e |read/write| server1(Server)\n    user2(User) <--\x3e |read/write| server2(Server)\n\n    server1 <--\x3e |read/write| db1[(DB)]\n    server2 <---\x3e |read/write| db2[(DB)]\n\n    db1 <--\x3e |replicate| db2"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph TB\n\n    user1(User) <--\x3e |read/write| server1(Server)\n    user2(User) <--\x3e |read/write| server2(Server)\n\n    server1 & server2 <--\x3e |read/write| db[(DB)]"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph TB\n\n    user1(User) <--\x3e |read/write| server(Server)\n    user2(User) <--\x3e |read/write| server(Server)\n\n    server <--\x3e |read/write| primary[(DB)]\n    primary <--\x3e |read/write| secondary[(DB)]"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Definition"})}),(0,i.jsx)("td",{children:"Some data may not be consistent"}),(0,i.jsx)("td",{children:"Network issues might stop the system"}),(0,i.jsx)("td",{children:"Some data might not be available when a failure happens"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:"Social networks, real-time analytics, recommendation systems"}),(0,i.jsx)("td",{children:"Financial applications, e-commerce"}),(0,i.jsx)("td",{children:"Multi-datacenter deployments"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Examples"})}),(0,i.jsx)("td",{children:"Cassandra, DynamoDB, Riak"}),(0,i.jsx)("td",{children:"Google Spanner, RDBMS with high availability configurations"}),(0,i.jsx)("td",{children:"MongoDB with replica sets, BigTable"})]})]})]})})]}),"\n",(0,i.jsx)(t.h2,{id:"data-synchronization--distribution-mechanisms",children:"Data Synchronization & Distribution Mechanisms"}),"\n",(0,i.jsxs)(s.Z,{queryString:"primary",children:[(0,i.jsx)(d.Z,{value:"sharding",label:"Sharding/Partitioning",children:(0,i.jsxs)(s.Z,{queryString:"secondary",children:[(0,i.jsxs)(d.Z,{value:"overview",label:"Overview",attributes:{className:"tabs__vertical"},children:[(0,i.jsx)(t.p,{children:"Database sharding splits a large database across machines for better handling of massive datasets."}),(0,i.jsx)(t.h3,{id:"benefits",children:"Benefits"}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Improve response time"}),"\n",(0,i.jsx)(t.li,{children:"Avoid total service outage"}),"\n",(0,i.jsx)(t.li,{children:"Scale efficiently"}),"\n"]})]}),(0,i.jsx)(d.Z,{value:"strategies",label:"Strategies",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Type"}),(0,i.jsx)("th",{style:{minWidth:"350px"},children:"Visualization"}),(0,i.jsx)("th",{children:"Definition"}),(0,i.jsx)("th",{children:"Use Cases"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Consistent Hashing"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    table(Table) --\x3e hashFn(Hash Function)\n\n    hashFn --\x3e hashRing{Hash Ring}\n\n    hashRing --\x3e shard1(Shard 1)\n    hashRing --\x3e shard2(Shard 2)\n    hashRing --\x3e shard3(Shard N)"})}),(0,i.jsx)("td",{children:"Distributes data across a dynamic number of partitions using a hash function"}),(0,i.jsx)("td",{children:"Distributed databases, Content Delivery Networks (CDNs)"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Directory Based Sharding"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    table(( )) --\x3e |shard key<br/>delivery zone| hashTable(( ))\n    hashTable --\x3e |s1| shard1(( ))\n    hashTable --\x3e |s2| shard2(( ))\n    hashTable --\x3e |s3| shard3(( ))\n    hashTable --\x3e |s4| shard4(( ))\n\n    table ~~~|<table><thead><tr><th>Delivery Zone</th><th>First Name</th><th>Last Name</th></tr></thead><tbody><tr><td>3</td><td>Joe</td><td>Doe</td></tr><tr><td>2</td><td>John</td><td>Smith</td></tr><tr><td>1</td><td>Jane</td><td>Williams</td></tr><tr><td>4</td><td>Jack</td><td>Jones</td></tr></tbody></table>| table\n    hashTable ~~~|<table><thead><tr><th>Delivery Zone</th><th>Shard ID</th></tr></thead><tbody><tr><td>1</td><td>S1</td></tr><tr><td>2</td><td>S2</td></tr><tr><td>3</td><td>S3</td></tr><tr><td>4</td><td>S4</td></tr></tbody></table>| hashTable\n    shard1 ~~~|<table><tr><td>1</td><td>Jane</td><td>Williams</td></tr></table>| shard1\n    shard2 ~~~|<table><tr><td>2</td><td>John</td><td>Smith</td></tr></table>| shard2\n    shard3 ~~~|<table><tr><td>3</td><td>Joe</td><td>Doe</td></tr></table>| shard3\n    shard4 ~~~|<table><tr><td>4</td><td>Jack</td><td>Jones</td></tr></table>| shard4"})}),(0,i.jsx)("td",{children:"Central directory maps data to specific shards based on predefined rules"}),(0,i.jsx)("td",{children:"Strong consistency and moderate scalability"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Geo Sharding"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    table(Users) --\x3e shardUS(US Users)\n    table --\x3e shardEU(EU Users)\n    table --\x3e shardAsia(Asia Users)"})}),(0,i.jsx)("td",{children:"Divides data based on geographic regions to localize data access"}),(0,i.jsx)("td",{children:"Applications requiring regional data localization or geo-distributed databases"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Horizontal Partitioning (Sharding)"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    table(( )) --\x3e shard1(( ))\n    table --\x3e shard2(( ))\n\n    table ~~~|<table><thead><tr><th>User ID</th><th>First Name</th><th>Last Name</th><th>Status</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>Doe</td><td>Active</td></tr><tr><td>2</td><td>John</td><td>Smith</td><td>Inactive</td></tr><tr><td>3</td><td>Jane</td><td>Williams</td><td>Active</td></tr><tr><td>4</td><td>Jack</td><td>Jones</td><td>Inactive</td></tr></tbody></table>| table\n    shard1 ~~~|<table><thead><tr><th>User ID</th><th>First Name</th><th>Last Name</th><th>Status</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>Doe</td><td>Active</td></tr><tr><td>2</td><td>John</td><td>Smith</td><td>Inactive</td></tr></tbody></table>| shard1\n    shard2 ~~~|<table><thead><tr><th>User ID</th><th>First Name</th><th>Last Name</th><th>Status</th></tr></thead><tbody><tr><td>3</td><td>Jane</td><td>Williams</td><td>Active</td></tr><tr><td>4</td><td>Jack</td><td>Jones</td><td>Inactive</td></tr></tbody></table>| shard2"})}),(0,i.jsx)("td",{children:"Data is partitioned across multiple databases or shards based on a certain criterion such as user ID, timestamp"}),(0,i.jsx)("td",{children:"High data volume and scalability requirements"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Key-Based Sharding"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    table(( )) --\x3e |shard key<br/>col1| hashFn(Hash Function)\n    hashFn --\x3e hashTable(( ))\n    hashTable --\x3e shard1(( ))\n    hashTable --\x3e shard2(( ))\n\n    table ~~~|<table><thead><tr><th>col1</th><th>col2</th><th>col3</th></tr></thead><tbody><tr><td>A</td><td></td><td></td></tr><tr><td>B</td><td></td><td></td></tr><tr><td>C</td><td></td><td></td></tr><tr><td>D</td><td></td><td></td></tr></tbody></table>| table\n    hashTable ~~~|<table><thead><tr><th>col1</th><th>Hash Value</th></tr></thead><tbody><tr><td>A</td><td>1</td></tr><tr><td>B</td><td>2</td></tr><tr><td>C</td><td>1</td></tr><tr><td>D</td><td>2</td></tr></tbody></table>| hashTable\n    shard1 ~~~|<table><thead><tr><th>col1</th><th>col2</th><th>col3</th></tr></thead><tbody><tr><td>A</td><td></td><td></td></tr><tr><td>C</td><td></td><td></td></tr></tbody></table>| shard1\n    shard2 ~~~|<table><thead><tr><th>col1</th><th>col2</th><th>col3</th></tr></thead><tbody><tr><td>B</td><td></td><td></td></tr><tr><td>D</td><td></td><td></td></tr></tbody></table>| shard2"})}),(0,i.jsx)("td",{children:"Data is distributed across shards based on a predefined key"}),(0,i.jsx)("td",{children:"Predictable access patterns and high scalability requirements"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Range-Based Sharding"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    table(( )) --\x3e |0-50| shard1(( ))\n    table --\x3e |50-100| shard2(( ))\n    table --\x3e |100+| shard3(( ))\n\n    table ~~~|<table><thead><tr><th>Product</th><th>Price</th></tr></thead><tbody><tr><td>Coffee</td><td>20</td></tr><tr><td>Tea</td><td>15</td></tr><tr><td>Laptop</td><td>3000</td></tr><tr><td>Jeans</td><td>70</td></tr></tbody></table>| table\n    shard1 ~~~|<table><thead><tr><th>Product</th><th>Price</th></tr></thead><tbody><tr><td>Coffee</td><td>20</td></tr><tr><td>Tea</td><td>15</td></tr></tbody></table>| shard1\n    shard2 ~~~|<table><thead><tr><th>Product</th><th>Price</th></tr></thead><tbody><tr><td>Jeans</td><td>70</td></tr></tbody></table>| shard2\n    shard3 ~~~|<table><thead><tr><th>Product</th><th>Price</th></tr></thead><tbody><tr><td>Laptop</td><td>3000</td></tr></tbody></table>| shard3"})}),(0,i.jsx)("td",{children:"Divides data into ranges (numeric ranges, alphabetical ranges) and assigns each range to a shard"}),(0,i.jsx)("td",{children:"Range-based queries and moderate scalability requirements. Time-series data or data with a sequential range"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Vertical Partitioning"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    table(( )) --\x3e shard1(( ))\n    table --\x3e shard2(( ))\n\n    table ~~~|<table><thead><tr><th>User ID</th><th>First Name</th><th>Last Name</th><th>Status</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>Doe</td><td>Active</td></tr><tr><td>2</td><td>John</td><td>Smith</td><td>Inactive</td></tr><tr><td>3</td><td>Jane</td><td>Williams</td><td>Active</td></tr><tr><td>4</td><td>Jack</td><td>Jones</td><td>Inactive</td></tr></tbody></table>| table\n    shard1 ~~~|<table><thead><tr><th>User ID</th><th>First Name</th><th>Last Name</th></tr></thead><tbody><tr><td>1</td><td>Joe</td><td>Doe</td></tr><tr><td>2</td><td>John</td><td>Smith</td></tr><tr><td>3</td><td>Jane</td><td>Williams</td></tr><tr><td>4</td><td>Jack</td><td>Jones</td></tr></tbody></table>| shard1\n    shard2 ~~~|<table><thead><tr><th>User ID</th><th>Status</th></tr></thead><tbody><tr><td>1</td><td>Active</td></tr><tr><td>2</td><td>Inactive</td></tr><tr><td>3</td><td>Active</td></tr><tr><td>4</td><td>Inactive</td></tr></tbody></table>| shard2"})}),(0,i.jsx)("td",{children:"Segregates data vertically based on attributes or columns"}),(0,i.jsx)("td",{children:"Specific data access patterns and less dynamic schemas"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Materialized Views"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    inventory[(Inventory)]\n    sales[(Sales)]\n    view[(Materialized View)]\n\n    inventory & sales --\x3e view\n\n    inventory ~~~|<table><thead><tr><th>Item ID</th><th>Item Name</th><th>Category ID</th></tr></thead><tbody><tr><td>111</td><td>Coffee</td><td>101</td></tr><tr><td>222</td><td>Tea</td><td>102</td></tr><tr><td>333</td><td>Juice</td><td>103</td></tr></tbody></table>| inventory\n    sales ~~~|<table><thead><tr><th>Sale ID</th><th>Item ID</th><th>Price</th></tr></thead><tbody><tr><td>100</td><td>111</td><td>20</td></tr><tr><td>200</td><td>222</td><td>15</td></tr><tr><td>300</td><td>111</td><td>20</td></tr></tbody></table>| sales\n    view ~~~|<table><thead><tr><th>Item ID</th><th>Total Sale</th></tr></thead><tbody><tr><td>111</td><td>40</td></tr><tr><td>222</td><td>15</td></tr></tbody></table>| view"})}),(0,i.jsxs)("td",{children:[(0,i.jsx)(t.p,{children:"Precomputed views for faster query performance"}),(0,i.jsx)(t.p,{children:"Pros:"}),(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Improved query performance"})}),(0,i.jsx)(t.p,{children:"Cons:"}),(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Overhead in maintaining materialized views, potential staleness"})}),(0,i.jsx)(t.p,{children:"Considerations:"}),(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"View maintenance and update strategies"}),(0,i.jsx)("li",{children:"Consistency with underlying data changes"}),(0,i.jsx)("li",{children:"Refresh policies and scheduling"}),(0,i.jsx)("li",{children:"Impact on write performance and storage requirements"})]})]}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Aggregated queries"}),(0,i.jsx)("li",{children:"Report generation"})]})})]})]})]})})]})}),(0,i.jsx)(d.Z,{value:"replication",label:"Replication",children:(0,i.jsxs)(s.Z,{queryString:"secondary",children:[(0,i.jsxs)(d.Z,{value:"overview",label:"Overview",attributes:{className:"tabs__vertical"},children:[(0,i.jsx)(t.p,{children:"Database replication is the process of duplicating data from one database to another, ensuring that multiple copies of the same data are available across different locations or systems. This redundancy enhances data availability, fault tolerance, and scalability"}),(0,i.jsx)(t.h3,{id:"benefits-1",children:"Benefits"}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Durability"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Replication enhances durability, preventing catastrophic data loss"}),"\n",(0,i.jsx)(t.li,{children:"It ensures data preservation across multiple servers"}),"\n",(0,i.jsx)(t.li,{children:"Replication, alongside backups, minimizes data loss windows and downtime"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Availability"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Replication boosts system availability and resilience"}),"\n",(0,i.jsx)(t.li,{children:"It enables seamless failover to standby servers"}),"\n",(0,i.jsx)(t.li,{children:"Without replication, server outages could cause prolonged downtime"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Increasing Throughput"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Replication spreads load across nodes, boosting throughput"}),"\n",(0,i.jsx)(t.li,{children:"Additional replicas can be added for further scalability"}),"\n",(0,i.jsx)(t.li,{children:"Proper management avoids replication overhead bottlenecks"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Reducing Latency"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Replication brings data closer to users, reducing latency"}),"\n",(0,i.jsx)(t.li,{children:"Shorter network distance leads to faster response times"}),"\n",(0,i.jsx)(t.li,{children:"Multi-region replication improves user experience and productivity"}),"\n"]}),"\n"]}),"\n"]})]}),(0,i.jsx)(d.Z,{value:"types",label:"Types",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{children:"Full Table Replication"}),(0,i.jsx)("th",{children:"Key-based Incremental Replication"}),(0,i.jsx)("th",{children:"Log-based Incremental Replication"}),(0,i.jsx)("th",{children:"Trigger-based Replication"}),(0,i.jsx)("th",{children:"Snapshot Replication"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Overview"})}),(0,i.jsx)("td",{children:"Replicates entire tables"}),(0,i.jsx)("td",{children:"Replicates only changed rows based on key values"}),(0,i.jsx)("td",{children:"Replicates changes based on transaction logs"}),(0,i.jsx)("td",{children:"Replicates changes based on triggers"}),(0,i.jsx)("td",{children:"Replicates a point-in-time copy of data"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Data Volume / Network Bandwidth Usage"})}),(0,i.jsx)("td",{children:"High"}),(0,i.jsx)("td",{children:"Moderate"}),(0,i.jsx)("td",{children:"Low"}),(0,i.jsx)("td",{children:"Moderate"}),(0,i.jsx)("td",{children:"High"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:"Data Warehousing, Reporting"}),(0,i.jsx)("td",{children:"Synchronizing specific datasets between databases"}),(0,i.jsx)("td",{children:"Replicating changes from a primary to secondary database"}),(0,i.jsx)("td",{children:"Replicating changes between databases with complex business logic"}),(0,i.jsx)("td",{children:"Creating backups for disaster recovery"})]})]})]})}),(0,i.jsx)(d.Z,{value:"methods",label:"Methods",children:(0,i.jsxs)("table",{class:"text_vertical",children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Method"}),(0,i.jsx)("th",{style:{minWidth:"350px"},children:"Visualization"}),(0,i.jsx)("th",{children:"Definition"}),(0,i.jsx)("th",{children:"Pros"}),(0,i.jsx)("th",{children:"Cons"}),(0,i.jsx)("th",{children:"Use Cases"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Bi-Directional"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    source[(Source)] --\x3e replica[(Replica)]\n    replica --\x3e source"})}),(0,i.jsx)("td",{children:"Data flows bidirectionally between source and target databases, allowing updates in both directions"}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"High availability and fault tolerance"}),(0,i.jsx)("li",{children:"Improved performance for distributed applications"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Complexity in conflict resolution"}),(0,i.jsx)("li",{children:"Increased risk of data inconsistencies"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Multi-site collaboration"}),(0,i.jsx)("li",{children:"Active-active data centers"}),(0,i.jsx)("li",{children:"Real-time data synchronization"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Broadcast"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    source[(Source)] --\x3e replica1[(Replica)]\n    source --\x3e replica2[(Replica)]\n    source --\x3e replica3[(Replica)]"})}),(0,i.jsx)("td",{children:"Data from a single source is replicated to multiple targets simultaneously"}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Scalability for large-scale distribution"}),(0,i.jsx)("li",{children:"Reduced network traffic"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Limited support for bidirectional data flows"}),(0,i.jsx)("li",{children:"Potential for data redundancy"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Mass data distribution"}),(0,i.jsx)("li",{children:"Real-time data broadcasting"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cascading"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    source[(Source)] --\x3e db[(DB)]\n\n    db --\x3e replica1[(Replica)]\n    db --\x3e replica2[(Replica)]\n    db --\x3e replica3[(Replica)]"})}),(0,i.jsx)("td",{children:"Replication is chained in a cascade, where changes propagate sequentially through multiple tiers of databases"}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Flexibility in data routing and transformation"}),(0,i.jsx)("li",{children:"Enhanced security through layered replication"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Increased complexity in setup and maintenance"}),(0,i.jsx)("li",{children:"Potential for latency and synchronization issues"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Hierarchical data distribution"}),(0,i.jsx)("li",{children:"Data transformation and filtering"}),(0,i.jsx)("li",{children:"Data distribution across geographical regions"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Consolidation"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    replica1[(Replica)] --\x3e source[(Source)]\n    replica2[(Replica)] --\x3e source\n    replica3[(Replica)] --\x3e source"})}),(0,i.jsx)("td",{children:"Data from multiple sources is consolidated into a single target database"}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Simplified data management"}),(0,i.jsx)("li",{children:"Reduced storage and infrastructure costs"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Risk of data loss if not implemented properly"}),(0,i.jsx)("li",{children:"Increased latency for distributed queries"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Data warehousing"}),(0,i.jsx)("li",{children:"Centralized reporting"}),(0,i.jsx)("li",{children:"Data aggregation"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Peer-to-Peer"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    db1[(DB)]\n    db2[(DB)]\n    db3[(DB)]\n\n    db1 & db2 --\x3e db3\n    db1 & db3 --\x3e db2\n    db2 & db3 --\x3e db1"})}),(0,i.jsx)("td",{children:"All databases are peers and can act as both a source and a target. Data can flow between any pair of databases"}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Enhanced fault tolerance and scalability"}),(0,i.jsx)("li",{children:"Flexibility in data routing"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Complexity in configuration and maintenance"}),(0,i.jsx)("li",{children:"Potential for network congestion and data conflicts"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Decentralized applications"}),(0,i.jsx)("li",{children:"Collaborative editing environments"}),(0,i.jsx)("li",{children:"Distributed systems"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Unidirectional"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    source[(Source)] --\x3e replica[(Replica)]"})}),(0,i.jsx)("td",{children:"Data flows in one direction from source to target databases"}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Simplicity in setup"}),(0,i.jsx)("li",{children:"Reduced risk of conflicts"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Limited scalability for distributed systems"}),(0,i.jsx)("li",{children:"Potential for data latency"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Reporting and analytics"}),(0,i.jsx)("li",{children:"Disaster recovery"}),(0,i.jsx)("li",{children:"Load balancing"})]})})]})]})]})}),(0,i.jsxs)(d.Z,{value:"cdc",label:"CDC",children:[(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Change Data Capture (CDC)"}),": Captures changes in real-time as they occur at the source database"]}),(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{children:"Transactional CDC"}),(0,i.jsx)("th",{children:"Batch-Optimized CDC"}),(0,i.jsx)("th",{children:"Data Warehouse Ingest-Merge"}),(0,i.jsx)("th",{children:"Message-Encoded CDC"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Visualization"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    dbN[(N)] --\x3e db2[(2)] --\x3e db1[(1)]"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    db[( )] --\x3e db1[( )]\n    db ~~~|<table><tr><td>R1</td><td>\u25b4</td><td></td><td></td><td></td></tr><tr><td>R1</td><td></td><td>\u25b4</td><td>\u25b4</td><td></td></tr><tr><td>R2</td><td></td><td>\u25b4</td><td></td><td>\u25b4</td></tr><tr><td>R1</td><td>\u25b4</td><td></td><td></td><td></td></tr><tr><td>R2</td><td></td><td></td><td>\u25b4</td><td></td></tr></table>| db\n    db1 ~~~|<table><tr><td>R1</td><td>\u25b4</td><td>\u25b4</td><td>\u25b4</td><td></td></tr><tr><td>R2</td><td></td><td>\u25b4</td><td>\u25b4</td><td>\u25b4</td></tr></table>| db1"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    db1[( )] --\x3e db[( )]\n    db2[( )] --\x3e db\n    db3[( )] --\x3e db\n\n    db ~~~|<table><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></table>| db\n    db1 ~~~|<table><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></table>| db1\n    db2 ~~~|<table><tr><td></td><td></td><td></td></tr></table>| db2\n    db3 ~~~|<table><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></table>| db3"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    mgsN((N)) -.-> msg2((2)) -.-> msg1((1))"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Definition"})}),(0,i.jsx)("td",{children:"Captures changes in real-time as they occur at the source database"}),(0,i.jsx)("td",{children:"Captures changes in bulk at specific intervals, rather than in real-time"}),(0,i.jsx)("td",{children:"Ingests and merges data from multiple sources into a data warehouse"}),(0,i.jsx)("td",{children:"Encodes changes into messages for asynchronous processing and consumption"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Performance"})}),(0,i.jsx)("td",{children:"Real-time, minimal latency for data replication"}),(0,i.jsx)("td",{children:"High throughput, reduced impact on source systems due to batch processing"}),(0,i.jsx)("td",{children:"Typically batch-oriented, suitable for large-scale data movement"}),(0,i.jsx)("td",{children:"Depends on message broker performance; can be asynchronous, may introduce latency"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Data Consistency"})}),(0,i.jsx)("td",{children:"Ensures consistency between source and target systems in near real-time"}),(0,i.jsx)("td",{children:"Data consistency may lag behind real-time due to batch processing"}),(0,i.jsx)("td",{children:"May require additional checks to maintain consistency during merge process"}),(0,i.jsx)("td",{children:"Consistency depends on message delivery guarantees and processing logic"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:"Real-time data synchronization (financial transactions, inventory management)"}),(0,i.jsx)("td",{children:"Daily reporting, data warehousing"}),(0,i.jsx)("td",{children:"Commonly used for data warehousing, analytics, and reporting purposes"}),(0,i.jsx)("td",{children:"Useful for event-driven architectures, microservices, and distributed systems"})]})]})]})]}),(0,i.jsx)(d.Z,{value:"strategies",label:"Strategies",children:(0,i.jsxs)("table",{class:"text_vertical",children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Replication Strategy"}),(0,i.jsx)("th",{style:{minWidth:"350px"},children:"Visualization"}),(0,i.jsx)("th",{children:"Description"}),(0,i.jsx)("th",{children:"Pros"}),(0,i.jsx)("th",{children:"Cons"}),(0,i.jsx)("th",{children:"Use Cases"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Leader-Follower Replication (Source-Replica / Master-Slave / Primary-Secondary)"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n   source[(Source)] --\x3e replicaA[(Replica)]\n   source --\x3e replicaB[(Replica)]"})}),(0,i.jsx)("td",{children:"Primary database instance accepts write operations, while one or more replicas replicate data from the leader. Replicas typically handle read operations"}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Simple setup and maintenance"}),(0,i.jsx)("li",{children:"Consistent read operations"}),(0,i.jsx)("li",{children:"Failover support for the leader"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Write operations bottlenecked by leader"}),(0,i.jsx)("li",{children:"Potential for replication lag"}),(0,i.jsx)("li",{children:"Single point of failure (leader)"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"High availability for read-heavy workloads"}),(0,i.jsx)("li",{children:"Load balancing read operations"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Active/Active Replication"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph TB\n\n    coordinator(Coordinator)\n\n    subgraph domainA[ ]\n        direction TB\n\n        a_dbA[( )]\n        a_dbB[( )]\n\n        a_dbA --\x3e a_dbB\n        a_dbB --\x3e a_dbA\n    end\n\n    coordinator --\x3e a_dbA\n    coordinator --\x3e a_dbB\n\n    subgraph domainB[ ]\n        direction TB\n\n        b_dbA[( )]\n        b_dbB[( )]\n\n        b_dbA --\x3e b_dbB\n        b_dbB --\x3e b_dbA\n    end\n\n    coordinator --\x3e b_dbA\n    coordinator --\x3e b_dbB"})}),(0,i.jsx)("td",{children:"Multiple database instances accept both read and write operations simultaneously. Each instance can serve read and write requests independently"}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Distributed load balancing"}),(0,i.jsx)("li",{children:"Improved fault tolerance"}),(0,i.jsx)("li",{children:"Minimal replication lag"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Complex conflict resolution"}),(0,i.jsx)("li",{children:"Increased risk of data inconsistency"}),(0,i.jsx)("li",{children:"Higher infrastructure and maintenance costs"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Geographically distributed applications"}),(0,i.jsx)("li",{children:"Low-latency requirements"}),(0,i.jsx)("li",{children:"High throughput"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Multi-Leader Replication (Master-Master / Primary-Primary)"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    subgraph SourcesA[ ]\n        direction TB\n\n        serverA(Server) --\x3e |read/write| sourceA[(Source)]\n        serverA --\x3e |read| replicaA[(Replica)]\n        sourceA -.-> replicaA\n    end\n\n    subgraph SourcesB[ ]\n        direction TB\n\n        serverB(Server) --\x3e |read/write| sourceB[(Source)]\n        serverB --\x3e |read| replicaB[(Replica)]\n        sourceB -.-> replicaB\n    end\n\n    sourceA --\x3e sourceB\n    sourceB --\x3e sourceA"})}),(0,i.jsx)("td",{children:"Multiple database instances accept write operations independently, and changes are asynchronously replicated between them"}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Improved write scalability"}),(0,i.jsx)("li",{children:"Enhanced fault tolerance"}),(0,i.jsx)("li",{children:"No single point of failure for writes"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Complex conflict resolution"}),(0,i.jsx)("li",{children:"Increased risk of data conflicts and inconsistency"}),(0,i.jsx)("li",{children:"Potential for replication lag"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Geographically distributed teams"}),(0,i.jsx)("li",{children:"Active-active setups requiring write capabilities on all nodes"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Leaderless Replication"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    subgraph typeA[Circular Topology]\n        direction LR\n\n        a_dbA[(Source)] ---\x3e a_dbB[(Source)] & a_dbC[(Source)] ---\x3e a_dbD[(Source)]\n    end\n\n    subgraph typeB[Star Topology]\n        direction TB\n\n        b_source[(Source Root)]\n        b_leafA[(Source Leaf)]\n        b_leafB[(Source Leaf)]\n        b_leafC[(Source Leaf)]\n\n        b_source --\x3e b_leafA\n        b_leafA --\x3e b_source\n\n        b_leafA --\x3e b_leafB\n        b_leafB --\x3e b_leafA\n\n        b_leafA --\x3e b_leafC\n        b_leafC --\x3e b_leafA\n    end\n\n    subgraph typeC[All-to-All Topology]\n        direction LR\n\n        c_dbA[(Source)]\n        c_dbB[(Source)]\n        c_dbC[(Source)]\n\n        c_dbA & c_dbB --\x3e c_dbC\n        c_dbA & c_dbC --\x3e c_dbB\n        c_dbB & c_dbC --\x3e c_dbA\n    end"})}),(0,i.jsx)("td",{children:"No designated leader. Each node in the cluster can accept both read and write operations. Data is replicated across all nodes in the cluster"}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"No single point of failure"}),(0,i.jsx)("li",{children:"High availability for both reads and writes"}),(0,i.jsx)("li",{children:"Linear scalability"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Complex consistency and conflict resolution"}),(0,i.jsx)("li",{children:"Increased network traffic for replication"}),(0,i.jsx)("li",{children:"Potential for divergent data states"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Highly distributed environments"}),(0,i.jsx)("li",{children:"Scalable architectures"}),(0,i.jsx)("li",{children:"Fault tolerance"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Quorum Writes and Reads"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"    graph LR\n\n    subgraph read[Read]\n        direction LR\n\n        readCoordinator --\x3e |response| readClient\n        readCoordinator <--\x3e |read quorum<br/>response| read_dbA[( )]\n        readCoordinator <--\x3e |read quorum<br/>response| read_dbB[( )]\n        readCoordinator <--\x3e |read quorum<br/>response| read_dbC[( )]\n\n        readClient(Client) --\x3e |read| readCoordinator(Coordinator)\n    end\n\n    subgraph write[Write]\n        direction LR\n\n        write_dbA[( )]\n        write_dbB[( )]\n\n        writeClient(Client) <--\x3e |write<br/>respond| writeCoordinator(Coordinator)\n        writeCoordinator <--\x3e |prepare<br/>acknowledge| write_dbA\n        writeCoordinator <--\x3e |commit<br/>acknowledge| write_dbA\n\n        writeCoordinator <--\x3e |prepare<br/>acknowledge| write_dbB\n        writeCoordinator <--\x3e |commit<br/>acknowledge| write_dbB\n    end"})}),(0,i.jsx)("td",{children:"Requires a certain number (quorum) of nodes to agree on a write or read operation before it's considered successful. It's often used in distributed databases to ensure consistency and availability"}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Improved fault tolerance"}),(0,i.jsx)("li",{children:"Tunable consistency levels"}),(0,i.jsx)("li",{children:"Reduced risk of split-brain scenarios"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Increased coordination overhead"}),(0,i.jsx)("li",{children:"Potential for performance degradation with large clusters"}),(0,i.jsx)("li",{children:"Complexity in determining appropriate quorum sizes"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Highly available systems"}),(0,i.jsx)("li",{children:"Consistency across distributed nodes"})]})})]})]})]})}),(0,i.jsx)(d.Z,{value:"conflicts",label:"Conflict Resolutions",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Criteria"}),(0,i.jsx)("th",{children:"Last Write Wins (LWW)"}),(0,i.jsx)("th",{children:"Conflict-free Replicated Data Types (CRDTs)"}),(0,i.jsx)("th",{children:"Operational Transformation"}),(0,i.jsx)("th",{children:"Application-specific Resolution"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Principle"})}),(0,i.jsx)("td",{children:"The latest update overwrites previous ones"}),(0,i.jsx)("td",{children:"Concurrent updates merge seamlessly"}),(0,i.jsx)("td",{children:"Transformations are applied to resolve conflicts"}),(0,i.jsx)("td",{children:"Custom logic defines resolution rules"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Concurrency Control"})}),(0,i.jsx)("td",{children:"Often based on timestamps"}),(0,i.jsx)("td",{children:"Built-in, ensures eventual consistency"}),(0,i.jsx)("td",{children:"Complex, requires careful design"}),(0,i.jsx)("td",{children:"Depends on implementation approach"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Conflict Detection"})}),(0,i.jsx)("td",{children:"Timestamps or version vectors"}),(0,i.jsx)("td",{children:"Built-in mechanisms handle concurrent updates"}),(0,i.jsx)("td",{children:"Requires tracking dependencies"}),(0,i.jsx)("td",{children:"Custom logic or metadata tracking"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:"Simple applications with low concurrency where data loss is acceptable"}),(0,i.jsx)("td",{children:"Collaborative editing systems, real-time communication systems"}),(0,i.jsx)("td",{children:"Collaborative editing, version control systems, distributed databases"}),(0,i.jsx)("td",{children:"Application-specific needs, such as financial transactions"})]})]})]})})]})})]}),"\n",(0,i.jsx)(t.h2,{id:"communication-patterns",children:"Communication Patterns"}),"\n",(0,i.jsxs)(s.Z,{queryString:"primary",children:[(0,i.jsxs)(d.Z,{value:"overview",label:"Overview",children:[(0,i.jsx)(t.p,{children:"Distributed databases offer scalability and fault tolerance, but introduce communication challenges."}),(0,i.jsx)(t.h3,{id:"core-concepts",children:"Core Concepts"}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Data Distribution"}),": Understanding how data is sharded or replicated across nodes is crucial for choosing communication patterns"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Synchronous vs. Asynchronous"}),": Synchronous communication waits for a response before proceeding, while asynchronous allows independent execution. Selection depends on real-time response needs and fault tolerance requirements"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Consistency Models"}),": Different consistency models (eventual consistency, strong consistency) define how quickly updates propagate across nodes, impacting communication frequency"]}),"\n"]})]}),(0,i.jsx)(d.Z,{value:"patterns",label:"Patterns",children:(0,i.jsxs)(s.Z,{queryString:"secondary",children:[(0,i.jsx)(d.Z,{value:"choreography",label:"Choreography",attributes:{className:"tabs__vertical"},children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Visualization"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph LR\n\n  source[(Source)]\n  replica1[(Replica)]\n  replica2[(Replica)]\n  broker([Message Broker])\n\n  source --\x3e broker\n  broker --\x3e |subscribe| replica1 & replica2\n  replica1 & replica2 -.-> |listen| broker"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Definition"})}),(0,i.jsx)("td",{children:"Decentralized coordination between services"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Pros"})}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Scalability"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cons"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Harder to reason about global system state"}),(0,i.jsx)("li",{children:"Potential for cascading failures"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Considerations"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Event-driven architecture"}),(0,i.jsx)("li",{children:"Message formats and protocols"}),(0,i.jsx)("li",{children:"Resilience against message loss or duplication"}),(0,i.jsx)("li",{children:"Scalability and message routing mechanisms"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Event-driven architectures"}),(0,i.jsx)("li",{children:"Decoupled systems"})]})})]})]})]})}),(0,i.jsx)(d.Z,{value:"cqrs",label:"CQRS",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Visualization"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph LR\n\n  write[(Write)]\n  read[(Read)]\n  event([EventBus])\n  command(Command)\n  query(Query)\n\n  command --\x3e |write| write\n  write --\x3e |event| event\n\n  query ----\x3e |read| read\n  event -.-> |event| read"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Definition"})}),(0,i.jsx)("td",{children:"Command Query Responsibility Segregation (CQRS). Separates read and write operations"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Pros"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Optimized read/write operations"}),(0,i.jsx)("li",{children:"Scalability"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cons"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Increased complexity in implementation"}),(0,i.jsx)("li",{children:"Potential consistency issues"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Considerations"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Consistency between read and write models"}),(0,i.jsx)("li",{children:"Data synchronization mechanisms"}),(0,i.jsx)("li",{children:"Scalability of read and write paths"}),(0,i.jsx)("li",{children:"Complexity of maintaining separate models"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Complex read/write operations"}),(0,i.jsx)("li",{children:"Scalability requirements"})]})})]})]})]})}),(0,i.jsx)(d.Z,{value:"dqp",label:"Distributed Query Processing",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Visualization"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph LR\n\n  service(Service)\n\n  subgraph dqp [Distributed Query Processing]\n    direction TB\n\n    job1(Job)\n    job2(Job)\n    job3(Job)\n  end\n\n  sql[(PostgreSQL)]\n  bq[(BigQuery)]\n\n  service --\x3e |read data<br/>from multiple sources| dqp\n  dqp --\x3e |read| sql\n  dqp --\x3e |read| bq"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Definition"})}),(0,i.jsx)("td",{children:"Executes queries across distributed nodes"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Pros"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Scalability"}),(0,i.jsx)("li",{children:"Improved query performance"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cons"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Increased network overhead"}),(0,i.jsx)("li",{children:"Potential data consistency challenges"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Considerations"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Query optimization and pushdown mechanisms"}),(0,i.jsx)("li",{children:"Data locality and network overhead"}),(0,i.jsx)("li",{children:"Consistency and isolation levels"}),(0,i.jsx)("li",{children:"Handling failures and partial results"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Analytical workloads"}),(0,i.jsx)("li",{children:"Data-intensive applications"})]})})]})]})]})}),(0,i.jsx)(d.Z,{value:"event-sourcing",label:"Event Sourcing",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Visualization"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph LR\n\n  service(Service)\n  eventStore[(EventStore)]\n  eventBus([EventBus])\n  read[(Read DB)]\n  replay(Replay)\n\n  service --\x3e |item 1 added| eventStore\n  service --\x3e |item 2 added| eventStore\n  service --\x3e |item 3 added| eventStore\n\n  eventStore --\x3e |publish event| eventBus\n  eventBus --\x3e |event published| read\n\n  eventStore --\x3e |replay event| replay"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Definition"})}),(0,i.jsx)("td",{children:"Stores events instead of current state for data changes. Appends only storage for replay of events to specific state/snapshot"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Pros"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Full audit trail"}),(0,i.jsx)("li",{children:"Scalability"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cons"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Complexity in replaying events"}),(0,i.jsx)("li",{children:"Potential for performance issues"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Considerations"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Event schema evolution and compatibility"}),(0,i.jsx)("li",{children:"Event storage and indexing strategies"}),(0,i.jsx)("li",{children:"Event replay and snapshotting mechanisms"}),(0,i.jsx)("li",{children:"Eventual consistency and read model projections"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Auditing"}),(0,i.jsx)("li",{children:"Versioning"}),(0,i.jsx)("li",{children:"Rebuilding state"})]})})]})]})]})}),(0,i.jsx)(d.Z,{value:"modular",label:"Modular",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Visualization"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph LR\n\n  service1(Service)\n  service2(Service)\n  db1[(DB)]\n  db2[(DB)]\n\n  service1 --\x3e |read/write| db1\n  service2 --\x3e |read/write| db2"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Definition"})}),(0,i.jsx)("td",{children:"Data and transactions are divided into modules"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Pros"})}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Scalability"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cons"})}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Potential inconsistency in data between modules"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Considerations"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Transaction isolation levels"}),(0,i.jsx)("li",{children:"ACID compliance"}),(0,i.jsx)("li",{children:"Coordination and consistency across distributed transactions"}),(0,i.jsx)("li",{children:"Rollback and compensating actions for failures"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Microservices architecture"})})})]})]})]})}),(0,i.jsx)(d.Z,{value:"orchestration",label:"Orchestration",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Visualization"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph LR\n\n  service(Service)\n\n  subgraph Orchestration\n    direction LR\n\n    step1(Step 1)\n    step2(Step 2)\n    step3(Step 3)\n\n    step1 --\x3e step2 --\x3e step3\n  end\n\n  service --\x3e |event| Orchestration\n\n  step1 <--\x3e serviceA(Service)\n  step2 <--\x3e serviceB(Service) <--\x3e serviceC(Service)\n  step3 <--\x3e serviceD(Service)"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Definition"})}),(0,i.jsx)("td",{children:"Sequences distributed transactions into a saga"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Pros"})}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Maintains consistency"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cons"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Complexity in handling compensating transactions"}),(0,i.jsx)("li",{children:"Potential for inconsistencies"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Considerations"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Transactional boundaries and compensation logic"}),(0,i.jsx)("li",{children:"Consistency and atomicity guarantees"}),(0,i.jsx)("li",{children:"Long-running transaction handling"}),(0,i.jsx)("li",{children:"Saga orchestration and message correlation"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Long-lived transactions"}),(0,i.jsx)("li",{children:"Business workflows"})]})})]})]})]})}),(0,i.jsx)(d.Z,{value:"outbox",label:"Outbox",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Visualization"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph LR\n\n  service(Service)\n\n  subgraph Database [Database]\n    direction LR\n\n    transaction[[Transaction]]\n\n    db[(Database Table)]\n    outbox[(Outbox Table)]\n  end\n\n  service --- |1. event| transaction\n\n  transaction --\x3e |upsert/delete| db\n  transaction --\x3e |insert| outbox\n\n  relay(Message Relay) --\x3e |2. read| outbox\n  relay --\x3e |3. publish| broker([Message Broker])"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Definition"})}),(0,i.jsx)("td",{children:"Uses an outbox table to guarantee message delivery"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Pros"})}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Ensures message delivery"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cons"})}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Requires additional infrastructure, complexity in implementation"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Considerations"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Outbox implementation and integration patterns"}),(0,i.jsx)("li",{children:"Message delivery guarantees and retries"}),(0,i.jsx)("li",{children:"Error handling and dead letter queues"}),(0,i.jsx)("li",{children:"Scalability and performance considerations"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Event-driven architectures"})})})]})]})]})}),(0,i.jsx)(d.Z,{value:"parallel-pipelines",label:"Parallel Pipelines",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Visualization"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph LR\n\n  subgraph sources [Data Sources]\n    direction LR\n\n    sql[(PostgreSQL)]\n    bq[(BigQuery)]\n  end\n\n  sources --\x3e filter(Data Filtering)\n  filter --\x3e clean(Data Cleaning)\n  clean --\x3e filter2(Data Filtering)\n  filter2 --\x3e aggregation(Data Aggregation)\n  aggregation --\x3e db[(Destination<br/>Data Warehouse)]"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Definition"})}),(0,i.jsx)("td",{children:"Divides data processing into parallel pipelines"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Pros"})}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Increased throughput"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cons"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Complexity in managing parallelism"}),(0,i.jsx)("li",{children:"Potential for data skew"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Considerations"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Parallelism and concurrency control mechanisms"}),(0,i.jsx)("li",{children:"Data partitioning and load balancing"}),(0,i.jsx)("li",{children:"Fault tolerance and error recovery strategies"}),(0,i.jsx)("li",{children:"Resource utilization and bottleneck detection"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Data processing pipelines"})})})]})]})]})}),(0,i.jsx)(d.Z,{value:"phase-commit",label:"Phase Commit",children:(0,i.jsxs)("table",{class:"text_vertical",children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{children:"Two-Phase Commit (2PC)"}),(0,i.jsx)("th",{children:"Three-Phase Commit (3PC)"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Visualization"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  sequenceDiagram\n  autonumber\n\n  participant Node1\n  participant Coordinator\n  participant Node2\n\n  Note over Node1,Node2: Lock\n  alt Pre-Commit Phase\n      activate Coordinator\n      Coordinator->>Node1: Pre-Commit\n      Node1->>Coordinator: Ack\n\n\n      alt Abort or Continue\n          Node1--\x3e>Coordinator: Abort\n          Coordinator--\x3e>Node2: Abort\n      else\n          alt Abort or Continue\n              Coordinator->>Node2: Pre-Commit\n              Node2->>Coordinator: Ack\n          else\n              Node2--\x3e>Coordinator: Abort\n              Coordinator--\x3e>Node1: Abort\n          end\n      end\n\n      deactivate Coordinator\n  end\n\n  alt Commit Phase\n      activate Coordinator\n      Coordinator->>Node1: Commit\n      Node1->>Coordinator: Ack\n\n      Coordinator->>Node2: Commit\n      Node2->>Coordinator: Ack\n      deactivate Coordinator\n  end\n\n  Note over Node1,Node2: Release Lock"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  sequenceDiagram\n  autonumber\n\n  participant Node1\n  participant Coordinator\n  participant Node2\n\n  alt Prepare Phase\n      activate Coordinator\n      Coordinator->>Node1: Prepare\n      Node1->>Coordinator: Ack\n\n      Coordinator->>Node2: Prepare\n      Node2->>Coordinator: Ack\n      deactivate Coordinator\n  end\n\n  Note over Node1,Node2: Lock\n\n  alt Pre-Commit Phase\n      activate Coordinator\n      Coordinator->>Node1: Pre-Commit\n      Node1->>Coordinator: Ack\n\n\n      alt Abort or Continue\n          Node1--\x3e>Coordinator: Abort\n          Coordinator--\x3e>Node2: Abort\n      else\n          alt Abort or Continue\n              Coordinator->>Node2: Pre-Commit\n              Node2->>Coordinator: Ack\n          else\n              Node2--\x3e>Coordinator: Abort\n              Coordinator--\x3e>Node1: Abort\n          end\n      end\n\n      deactivate Coordinator\n  end\n\n  alt Commit Phase\n      activate Coordinator\n      Coordinator->>Node1: Commit\n      Node1->>Coordinator: Ack\n\n      Coordinator->>Node2: Commit\n      Node2->>Coordinator: Ack\n      deactivate Coordinator\n  end\n\n  Note over Node1,Node2: Release Lock"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Definition"})}),(0,i.jsx)("td",{children:"Ensures all participants commit or abort together in 2 phases"}),(0,i.jsx)("td",{children:'Extension of 2PC adding a "prepare to abort" phase for increased fault tolerance'})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Steps"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"First Phase (Pre-Commit Phase):"}),(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"Voting Request:"})," Coordinator asks participants if they can commit the transaction"]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"Voting:"}),' Participants pre-execute the transaction, responding "YES" if executable, "NO" if not']})]})]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"Second Phase (Commit/Rollback Phase):"}),(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"All YES Votes:"}),' Coordinator sends "commit" command to all']}),(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"Some NO Votes:"}),' Coordinator sends "rollback" command if any participant dissents or doesn\'t respond']})]})]})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"First Phase (Prepare Phase)"}),(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Coordinator sends commit inquiry"}),(0,i.jsx)("li",{children:'Participants respond with "can" or "cannot"'})]})]}),(0,i.jsxs)("li",{children:[(0,i.jsx)(t.p,{children:"Second Phase (Pre-Commit Phase)"}),(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"If all agree, coordinator sends pre-commit message"}),(0,i.jsx)("li",{children:'Participants pre-execute, send "ready to commit"'})]})]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"Third Phase (Commit Phase)"}),(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Coordinator sends commit message when all ready"}),(0,i.jsx)("li",{children:'Participants commit; any "abort" or no response cancels transaction'})]})]})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Pros"})}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Ensures transaction atomicity in a distributed environment"})})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Better solves single point of failure and blocking problems: By adding a prepare phase and timeouts. This allows for better handling of coordinator failures and avoids blocking issues"}),(0,i.jsx)("li",{children:"Enhances system availability and robustness: Commit timeouts prevent long waits for unresponsive participants, boosting system availability and robustness"}),(0,i.jsx)("li",{children:"Improves transaction execution efficiency: Lets participants start working early (prepare phase), improving efficiency for long transactions"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cons"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Performance overhead: Requires frequent network messages (requests, votes, commands) which increases latency, especially in slow networks"}),(0,i.jsx)("li",{children:"Single point of failure: Coordinator failure leaves participants unsure about commit/rollback, impacting performance. Use multiple coordinators (primary-secondary) or heartbeat/timeouts for fault tolerance"}),(0,i.jsx)("li",{children:"Blocking problem: Can block if a participant fails to respond during voting. Timeouts help avoid this by letting the coordinator rollback after a set wait time"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Higher message overhead: Reduces performance especially in bad networks. Optimize network and messages to reduce overhead"}),(0,i.jsx)("li",{children:"Increased complexity: New stage and timeouts make it trickier to implement and maintain. Consider Paxos or Raft for better fault tolerance, blocking handling, and performance"}),(0,i.jsx)("li",{children:"Blocking problem still exists: Network partitions or simultaneous failures can still cause blocking. Fault recovery with logs helps resume operations by restoring state"})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Cases"})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Simple data updates across a few geographically distributed databases"}),(0,i.jsx)("li",{children:"Financial transactions"})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:"Scenarios with potential coordinator failures: Single Point of Failure (SPOF)"}),(0,i.jsx)("li",{children:"Large-scale distributed databases"})]})})]})]})]})})]})})]}),"\n",(0,i.jsx)(t.h2,{id:"cache",children:"Cache"}),"\n",(0,i.jsxs)(s.Z,{queryString:"primary",children:[(0,i.jsxs)(d.Z,{value:"overview",label:"Overview",children:[(0,i.jsx)(t.p,{children:"Traditional cache stores frequently accessed data in a faster-to-access location (usually RAM) compared to the primary data source (typically a database)."}),(0,i.jsx)(t.p,{children:"Distributed cache extends this concept by spreading the cached data across multiple machines (nodes) within a network."})]}),(0,i.jsx)(d.Z,{value:"strategies",label:"Strategies",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Strategy"}),(0,i.jsx)("th",{style:{minWidth:"350px"},children:"Visualization"}),(0,i.jsx)("th",{children:"Definition"}),(0,i.jsx)("th",{children:"Use Cases"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Read Cache-Aside (Lazy-Loading)"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph LR\n\n  app(Application)\n  cache(Cache)\n  db[(DB)]\n\n  app --\x3e |5. update cache| cache\n  app --\x3e |1. read| cache\n  cache --\x3e |2. miss| app\n  app --\x3e |3. read| db\n  db --\x3e |4. get data| app"})}),(0,i.jsx)("td",{children:"If the data is not in the cache, the application fetches it from the data source and then caches it for subsequent accesses"}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Frequently accessed, read-heavy workloads with acceptable eventual consistency (Content Delivery Networks: CDN)"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Read-Through"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph LR\n\n  app(Application)\n  cache(Cache)\n  db[(DB)]\n\n  app --\x3e |1. read| cache\n  cache ~~~|2. miss| cache\n  cache --\x3e |3. read| db\n  db --\x3e |4. get data| cache\n  cache --\x3e |5. update cache| cache"})}),(0,i.jsx)("td",{children:"Data is fetched from the main storage only when it's not found in the cache, ensuring that the cache reflects the most up-to-date information available"}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Read-heavy workloads where data consistency is managed by Cache Provider (middleware and proxy servers)"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Write-Around"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph LR\n\n  app(Application)\n  cache(Cache)\n  db[(DB)]\n\n  app --\x3e |1. write db| db\n  cache --\x3e |2. read from cache<br/>if data exists| app\n  db --\x3e |3.1. read from DB<br/>if data missing| app\n  app --\x3e |3.2. update cache| cache"})}),(0,i.jsx)("td",{children:"Data is written directly to the main storage, bypassing the cache, but subsequent reads of that data can be cached for faster access"}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Write-heavy workloads, large file writes, streaming applications"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Write-Back"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph TB\n\n  app(Application)\n  cache(Cache)\n  db[(DB)]\n\n  app --\x3e |1. write to cache constantly| cache\n  cache --\x3e |2. write to DB once in a while| db"})}),(0,i.jsx)("td",{children:"Data is written to the cache first and then later transferred to the main memory, reducing the frequency of memory writes and improving system performance by allowing multiple updates before writing back to memory"}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsxs)("li",{children:["Write-heavy workloads where eventual consistency is acceptable (CPU caches, virtualization platforms in enhancing the performance of virtual machines ",(0,i.jsx)("b",{children:"VMs"}),")"]})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Write-Through"})}),(0,i.jsx)("td",{children:(0,i.jsx)(t.mermaid,{value:"  graph TB\n\n  app(Application)\n  cache(Cache)\n  db[(DB)]\n\n  app --\x3e |1. write| cache\n  cache --\x3e |2. write immediately| db"})}),(0,i.jsx)("td",{children:"Data is written simultaneously to both the cache and the underlying storage, ensuring consistency between the two at all times"}),(0,i.jsx)("td",{children:(0,i.jsx)("ul",{children:(0,i.jsx)("li",{children:"Real-time data updates where consistency is paramount (real-time analytics and dashboards)"})})})]})]})]})})]})]})}function j(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(x,{...e})}):x(e)}}}]);