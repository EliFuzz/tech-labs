"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[9597],{71788:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>v,contentTitle:()=>g,default:()=>w,frontMatter:()=>m,metadata:()=>i,toc:()=>b});const i=JSON.parse('{"id":"education/computer-science/algorithms/algo/fast-powering","title":"Fast Powering","description":"Fast Powering","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/fast-powering.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/fast-powering","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/fast-powering","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/fast-powering.mdx","tags":[],"version":"current","frontMatter":{"title":"Fast Powering","description":"Fast Powering","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Factorial","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/factorial"},"next":{"title":"Fibonacci Number","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/fibonacci-number"}}');var r=t(86070),s=t(15658),a=t(33407),l=t(33903),o=t(68171);const c="package main\n\n// iterative\nfunc fastPowerIterative(x, n int) int {\n    result := 1\n    for n > 0 {\n        if n&1 == 1 {\n            result *= x\n        }\n        x *= x\n        n >>= 1\n    }\n    return result\n}\n\n// recursive\nfunc fastPowerRecursive(x, n int) int {\n    if n == 0 {\n        return 1\n    }\n    temp := fastPowerRecursive(x, n/2)\n    if n%2 == 0 {\n        return temp * temp\n    }\n    return x * temp * temp\n}\n",u="public class Main {\n\n  // iterative\n  public static int fastPowerIterative(int x, int n) {\n    int result = 1;\n    while (n > 0) {\n      if ((n & 1) == 1) {\n        result *= x;\n      }\n      x *= x;\n      n >>= 1;\n    }\n    return result;\n  }\n\n  // recursive\n  public static int fastPowerRecursive(int x, int n) {\n    if (n == 0) {\n      return 1;\n    }\n    int temp = fastPowerRecursive(x, n / 2);\n    if (n % 2 == 0) {\n      return temp * temp;\n    }\n    return x * temp * temp;\n  }\n}\n",d="// iterative\nfunction fastPowerIterative(x, n) {\n  let result = 1;\n  while (n > 0) {\n    if (n & 1) {\n      result *= x;\n    }\n    x *= x;\n    n >>= 1;\n  }\n  return result;\n}\n\n// recursive\nfunction fastPowerRecursive(x, n) {\n  if (n === 0) {\n    return 1;\n  }\n  const temp = fastPowerRecursive(x, Math.floor(n / 2));\n  if (n % 2 === 0) {\n    return temp * temp;\n  }\n  return x * temp * temp;\n}\n",p="// iterative\nfun fastPowerIterative(x: Int, n: Int): Int {\n    var result = 1\n    var base = x\n    var exponent = n\n    while (exponent > 0) {\n        if (exponent and 1 == 1) {\n            result *= base\n        }\n        base *= base\n        exponent = exponent shr 1\n    }\n    return result\n}\n\n// recursive\nfun fastPowerRecursive(x: Int, n: Int): Int {\n    if (n == 0) {\n        return 1\n    }\n    val temp = fastPowerRecursive(x, n / 2)\n    return if (n % 2 == 0) temp * temp else x * temp * temp\n}\n",h="# iterative\ndef fast_power_iterative(x, n):\n    result = 1\n    while n > 0:\n        if n & 1:\n            result *= x\n        x *= x\n        n >>= 1\n    return result\n\n# recursive\ndef fast_power_recursive(x, n):\n    if n == 0:\n        return 1\n    temp = fast_power_recursive(x, n // 2)\n    if n % 2 == 0:\n        return temp * temp\n    return x * temp * temp\n",x="// iterative\nfn fast_power_iterative(x: i32, n: i32) -> i32 {\n    let mut result = 1;\n    let mut base = x;\n    let mut exponent = n;\n    while exponent > 0 {\n        if exponent & 1 == 1 {\n            result *= base;\n        }\n        base *= base;\n        exponent >>= 1;\n    }\n    result\n}\n\n// recursive\nfn fast_power_recursive(x: i32, n: i32) -> i32 {\n    if n == 0 {\n        return 1;\n    }\n    let temp = fast_power_recursive(x, n / 2);\n    if n % 2 == 0 {\n        temp * temp\n    } else {\n        x * temp * temp\n    }\n}\n",f="// iterative\nfunction fastPowerIterative(x: number, n: number): number {\n  let result = 1;\n  while (n > 0) {\n    if (n & 1) {\n      result *= x;\n    }\n    x *= x;\n    n >>= 1;\n  }\n  return result;\n}\n\n// recursive\nfunction fastPowerRecursive(x: number, n: number): number {\n  if (n === 0) {\n    return 1;\n  }\n  const temp = fastPowerRecursive(x, Math.floor(n / 2));\n  if (n % 2 === 0) {\n    return temp * temp;\n  }\n  return x * temp * temp;\n}\n",m={title:"Fast Powering",description:"Fast Powering",hide_table_of_contents:!0},g=void 0,v={},b=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function j(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(a.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"definition",label:"Definition",children:(0,r.jsx)(n.p,{children:"The Fast Powering Algorithm, also known as Exponentiation by Squaring, is a method used to efficiently compute large powers of a number. It reduces the number of multiplications required, making it significantly faster than the naive approach of repeated multiplication"})}),(0,r.jsx)(l.A,{value:"how",label:"Explanation",children:(0,r.jsxs)(n.p,{children:["First step involves checking if the exponent (",(0,r.jsx)(n.code,{children:"n"}),") is ",(0,r.jsx)(n.code,{children:"0"}),"; if it is, the algorithm returns ",(0,r.jsx)(n.code,{children:"1"}),". Next, for even exponents, the algorithm recursively computes the value of ",(0,r.jsx)(n.code,{children:"x"})," raised to the power of half of ",(0,r.jsx)(n.code,{children:"n"}),". On the other hand, for odd exponents, it multiplies ",(0,r.jsx)(n.code,{children:"x"})," by the result of ",(0,r.jsx)(n.code,{children:"x"})," raised to half of (",(0,r.jsx)(n.code,{children:"n - 1"}),"), and then continues this process recursively. Finally, the algorithm combines the results obtained from both even and odd exponent calculations to obtain the final result"]})}),(0,r.jsx)(l.A,{value:"guidance",label:"Guidance",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["See if the exponent ",(0,r.jsx)(n.code,{children:"n"})," is ",(0,r.jsx)(n.code,{children:"0"}),". If it is, just give back ",(0,r.jsx)(n.code,{children:"1"})]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"n"})," is an even number, find out what ",(0,r.jsx)(n.code,{children:"x"})," raised to the power of half of ",(0,r.jsx)(n.code,{children:"n"})," is, and do it again until you get the answer"]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"n"})," is an odd number, first find out what ",(0,r.jsx)(n.code,{children:"x"})," raised to the power of half of (",(0,r.jsx)(n.code,{children:"n - 1"}),") is, then multiply it by ",(0,r.jsx)(n.code,{children:"x"}),", and repeat until you get the answer"]}),"\n",(0,r.jsx)(n.li,{children:"Combine the results obtained and return the final result"}),"\n"]})}),(0,r.jsx)(l.A,{value:"tips",label:"Tips",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"utilize recursion efficiently to minimize the number of multiplications"}),"\n",(0,r.jsx)(n.li,{children:"optimize for even and odd exponents separately"}),"\n"]})})]}),"\n",(0,r.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(a.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"practice",label:"Practice",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"fast_power(x, n):\n  if n == 0:\n    return 1\n  else if n % 2 == 0:\n    temp = fast_power(x, n/2)\n    return temp * temp\n  else:\n    temp = fast_power(x, (n-1)/2)\n    return x * temp * temp\n"})})}),(0,r.jsx)(l.A,{value:"solution",label:"Solution",children:(0,r.jsxs)(a.A,{queryString:"code",children:[(0,r.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(o.A,{language:"go",children:c})}),(0,r.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(o.A,{language:"java",children:u})}),(0,r.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(o.A,{language:"js",children:d})}),(0,r.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(o.A,{language:"kotlin",children:p})}),(0,r.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(o.A,{language:"python",children:h})}),(0,r.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(o.A,{language:"rust",children:x})}),(0,r.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(o.A,{language:"ts",children:f})})]})})]})]})}function w(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(j,{...e})}):j(e)}}}]);