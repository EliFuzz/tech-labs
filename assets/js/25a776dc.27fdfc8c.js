"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[8816],{95221:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>f,contentTitle:()=>m,default:()=>N,frontMatter:()=>x,metadata:()=>a,toc:()=>j});const a=JSON.parse('{"id":"education/computer-science/algorithms/algo/straight-traversal","title":"Straight Traversal","description":"Straight Traversal","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/straight-traversal.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/straight-traversal","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/straight-traversal","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/straight-traversal.mdx","tags":[],"version":"current","frontMatter":{"title":"Straight Traversal","description":"Straight Traversal","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Square Root - Newton\'s method","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/square-root-newtons-method"},"next":{"title":"Strongly Connected Components - Kosaraju\'s Algorithm","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/strongly-connected-components-kosarajus-algorithm"}}');var r=n(86070),i=n(15658),s=n(52421),l=n(74610),c=n(42953);const o='package main\n\ntype Node struct {\n    data int\n    next *Node\n}\n\nfunc traverseList(head *Node) {\n    current := head\n    for current != nil {\n        fmt.Print(current.data, " ")\n        current = current.next\n    }\n}\n',d='class Node {\n\n  int data;\n  Node next;\n\n  Node(int data) {\n    this.data = data;\n    next = null;\n  }\n}\n\nclass LinkedListTraversal {\n\n  static void traverseList(Node head) {\n    Node current = head;\n    while (current != null) {\n      System.out.print(current.data + " ");\n      current = current.next;\n    }\n  }\n}\n',h="class Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\nfunction traverseList(head) {\n  let current = head;\n  while (current !== null) {\n    console.log(current.data);\n    current = current.next;\n  }\n}\n",u='class Node(var data: Int) {\n    var next: Node? = null\n}\n\nfun traverseList(head: Node?) {\n    var current = head\n    while (current != null) {\n        print("${current.data} ")\n        current = current.next\n    }\n}\n',p="class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\ndef traverse_list(head):\n    current = head\n    while current:\n        print(current.data, end=' ')\n        current = current.next\n",g='struct Node {\n    data: i32,\n    next: Option<Box<Node>>,\n}\n\nimpl Node {\n    fn new(data: i32) -> Self {\n        Node { data, next: None }\n    }\n}\n\nfn traverse_list(mut head: Option<Box<Node>>) {\n    while let Some(node) = head {\n        println!("{}", node.data);\n        head = node.next;\n    }\n}\n',v="class Node {\n  data: number;\n  next: Node | null;\n\n  constructor(data: number) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\nfunction traverseList(head: Node | null): void {\n  let current: Node | null = head;\n  while (current !== null) {\n    console.log(current.data);\n    current = current.next;\n  }\n}\n",x={title:"Straight Traversal",description:"Straight Traversal",hide_table_of_contents:!0},m=void 0,f={},j=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function b(e){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(s.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"definition",label:"Definition",children:(0,r.jsx)(t.p,{children:"The Straight Traversal Algorithm is a method used in graph theory to traverse a graph by moving along edges in a straight path from one vertex to another, without revisiting any vertices"})}),(0,r.jsx)(l.A,{value:"how",label:"Explanation",children:(0,r.jsx)(t.p,{children:"Select a starting vertex. Then explores adjacent vertices in a systematic manner, without revisiting any vertices already visited. The algorithm employs a data structure to keep track of visited vertices and the current path. It continues until all reachable vertices have been visited or until a specific condition is met. The choice of data structure (stack or queue) may affect the order in which vertices are visited"})}),(0,r.jsx)(l.A,{value:"guidance",label:"Guidance",children:(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Select a vertex to start the traversal"}),"\n",(0,r.jsxs)(t.li,{children:["Initialize a data structure to keep track of visited vertices and the current path","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Explore the neighbors of the current vertex"}),"\n",(0,r.jsx)(t.li,{children:"Select the next vertex to visit based on a specific criteria (e.g., alphabetical order, distance, etc.)"}),"\n",(0,r.jsx)(t.li,{children:"Update the data structures to mark the current vertex as visited and add it to the path"}),"\n",(0,r.jsx)(t.li,{children:"Repeat the process until all reachable vertices have been visited"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.li,{children:"Terminate the algorithm when all vertices have been visited or when a specific condition is met"}),"\n"]})}),(0,r.jsx)(l.A,{value:"tips",label:"Tips",children:(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"consider different strategies for selecting the next vertex to visit, such as depth-first or breadth-first"}),"\n",(0,r.jsx)(t.li,{children:"implement mechanisms to detect and handle cycles in the graph to prevent infinite loops"}),"\n",(0,r.jsx)(t.li,{children:"ensure the graph is properly represented to facilitate efficient traversal"}),"\n"]})})]}),"\n",(0,r.jsx)(t.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(s.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"practice",label:"Practice",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"straightTraversal(graph, startVertex):\n  stack = empty stack\n  visited = set() // Set to keep track of visited vertices\n  path = empty list\n\n  stack.push(startVertex)\n\n  while stack is not empty:\n    currentVertex = stack.pop()\n\n    if currentVertex is not in visited:\n      add currentVertex to visited set\n      add currentVertex to path list\n\n      for each neighbor in graph.adjacent(currentVertex):\n        if neighbor is not in visited:\n          stack.push(neighbor)\n\n  return path\n"})})}),(0,r.jsx)(l.A,{value:"solution",label:"Solution",children:(0,r.jsxs)(s.A,{queryString:"code",children:[(0,r.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(c.A,{language:"go",children:o})}),(0,r.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(c.A,{language:"java",children:d})}),(0,r.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(c.A,{language:"js",children:h})}),(0,r.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(c.A,{language:"kotlin",children:u})}),(0,r.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(c.A,{language:"python",children:p})}),(0,r.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(c.A,{language:"rust",children:g})}),(0,r.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(c.A,{language:"ts",children:v})})]})})]})]})}function N(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(b,{...e})}):b(e)}}}]);