"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[4453],{28299:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>x,default:()=>I,frontMatter:()=>p,metadata:()=>s,toc:()=>_});const s=JSON.parse('{"id":"education/computer-science/algorithms/algo/power-set","title":"Power Set","description":"Power Set","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/power-set.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/power-set","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/power-set","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/power-set.mdx","tags":[],"version":"current","frontMatter":{"title":"Power Set","description":"Power Set","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Polynomial Hash","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/polynomial-hash"},"next":{"title":"Primality Test","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/primality-test"}}');var i=t(23420),r=t(38906),a=t(31519),l=t(20007),o=t(20636);const u="package main\n\nfunc backtrackingPowerSetRecursive(originalSet []int, allSubsets [][]int, currentSubSet []int, startAt int) [][]int {\n\tfor position := startAt; position < len(originalSet); position++ {\n\t\tcurrentSubSet = append(currentSubSet, originalSet[position])\n\t\tallSubsets = append(allSubsets, append([]int{}, currentSubSet...))\n\n\t\tallSubsets = backtrackingPowerSetRecursive(originalSet, allSubsets, currentSubSet, position+1)\n\n\t\tcurrentSubSet = currentSubSet[:len(currentSubSet)-1]\n\t}\n\n\treturn allSubsets\n}\n\nfunc bitwisePowerSet(originalSet []int) [][]int {\n\tvar subSets [][]int\n\tnumberOfCombinations := 1 << len(originalSet)\n\n\tfor combinationIndex := 0; combinationIndex < numberOfCombinations; combinationIndex++ {\n\t\tvar subSet []int\n\n\t\tfor setElementIndex := 0; setElementIndex < len(originalSet); setElementIndex++ {\n\t\t\tif combinationIndex&(1<<setElementIndex) != 0 {\n\t\t\t\tsubSet = append(subSet, originalSet[setElementIndex])\n\t\t\t}\n\t\t}\n\n\t\tsubSets = append(subSets, subSet)\n\t}\n\n\treturn subSets\n}\n\nfunc cascadingPowerSet(originalSet []int) [][]int {\n\tsets := [][]int{{}}\n\n\tfor numIdx := 0; numIdx < len(originalSet); numIdx++ {\n\t\texistingSetsNum := len(sets)\n\n\t\tfor setIdx := 0; setIdx < existingSetsNum; setIdx++ {\n\t\t\tset := append([]int{}, sets[setIdx]...)\n\t\t\tset = append(set, originalSet[numIdx])\n\t\t\tsets = append(sets, set)\n\t\t}\n\t}\n\n\treturn sets\n}\n",c="import java.util.ArrayList;\nimport java.util.List;\n\npublic class PowerSet {\n\n  public static List<List<Integer>> backtrackingPowerSetRecursive(int[] originalSet) {\n    List<List<Integer>> allSubsets = new ArrayList<>();\n    allSubsets.add(new ArrayList<>());\n    backtrackingPowerSetRecursive(originalSet, allSubsets, new ArrayList<>(), 0);\n    return allSubsets;\n  }\n\n  private static void backtrackingPowerSetRecursive(int[] originalSet, List<List<Integer>> allSubsets, List<Integer> currentSubSet, int startAt) {\n    for (int position = startAt; position < originalSet.length; position++) {\n      currentSubSet.add(originalSet[position]);\n      allSubsets.add(new ArrayList<>(currentSubSet));\n\n      backtrackingPowerSetRecursive(originalSet, allSubsets, currentSubSet, position + 1);\n\n      currentSubSet.remove(currentSubSet.size() - 1);\n    }\n  }\n\n  public static List<List<Integer>> bitwisePowerSet(int[] originalSet) {\n    List<List<Integer>> subSets = new ArrayList<>();\n    int numberOfCombinations = 1 << originalSet.length;\n\n    for (int combinationIndex = 0; combinationIndex < numberOfCombinations; combinationIndex++) {\n      List<Integer> subSet = new ArrayList<>();\n\n      for (int setElementIndex = 0; setElementIndex < originalSet.length; setElementIndex++) {\n        if ((combinationIndex & (1 << setElementIndex)) != 0) {\n          subSet.add(originalSet[setElementIndex]);\n        }\n      }\n\n      subSets.add(subSet);\n    }\n\n    return subSets;\n  }\n\n  public static List<List<Integer>> cascadingPowerSet(int[] originalSet) {\n    List<List<Integer>> sets = new ArrayList<>();\n    sets.add(new ArrayList<>());\n\n    for (int numIdx = 0; numIdx < originalSet.length; numIdx++) {\n      int existingSetsNum = sets.size();\n\n      for (int setIdx = 0; setIdx < existingSetsNum; setIdx++) {\n        List<Integer> set = new ArrayList<>(sets.get(setIdx));\n        set.add(originalSet[numIdx]);\n        sets.add(set);\n      }\n    }\n\n    return sets;\n  }\n}\n",d="function backtrackingPowerSetRecursive(\n  originalSet,\n  allSubsets = [[]],\n  currentSubSet = [],\n  startAt = 0,\n) {\n  for (let position = startAt; position < originalSet.length; position += 1) {\n    currentSubSet.push(originalSet[position]);\n    allSubsets.push([...currentSubSet]);\n\n    backtrackingPowerSetRecursive(\n      originalSet,\n      allSubsets,\n      currentSubSet,\n      position + 1,\n    );\n\n    currentSubSet.pop();\n  }\n\n  return allSubsets;\n}\n\nfunction bitwisePowerSet(originalSet) {\n  const subSets = [];\n  const numberOfCombinations = 2 ** originalSet.length;\n\n  for (\n    let combinationIndex = 0;\n    combinationIndex < numberOfCombinations;\n    combinationIndex += 1\n  ) {\n    const subSet = [];\n\n    for (\n      let setElementIndex = 0;\n      setElementIndex < originalSet.length;\n      setElementIndex += 1\n    ) {\n      if (combinationIndex & (1 << setElementIndex)) {\n        subSet.push(originalSet[setElementIndex]);\n      }\n    }\n\n    subSets.push(subSet);\n  }\n\n  return subSets;\n}\n\nfunction cascadingPowerSet(originalSet) {\n  const sets = [[]];\n\n  for (let numIdx = 0; numIdx < originalSet.length; numIdx += 1) {\n    const existingSetsNum = sets.length;\n\n    for (let setIdx = 0; setIdx < existingSetsNum; setIdx += 1) {\n      const set = [...sets[setIdx], originalSet[numIdx]];\n      sets.push(set);\n    }\n  }\n\n  return sets;\n}\n",b="fun backtrackingPowerSetRecursive(originalSet: IntArray, allSubsets: MutableList<MutableList<Int>> = mutableListOf(mutableListOf()), currentSubSet: MutableList<Int> = mutableListOf(), startAt: Int = 0): MutableList<MutableList<Int>> {\n    for (position in startAt until originalSet.size) {\n        currentSubSet.add(originalSet[position])\n        allSubsets.add(currentSubSet.toMutableList())\n\n        backtrackingPowerSetRecursive(originalSet, allSubsets, currentSubSet, position + 1)\n\n        currentSubSet.removeAt(currentSubSet.size - 1)\n    }\n\n    return allSubsets\n}\n\nfun bitwisePowerSet(originalSet: IntArray): MutableList<MutableList<Int>> {\n    val subSets = mutableListOf<MutableList<Int>>()\n    val numberOfCombinations = 1 shl originalSet.size\n\n    for (combinationIndex in 0 until numberOfCombinations) {\n        val subSet = mutableListOf<Int>()\n\n        for (setElementIndex in 0 until originalSet.size) {\n            if (combinationIndex and (1 shl setElementIndex) != 0) {\n                subSet.add(originalSet[setElementIndex])\n            }\n        }\n\n        subSets.add(subSet)\n    }\n\n    return subSets\n}\n\nfun cascadingPowerSet(originalSet: IntArray): MutableList<MutableList<Int>> {\n    val sets = mutableListOf<MutableList<Int>>(mutableListOf())\n\n    for (numIdx in originalSet.indices) {\n        val existingSetsNum = sets.size\n\n        for (setIdx in 0 until existingSetsNum) {\n            val set = mutableListOf<Int>().apply { addAll(sets[setIdx]) }\n            set.add(originalSet[numIdx])\n            sets.add(set)\n        }\n    }\n\n    return sets\n}\n",m="def backtracking_power_set_recursive(original_set, all_subsets=[[]], current_sub_set=[], start_at=0):\n    for position in range(start_at, len(original_set)):\n        current_sub_set.append(original_set[position])\n        all_subsets.append(current_sub_set[:])\n\n        backtracking_power_set_recursive(\n            original_set, all_subsets, current_sub_set, position + 1\n        )\n\n        current_sub_set.pop()\n\n    return all_subsets\n\n\ndef bitwise_power_set(original_set):\n    sub_sets = []\n    number_of_combinations = 2 ** len(original_set)\n\n    for combination_index in range(number_of_combinations):\n        sub_set = []\n\n        for set_element_index in range(len(original_set)):\n            if combination_index & (1 << set_element_index):\n                sub_set.append(original_set[set_element_index])\n\n        sub_sets.append(sub_set)\n\n    return sub_sets\n\n\ndef cascading_power_set(original_set):\n    sets = [[]]\n\n    for num_idx in range(len(original_set)):\n        existing_sets_num = len(sets)\n\n        for set_idx in range(existing_sets_num):\n            set_ = sets[set_idx] + [original_set[num_idx]]\n            sets.append(set_)\n\n    return sets\n",S="fn backtracking_power_set_recursive(original_set: &[i32], all_subsets: &mut Vec<Vec<i32>>, current_sub_set: &mut Vec<i32>, start_at: usize) {\n    for position in start_at..original_set.len() {\n        current_sub_set.push(original_set[position]);\n        all_subsets.push(current_sub_set.clone());\n\n        backtracking_power_set_recursive(original_set, all_subsets, current_sub_set, position + 1);\n\n        current_sub_set.pop();\n    }\n}\n\nfn backtracking_power_set(original_set: &[i32]) -> Vec<Vec<i32>> {\n    let mut all_subsets = vec![vec![]];\n    backtracking_power_set_recursive(original_set, &mut all_subsets, &mut vec![], 0);\n    all_subsets\n}\n\nfn bitwise_power_set(original_set: &[i32]) -> Vec<Vec<i32>> {\n    let mut sub_sets = vec![];\n    let number_of_combinations = 1 << original_set.len();\n\n    for combination_index in 0..number_of_combinations {\n        let mut sub_set = vec![];\n\n        for set_element_index in 0..original_set.len() {\n            if combination_index & (1 << set_element_index) != 0 {\n                sub_set.push(original_set[set_element_index]);\n            }\n        }\n\n        sub_sets.push(sub_set);\n    }\n\n    sub_sets\n}\n\nfn cascading_power_set(original_set: &[i32]) -> Vec<Vec<i32>> {\n    let mut sets = vec![vec![]];\n\n    for num_idx in 0..original_set.len() {\n        let existing_sets_num = sets.len();\n\n        for set_idx in 0..existing_sets_num {\n            let mut set = sets[set_idx].clone();\n            set.push(original_set[num_idx]);\n            sets.push(set);\n        }\n    }\n\n    sets\n}\n",g="function backtrackingPowerSetRecursive(\n  originalSet: number[],\n  allSubsets: number[][] = [[]],\n  currentSubSet: number[] = [],\n  startAt: number = 0,\n): number[][] {\n  for (let position = startAt; position < originalSet.length; position += 1) {\n    currentSubSet.push(originalSet[position]);\n    allSubsets.push([...currentSubSet]);\n\n    backtrackingPowerSetRecursive(\n      originalSet,\n      allSubsets,\n      currentSubSet,\n      position + 1,\n    );\n\n    currentSubSet.pop();\n  }\n\n  return allSubsets;\n}\n\nfunction bitwisePowerSet(originalSet: number[]): number[][] {\n  const subSets: number[][] = [];\n  const numberOfCombinations = 2 ** originalSet.length;\n\n  for (\n    let combinationIndex = 0;\n    combinationIndex < numberOfCombinations;\n    combinationIndex += 1\n  ) {\n    const subSet: number[] = [];\n\n    for (\n      let setElementIndex = 0;\n      setElementIndex < originalSet.length;\n      setElementIndex += 1\n    ) {\n      if (combinationIndex & (1 << setElementIndex)) {\n        subSet.push(originalSet[setElementIndex]);\n      }\n    }\n\n    subSets.push(subSet);\n  }\n\n  return subSets;\n}\n\nfunction cascadingPowerSet(originalSet: number[]): number[][] {\n  const sets: number[][] = [[]];\n\n  for (let numIdx = 0; numIdx < originalSet.length; numIdx += 1) {\n    const existingSetsNum = sets.length;\n\n    for (let setIdx = 0; setIdx < existingSetsNum; setIdx += 1) {\n      const set = [...sets[setIdx], originalSet[numIdx]];\n      sets.push(set);\n    }\n  }\n\n  return sets;\n}\n",p={title:"Power Set",description:"Power Set",hide_table_of_contents:!0},x=void 0,h={},_=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function f(e){const n={annotation:"annotation",code:"code",h2:"h2",li:"li",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msup:"msup",p:"p",pre:"pre",semantics:"semantics",span:"span",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(a.A,{queryString:"primary",children:[(0,i.jsx)(l.A,{value:"definition",label:"Definition",children:(0,i.jsx)(n.p,{children:"The Power Set Algorithm is a method used to generate all possible subsets of a given set. It's commonly implemented using recursion and bitwise manipulation for efficiency"})}),(0,i.jsx)(l.A,{value:"how",label:"Explanation",children:(0,i.jsx)(n.p,{children:"Start with an empty set and iteratively adds elements from the original set, effectively doubling the number of subsets with each addition. It utilizes recursion to explore all possible combinations. By leveraging bitwise manipulation, it efficiently generates subsets by representing each subset as a binary number, where each bit position corresponds to an element in the set"})}),(0,i.jsx)(l.A,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Start with an empty set (result) and an integer variable (n) representing the size of the input set"}),"\n",(0,i.jsxs)(n.li,{children:["Use a loop to iterate from 0 to ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsx)(n.mrow,{children:(0,i.jsxs)(n.msup,{children:[(0,i.jsx)(n.mn,{children:"2"}),(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mi,{children:"n"}),(0,i.jsx)(n.mo,{children:"\u2212"}),(0,i.jsx)(n.mn,{children:"1"})]})]})}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"2^{n-1}"})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.8141em"}}),(0,i.jsxs)(n.span,{className:"mord",children:[(0,i.jsx)(n.span,{className:"mord",children:"2"}),(0,i.jsx)(n.span,{className:"msupsub",children:(0,i.jsx)(n.span,{className:"vlist-t",children:(0,i.jsx)(n.span,{className:"vlist-r",children:(0,i.jsx)(n.span,{className:"vlist",style:{height:"0.8141em"},children:(0,i.jsxs)(n.span,{style:{top:"-3.063em",marginRight:"0.05em"},children:[(0,i.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,i.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,i.jsxs)(n.span,{className:"mord mtight",children:[(0,i.jsx)(n.span,{className:"mord mathnormal mtight",children:"n"}),(0,i.jsx)(n.span,{className:"mbin mtight",children:"\u2212"}),(0,i.jsx)(n.span,{className:"mord mtight",children:"1"})]})})]})})})})})]})]})})]})]}),"\n",(0,i.jsx)(n.li,{children:"Within the loop, for each iteration, convert the current loop variable into a binary representation"}),"\n",(0,i.jsx)(n.li,{children:"For each bit in the binary representation, if the bit is set (1), add the corresponding element from the input set to the result set"}),"\n",(0,i.jsx)(n.li,{children:"Add the generated subset to the final result set"}),"\n",(0,i.jsx)(n.li,{children:"Repeat until all possible subsets are generated"}),"\n"]})}),(0,i.jsx)(l.A,{value:"tips",label:"Tips",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"utilize bitwise manipulation to efficiently represent subsets"}),"\n",(0,i.jsx)(n.li,{children:"use memoization techniques if necessary to optimize performance for larger input sets"}),"\n"]})})]}),"\n",(0,i.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(a.A,{queryString:"primary",children:[(0,i.jsx)(l.A,{value:"practice",label:"Practice",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"powerSet(inputSet):\n  memo = {} # Initialize a memoization dictionary to store already computed subsets\n  result = [] # Initialize an empty list to store subsets\n\n  generateSubset(0, []) # Start the recursive function with index 0 and an empty subset\n  return result # Return the power set\n\n# Recursive function to generate subsets\ngenerateSubset(index, currentSubset):\n  if index == len(inputSet): # Base case: If index equals the length of input set\n    result.append(currentSubset) # Add currentSubset to result list\n    return\n  if (index, currentSubset) in memo: # Check if subset with current index and currentSubset is memoized\n    return\n  generateSubset(index + 1, currentSubset) # Skip current element\n  generateSubset(index + 1, currentSubset + [inputSet[index]]) # Include current element\n  memo[(index, currentSubset)] = True # Memoize the current subset\n"})})}),(0,i.jsx)(l.A,{value:"solution",label:"Solution",children:(0,i.jsxs)(a.A,{queryString:"code",children:[(0,i.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(o.A,{language:"go",children:u})}),(0,i.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(o.A,{language:"java",children:c})}),(0,i.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(o.A,{language:"js",children:d})}),(0,i.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(o.A,{language:"kotlin",children:b})}),(0,i.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(o.A,{language:"python",children:m})}),(0,i.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(o.A,{language:"rust",children:S})}),(0,i.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(o.A,{language:"ts",children:g})})]})})]})]})}function I(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(f,{...e})}):f(e)}}}]);