"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[6510],{78061:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>b,contentTitle:()=>f,default:()=>v,frontMatter:()=>p,metadata:()=>i,toc:()=>y});const i=JSON.parse('{"id":"education/computer-science/algorithms/algo/counting-sort","title":"Counting Sort","description":"Counting Sort","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/counting-sort.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/counting-sort","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/counting-sort","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/counting-sort.mdx","tags":[],"version":"current","frontMatter":{"title":"Counting Sort","description":"Counting Sort","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Complex Number","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/complex-number"},"next":{"title":"Depth-First Search (DFS)","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/depth-first-search"}}');var r=t(86070),o=t(15658),a=t(52421),c=t(74610),s=t(42953);const l="func countingSort(arr []int, max int) []int {\n    count := make([]int, max+1)\n    sorted := make([]int, len(arr))\n\n    for _, num := range arr {\n        count[num]++\n    }\n\n    index := 0\n    for i := 0; i <= max; i++ {\n        for count[i] > 0 {\n            sorted[index] = i\n            index++\n            count[i]--\n        }\n    }\n\n    return sorted\n}\n",u="public class CountingSort {\n\n  public static int[] countingSort(int[] arr, int max) {\n    int[] count = new int[max + 1];\n    int[] sorted = new int[arr.length];\n\n    for (int num : arr) {\n      count[num]++;\n    }\n\n    int index = 0;\n    for (int i = 0; i <= max; i++) {\n      while (count[i] > 0) {\n        sorted[index] = i;\n        index++;\n        count[i]--;\n      }\n    }\n\n    return sorted;\n  }\n}\n",d="function countingSort(arr, max) {\n  const count = new Array(max + 1).fill(0);\n  const sorted = [];\n\n  arr.forEach((num) => count[num]++);\n\n  let index = 0;\n  for (let i = 0; i <= max; i++) {\n    while (count[i] > 0) {\n      sorted[index++] = i;\n      count[i]--;\n    }\n  }\n\n  return sorted;\n}\n",h="fun countingSort(arr: IntArray, max: Int): IntArray {\n    val count = IntArray(max + 1)\n    val sorted = IntArray(arr.size)\n\n    arr.forEach { num -> count[num]++ }\n\n    var index = 0\n    for (i in 0..max) {\n        while (count[i] > 0) {\n            sorted[index++] = i\n            count[i]--\n        }\n    }\n\n    return sorted\n}\n",m="def counting_sort(arr, max_val):\n    count = [0] * (max_val + 1)\n    sorted_arr = []\n\n    for num in arr:\n        count[num] += 1\n\n    for i in range(max_val + 1):\n        sorted_arr.extend([i] * count[i])\n\n    return sorted_arr\n",g="fn counting_sort(arr: &[usize], max: usize) -> Vec<usize> {\n    let mut count = vec![0; max + 1];\n    let mut sorted = vec![0; arr.len()];\n\n    for &num in arr {\n        count[num] += 1;\n    }\n\n    let mut index = 0;\n    for i in 0..=max {\n        while count[i] > 0 {\n            sorted[index] = i;\n            index += 1;\n            count[i] -= 1;\n        }\n    }\n\n    sorted\n}\n",x="function countingSort(arr: number[], max: number): number[] {\n  const count: number[] = new Array(max + 1).fill(0);\n  const sorted: number[] = [];\n\n  arr.forEach((num) => count[num]++);\n\n  let index = 0;\n  for (let i = 0; i <= max; i++) {\n    while (count[i] > 0) {\n      sorted[index++] = i;\n      count[i]--;\n    }\n  }\n\n  return sorted;\n}\n",p={title:"Counting Sort",description:"Counting Sort",hide_table_of_contents:!0},f=void 0,b={},y=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function j(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(a.A,{queryString:"primary",children:[(0,r.jsx)(c.A,{value:"definition",label:"Definition",children:(0,r.jsx)(e.p,{children:"Counting Sort is a non-comparative sorting algorithm that sorts elements by counting the number of occurrences of each unique element in the input array. It operates on integer arrays with a defined range of values"})}),(0,r.jsx)(c.A,{value:"how",label:"Explanation",children:(0,r.jsx)(e.p,{children:"The algorithm begins by tallying the occurrences of each distinct element within the input array. These counts are then utilized to ascertain the respective positions of the elements within the sorted output array. Finally, the sorted array is assembled using the counts and positions obtained in the previous step"})}),(0,r.jsx)(c.A,{value:"guidance",label:"Guidance",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Initialize an auxiliary array, to store the count of each unique element"}),"\n",(0,r.jsx)(e.li,{children:"Traverse the input array, and increment the corresponding count in count array for each element encountered"}),"\n",(0,r.jsx)(e.li,{children:"Modify the count array to contain the actual position of each element in the sorted array"}),"\n",(0,r.jsx)(e.li,{children:"Iterate through the count array to construct the sorted array, by placing each element from the input array into its correct position based on the counts"}),"\n"]})}),(0,r.jsx)(c.A,{value:"tips",label:"Tips",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"counting Sort is most efficient when the range of input elements is not significantly greater than the number of elements to be sorted"}),"\n",(0,r.jsx)(e.li,{children:"ensure the input array contains only non-negative integers or modify the algorithm accordingly if negative integers are present"}),"\n"]})})]}),"\n",(0,r.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(a.A,{queryString:"primary",children:[(0,r.jsx)(c.A,{value:"practice",label:"Practice",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"counting_sort(arr[], size, max_val):\n  // Initialize count array with zeros\n  for i = 0 to max_val:\n    count[i] = 0\n\n  // Count occurrences of each element\n  for i = 0 to size:\n    count[arr[i]]++\n\n  // Modify count array to contain actual position\n  for i = 1 to max_val:\n    count[i] += count[i - 1]\n\n  // Build the sorted array\n  for i = size - 1 downto 0:\n    sorted[count[arr[i]] - 1] = arr[i]\n    count[arr[i]]--\n\n  // Copy sorted array to original array\n  for i = 0 to size:\n    arr[i] = sorted[i]\n"})})}),(0,r.jsx)(c.A,{value:"solution",label:"Solution",children:(0,r.jsxs)(a.A,{queryString:"code",children:[(0,r.jsx)(c.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(s.A,{language:"go",children:l})}),(0,r.jsx)(c.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(s.A,{language:"java",children:u})}),(0,r.jsx)(c.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(s.A,{language:"js",children:d})}),(0,r.jsx)(c.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(s.A,{language:"kotlin",children:h})}),(0,r.jsx)(c.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(s.A,{language:"python",children:m})}),(0,r.jsx)(c.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(s.A,{language:"rust",children:g})}),(0,r.jsx)(c.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(s.A,{language:"ts",children:x})})]})})]})]})}function v(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(j,{...n})}):j(n)}}}]);