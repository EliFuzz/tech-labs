"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[1625],{37471:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>b,contentTitle:()=>f,default:()=>S,frontMatter:()=>j,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"education/computer-science/algorithms/algo/longest-common-substring","title":"Longest Common Substring (LCS)","description":"Longest Common Substring (LCS)","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/longest-common-substring.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/longest-common-substring","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/longest-common-substring","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/longest-common-substring.mdx","tags":[],"version":"current","frontMatter":{"title":"Longest Common Substring (LCS)","description":"Longest Common Substring (LCS)","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Longest Common Subsequence (LCS)","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/longest-common-subsequence"},"next":{"title":"Longest Increasing Subsequence (LIS)","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/longest-increasing-subsequence"}}');var r=e(86070),s=e(15658),l=e(52421),o=e(74610),a=e(42953);const c="package main\n\nfunc longestCommonSubstring(str1, str2 string) string {\n    var longest, current string\n    matrix := make([][]int, len(str1)+1)\n    for i := range matrix {\n        matrix[i] = make([]int, len(str2)+1)\n    }\n\n    for i := 1; i <= len(str1); i++ {\n        for j := 1; j <= len(str2); j++ {\n            if str1[i-1] == str2[j-1] {\n                matrix[i][j] = matrix[i-1][j-1] + 1\n                current = str1[i-matrix[i][j] : i]\n                if len(current) > len(longest) {\n                    longest = current\n                }\n            }\n        }\n    }\n\n    return longest\n}\n",g="public class LongestCommonSubstring {\n\n  public static String longestCommonSubstring(String str1, String str2) {\n    int[][] matrix = new int[str1.length() + 1][str2.length() + 1];\n    int maxLength = 0;\n    int endIndex = 0;\n\n    for (int i = 1; i <= str1.length(); i++) {\n      for (int j = 1; j <= str2.length(); j++) {\n        if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n          matrix[i][j] = matrix[i - 1][j - 1] + 1;\n          if (matrix[i][j] > maxLength) {\n            maxLength = matrix[i][j];\n            endIndex = i;\n          }\n        }\n      }\n    }\n\n    return str1.substring(endIndex - maxLength, endIndex);\n  }\n}\n",m='function longestCommonSubstring(str1, str2) {\n  const matrix = Array.from({ length: str1.length + 1 }, () =>\n    Array.from({ length: str2.length + 1 }, () => 0),\n  );\n  let longest = "";\n\n  for (let i = 1; i <= str1.length; i++) {\n    for (let j = 1; j <= str2.length; j++) {\n      if (str1[i - 1] === str2[j - 1]) {\n        matrix[i][j] = matrix[i - 1][j - 1] + 1;\n        if (matrix[i][j] > longest.length) {\n          longest = str1.substring(i - matrix[i][j], i);\n        }\n      }\n    }\n  }\n\n  return longest;\n}\n',u='fun longestCommonSubstring(str1: String, str2: String): String {\n    val matrix = Array(str1.length + 1) { IntArray(str2.length + 1) }\n    var longest = ""\n\n    for (i in 1..str1.length) {\n        for (j in 1..str2.length) {\n            if (str1[i - 1] == str2[j - 1]) {\n                matrix[i][j] = matrix[i - 1][j - 1] + 1\n                if (matrix[i][j] > longest.length) {\n                    longest = str1.substring(i - matrix[i][j], i)\n                }\n            }\n        }\n    }\n\n    return longest\n}\n',h='def longest_common_substring(str1, str2):\n    matrix = [[0] * (len(str2) + 1) for _ in range(len(str1) + 1)]\n    longest = ""\n\n    for i in range(1, len(str1) + 1):\n        for j in range(1, len(str2) + 1):\n            if str1[i - 1] == str2[j - 1]:\n                matrix[i][j] = matrix[i - 1][j - 1] + 1\n                if matrix[i][j] > len(longest):\n                    longest = str1[i - matrix[i][j] : i]\n\n    return longest\n',d="fn longest_common_substring(str1: &str, str2: &str) -> String {\n    let mut matrix = vec![vec![0; str2.len() + 1]; str1.len() + 1];\n    let mut longest = String::new();\n\n    for (i, c1) in str1.chars().enumerate() {\n        for (j, c2) in str2.chars().enumerate() {\n            if c1 == c2 {\n                matrix[i + 1][j + 1] = matrix[i][j] + 1;\n                if matrix[i + 1][j + 1] > longest.len() {\n                    longest = str1[i + 1 - matrix[i + 1][j + 1]..=i].to_string();\n                }\n            }\n        }\n    }\n\n    longest\n}\n",x='function longestCommonSubstring(str1: string, str2: string): string {\n  const matrix: number[][] = Array.from({ length: str1.length + 1 }, () =>\n    Array.from({ length: str2.length + 1 }, () => 0),\n  );\n  let longest: string = "";\n\n  for (let i = 1; i <= str1.length; i++) {\n    for (let j = 1; j <= str2.length; j++) {\n      if (str1[i - 1] === str2[j - 1]) {\n        matrix[i][j] = matrix[i - 1][j - 1] + 1;\n        if (matrix[i][j] > longest.length) {\n          longest = str1.substring(i - matrix[i][j], i);\n        }\n      }\n    }\n  }\n\n  return longest;\n}\n',j={title:"Longest Common Substring (LCS)",description:"Longest Common Substring (LCS)",hide_table_of_contents:!0},f=void 0,b={},p=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function v(n){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(l.A,{queryString:"primary",children:[(0,r.jsx)(o.A,{value:"definition",label:"Definition",children:(0,r.jsx)(t.p,{children:"The Longest Common Substring (LCS) Algorithm is a dynamic programming technique used to find the longest contiguous sequence of characters that is present in two given strings"})}),(0,r.jsx)(o.A,{value:"how",label:"Explanation",children:(0,r.jsx)(t.p,{children:"Building a matrix where each cell represents the length of the longest common substring ending at that position. It iteratively fills this matrix based on whether characters match in the two strings. The algorithm then traces back from the cell with the maximum value to reconstruct the actual substring"})}),(0,r.jsx)(o.A,{value:"guidance",label:"Guidance",children:(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Create a matrix with dimensions (length of string 1 + 1) by (length of string 2 + 1)"}),"\n",(0,r.jsx)(t.li,{children:"Initialize the first row and first column of the matrix with zeros"}),"\n",(0,r.jsx)(t.li,{children:"Iterate through each cell of the matrix, starting from the second row and second column"}),"\n",(0,r.jsx)(t.li,{children:"If the characters at the corresponding positions in the two strings match, set the value of the current cell to the value of the cell diagonally left and above it, plus one"}),"\n",(0,r.jsx)(t.li,{children:"If the characters do not match, set the value of the current cell to zero"}),"\n",(0,r.jsx)(t.li,{children:"Track the maximum value encountered during the iteration and its position"}),"\n",(0,r.jsx)(t.li,{children:"Trace back from the cell with the maximum value to reconstruct the longest common substring"}),"\n"]})}),(0,r.jsx)(o.A,{value:"tips",label:"Tips",children:(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"optimize space usage by updating the matrix row by row instead of storing the entire matrix"}),"\n",(0,r.jsx)(t.li,{children:"use efficient data structures like arrays instead of matrices for better memory utilization"}),"\n",(0,r.jsx)(t.li,{children:"if memory is a concern, you can optimize further by using a rolling array approach, updating only the necessary portions of the matrix"}),"\n"]})})]}),"\n",(0,r.jsx)(t.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(l.A,{queryString:"primary",children:[(0,r.jsx)(o.A,{value:"practice",label:"Practice",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"longest_common_substring(string1, string2):\n  m = length(string1)\n  n = length(string2)\n  max_length = 0\n  end_index = 0\n\n  # Initialize a matrix to store lengths of longest common suffixes\n  # Initialize max_length and end_index to track the longest substring\n  matrix = [[0] * (n + 1) for _ in range(m + 1)]\n\n  # Iterate through each character of both strings\n  for i from 1 to m:\n    for j from 1 to n:\n      if string1[i - 1] == string2[j - 1]:\n        matrix[i][j] = matrix[i - 1][j - 1] + 1\n        if matrix[i][j] > max_length:\n          max_length = matrix[i][j]\n          end_index = i\n      else:\n        matrix[i][j] = 0\n\n  # Reconstruct the longest common substring\n  longest_substring = string1[end_index - max_length : end_index]\n\n  return longest_substring\n"})})}),(0,r.jsx)(o.A,{value:"solution",label:"Solution",children:(0,r.jsxs)(l.A,{queryString:"code",children:[(0,r.jsx)(o.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(a.A,{language:"go",children:c})}),(0,r.jsx)(o.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(a.A,{language:"java",children:g})}),(0,r.jsx)(o.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(a.A,{language:"js",children:m})}),(0,r.jsx)(o.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(a.A,{language:"kotlin",children:u})}),(0,r.jsx)(o.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(a.A,{language:"python",children:h})}),(0,r.jsx)(o.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(a.A,{language:"rust",children:d})}),(0,r.jsx)(o.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(a.A,{language:"ts",children:x})})]})})]})]})}function S(n={}){const{wrapper:t}={...(0,s.R)(),...n.components};return t?(0,r.jsx)(t,{...n,children:(0,r.jsx)(v,{...n})}):v(n)}}}]);