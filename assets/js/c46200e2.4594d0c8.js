"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[387],{58878:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>y,contentTitle:()=>d,default:()=>C,frontMatter:()=>g,metadata:()=>v,toc:()=>x});var a=e(11527),i=e(84135),r=e(40521),l=e(74109),s=e(80035);const o='package main\n\nfunc hamiltonianCycleUtil(path []int, pos int) bool {\n    if pos == numVertices {\n        if graph[path[pos-1]][path[0]] == 1 {\n            return true\n        }\n        return false\n    }\n\n    for v := 1; v < numVertices; v++ {\n        if isSafe(v, path, pos) {\n            path[pos] = v\n            if hamiltonianCycleUtil(path, pos+1) {\n                return true\n            }\n            path[pos] = -1\n        }\n    }\n    return false\n}\n\nfunc isSafe(v int, path []int, pos int) bool {\n    if graph[path[pos-1]][v] == 0 {\n        return false\n    }\n    for i := 0; i < pos; i++ {\n        if path[i] == v {\n            return false\n        }\n    }\n    return true\n}\n\nfunc hamiltonianCycle() {\n    path := make([]int, numVertices)\n    for i := range path {\n        path[i] = -1\n    }\n    path[0] = 0\n    if !hamiltonianCycleUtil(path, 1) {\n        fmt.Println("No Hamiltonian Cycle exists")\n        return\n    }\n    fmt.Println("Hamiltonian Cycle exists: ")\n    for _, vertex := range path {\n        fmt.Print(vertex, " ")\n    }\n    fmt.Println(path[0])\n}\n',p='import java.util.Arrays;\n\npublic class HamiltonianCycle {\n\n  static final int V = 6;\n  static int[] path;\n\n  static boolean isSafe(int v, int graph[][], int path[], int pos) {\n    if (graph[path[pos - 1]][v] == 0) {\n      return false;\n    }\n\n    for (int i = 0; i < pos; i++) {\n      if (path[i] == v) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  static boolean hamCycleUtil(int graph[][], int path[], int pos) {\n    if (pos == V) {\n      if (graph[path[pos - 1]][path[0]] == 1) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    for (int v = 1; v < V; v++) {\n      if (isSafe(v, graph, path, pos)) {\n        path[pos] = v;\n        if (hamCycleUtil(graph, path, pos + 1)) {\n          return true;\n        }\n        path[pos] = -1;\n      }\n    }\n\n    return false;\n  }\n\n  static int hamCycle(int graph[][]) {\n    path = new int[V];\n    Arrays.fill(path, -1);\n\n    path[0] = 0;\n    if (!hamCycleUtil(graph, path, 1)) {\n      System.out.println("No Hamiltonian Cycle exists");\n      return 0;\n    }\n\n    System.out.println("Hamiltonian Cycle exists: ");\n    for (int i = 0; i < V; i++) {\n      System.out.print(" " + path[i] + " ");\n    }\n\n    System.out.println(" " + path[0] + " ");\n    return 1;\n  }\n}\n',h='const V = 6;\nlet path = [];\n\nfunction isSafe(v, graph, path, pos) {\n  if (graph[path[pos - 1]][v] === 0) {\n    return false;\n  }\n\n  for (let i = 0; i < pos; i++) {\n    if (path[i] === v) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction hamCycleUtil(graph, path, pos) {\n  if (pos === V) {\n    if (graph[path[pos - 1]][path[0]] === 1) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  for (let v = 1; v < V; v++) {\n    if (isSafe(v, graph, path, pos)) {\n      path[pos] = v;\n      if (hamCycleUtil(graph, path, pos + 1)) {\n        return true;\n      }\n      path[pos] = -1;\n    }\n  }\n\n  return false;\n}\n\nfunction hamCycle(graph) {\n  path = new Array(V).fill(-1);\n\n  path[0] = 0;\n  if (!hamCycleUtil(graph, path, 1)) {\n    console.log("No Hamiltonian Cycle exists");\n    return;\n  }\n\n  console.log("Hamiltonian Cycle exists: ");\n  for (let i = 0; i < V; i++) {\n    process.stdout.write(" " + path[i] + " ");\n  }\n\n  console.log(" " + path[0] + " ");\n}\n',c='internal class HamiltonianCycle {\n    private val V = 6\n    private lateinit var path: IntArray\n\n    private fun isSafe(v: Int, graph: Array<IntArray>, path: IntArray, pos: Int): Boolean {\n        if (graph[path[pos - 1]][v] == 0) return false\n\n        for (i in 0 until pos) if (path[i] == v) return false\n\n        return true\n    }\n\n    private fun hamCycleUtil(graph: Array<IntArray>, path: IntArray, pos: Int): Boolean {\n        if (pos == V) {\n            return graph[path[pos - 1]][path[0]] == 1\n        }\n\n        for (v in 1 until V) {\n            if (isSafe(v, graph, path, pos)) {\n                path[pos] = v\n                if (hamCycleUtil(graph, path, pos + 1)) return true\n                path[pos] = -1\n            }\n        }\n\n        return false\n    }\n\n    fun hamCycle(graph: Array<IntArray>) {\n        path = IntArray(V) { -1 }\n\n        path[0] = 0\n        if (!hamCycleUtil(graph, path, 1)) {\n            println("No Hamiltonian Cycle exists")\n            return\n        }\n\n        println("Hamiltonian Cycle exists: ")\n        for (i in 0 until V) print(" ${path[i]} ")\n\n        println(" ${path[0]} ")\n    }\n}\n',u='V = 6\n\ndef isSafe(v, graph, path, pos):\n    if graph[path[pos - 1]][v] == 0:\n        return False\n\n    for i in range(pos):\n        if path[i] == v:\n            return False\n\n    return True\n\ndef hamCycleUtil(graph, path, pos):\n    if pos == V:\n        return graph[path[pos - 1]][path[0]] == 1\n\n    for v in range(1, V):\n        if isSafe(v, graph, path, pos):\n            path[pos] = v\n            if hamCycleUtil(graph, path, pos + 1):\n                return True\n            path[pos] = -1\n\n    return False\n\ndef hamCycle(graph):\n    path = [-1] * V\n    path[0] = 0\n    if not hamCycleUtil(graph, path, 1):\n        print("No Hamiltonian Cycle exists")\n        return\n\n    print("Hamiltonian Cycle exists:")\n    for vertex in path:\n        print(vertex, end=" ")\n    print(path[0])\n',f='const V: usize = 6;\n\nfn is_safe(v: usize, graph: &[[i32; V]; V], path: &[i32], pos: usize) -> bool {\n    if graph[path[pos - 1] as usize][v] == 0 {\n        return false;\n    }\n\n    for i in 0..pos {\n        if path[i] == v as i32 {\n            return false;\n        }\n    }\n\n    true\n}\n\nfn ham_cycle_util(graph: &[[i32; V]; V], path: &mut [i32], pos: usize) -> bool {\n    if pos == V {\n        return graph[path[pos - 1] as usize][path[0] as usize] == 1;\n    }\n\n    for v in 1..V {\n        if is_safe(v, graph, path, pos) {\n            path[pos] = v as i32;\n            if ham_cycle_util(graph, path, pos + 1) {\n                return true;\n            }\n            path[pos] = -1;\n        }\n    }\n\n    false\n}\n\nfn ham_cycle(graph: &[[i32; V]; V]) {\n    let mut path = vec![-1; V];\n    path[0] = 0;\n    if !ham_cycle_util(graph, &mut path, 1) {\n        println!("No Hamiltonian Cycle exists");\n        return;\n    }\n\n    println!("Hamiltonian Cycle exists:");\n    for vertex in path {\n        print!("{} ", vertex);\n    }\n    println!("{}", path[0]);\n}\n',m='const V: number = 6;\n\nfunction isSafe(\n  v: number,\n  graph: number[][],\n  path: number[],\n  pos: number,\n): boolean {\n  if (graph[path[pos - 1]][v] === 0) return false;\n\n  for (let i = 0; i < pos; i++) if (path[i] === v) return false;\n\n  return true;\n}\n\nfunction hamCycleUtil(graph: number[][], path: number[], pos: number): boolean {\n  if (pos === V) {\n    return graph[path[pos - 1]][path[0]] === 1;\n  }\n\n  for (let v = 1; v < V; v++) {\n    if (isSafe(v, graph, path, pos)) {\n      path[pos] = v;\n      if (hamCycleUtil(graph, path, pos + 1)) return true;\n      path[pos] = -1;\n    }\n  }\n\n  return false;\n}\n\nfunction hamCycle(graph: number[][]): void {\n  let path: number[] = Array(V).fill(-1);\n\n  path[0] = 0;\n  if (!hamCycleUtil(graph, path, 1)) {\n    console.log("No Hamiltonian Cycle exists");\n    return;\n  }\n\n  console.log("Hamiltonian Cycle exists:");\n  for (let i = 0; i < V; i++) process.stdout.write(" " + path[i] + " ");\n\n  console.log(" " + path[0] + " ");\n}\n',g={title:"Hamiltonian Cycle",description:"Hamiltonian Cycle",hide_table_of_contents:!0},d=void 0,v={id:"education/computer-science/algorithms/algo/hamiltonian-cycle",title:"Hamiltonian Cycle",description:"Hamiltonian Cycle",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/hamiltonian-cycle.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/hamiltonian-cycle",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/hamiltonian-cycle",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/hamiltonian-cycle.mdx",tags:[],version:"current",frontMatter:{title:"Hamiltonian Cycle",description:"Hamiltonian Cycle",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Floyd-Warshall Algorithm",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/floyd-warshall-algorithm"},next:{title:"Hamming Distance",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/hamming-distance"}},y={},x=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function b(n){const t={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"definition",children:"Definition"}),"\n",(0,a.jsxs)(r.Z,{queryString:"primary",children:[(0,a.jsx)(l.Z,{value:"definition",label:"Definition",children:(0,a.jsx)(t.p,{children:"The Hamiltonian Cycle Algorithm aims to find a cycle that visits every vertex in a graph exactly once and returns to the starting vertex. It's a problem of determining whether such a cycle exists in a given graph"})}),(0,a.jsx)(l.Z,{value:"how",label:"Explanation",children:(0,a.jsx)(t.p,{children:"The algorithm explores all possible permutations of vertices to find a cycle that visits each vertex exactly once and returns to the starting vertex. It typically uses backtracking to efficiently explore the solution space"})}),(0,a.jsx)(l.Z,{value:"guidance",label:"Guidance",children:(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Start with any vertex as the current vertex"}),"\n",(0,a.jsx)(t.li,{children:"Explore all unvisited vertices adjacent to the current vertex"}),"\n",(0,a.jsx)(t.li,{children:"If all vertices are visited and the current vertex has an edge to the start vertex, then a Hamiltonian cycle is found"}),"\n",(0,a.jsx)(t.li,{children:"Otherwise, mark the current vertex as visited and recursively explore the unvisited adjacent vertices"}),"\n",(0,a.jsx)(t.li,{children:"Backtrack if no Hamiltonian cycle is found from the current vertex"}),"\n"]})}),(0,a.jsx)(l.Z,{value:"tips",label:"Tips",children:(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Implement efficient data structures for graph representation and vertex visitation tracking to optimize performance"}),"\n",(0,a.jsx)(t.li,{children:"Prune unnecessary branches early in the search process to reduce computation time"}),"\n",(0,a.jsx)(t.li,{children:"Consider heuristic approaches or domain-specific knowledge if applicable to improve search efficiency"}),"\n"]})})]}),"\n",(0,a.jsx)(t.h2,{id:"practice",children:"Practice"}),"\n",(0,a.jsxs)(r.Z,{queryString:"primary",children:[(0,a.jsx)(l.Z,{value:"practice",label:"Practice",children:(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-python",children:'hamiltonianCycle(graph):\n  numVertices = graph.numVertices()\n  path = array of size numVertices\n  for each vertex in graph:\n    path[0] = vertex\n    if hamiltonianCycleUtil(graph, path, 1):\n      return path\n  return "No Hamiltonian cycle found"\n\nhamiltonianCycleUtil(graph, path, pos):\n  if pos == graph.numVertices():\n    if graph.hasEdge(path[pos-1], path[0]):\n      return true\n    else:\n      return false\n  for v in graph.adjacentVertices(path[pos-1]):\n    if not isVisited(v, path, pos):\n      path[pos] = v\n      if hamiltonianCycleUtil(graph, path, pos+1):\n        return true\n      path[pos] = -1\n  return false\n\nisVisited(vertex, path, pos):\n  for i from 0 to pos-1:\n    if path[i] == vertex:\n      return true\n  return false\n'})})}),(0,a.jsx)(l.Z,{value:"solution",label:"Solution",children:(0,a.jsxs)(r.Z,{queryString:"code",children:[(0,a.jsx)(l.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,a.jsx)(s.Z,{language:"go",children:o})}),(0,a.jsx)(l.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,a.jsx)(s.Z,{language:"java",children:p})}),(0,a.jsx)(l.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,a.jsx)(s.Z,{language:"js",children:h})}),(0,a.jsx)(l.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,a.jsx)(s.Z,{language:"kotlin",children:c})}),(0,a.jsx)(l.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,a.jsx)(s.Z,{language:"python",children:u})}),(0,a.jsx)(l.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,a.jsx)(s.Z,{language:"rust",children:f})}),(0,a.jsx)(l.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,a.jsx)(s.Z,{language:"ts",children:m})})]})})]})]})}function C(n={}){const{wrapper:t}={...(0,i.a)(),...n.components};return t?(0,a.jsx)(t,{...n,children:(0,a.jsx)(b,{...n})}):b(n)}}}]);