"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[8250],{32886:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>x,default:()=>v,frontMatter:()=>f,metadata:()=>j,toc:()=>b});var i=t(11527),r=t(88672),a=t(29140),l=t(52360),s=t(52296);const h="package main\n\nfunc binarySearch(arr []int, target int) int {\n    left, right := 0, len(arr)-1\n\n    for left <= right {\n        mid := left + (right-left)/2\n\n        if arr[mid] == target {\n            return mid\n        } else if arr[mid] < target {\n            left = mid + 1\n        } else {\n            right = mid - 1\n        }\n    }\n\n    return -1\n}\n",c="public class Main {\n\n  public static int binarySearch(int[] arr, int target) {\n    int left = 0;\n    int right = arr.length - 1;\n\n    while (left <= right) {\n      int mid = left + (right - left) / 2;\n\n      if (arr[mid] == target) {\n        return mid;\n      } else if (arr[mid] < target) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n\n    return -1;\n  }\n}\n",d="function binarySearch(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  return -1;\n}\n",o="fun binarySearch(arr: IntArray, target: Int): Int {\n    var left = 0\n    var right = arr.size - 1\n\n    while (left <= right) {\n        val mid = left + (right - left) / 2\n\n        when {\n            arr[mid] == target -> return mid\n            arr[mid] < target -> left = mid + 1\n            else -> right = mid - 1\n        }\n    }\n\n    return -1\n}\n",g="def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return -1\n",u="fn binary_search(arr: &[i32], target: i32) -> i32 {\n    let mut left = 0;\n    let mut right = arr.len() - 1;\n\n    while left <= right {\n        let mid = left + (right - left) / 2;\n\n        if arr[mid] == target {\n            return mid as i32;\n        } else if arr[mid] < target {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    -1\n}\n",m="function binarySearch(arr: number[], target: number): number {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  return -1;\n}\n",f={title:"Binary Search",description:"Binary Search",hide_table_of_contents:!0},x=void 0,j={id:"education/computer-science/algorithms/algo/binary-search",title:"Binary Search",description:"Binary Search",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/binary-search.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/binary-search",permalink:"/docs/education/computer-science/algorithms/algo/binary-search",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/binary-search.mdx",tags:[],version:"current",frontMatter:{title:"Binary Search",description:"Binary Search",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Binary Floating Point",permalink:"/docs/education/computer-science/algorithms/algo/binary-floating-point"},next:{title:"Bit Manipulation",permalink:"/docs/education/computer-science/algorithms/algo/bit-manipulation"}},p={},b=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function y(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(a.Z,{children:[(0,i.jsx)(l.Z,{value:"definition",label:"Definition",children:(0,i.jsx)(n.p,{children:"Binary search is an efficient algorithm used to find a target value within a sorted array or list. It works by repeatedly dividing the search interval in half until the target value is found or the interval is empty"})}),(0,i.jsx)(l.Z,{value:"how",label:"Explanation",children:(0,i.jsx)(n.p,{children:"Start with a sorted array. Find the middle index of the array. If the middle element matches the target, return its index. If the middle element is greater than the target, search the left half, otherwise search the right half. Repeat until the target is found or the search interval is empty"})}),(0,i.jsx)(l.Z,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Initialize variables","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"low as the starting index of the array (0) and high as the ending index (length of the array - 1)"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["While low is less than or equal to high, continue the search","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["calculate the middle index","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"mid = (low + high) / 2"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["if the middle element is equal to the target value","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["return ",(0,i.jsx)(n.code,{children:"mid"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["if the middle element is greater than the target value","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["set ",(0,i.jsx)(n.code,{children:"high = mid - 1"})," to search the left half"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["if the middle element is less than the target value","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["set ",(0,i.jsx)(n.code,{children:"low = mid + 1"})," to search the right half"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"repeat steps in a while loop until low is greater than high, indicating the target value is not present in the array"}),"\n"]}),"\n"]}),"\n"]})}),(0,i.jsx)(l.Z,{value:"tips",label:"Tips",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ensure the array is sorted beforehand"}),"\n",(0,i.jsx)(n.li,{children:"watch out for integer overflow when calculating the midpoint (mid = (low + high) / 2). Consider using mid = low + (high - low) / 2 to avoid this issue"}),"\n",(0,i.jsx)(n.li,{children:"make sure to handle edge cases such as empty arrays or arrays with only one element"}),"\n",(0,i.jsx)(n.li,{children:"remember to handle scenarios where the target value is not present in the array"}),"\n"]})})]}),"\n",(0,i.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(a.Z,{children:[(0,i.jsx)(l.Z,{value:"practice",label:"Practice",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"binarySearch(arr, target):\n  low = 0\n  high = length(arr) - 1\n\n  while low <= high:\n    mid = (low + high) / 2\n\n    if arr[mid] == target:\n      return mid\n    elif arr[mid] < target:\n      low = mid + 1\n    else:\n      high = mid - 1\n\n  return -1 // Target not found\n"})})}),(0,i.jsx)(l.Z,{value:"solution",label:"Solution",children:(0,i.jsxs)(a.Z,{queryString:"code",children:[(0,i.jsx)(l.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(s.Z,{language:"go",children:h})}),(0,i.jsx)(l.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(s.Z,{language:"java",children:c})}),(0,i.jsx)(l.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(s.Z,{language:"js",children:d})}),(0,i.jsx)(l.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(s.Z,{language:"kotlin",children:o})}),(0,i.jsx)(l.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(s.Z,{language:"python",children:g})}),(0,i.jsx)(l.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(s.Z,{language:"rust",children:u})}),(0,i.jsx)(l.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(s.Z,{language:"ts",children:m})})]})})]})]})}function v(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(y,{...e})}):y(e)}}}]);