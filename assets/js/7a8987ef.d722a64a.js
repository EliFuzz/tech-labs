"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[4916],{51382:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>g,contentTitle:()=>f,default:()=>v,frontMatter:()=>b,metadata:()=>x,toc:()=>C});var r=i(86070),a=i(25710),t=i(98459),l=i(37515),s=i(18792);const m='package main\n\nimport (\n\t"math"\n)\n\ntype ComplexNumber struct {\n\tre float64\n\tim float64\n}\n\nfunc NewComplexNumber(re float64, im float64) *ComplexNumber {\n\treturn &ComplexNumber{re, im}\n}\n\nfunc (c *ComplexNumber) Add(addend *ComplexNumber) *ComplexNumber {\n\treturn NewComplexNumber(c.re+addend.re, c.im+addend.im)\n}\n\nfunc (c *ComplexNumber) Subtract(subtrahend *ComplexNumber) *ComplexNumber {\n\treturn NewComplexNumber(c.re-subtrahend.re, c.im-subtrahend.im)\n}\n\nfunc (c *ComplexNumber) Multiply(multiplicand *ComplexNumber) *ComplexNumber {\n\treturn NewComplexNumber(c.re*multiplicand.re-c.im*multiplicand.im, c.re*multiplicand.im+c.im*multiplicand.re)\n}\n\nfunc (c *ComplexNumber) Divide(divider *ComplexNumber) *ComplexNumber {\n\tfinalDivider := math.Pow(divider.re, 2) + math.Pow(divider.im, 2)\n\tdividerConjugate := NewComplexNumber(divider.re, -divider.im)\n\tfinalDivident := c.Multiply(dividerConjugate)\n\treturn NewComplexNumber(finalDivident.re/finalDivider, finalDivident.im/finalDivider)\n}\n\nfunc (c *ComplexNumber) Conjugate() *ComplexNumber {\n\treturn NewComplexNumber(c.re, -c.im)\n}\n\nfunc (c *ComplexNumber) GetRadius() float64 {\n\treturn math.Sqrt(math.Pow(c.re, 2) + math.Pow(c.im, 2))\n}\n\nfunc (c *ComplexNumber) GetPhase(inRadians bool) float64 {\n\tphase := math.Atan(math.Abs(c.im) / math.Abs(c.re))\n\n\tif c.re < 0 && c.im > 0 {\n\t\tphase = math.Pi - phase\n\t} else if c.re < 0 && c.im < 0 {\n\t\tphase = -(math.Pi - phase)\n\t} else if c.re > 0 && c.im < 0 {\n\t\tphase = -phase\n\t} else if c.re == 0 && c.im > 0 {\n\t\tphase = math.Pi / 2\n\t} else if c.re == 0 && c.im < 0 {\n\t\tphase = -math.Pi / 2\n\t} else if c.re < 0 && c.im == 0 {\n\t\tphase = math.Pi\n\t} else if c.re > 0 && c.im == 0 {\n\t\tphase = 0\n\t} else if c.re == 0 && c.im == 0 {\n\t\tphase = 0\n\t}\n\n\tif !inRadians {\n\t\tphase = c.RadianToDegree(phase)\n\t}\n\n\treturn phase\n}\n\nfunc (c *ComplexNumber) GetPolarForm(inRadians bool) (float64, float64) {\n\treturn c.GetRadius(), c.GetPhase(inRadians)\n}\n\nfunc (c *ComplexNumber) RadianToDegree(radian float64) float64 {\n\treturn radian * (180 / math.Pi)\n}\n',d="import java.lang.Math;\n\npublic class ComplexNumber {\n\n  private double re;\n  private double im;\n\n  public ComplexNumber() {\n    this.re = 0;\n    this.im = 0;\n  }\n\n  public ComplexNumber(double re, double im) {\n    this.re = re;\n    this.im = im;\n  }\n\n  public ComplexNumber add(ComplexNumber addend) {\n    return new ComplexNumber(this.re + addend.re, this.im + addend.im);\n  }\n\n  public ComplexNumber subtract(ComplexNumber subtrahend) {\n    return new ComplexNumber(this.re - subtrahend.re, this.im - subtrahend.im);\n  }\n\n  public ComplexNumber multiply(ComplexNumber multiplicand) {\n    return new ComplexNumber(\n        this.re * multiplicand.re - this.im * multiplicand.im,\n        this.re * multiplicand.im + this.im * multiplicand.re\n    );\n  }\n\n  public ComplexNumber divide(ComplexNumber divider) {\n    double finalDivider = Math.pow(divider.re, 2) + Math.pow(divider.im, 2);\n    ComplexNumber dividerConjugate = this.conjugate(divider);\n    ComplexNumber finalDivident = this.multiply(dividerConjugate);\n    return new ComplexNumber(\n        finalDivident.re / finalDivider,\n        finalDivident.im / finalDivider\n    );\n  }\n\n  public ComplexNumber conjugate(ComplexNumber number) {\n    return new ComplexNumber(number.re, -1 * number.im);\n  }\n\n  public double getRadius() {\n    return Math.sqrt(Math.pow(this.re, 2) + Math.pow(this.im, 2));\n  }\n\n  public double getPhase(boolean inRadians) {\n    double phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));\n\n    if (this.re < 0 && this.im > 0) {\n      phase = Math.PI - phase;\n    } else if (this.re < 0 && this.im < 0) {\n      phase = -(Math.PI - phase);\n    } else if (this.re > 0 && this.im < 0) {\n      phase = -phase;\n    } else if (this.re == 0 && this.im > 0) {\n      phase = Math.PI / 2;\n    } else if (this.re == 0 && this.im < 0) {\n      phase = -Math.PI / 2;\n    } else if (this.re < 0 && this.im == 0) {\n      phase = Math.PI;\n    } else if (this.re > 0 && this.im == 0) {\n      phase = 0;\n    } else if (this.re == 0 && this.im == 0) {\n      phase = 0;\n    }\n\n    if (!inRadians) {\n      phase = radianToDegree(phase);\n    }\n\n    return phase;\n  }\n\n  public double[] getPolarForm(boolean inRadians) {\n    double[] polarForm = new double[2];\n    polarForm[0] = this.getRadius();\n    polarForm[1] = this.getPhase(inRadians);\n    return polarForm;\n  }\n\n  private double radianToDegree(double radian) {\n    return radian * (180 / Math.PI);\n  }\n}\n",u="class ComplexNumber {\n  constructor({ re = 0, im = 0 } = {}) {\n    this.re = re;\n    this.im = im;\n  }\n\n  radianToDegree(radian) {\n    return radian * (180 / Math.PI);\n  }\n\n  add(addend) {\n    const complexAddend = this.toComplexNumber(addend);\n\n    return new ComplexNumber({\n      re: this.re + complexAddend.re,\n      im: this.im + complexAddend.im,\n    });\n  }\n\n  subtract(subtrahend) {\n    const complexSubtrahend = this.toComplexNumber(subtrahend);\n\n    return new ComplexNumber({\n      re: this.re - complexSubtrahend.re,\n      im: this.im - complexSubtrahend.im,\n    });\n  }\n\n  multiply(multiplicand) {\n    const complexMultiplicand = this.toComplexNumber(multiplicand);\n\n    return new ComplexNumber({\n      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,\n      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,\n    });\n  }\n\n  divide(divider) {\n    const complexDivider = this.toComplexNumber(divider);\n    const dividerConjugate = this.conjugate(complexDivider);\n    const finalDivident = this.multiply(dividerConjugate);\n    const finalDivider = complexDivider.re ** 2 + complexDivider.im ** 2;\n\n    return new ComplexNumber({\n      re: finalDivident.re / finalDivider,\n      im: finalDivident.im / finalDivider,\n    });\n  }\n\n  conjugate(number) {\n    const complexNumber = this.toComplexNumber(number);\n\n    return new ComplexNumber({\n      re: complexNumber.re,\n      im: -1 * complexNumber.im,\n    });\n  }\n\n  getRadius() {\n    return Math.sqrt(this.re ** 2 + this.im ** 2);\n  }\n\n  getPhase(inRadians = true) {\n    let phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));\n\n    if (this.re < 0 && this.im > 0) {\n      phase = Math.PI - phase;\n    } else if (this.re < 0 && this.im < 0) {\n      phase = -(Math.PI - phase);\n    } else if (this.re > 0 && this.im < 0) {\n      phase = -phase;\n    } else if (this.re === 0 && this.im > 0) {\n      phase = Math.PI / 2;\n    } else if (this.re === 0 && this.im < 0) {\n      phase = -Math.PI / 2;\n    } else if (this.re < 0 && this.im === 0) {\n      phase = Math.PI;\n    } else if (this.re > 0 && this.im === 0) {\n      phase = 0;\n    } else if (this.re === 0 && this.im === 0) {\n      phase = 0;\n    }\n\n    if (!inRadians) {\n      phase = radianToDegree(phase);\n    }\n\n    return phase;\n  }\n\n  getPolarForm(inRadians = true) {\n    return {\n      radius: this.getRadius(),\n      phase: this.getPhase(inRadians),\n    };\n  }\n\n  toComplexNumber(number) {\n    if (number instanceof ComplexNumber) {\n      return number;\n    }\n\n    return new ComplexNumber({ re: number });\n  }\n}\n",o="import kotlin.math.*\n\nclass ComplexNumber(private var re: Double = 0.0, private var im: Double = 0.0) {\n    fun add(addend: ComplexNumber): ComplexNumber {\n        return ComplexNumber(re + addend.re, im + addend.im)\n    }\n\n    fun subtract(subtrahend: ComplexNumber): ComplexNumber {\n        return ComplexNumber(re - subtrahend.re, im - subtrahend.im)\n    }\n\n    fun multiply(multiplicand: ComplexNumber): ComplexNumber {\n        return ComplexNumber(\n                re * multiplicand.re - im * multiplicand.im,\n                re * multiplicand.im + im * multiplicand.re\n        )\n    }\n\n    fun divide(divider: ComplexNumber): ComplexNumber {\n        val finalDivider = divider.re.pow(2) + divider.im.pow(2)\n        val dividerConjugate = conjugate(divider)\n        val finalDividend = multiply(dividerConjugate)\n        return ComplexNumber(finalDividend.re / finalDivider, finalDividend.im / finalDivider)\n    }\n\n    fun conjugate(number: ComplexNumber): ComplexNumber {\n        return ComplexNumber(number.re, -1 * number.im)\n    }\n\n    fun getRadius(): Double {\n        return sqrt(re.pow(2) + im.pow(2))\n    }\n\n    fun getPhase(inRadians: Boolean = true): Double {\n        var phase = atan(abs(im) / abs(re))\n\n        if (re < 0 && im > 0) {\n            phase = PI - phase\n        } else if (re < 0 && im < 0) {\n            phase = -(PI - phase)\n        } else if (re > 0 && im < 0) {\n            phase = -phase\n        } else if (re == 0.0 && im > 0) {\n            phase = PI / 2\n        } else if (re == 0.0 && im < 0) {\n            phase = -PI / 2\n        } else if (re < 0 && im == 0.0) {\n            phase = PI\n        } else if (re > 0 && im == 0.0) {\n            phase = 0.0\n        } else if (re == 0.0 && im == 0.0) {\n            phase = 0.0\n        }\n\n        if (!inRadians) {\n            phase = Math.toDegrees(phase)\n        }\n\n        return phase\n    }\n\n    fun getPolarForm(inRadians: Boolean = true): Pair<Double, Double> {\n        return Pair(getRadius(), getPhase(inRadians))\n    }\n}\n",h="import math\n\nclass ComplexNumber:\n    def __init__(self, re=0, im=0):\n        self.re = re\n        self.im = im\n\n    def add(self, addend):\n        return ComplexNumber(self.re + addend.re, self.im + addend.im)\n\n    def subtract(self, subtrahend):\n        return ComplexNumber(self.re - subtrahend.re, self.im - subtrahend.im)\n\n    def multiply(self, multiplicand):\n        return ComplexNumber(\n            self.re * multiplicand.re - self.im * multiplicand.im,\n            self.re * multiplicand.im + self.im * multiplicand.re\n        )\n\n    def divide(self, divider):\n        final_divider = divider.re ** 2 + divider.im ** 2\n        divider_conjugate = self.conjugate(divider)\n        final_dividend = self.multiply(divider_conjugate)\n        return ComplexNumber(final_dividend.re / final_divider, final_dividend.im / final_divider)\n\n    def conjugate(self, number):\n        return ComplexNumber(number.re, -1 * number.im)\n\n    def get_radius(self):\n        return math.sqrt(self.re ** 2 + self.im ** 2)\n\n    def get_phase(self, in_radians=True):\n        phase = math.atan(abs(self.im) / abs(self.re))\n\n        if self.re < 0 and self.im > 0:\n            phase = math.pi - phase\n        elif self.re < 0 and self.im < 0:\n            phase = -(math.pi - phase)\n        elif self.re > 0 and self.im < 0:\n            phase = -phase\n        elif self.re == 0 and self.im > 0:\n            phase = math.pi / 2\n        elif self.re == 0 and self.im < 0:\n            phase = -math.pi / 2\n        elif self.re < 0 and self.im == 0:\n            phase = math.pi\n        elif self.re > 0 and self.im == 0:\n            phase = 0\n        elif self.re == 0 and self.im == 0:\n            phase = 0\n\n        if not in_radians:\n            phase = math.degrees(phase)\n\n        return phase\n\n    def get_polar_form(self, in_radians=True):\n        return self.get_radius(), self.get_phase(in_radians)\n",p="use std::f64::consts::PI;\n\n#[derive(Debug)]\nstruct ComplexNumber {\n    re: f64,\n    im: f64,\n}\n\nimpl ComplexNumber {\n    fn new(re: f64, im: f64) -> ComplexNumber {\n        ComplexNumber { re, im }\n    }\n\n    fn add(&self, addend: &ComplexNumber) -> ComplexNumber {\n        ComplexNumber::new(self.re + addend.re, self.im + addend.im)\n    }\n\n    fn subtract(&self, subtrahend: &ComplexNumber) -> ComplexNumber {\n        ComplexNumber::new(self.re - subtrahend.re, self.im - subtrahend.im)\n    }\n\n    fn multiply(&self, multiplicand: &ComplexNumber) -> ComplexNumber {\n        ComplexNumber::new(\n            self.re * multiplicand.re - self.im * multiplicand.im,\n            self.re * multiplicand.im + self.im * multiplicand.re,\n        )\n    }\n\n    fn divide(&self, divider: &ComplexNumber) -> ComplexNumber {\n        let final_divider = divider.re.powf(2.0) + divider.im.powf(2.0);\n        let divider_conjugate = self.conjugate(divider);\n        let final_dividend = self.multiply(&divider_conjugate);\n        ComplexNumber::new(final_dividend.re / final_divider, final_dividend.im / final_divider)\n    }\n\n    fn conjugate(&self, number: &ComplexNumber) -> ComplexNumber {\n        ComplexNumber::new(number.re, -1.0 * number.im)\n    }\n\n    fn get_radius(&self) -> f64 {\n        (self.re.powf(2.0) + self.im.powf(2.0)).sqrt()\n    }\n\n    fn get_phase(&self, in_radians: bool) -> f64 {\n        let mut phase = (self.im / self.re).atan().abs();\n\n        if self.re < 0.0 && self.im > 0.0 {\n            phase = PI - phase;\n        } else if self.re < 0.0 && self.im < 0.0 {\n            phase = -(PI - phase);\n        } else if self.re > 0.0 && self.im < 0.0 {\n            phase = -phase;\n        } else if self.re == 0.0 && self.im > 0.0 {\n            phase = PI / 2.0;\n        } else if self.re == 0.0 && self.im < 0.0 {\n            phase = -PI / 2.0;\n        } else if self.re < 0.0 && self.im == 0.0 {\n            phase = PI;\n        } else if self.re > 0.0 && self.im == 0.0 {\n            phase = 0.0;\n        } else if self.re == 0.0 && self.im == 0.0 {\n            phase = 0.0;\n        }\n\n        if !in_radians {\n            phase = phase.to_degrees();\n        }\n\n        phase\n    }\n\n    fn get_polar_form(&self, in_radians: bool) -> (f64, f64) {\n        (self.get_radius(), self.get_phase(in_radians))\n    }\n}\n",c="class ComplexNumber {\n  re: number;\n  im: number;\n\n  constructor({ re = 0, im = 0 }: { re?: number; im?: number } = {}) {\n    this.re = re;\n    this.im = im;\n  }\n\n  add(addend: ComplexNumber): ComplexNumber {\n    return new ComplexNumber({\n      re: this.re + addend.re,\n      im: this.im + addend.im,\n    });\n  }\n\n  subtract(subtrahend: ComplexNumber): ComplexNumber {\n    return new ComplexNumber({\n      re: this.re - subtrahend.re,\n      im: this.im - subtrahend.im,\n    });\n  }\n\n  multiply(multiplicand: ComplexNumber): ComplexNumber {\n    return new ComplexNumber({\n      re: this.re * multiplicand.re - this.im * multiplicand.im,\n      im: this.re * multiplicand.im + this.im * multiplicand.re,\n    });\n  }\n\n  divide(divider: ComplexNumber): ComplexNumber {\n    const finalDivider = divider.re ** 2 + divider.im ** 2;\n    const dividerConjugate = this.conjugate(divider);\n    const finalDividend = this.multiply(dividerConjugate);\n    return new ComplexNumber({\n      re: finalDividend.re / finalDivider,\n      im: finalDividend.im / finalDivider,\n    });\n  }\n\n  conjugate(number: ComplexNumber): ComplexNumber {\n    return new ComplexNumber({\n      re: number.re,\n      im: -1 * number.im,\n    });\n  }\n\n  getRadius(): number {\n    return Math.sqrt(this.re ** 2 + this.im ** 2);\n  }\n\n  getPhase(inRadians: boolean = true): number {\n    let phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));\n\n    if (this.re < 0 && this.im > 0) {\n      phase = Math.PI - phase;\n    } else if (this.re < 0 && this.im < 0) {\n      phase = -(Math.PI - phase);\n    } else if (this.re > 0 && this.im < 0) {\n      phase = -phase;\n    } else if (this.re === 0 && this.im > 0) {\n      phase = Math.PI / 2;\n    } else if (this.re === 0 && this.im < 0) {\n      phase = -Math.PI / 2;\n    } else if (this.re < 0 && this.im === 0) {\n      phase = Math.PI;\n    } else if (this.re > 0 && this.im === 0) {\n      phase = 0;\n    } else if (this.re === 0 && this.im === 0) {\n      phase = 0;\n    }\n\n    if (!inRadians) {\n      phase = this.radianToDegree(phase);\n    }\n\n    return phase;\n  }\n\n  getPolarForm(inRadians: boolean = true): { radius: number; phase: number } {\n    return {\n      radius: this.getRadius(),\n      phase: this.getPhase(inRadians),\n    };\n  }\n\n  private radianToDegree(radian: number): number {\n    return radian * (180 / Math.PI);\n  }\n}\n",b={title:"Complex Number",description:"Complex Number",hide_table_of_contents:!0},f=void 0,x={id:"education/computer-science/algorithms/algo/complex-number",title:"Complex Number",description:"Complex Number",source:"@site/docs/education/01-computer-science/10-algorithms/04-algo/complex-number.mdx",sourceDirName:"education/01-computer-science/10-algorithms/04-algo",slug:"/education/computer-science/algorithms/algo/complex-number",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/complex-number",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/complex-number.mdx",tags:[],version:"current",frontMatter:{title:"Complex Number",description:"Complex Number",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Combinations",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/combinations"},next:{title:"Counting Sort",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/counting-sort"}},g={},C=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function N(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(t.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"definition",label:"Definition",children:(0,r.jsxs)(n.p,{children:["The Complex Number Algorithm is designed to perform arithmetic operations (addition, subtraction, multiplication, division) on complex numbers. Complex numbers consist of a real part and an imaginary part and are represented in the form a + bi, where 'a' is the real part, 'b' is the imaginary part, and 'i' is the imaginary unit (",(0,r.jsx)(n.code,{children:"\u221a-1"}),")"]})}),(0,r.jsx)(l.A,{value:"how",label:"Explanation",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Addition:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"add their real parts and imaginary parts separately"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Subtraction","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"subtract the corresponding real and imaginary parts"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Multiplication","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"use the distributive property and multiply each term of one number by each term of the other"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Division","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"multiply the numerator and denominator by the complex conjugate of the denominator, then simplify"}),"\n"]}),"\n"]}),"\n"]})}),(0,r.jsx)(l.A,{value:"guidance",label:"Guidance",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Addition","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"add the real parts of both complex numbers"}),"\n",(0,r.jsx)(n.li,{children:"add the imaginary parts of both complex numbers"}),"\n",(0,r.jsx)(n.li,{children:"combine the results to get the sum"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Subtraction","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"subtract the real part of the second complex number from the real part of the first"}),"\n",(0,r.jsx)(n.li,{children:"subtract the imaginary part of the second complex number from the imaginary part of the first"}),"\n",(0,r.jsx)(n.li,{children:"combine the results to get the difference"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Multiplication","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"multiply the real parts of both complex numbers"}),"\n",(0,r.jsx)(n.li,{children:"multiply the imaginary parts of both complex numbers"}),"\n",(0,r.jsx)(n.li,{children:"combine the results to get the product"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Division","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"find the complex conjugate of the denominator"}),"\n",(0,r.jsx)(n.li,{children:"multiply the numerator and denominator by the complex conjugate"}),"\n",(0,r.jsx)(n.li,{children:"simplify the result to obtain the quotient"}),"\n"]}),"\n"]}),"\n"]})}),(0,r.jsx)(l.A,{value:"tips",label:"Tips",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"ensure that the programming language you're using supports complex number arithmetic natively or through libraries"}),"\n",(0,r.jsx)(n.li,{children:"pay attention to handling special cases, such as division by zero or complex numbers with zero imaginary parts"}),"\n",(0,r.jsx)(n.li,{children:"use built-in functions or libraries for complex arithmetic operations to simplify implementation and improve efficiency"}),"\n"]})})]}),"\n",(0,r.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(t.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"practice",label:"Practice",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"addComplex(a, b):\n  return (a.real + b.real, a.imag + b.imag)\n\nsubtractComplex(a, b):\n  return (a.real - b.real, a.imag - b.imag)\n\nmultiplyComplex(a, b):\n  real = (a.real * b.real) - (a.imag * b.imag)\n  imag = (a.real * b.imag) + (a.imag * b.real)\n  return (real, imag)\n\ndivideComplex(a, b):\n  conjugate_b = (b.real, -b.imag)\n  numerator = multiplyComplex(a, conjugate_b)\n  denominator = multiplyComplex(b, conjugate_b)\n  return (numerator.real / denominator.real, numerator.imag / denominator.real)\n"})})}),(0,r.jsx)(l.A,{value:"solution",label:"Solution",children:(0,r.jsxs)(t.A,{queryString:"code",children:[(0,r.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(s.A,{language:"go",children:m})}),(0,r.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(s.A,{language:"java",children:d})}),(0,r.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(s.A,{language:"js",children:u})}),(0,r.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(s.A,{language:"kotlin",children:o})}),(0,r.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(s.A,{language:"python",children:h})}),(0,r.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(s.A,{language:"rust",children:p})}),(0,r.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(s.A,{language:"ts",children:c})})]})})]})]})}function v(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(N,{...e})}):N(e)}}}]);