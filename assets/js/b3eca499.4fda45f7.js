"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[1932],{8722:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>v,contentTitle:()=>g,default:()=>j,frontMatter:()=>x,metadata:()=>b,toc:()=>p});var t=s(11527),a=s(88672),h=s(29140),i=s(52360),r=s(52296);const l="package main\n\ntype BloomFilter struct {\n\tsize    int\n\tstorage []bool\n}\n\nfunc NewBloomFilter(size int) *BloomFilter {\n\treturn &BloomFilter{\n\t\tsize:    size,\n\t\tstorage: make([]bool, size),\n\t}\n}\n\nfunc (bf *BloomFilter) insert(item string) {\n\thashValues := bf.getHashValues(item)\n\tfor _, val := range hashValues {\n\t\tbf.storage[val] = true\n\t}\n}\n\nfunc (bf *BloomFilter) mayContain(item string) bool {\n\thashValues := bf.getHashValues(item)\n\tfor _, hashIndex := range hashValues {\n\t\tif !bf.storage[hashIndex] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (bf *BloomFilter) getHashValues(item string) []int {\n\treturn []int{bf.firstHash(item), bf.secondHash(item), bf.thirdHash(item)}\n}\n\nfunc (bf *BloomFilter) firstHash(item string) int {\n\thash := 0\n\tfor _, char := range item {\n\t\thash = (hash << 5) + hash + int(char)\n\t\thash &= hash\n\t\thash = abs(hash)\n\t}\n\treturn hash % bf.size\n}\n\nfunc (bf *BloomFilter) secondHash(item string) int {\n\thash := 5381\n\tfor _, char := range item {\n\t\thash = (hash << 5) + hash + int(char)\n\t}\n\treturn abs(hash) % bf.size\n}\n\nfunc (bf *BloomFilter) thirdHash(item string) int {\n\thash := 0\n\tfor _, char := range item {\n\t\thash = (hash << 5) - hash\n\t\thash += int(char)\n\t\thash &= hash\n\t}\n\treturn abs(hash) % bf.size\n}\n\nfunc abs(x int) int {\n\tif x < 0 {\n\t\treturn -x\n\t}\n\treturn x\n}\n",c="import java.util.function.IntUnaryOperator;\n\npublic class BloomFilter {\n\n  private final int size;\n  private final boolean[] storage;\n\n  public BloomFilter(int size) {\n    this.size = size;\n    this.storage = createStore(size);\n  }\n\n  public void insert(String item) {\n    int[] hashValues = getHashValues(item);\n    for (int val : hashValues) {\n      setValue(val);\n    }\n  }\n\n  public boolean mayContain(String item) {\n    int[] hashValues = getHashValues(item);\n    for (int hashIndex : hashValues) {\n      if (!getValue(hashIndex)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private boolean[] createStore(int size) {\n    boolean[] storage = new boolean[size];\n    return storage;\n  }\n\n  private void setValue(int index) {\n    storage[index] = true;\n  }\n\n  private boolean getValue(int index) {\n    return storage[index];\n  }\n\n  private int firstHash(String item) {\n    int hash = 0;\n    for (int charIndex = 0; charIndex < item.length(); charIndex++) {\n      char character = item.charAt(charIndex);\n      hash = (hash << 5) + hash + character;\n      hash &= hash;\n      hash = Math.abs(hash);\n    }\n    return hash % size;\n  }\n\n  private int secondHash(String item) {\n    int hash = 5381;\n    for (int charIndex = 0; charIndex < item.length(); charIndex++) {\n      char character = item.charAt(charIndex);\n      hash = (hash << 5) + hash + character;\n    }\n    return Math.abs(hash % size);\n  }\n\n  private int thirdHash(String item) {\n    int hash = 0;\n    for (int charIndex = 0; charIndex < item.length(); charIndex++) {\n      char character = item.charAt(charIndex);\n      hash = (hash << 5) - hash;\n      hash += character;\n      hash &= hash;\n    }\n    return Math.abs(hash % size);\n  }\n\n  private int[] getHashValues(String item) {\n    return new int[]{firstHash(item), secondHash(item), thirdHash(item)};\n  }\n}\n",o="class BloomFilter {\n  constructor(size = 100) {\n    this.size = size;\n    this.storage = this.createStore(size);\n  }\n\n  insert(item) {\n    const hashValues = this.getHashValues(item);\n    hashValues.forEach((val) => this.storage.setValue(val));\n  }\n\n  mayContain(item) {\n    const hashValues = this.getHashValues(item);\n    for (let hashIndex = 0; hashIndex < hashValues.length; hashIndex += 1) {\n      if (!this.storage.getValue(hashValues[hashIndex])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  createStore(size) {\n    const storage = [];\n    for (\n      let storageCellIndex = 0;\n      storageCellIndex < size;\n      storageCellIndex += 1\n    ) {\n      storage.push(false);\n    }\n    const storageInterface = {\n      getValue(index) {\n        return storage[index];\n      },\n      setValue(index) {\n        storage[index] = true;\n      },\n    };\n    return storageInterface;\n  }\n\n  firstHash(item) {\n    let hash = 0;\n    for (let charIndex = 0; charIndex < item.length; charIndex += 1) {\n      const char = item.charCodeAt(charIndex);\n      hash = (hash << 5) + hash + char;\n      hash &= hash;\n      hash = Math.abs(hash);\n    }\n    return hash % this.size;\n  }\n\n  secondHash(item) {\n    let hash = 5381;\n    for (let charIndex = 0; charIndex < item.length; charIndex += 1) {\n      const char = item.charCodeAt(charIndex);\n      hash = (hash << 5) + hash + char;\n    }\n    return Math.abs(hash % this.size);\n  }\n\n  thirdHash(item) {\n    let hash = 0;\n    for (let charIndex = 0; charIndex < item.length; charIndex += 1) {\n      const char = item.charCodeAt(charIndex);\n      hash = (hash << 5) - hash;\n      hash += char;\n      hash &= hash;\n    }\n    return Math.abs(hash % this.size);\n  }\n\n  getHashValues(item) {\n    return [this.firstHash(item), this.secondHash(item), this.thirdHash(item)];\n  }\n}\n",d="class BloomFilter(size: Int = 100) {\n\n    private val size: Int = size\n    private val storage: BooleanArray = createStore(size)\n\n    fun insert(item: String) {\n        val hashValues = getHashValues(item)\n        hashValues.forEach { storage[it] = true }\n    }\n\n    fun mayContain(item: String): Boolean {\n        val hashValues = getHashValues(item)\n        for (hashIndex in hashValues.indices) {\n            if (!storage[hashValues[hashIndex]]) {\n                return false\n            }\n        }\n        return true\n    }\n\n    private fun createStore(size: Int): BooleanArray {\n        return BooleanArray(size) { false }\n    }\n\n    private fun firstHash(item: String): Int {\n        var hash = 0\n        for (charIndex in item.indices) {\n            val char = item[charIndex].toInt()\n            hash = (hash shl 5) + hash + char\n            hash = hash and hash\n            hash = hash.absoluteValue\n        }\n        return hash % size\n    }\n\n    private fun secondHash(item: String): Int {\n        var hash = 5381\n        for (charIndex in item.indices) {\n            val char = item[charIndex].toInt()\n            hash = (hash shl 5) + hash + char\n        }\n        return hash.absoluteValue % size\n    }\n\n    private fun thirdHash(item: String): Int {\n        var hash = 0\n        for (charIndex in item.indices) {\n            val char = item[charIndex].toInt()\n            hash = (hash shl 5) - hash\n            hash += char\n            hash = hash and hash\n        }\n        return hash.absoluteValue % size\n    }\n\n    private fun getHashValues(item: String): IntArray {\n        return intArrayOf(firstHash(item), secondHash(item), thirdHash(item))\n    }\n}\n",u="class BloomFilter:\n    def __init__(self, size=100):\n        self.size = size\n        self.storage = self.create_store(size)\n\n    def insert(self, item):\n        hash_values = self.get_hash_values(item)\n        for val in hash_values:\n            self.storage[val] = True\n\n    def may_contain(self, item):\n        hash_values = self.get_hash_values(item)\n        for hash_index in range(len(hash_values)):\n            if not self.storage[hash_values[hash_index]]:\n                return False\n        return True\n\n    def create_store(self, size):\n        return [False] * size\n\n    def first_hash(self, item):\n        hash_val = 0\n        for char_index in range(len(item)):\n            char = ord(item[char_index])\n            hash_val = (hash_val << 5) + hash_val + char\n            hash_val &= hash_val\n            hash_val = abs(hash_val)\n        return hash_val % self.size\n\n    def second_hash(self, item):\n        hash_val = 5381\n        for char_index in range(len(item)):\n            char = ord(item[char_index])\n            hash_val = (hash_val << 5) + hash_val + char\n        return abs(hash_val % self.size)\n\n    def third_hash(self, item):\n        hash_val = 0\n        for char_index in range(len(item)):\n            char = ord(item[char_index])\n            hash_val = (hash_val << 5) - hash_val\n            hash_val += char\n            hash_val &= hash_val\n        return abs(hash_val % self.size)\n\n    def get_hash_values(self, item):\n        return [self.first_hash(item), self.second_hash(item), self.third_hash(item)]\n",m="struct BloomFilter {\n    size: usize,\n    storage: Vec<bool>,\n}\n\nimpl BloomFilter {\n    fn new(size: usize) -> Self {\n        BloomFilter {\n            size,\n            storage: vec![false; size],\n        }\n    }\n\n    fn insert(&mut self, item: &str) {\n        let hash_values = self.get_hash_values(item);\n        for val in hash_values {\n            self.storage[val] = true;\n        }\n    }\n\n    fn may_contain(&self, item: &str) -> bool {\n        let hash_values = self.get_hash_values(item);\n        for &hash_index in &hash_values {\n            if !self.storage[hash_index] {\n                return false;\n            }\n        }\n        true\n    }\n\n    fn create_store(&self) -> Vec<bool> {\n        vec![false; self.size]\n    }\n\n    fn first_hash(&self, item: &str) -> usize {\n        let mut hash = 0;\n        for char in item.chars() {\n            let char_code = char as usize;\n            hash = (hash << 5) + hash + char_code;\n            hash &= hash;\n            hash = hash.abs();\n        }\n        hash % self.size\n    }\n\n    fn second_hash(&self, item: &str) -> usize {\n        let mut hash = 5381;\n        for char in item.chars() {\n            let char_code = char as usize;\n            hash = (hash << 5) + hash + char_code;\n        }\n        hash.abs() % self.size\n    }\n\n    fn third_hash(&self, item: &str) -> usize {\n        let mut hash = 0;\n        for char in item.chars() {\n            let char_code = char as usize;\n            hash = (hash << 5) - hash;\n            hash += char_code;\n            hash &= hash;\n        }\n        hash.abs() % self.size\n    }\n\n    fn get_hash_values(&self, item: &str) -> Vec<usize> {\n        vec![\n            self.first_hash(item),\n            self.second_hash(item),\n            self.third_hash(item),\n        ]\n    }\n}\n",f="class BloomFilter {\n  private size: number;\n  private storage: { [index: number]: boolean };\n\n  constructor(size: number = 100) {\n    this.size = size;\n    this.storage = this.createStore(size);\n  }\n\n  insert(item: string): void {\n    const hashValues = this.getHashValues(item);\n    hashValues.forEach((val) => {\n      this.storage[val] = true;\n    });\n  }\n\n  mayContain(item: string): boolean {\n    const hashValues = this.getHashValues(item);\n    for (let hashIndex = 0; hashIndex < hashValues.length; hashIndex += 1) {\n      if (!this.storage[hashValues[hashIndex]]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private createStore(size: number): { [index: number]: boolean } {\n    const storage: { [index: number]: boolean } = {};\n    for (\n      let storageCellIndex = 0;\n      storageCellIndex < size;\n      storageCellIndex += 1\n    ) {\n      storage[storageCellIndex] = false;\n    }\n    return storage;\n  }\n\n  private firstHash(item: string): number {\n    let hash = 0;\n    for (let charIndex = 0; charIndex < item.length; charIndex += 1) {\n      const char = item.charCodeAt(charIndex);\n      hash = (hash << 5) + hash + char;\n      hash &= hash;\n      hash = Math.abs(hash);\n    }\n    return hash % this.size;\n  }\n\n  private secondHash(item: string): number {\n    let hash = 5381;\n    for (let charIndex = 0; charIndex < item.length; charIndex += 1) {\n      const char = item.charCodeAt(charIndex);\n      hash = (hash << 5) + hash + char;\n    }\n    return Math.abs(hash % this.size);\n  }\n\n  private thirdHash(item: string): number {\n    let hash = 0;\n    for (let charIndex = 0; charIndex < item.length; charIndex += 1) {\n      const char = item.charCodeAt(charIndex);\n      hash = (hash << 5) - hash;\n      hash += char;\n      hash &= hash;\n    }\n    return Math.abs(hash % this.size);\n  }\n\n  private getHashValues(item: string): number[] {\n    return [this.firstHash(item), this.secondHash(item), this.thirdHash(item)];\n  }\n}\n",x={title:"Bloom Filter",description:"Bloom Filter Data Structure",hide_table_of_contents:!0},g=void 0,b={id:"education/computer-science/data-structures/basic/bloom-filter",title:"Bloom Filter",description:"Bloom Filter Data Structure",source:"@site/docs/education/01-computer-science/09-data-structures/02-basic/19-bloom-filter.mdx",sourceDirName:"education/01-computer-science/09-data-structures/02-basic",slug:"/education/computer-science/data-structures/basic/bloom-filter",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/bloom-filter",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/19-bloom-filter.mdx",tags:[],version:"current",sidebarPosition:19,frontMatter:{title:"Bloom Filter",description:"Bloom Filter Data Structure",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Disjoint Set",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/disjoint-set"},next:{title:"LRU Cache",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/lru-cache"}},v={},p=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function _(e){const n={admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:s(5484).Z+""})}),"\n",(0,t.jsxs)("table",{children:[(0,t.jsxs)("thead",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Space"}),(0,t.jsx)("th",{colspan:"4",children:"Time"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{}),(0,t.jsx)("th",{children:"Access"}),(0,t.jsx)("th",{children:"Lookup"}),(0,t.jsx)("th",{children:"Insertion"}),(0,t.jsx)("th",{children:"Deletion"})]})]}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"fair",children:"O(n)"})}),(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,t.jsx)("td",{children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)("code",{className:"fair",children:"O(k)"})," ",(0,t.jsx)("br",{})," \u2022 ",(0,t.jsx)(n.code,{children:"k"})," number of the hash\nfunction implemented"]})}),(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"fair",children:"O(k)"})}),(0,t.jsx)("td",{children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)("code",{className:"na",children:"N/A"}),"\n",(0,t.jsx)("br",{})," \u2022 not supported"]})})]})})]}),"\n",(0,t.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,t.jsxs)(h.Z,{children:[(0,t.jsxs)(i.Z,{value:"short",label:"Short",children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Bloom Filter"})," is a space-efficient probabilistic data structure that is used to test whether an element is a member of a set."]}),(0,t.jsx)(n.admonition,{title:"Simplified",type:"note",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Bloom Filter"}),' is like a super-efficient memory that can quickly check if an item is in a set. It can say "probably yes" or "definitely no". The "probably yes" can sometimes be wrong, but\n"definitely no" is always right. For example, your browser uses it to check if a URL is safe.']})})]}),(0,t.jsxs)(i.Z,{value:"detailed",label:"Detailed",children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Bloom Filter"})," (invented by Burton Howard ",(0,t.jsx)(n.strong,{children:"Bloom"}),") is a fast, memory-efficient data structure that checks if an element is in a set. It can return false positives but never false negatives.\nIt's useful when conventional hashing would require too much memory."]}),(0,t.jsxs)(n.p,{children:["The filter is a bit array of ",(0,t.jsx)(n.code,{children:"m"})," bits, all set to 0 initially. It uses ",(0,t.jsx)(n.code,{children:"k"})," hash functions that map an element to one of the ",(0,t.jsx)(n.code,{children:"m"})," array positions. The choice of ",(0,t.jsx)(n.code,{children:"k"})," and ",(0,t.jsx)(n.code,{children:"m"})," depends on the desired\nfalse positive rate."]}),(0,t.jsx)(n.p,{children:"The filter supports two operations: insertion and search. Deletion isn't possible. When inserting, the hash functions create indexes and set the corresponding bits to true. When searching, if all\nhashed indexes are true, the element might be in the set. If any index is false, the element is definitely not in the set."}),(0,t.jsx)(n.p,{children:"False positive probability depends on the filter size, number of hash functions, and number of inserted items."}),(0,t.jsx)(n.p,{children:"It's calculated as:"}),(0,t.jsxs)(n.p,{children:["(1-e",(0,t.jsx)("sup",{children:"-kn/m"}),")",(0,t.jsx)("sup",{children:"k"})]}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"k"})," is the number of hash functions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"m"})," is the filter size"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"n"})," is the number of items inserted"]}),"\n"]}),(0,t.jsx)(n.p,{children:"These parameters should be chosen based on the acceptable false positive rate."})]})]}),"\n",(0,t.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,t.jsxs)(h.Z,{children:[(0,t.jsx)(i.Z,{value:"practice",label:"Practice",children:(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Aspect"}),(0,t.jsx)("th",{children:"Pseudo Code"})]})}),(0,t.jsxs)("tbody",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"Insertion"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"insert(item):\n  hash_values = get_hash_values(item)\n  for each val in hash_values:\n    storage.setValue(val)\n\nget_hash_values(item):\n  return [hash_function]\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"May Contain"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"may_contain(item):\n  hash_values = get_hash_values(item)\n  for hash_index from 0 to length(hash_values) - 1:\n    if storage.get_value(hash_values[hash_index]) != \xf8:\n      return False\n  return True\n\nget_hash_values(item):\n  return [hash_function]\n"})})})]})]})]})}),(0,t.jsx)(i.Z,{value:"solution",label:"Solution",children:(0,t.jsxs)(h.Z,{queryString:"code",children:[(0,t.jsx)(i.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,t.jsx)(r.Z,{language:"go",children:l})}),(0,t.jsx)(i.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,t.jsx)(r.Z,{language:"java",children:c})}),(0,t.jsx)(i.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,t.jsx)(r.Z,{language:"js",children:o})}),(0,t.jsx)(i.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,t.jsx)(r.Z,{language:"kotlin",children:d})}),(0,t.jsx)(i.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,t.jsx)(r.Z,{language:"python",children:u})}),(0,t.jsx)(i.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,t.jsx)(r.Z,{language:"rust",children:m})}),(0,t.jsx)(i.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,t.jsx)(r.Z,{language:"ts",children:f})})]})})]})]})}function j(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(_,{...e})}):_(e)}},5484:(e,n,s)=>{s.d(n,{Z:()=>t});const t=s.p+"assets/images/bloomFilter-9a7210c4b2d721ed5be57513b9af9651.svg"}}]);