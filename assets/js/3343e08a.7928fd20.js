"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[9380],{38497:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>m,contentTitle:()=>v,default:()=>x,frontMatter:()=>k,metadata:()=>i,toc:()=>b});const i=JSON.parse('{"id":"education/computer-science/algorithms/algo/depth-first-search","title":"Depth-First Search (DFS)","description":"Depth-First Search (DFS)","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/depth-first-search.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/depth-first-search","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/depth-first-search","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/depth-first-search.mdx","tags":[],"version":"current","frontMatter":{"title":"Depth-First Search (DFS)","description":"Depth-First Search (DFS)","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Counting Sort","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/counting-sort"},"next":{"title":"Detect Graph Cycle","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/detect-graph-cycle"}}');var s=t(86070),r=t(15658),a=t(33407),o=t(33903),l=t(68171);const c='package main\n\nimport (\n\t"container/list"\n)\n\n// Graph DFS\nfunc DFS(graph [][]int, start int) {\n\tvisited := make([]bool, len(graph))\n\tstack := list.New()\n\tstack.PushBack(start)\n\n\tfor stack.Len() > 0 {\n\t\telement := stack.Back()\n\t\tstack.Remove(element)\n\t\tnode := element.Value.(int)\n\t\tif !visited[node] {\n\t\t\tvisited[node] = true\n\t\t\tfmt.Printf("%d ", node)\n\n\t\t\tfor _, neighbor := range graph[node] {\n\t\t\t\tif !visited[neighbor] {\n\t\t\t\t\tstack.PushBack(neighbor)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Binary Tree DFS\ntype TreeNode struct {\n\tVal   int\n\tLeft  *TreeNode\n\tRight *TreeNode\n}\n\nfunc DFSBinaryTree(root *TreeNode) {\n\tif root == nil {\n\t\treturn\n\t}\n\tstack := list.New()\n\tstack.PushBack(root)\n\n\tfor stack.Len() > 0 {\n\t\telement := stack.Back()\n\t\tstack.Remove(element)\n\t\tnode := element.Value.(*TreeNode)\n\t\tfmt.Printf("%d ", node.Val)\n\n\t\tif node.Right != nil {\n\t\t\tstack.PushBack(node.Right)\n\t\t}\n\t\tif node.Left != nil {\n\t\t\tstack.PushBack(node.Left)\n\t\t}\n\t}\n}\n',d='import java.util.*;\n\n// Graph DFS\nclass Graph {\n\n  void DFS(List<List<Integer>> graph, int start) {\n    boolean[] visited = new boolean[graph.size()];\n    Stack<Integer> stack = new Stack<>();\n    stack.push(start);\n\n    while (!stack.isEmpty()) {\n      int node = stack.pop();\n      if (!visited[node]) {\n        visited[node] = true;\n        System.out.print(node + " ");\n\n        for (int neighbor : graph.get(node)) {\n          if (!visited[neighbor]) {\n            stack.push(neighbor);\n          }\n        }\n      }\n    }\n  }\n}\n\n// Binary Tree DFS\nclass BinaryTree {\n\n  void dfs(TreeNode root) {\n    if (root == null) {\n      return;\n    }\n    Stack<TreeNode> stack = new Stack<>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n      TreeNode node = stack.pop();\n      System.out.print(node.val + " ");\n\n      if (node.right != null) {\n        stack.push(node.right);\n      }\n      if (node.left != null) {\n        stack.push(node.left);\n      }\n    }\n  }\n\n  static class TreeNode {\n\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n}\n',h='// Graph DFS\nfunction DFS(graph, start) {\n  let visited = new Array(graph.length).fill(false);\n  let stack = [];\n  stack.push(start);\n\n  while (stack.length > 0) {\n    let node = stack.pop();\n    if (!visited[node]) {\n      visited[node] = true;\n      process.stdout.write(node + " ");\n\n      for (let neighbor of graph[node]) {\n        if (!visited[neighbor]) {\n          stack.push(neighbor);\n        }\n      }\n    }\n  }\n}\n\n// Binary Tree DFS\nclass TreeNode {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction DFSBinaryTree(root) {\n  if (root === null) {\n    return;\n  }\n  let stack = [];\n  stack.push(root);\n\n  while (stack.length > 0) {\n    let node = stack.pop();\n    process.stdout.write(node.val + " ");\n\n    if (node.right !== null) {\n      stack.push(node.right);\n    }\n    if (node.left !== null) {\n      stack.push(node.left);\n    }\n  }\n}\n',p='import java.util.*\n\n// Graph DFS\nfun DFS(graph: List<List<Int>>, start: Int) {\n    val visited = BooleanArray(graph.size)\n    val stack = Stack<Int>()\n    stack.push(start)\n\n    while (!stack.isEmpty()) {\n        val node = stack.pop()\n        if (!visited[node]) {\n            visited[node] = true\n            print("$node ")\n\n            for (neighbor in graph[node]) {\n                if (!visited[neighbor]) {\n                    stack.push(neighbor)\n                }\n            }\n        }\n    }\n}\n\n// Binary Tree DFS\nclass DepthFirstSearch {\n\n    fun dfs(root: TreeNode?) {\n        if (root == null) {\n            return\n        }\n        val stack = Stack<TreeNode>()\n        stack.push(root)\n\n        while (!stack.isEmpty()) {\n            val node = stack.pop()\n            print("${node.`val`} ")\n\n            if (node.right != null) {\n                stack.push(node.right)\n            }\n            if (node.left != null) {\n                stack.push(node.left)\n            }\n        }\n    }\n\n    class TreeNode(var `val`: Int) {\n        var left: TreeNode? = null\n        var right: TreeNode? = null\n    }\n}\n',u='# Graph DFS\ndef dfs_graph(graph, start):\n    visited = [False] * len(graph)\n    stack = []\n    stack.append(start)\n\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            visited[node] = True\n            print(node, end=" ")\n\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    stack.append(neighbor)\n\n# Binary Tree DFS\nclass TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef dfs_binary_tree(root):\n    if not root:\n        return\n    stack = []\n    stack.append(root)\n\n    while stack:\n        node = stack.pop()\n        print(node.val, end=" ")\n\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n',g='use std::collections::VecDeque;\n\n// Graph DFS\nfn dfs(graph: &Vec<Vec<usize>>, start: usize) {\n    let mut visited = vec![false; graph.len()];\n    let mut stack = Vec::new();\n    stack.push(start);\n\n    while let Some(node) = stack.pop() {\n        if !visited[node] {\n            visited[node] = true;\n            print!("{} ", node);\n\n            for &neighbor in &graph[node] {\n                if !visited[neighbor] {\n                    stack.push(neighbor);\n                }\n            }\n        }\n    }\n}\n\n// Binary Tree DFS\nstruct TreeNode {\n    val: i32,\n    left: Option<Box<TreeNode>>,\n    right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn dfs_binary_tree(root: Option<Box<TreeNode>>) {\n    let mut stack = Vec::new();\n    stack.push(root);\n\n    while let Some(mut node) = stack.pop() {\n        if let Some(n) = node.as_ref() {\n            print!("{} ", n.val);\n\n            if let Some(right) = &n.right {\n                stack.push(Some(right.clone()));\n            }\n            if let Some(left) = &n.left {\n                stack.push(Some(left.clone()));\n            }\n        }\n    }\n}\n',f="// Graph DFS\nfunction DFS(graph: number[][], start: number): void {\n  const visited: boolean[] = new Array(graph.length).fill(false);\n  const stack: number[] = [];\n  stack.push(start);\n\n  while (stack.length > 0) {\n    const node: number = stack.pop()!;\n    if (!visited[node]) {\n      visited[node] = true;\n      process.stdout.write(`${node} `);\n\n      for (const neighbor of graph[node]) {\n        if (!visited[neighbor]) {\n          stack.push(neighbor);\n        }\n      }\n    }\n  }\n}\n\n// Binary Tree DFS\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n\n  constructor(val: number) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction DFSBinaryTree(root: TreeNode | null): void {\n  if (!root) {\n    return;\n  }\n  const stack: (TreeNode | null)[] = [];\n  stack.push(root);\n\n  while (stack.length > 0) {\n    const node: TreeNode | null = stack.pop()!;\n    if (node !== null) {\n      process.stdout.write(`${node.val} `);\n\n      if (node.right !== null) {\n        stack.push(node.right);\n      }\n      if (node.left !== null) {\n        stack.push(node.left);\n      }\n    }\n  }\n}\n",k={title:"Depth-First Search (DFS)",description:"Depth-First Search (DFS)",hide_table_of_contents:!0},v=void 0,m={},b=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function S(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,s.jsxs)(a.A,{queryString:"primary",children:[(0,s.jsx)(o.A,{value:"definition",label:"Definition",children:(0,s.jsx)(e.p,{children:"Depth-First Search (DFS) is a fundamental graph traversal algorithm used to explore nodes and edges of a graph. It starts at a chosen node and explores as far as possible along each branch before backtracking"})}),(0,s.jsx)(o.A,{value:"how",label:"Explanation",children:(0,s.jsx)(e.p,{children:"Begin from a chosen node in the graph. Proceed by exploring each branch extensively before returning back. Keep track of visited nodes to prevent revisiting them"})}),(0,s.jsx)(o.A,{value:"guidance",label:"Guidance",children:(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Choose a starting node"}),"\n",(0,s.jsx)(e.li,{children:"Visit the node and mark it as visited"}),"\n",(0,s.jsxs)(e.li,{children:["Explore one of its neighbors","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"if the neighbor has unvisited neighbors, explore another neighbor"}),"\n",(0,s.jsx)(e.li,{children:"if all neighbors are visited, backtrack to the previous node"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.li,{children:"Repeat steps until all nodes are visited"}),"\n"]})}),(0,s.jsx)(o.A,{value:"tips",label:"Tips",children:(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"use a stack or recursion for implementation"}),"\n",(0,s.jsx)(e.li,{children:"be cautious of infinite loops in cyclic graphs"}),"\n",(0,s.jsx)(e.li,{children:"optimize memory usage by marking visited nodes appropriately"}),"\n"]})})]}),"\n",(0,s.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,s.jsxs)(a.A,{queryString:"primary",children:[(0,s.jsx)(o.A,{value:"practice",label:"Practice",children:(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"DFS(graph, start_node):\n  initialize an empty stack\n  push start_node onto the stack\n  initialize an empty set to keep track of visited nodes\n\n  while stack is not empty:\n    current_node = pop from stack\n    if current_node is not visited:\n      mark current_node as visited\n      visit current_node\n\n      for each neighbor in graph[current_node]:\n        if neighbor is not visited:\n          push neighbor onto stack\n"})})}),(0,s.jsx)(o.A,{value:"solution",label:"Solution",children:(0,s.jsxs)(a.A,{queryString:"code",children:[(0,s.jsx)(o.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,s.jsx)(l.A,{language:"go",children:c})}),(0,s.jsx)(o.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,s.jsx)(l.A,{language:"java",children:d})}),(0,s.jsx)(o.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,s.jsx)(l.A,{language:"js",children:h})}),(0,s.jsx)(o.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,s.jsx)(l.A,{language:"kotlin",children:p})}),(0,s.jsx)(o.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,s.jsx)(l.A,{language:"python",children:u})}),(0,s.jsx)(o.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,s.jsx)(l.A,{language:"rust",children:g})}),(0,s.jsx)(o.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,s.jsx)(l.A,{language:"ts",children:f})})]})})]})]})}function x(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(S,{...n})}):S(n)}}}]);