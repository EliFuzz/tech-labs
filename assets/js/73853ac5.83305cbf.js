"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[4122],{99335:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>b,contentTitle:()=>v,default:()=>B,frontMatter:()=>f,metadata:()=>q,toc:()=>m});var i=t(11527),r=t(84135),o=t(40521),s=t(74109),a=t(80035);const u='// Graph BFS\nfunc BFS(graph [][]int, start int) {\n    visited := make([]bool, len(graph))\n    queue := []int{start}\n    visited[start] = true\n\n    for len(queue) > 0 {\n        node := queue[0]\n        queue = queue[1:]\n        fmt.Print(node, " ")\n\n        for _, neighbor := range graph[node] {\n            if !visited[neighbor] {\n                visited[neighbor] = true\n                queue = append(queue, neighbor)\n            }\n        }\n    }\n}\n\n// Binary Tree BFS\ntype TreeNode struct {\n    Val   int\n    Left  *TreeNode\n    Right *TreeNode\n}\n\nfunc BFS(root *TreeNode) {\n    if root == nil {\n        return\n    }\n    queue := []*TreeNode{root}\n\n    for len(queue) > 0 {\n        node := queue[0]\n        queue = queue[1:]\n        fmt.Print(node.Val, " ")\n\n        if node.Left != nil {\n            queue = append(queue, node.Left)\n        }\n        if node.Right != nil {\n            queue = append(queue, node.Right)\n        }\n    }\n}\n',l='import java.util.*;\n\n// Graph BFS\nclass Graph {\n\n  void BFS(List<List<Integer>> graph, int start) {\n    boolean[] visited = new boolean[graph.size()];\n    Queue<Integer> queue = new LinkedList<>();\n    queue.add(start);\n    visited[start] = true;\n\n    while (!queue.isEmpty()) {\n      int node = queue.poll();\n      System.out.print(node + " ");\n\n      for (int neighbor : graph.get(node)) {\n        if (!visited[neighbor]) {\n          visited[neighbor] = true;\n          queue.add(neighbor);\n        }\n      }\n    }\n  }\n}\n\n// Binary Tree BFS\nclass BinaryTree {\n\n  void BFS(TreeNode root) {\n    if (root == null) {\n      return;\n    }\n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.add(root);\n\n    while (!queue.isEmpty()) {\n      TreeNode node = queue.poll();\n      System.out.print(node.val + " ");\n\n      if (node.left != null) {\n        queue.add(node.left);\n      }\n      if (node.right != null) {\n        queue.add(node.right);\n      }\n    }\n  }\n\n  class TreeNode {\n\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n}\n',d='// Graph BFS\nfunction BFS(graph, start) {\n  const visited = new Array(graph.length).fill(false);\n  const queue = [start];\n  visited[start] = true;\n\n  while (queue.length > 0) {\n    const node = queue.shift();\n    process.stdout.write(node + " ");\n\n    for (const neighbor of graph[node]) {\n      if (!visited[neighbor]) {\n        visited[neighbor] = true;\n        queue.push(neighbor);\n      }\n    }\n  }\n}\n\n// Binary Tree BFS\nclass TreeNode {\n  constructor(val) {\n    this.val = val;\n    this.left = this.right = null;\n  }\n}\n\nfunction BFS(root) {\n  if (!root) {\n    return;\n  }\n  const queue = [root];\n\n  while (queue.length > 0) {\n    const node = queue.shift();\n    process.stdout.write(node.val + " ");\n\n    if (node.left) {\n      queue.push(node.left);\n    }\n    if (node.right) {\n      queue.push(node.right);\n    }\n  }\n}\n',h='// Graph BFS\nfun BFS(graph: List<List<Int>>, start: Int) {\n    val visited = BooleanArray(graph.size)\n    val queue = LinkedList<Int>()\n    queue.add(start)\n    visited[start] = true\n\n    while (queue.isNotEmpty()) {\n        val node = queue.poll()\n        print("$node ")\n\n        for (neighbor in graph[node]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true\n                queue.add(neighbor)\n            }\n        }\n    }\n}\n\n// Binary Tree BFS\nclass TreeNode(var `val`: Int) {\n    var left: TreeNode? = null\n    var right: TreeNode? = null\n}\n\nfun BFS(root: TreeNode?) {\n    if (root == null) return\n    val queue = LinkedList<TreeNode>()\n    queue.add(root)\n\n    while (queue.isNotEmpty()) {\n        val node = queue.poll()\n        print("${node.`val`} ")\n\n        node.left?.let { queue.add(it) }\n        node.right?.let { queue.add(it) }\n    }\n}\n',c="# Graph BFS\nfrom collections import deque\n\ndef BFS(graph, start):\n    visited = [False] * len(graph)\n    queue = deque([start])\n    visited[start] = True\n\n    while queue:\n        node = queue.popleft()\n        print(node, end=' ')\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n\n# Binary Tree BFS\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef BFS(root):\n    if not root:\n        return\n    queue = deque([root])\n\n    while queue:\n        node = queue.popleft()\n        print(node.val, end=' ')\n\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n",g='// Graph BFS\nuse std::collections::VecDeque;\n\nfn bfs(graph: &Vec<Vec<usize>>, start: usize) {\n    let mut visited = vec![false; graph.len()];\n    let mut queue = VecDeque::new();\n    queue.push_back(start);\n    visited[start] = true;\n\n    while let Some(node) = queue.pop_front() {\n        print!("{} ", node);\n\n        for &neighbor in &graph[node] {\n            if !visited[neighbor] {\n                visited[neighbor] = true;\n                queue.push_back(neighbor);\n            }\n        }\n    }\n}\n\n// Binary Tree BFS\n#[derive(Debug)]\nstruct TreeNode {\n    val: i32,\n    left: Option<Box<TreeNode>>,\n    right: Option<Box<TreeNode>>,\n}\n\nimpl TreeNode {\n    fn new(val: i32) -> Self {\n        TreeNode { val, left: None, right: None }\n    }\n}\n\nfn bfs(root: Option<Box<TreeNode>>) {\n    if let Some(mut node) = root {\n        let mut queue = VecDeque::new();\n        queue.push_back(&mut node);\n\n        while let Some(cur) = queue.pop_front() {\n            print!("{} ", cur.val);\n\n            if let Some(left) = &mut cur.left {\n                queue.push_back(left);\n            }\n            if let Some(right) = &mut cur.right {\n                queue.push_back(right);\n            }\n        }\n    }\n}\n',p='// Graph BFS\nfunction BFS(graph: number[][], start: number): void {\n  const visited: boolean[] = new Array(graph.length).fill(false);\n  const queue: number[] = [start];\n  visited[start] = true;\n\n  while (queue.length > 0) {\n    const node: number = queue.shift()!;\n    process.stdout.write(node + " ");\n\n    for (const neighbor of graph[node]) {\n      if (!visited[neighbor]) {\n        visited[neighbor] = true;\n        queue.push(neighbor);\n      }\n    }\n  }\n}\n\n// Binary Tree BFS\nclass TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n\n  constructor(val: number) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nfunction BFS(root: TreeNode | null): void {\n  if (!root) return;\n  const queue: TreeNode[] = [root];\n\n  while (queue.length > 0) {\n    const node: TreeNode = queue.shift()!;\n    process.stdout.write(node.val + " ");\n\n    if (node.left) queue.push(node.left);\n    if (node.right) queue.push(node.right);\n  }\n}\n',f={title:"Breadth-First Search (BFS)",description:"Breadth-First Search (BFS)",hide_table_of_contents:!0},v=void 0,q={id:"education/computer-science/algorithms/algo/breadth-first-search",title:"Breadth-First Search (BFS)",description:"Breadth-First Search (BFS)",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/breadth-first-search.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/breadth-first-search",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/breadth-first-search",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/breadth-first-search.mdx",tags:[],version:"current",frontMatter:{title:"Breadth-First Search (BFS)",description:"Breadth-First Search (BFS)",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Bit Manipulation",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/bit-manipulation"},next:{title:"Bridges",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/bridges"}},b={},m=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function x(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(o.Z,{children:[(0,i.jsx)(s.Z,{value:"definition",label:"Definition",children:(0,i.jsx)(n.p,{children:"Breadth-First Search (BFS) is a graph traversal algorithm that explores all the neighbor nodes at the present depth before moving on to the nodes at the next depth level. It operates on a data structure called a queue, enabling it to visit nodes in a level-by-level manner"})}),(0,i.jsx)(s.Z,{value:"how",label:"Explanation",children:(0,i.jsx)(n.p,{children:"Breadth-First Search (BFS) begins from a chosen node, typically known as the root node, within a graph. It systematically explores all neighbor nodes at the current depth level before proceeding to nodes at deeper levels. Utilizing a queue, BFS manages the nodes awaiting exploration, initially adding the starting node to the queue. While the queue remains populated, BFS dequeues a node and examines its adjacent nodes. To prevent revisiting nodes and cycles, BFS marks each explored node as visited. This exploration process persists until the queue exhausts its contents"})}),(0,i.jsx)(s.Z,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"enqueue the starting node onto a queue"}),"\n",(0,i.jsx)(n.li,{children:"mark the starting node as visited"}),"\n",(0,i.jsxs)(n.li,{children:["while the queue is not empty","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"dequeue a node from the queue"}),"\n",(0,i.jsx)(n.li,{children:"visit the dequeued node and process it as needed"}),"\n",(0,i.jsx)(n.li,{children:"enqueue all of its unvisited neighbors onto the queue"}),"\n",(0,i.jsx)(n.li,{children:"mark each visited neighbor as visited"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:"continue this process until the queue becomes empty"}),"\n"]})}),(0,i.jsx)(s.Z,{value:"tips",label:"Tips",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"utilize a data structure like a queue to maintain the order of nodes to be visited"}),"\n",(0,i.jsx)(n.li,{children:"ensure efficient marking of visited nodes to avoid unnecessary revisits"}),"\n",(0,i.jsx)(n.li,{children:"BFS is particularly useful for finding the shortest path in unweighted graphs"}),"\n",(0,i.jsx)(n.li,{children:"it's ideal for finding connected components and checking if a graph is bipartite"}),"\n"]})})]}),"\n",(0,i.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(o.Z,{children:[(0,i.jsx)(s.Z,{value:"practice",label:"Practice",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"BFS(graph, start_node):\n  initialize an empty queue\n  enqueue start_node onto the queue\n  mark start_node as visited\n\n  while queue is not empty:\n    current_node = dequeue from queue\n    process current_node\n\n    for each neighbor_node of current_node:\n      if neighbor_node is not visited:\n        mark neighbor_node as visited\n        enqueue neighbor_node onto queue\n"})})}),(0,i.jsx)(s.Z,{value:"solution",label:"Solution",children:(0,i.jsxs)(o.Z,{queryString:"code",children:[(0,i.jsx)(s.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(a.Z,{language:"go",children:u})}),(0,i.jsx)(s.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(a.Z,{language:"java",children:l})}),(0,i.jsx)(s.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(a.Z,{language:"js",children:d})}),(0,i.jsx)(s.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(a.Z,{language:"kotlin",children:h})}),(0,i.jsx)(s.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(a.Z,{language:"python",children:c})}),(0,i.jsx)(s.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(a.Z,{language:"rust",children:g})}),(0,i.jsx)(s.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(a.Z,{language:"ts",children:p})})]})})]})]})}function B(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(x,{...e})}):x(e)}}}]);