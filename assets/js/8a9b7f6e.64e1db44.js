"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[6859],{10521:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>b,contentTitle:()=>v,default:()=>y,frontMatter:()=>g,metadata:()=>t,toc:()=>x});const t=JSON.parse('{"id":"education/computer-science/algorithms/algo/sieve-of-eratosthenes","title":"Sieve of Eratosthenes","description":"Sieve of Eratosthenes","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/sieve-of-eratosthenes.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/sieve-of-eratosthenes","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/sieve-of-eratosthenes","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/sieve-of-eratosthenes.mdx","tags":[],"version":"current","frontMatter":{"title":"Sieve of Eratosthenes","description":"Sieve of Eratosthenes","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Shortest Common Supersequence (SCS)","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/shortest-common-supersequence"},"next":{"title":"Square Root - Newton\'s method","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/square-root-newtons-method"}}');var r=i(86070),s=i(15658),a=i(52421),l=i(74610),o=i(42953);const p="package main\n\nfunc sieveOfEratosthenes(n int) []int {\n    primes := make([]bool, n+1)\n    var result []int\n\n    for i := 2; i <= n; i++ {\n        primes[i] = true\n    }\n\n    for p := 2; p*p <= n; p++ {\n        if primes[p] == true {\n            for i := p * p; i <= n; i += p {\n                primes[i] = false\n            }\n        }\n    }\n\n    for p := 2; p <= n; p++ {\n        if primes[p] {\n            result = append(result, p)\n        }\n    }\n\n    return result\n}\n",u="import java.util.ArrayList;\nimport java.util.List;\n\npublic class SieveOfEratosthenes {\n\n  public static List<Integer> sieveOfEratosthenes(int n) {\n    boolean[] primes = new boolean[n + 1];\n    List<Integer> result = new ArrayList<>();\n\n    for (int i = 2; i <= n; i++) {\n      primes[i] = true;\n    }\n\n    for (int p = 2; p * p <= n; p++) {\n      if (primes[p]) {\n        for (int i = p * p; i <= n; i += p) {\n          primes[i] = false;\n        }\n      }\n    }\n\n    for (int p = 2; p <= n; p++) {\n      if (primes[p]) {\n        result.add(p);\n      }\n    }\n\n    return result;\n  }\n}\n",c="function sieveOfEratosthenes(n) {\n  const primes = new Array(n + 1).fill(true);\n  const result = [];\n\n  for (let p = 2; p * p <= n; p++) {\n    if (primes[p]) {\n      for (let i = p * p; i <= n; i += p) {\n        primes[i] = false;\n      }\n    }\n  }\n\n  for (let p = 2; p <= n; p++) {\n    if (primes[p]) {\n      result.push(p);\n    }\n  }\n\n  return result;\n}\n",m="fun sieveOfEratosthenes(n: Int): List<Int> {\n    val primes = BooleanArray(n + 1) { true }\n    val result = mutableListOf<Int>()\n\n    for (p in 2..n) {\n        if (primes[p]) {\n            for (i in p * p..n step p) {\n                primes[i] = false\n            }\n        }\n    }\n\n    for (p in 2..n) {\n        if (primes[p]) {\n            result.add(p)\n        }\n    }\n\n    return result\n}\n",h="def sieve_of_eratosthenes(n):\n    primes = [True] * (n + 1)\n    primes[0] = primes[1] = False\n    result = []\n\n    for p in range(2, int(n**0.5) + 1):\n        if primes[p]:\n            for i in range(p * p, n + 1, p):\n                primes[i] = False\n\n    for p in range(2, n + 1):\n        if primes[p]:\n            result.append(p)\n\n    return result\n",f="fn sieve_of_eratosthenes(n: usize) -> Vec<usize> {\n    let mut primes = vec![true; n + 1];\n    let mut result = Vec::new();\n\n    for p in 2..=n {\n        if primes[p] {\n            for i in (p * p..=n).step_by(p) {\n                primes[i] = false;\n            }\n        }\n    }\n\n    for p in 2..=n {\n        if primes[p] {\n            result.push(p);\n        }\n    }\n\n    result\n}\n",d="function sieveOfEratosthenes(n: number): number[] {\n  const primes: boolean[] = new Array(n + 1).fill(true);\n  const result: number[] = [];\n\n  for (let p = 2; p * p <= n; p++) {\n    if (primes[p]) {\n      for (let i = p * p; i <= n; i += p) {\n        primes[i] = false;\n      }\n    }\n  }\n\n  for (let p = 2; p <= n; p++) {\n    if (primes[p]) {\n      result.push(p);\n    }\n  }\n\n  return result;\n}\n",g={title:"Sieve of Eratosthenes",description:"Sieve of Eratosthenes",hide_table_of_contents:!0},v=void 0,b={},x=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function j(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(a.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"definition",label:"Definition",children:(0,r.jsx)(n.p,{children:"The Sieve of Eratosthenes is an efficient algorithm for finding all prime numbers up to a specified integer. It works by iteratively marking the multiples of each prime number starting from 2, which are not prime, until no more multiples can be found"})}),(0,r.jsx)(l.A,{value:"how",label:"Explanation",children:(0,r.jsx)(n.p,{children:"Begins by creating a list of consecutive integers starting from 2 up to a specified maximum value. It then repeatedly finds the smallest unmarked number in the list (which is a prime number) and marks all of its multiples as composite (not prime). This process continues until there are no more unmarked numbers left in the list. The remaining unmarked numbers are all prime"})}),(0,r.jsx)(l.A,{value:"guidance",label:"Guidance",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Create a list of consecutive integers from 2 to the maximum value"}),"\n",(0,r.jsx)(n.li,{children:"Start with the first unmarked number (2) and mark all of its multiples as composite"}),"\n",(0,r.jsx)(n.li,{children:"Find the next unmarked number (which is a prime), and repeat the process of marking its multiples as composite"}),"\n",(0,r.jsx)(n.li,{children:"Continue this process until there are no more unmarked numbers left in the list"}),"\n",(0,r.jsx)(n.li,{children:"The remaining unmarked numbers are all prime"}),"\n"]})}),(0,r.jsx)(l.A,{value:"tips",label:"Tips",children:(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"utilize a boolean array to efficiently mark numbers as prime or composite"}),"\n",(0,r.jsx)(n.li,{children:"avoid checking even numbers greater than 2 since they are not prime"}),"\n",(0,r.jsx)(n.li,{children:"optimize the algorithm by only iterating up to the square root of the maximum value to mark multiples"}),"\n"]})})]}),"\n",(0,r.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(a.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"practice",label:"Practice",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"sieve_of_eratosthenes(maxValue):\n  Let isPrime be an array of Boolean values, indexed from 0 to maxValue, initialized to true\n  isPrime[0] = false\n  isPrime[1] = false\n\n  for i from 2 to square_root(maxValue):\n    if isPrime[i] is true:\n      for j from i^2 to maxValue with step i:\n        isPrime[j] = false\n\n  primes = empty list\n  for i from 2 to maxValue:\n    if isPrime[i] is true:\n      append i to primes\n\n  return primes\n"})})}),(0,r.jsx)(l.A,{value:"solution",label:"Solution",children:(0,r.jsxs)(a.A,{queryString:"code",children:[(0,r.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(o.A,{language:"go",children:p})}),(0,r.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(o.A,{language:"java",children:u})}),(0,r.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(o.A,{language:"js",children:c})}),(0,r.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(o.A,{language:"kotlin",children:m})}),(0,r.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(o.A,{language:"python",children:h})}),(0,r.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(o.A,{language:"rust",children:f})}),(0,r.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(o.A,{language:"ts",children:d})})]})})]})]})}function y(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(j,{...e})}):j(e)}}}]);