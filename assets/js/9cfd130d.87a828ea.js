"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[4437],{98078:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>w,contentTitle:()=>u,default:()=>v,frontMatter:()=>c,metadata:()=>f,toc:()=>p});var t=i(86070),a=i(27468),r=i(20301),g=i(35379),m=i(81895);const d='package main\n\nimport (\n    "image"\n    "image/color"\n    "image/jpeg"\n    "os"\n)\n\ntype energyMatrix [][]float64\n\nfunc computeEnergy(img image.Image) energyMatrix {\n    bounds := img.Bounds()\n    width, height := bounds.Max.X, bounds.Max.Y\n\n    energy := make(energyMatrix, height)\n    for y := range energy {\n        energy[y] = make([]float64, width)\n    }\n\n    for y := 0; y < height; y++ {\n        for x := 0; x < width; x++ {\n            dx := getColorDelta(bounds, img, x-1, y, x+1, y)\n            dy := getColorDelta(bounds, img, x, y-1, x, y+1)\n            energy[y][x] = dx*dx + dy*dy\n        }\n    }\n\n    return energy\n}\n\nfunc getColorDelta(bounds image.Rectangle, img image.Image, x1, y1, x2, y2 int) float64 {\n    x1 = clamp(x1, 0, bounds.Max.X-1)\n    y1 = clamp(y1, 0, bounds.Max.Y-1)\n    x2 = clamp(x2, 0, bounds.Max.X-1)\n    y2 = clamp(y2, 0, bounds.Max.Y-1)\n\n    c1 := img.At(x1, y1)\n    r1, g1, b1, _ := c1.RGBA()\n    c2 := img.At(x2, y2)\n    r2, g2, b2, _ := c2.RGBA()\n\n    dr := float64(r1 - r2)\n    dg := float64(g1 - g2)\n    db := float64(b1 - b2)\n\n    return (dr*dr + dg*dg + db*db) / 3.0 // taking average of the color differences\n}\n\nfunc clamp(x, min, max int) int {\n    if x < min {\n        return min\n    }\n    if x > max {\n        return max\n    }\n    return x\n}\n\nfunc findVerticalSeam(energy energyMatrix) []int {\n    height, width := len(energy), len(energy[0])\n\n    distTo := make([][]float64, height)\n    edgeTo := make([][]int, height)\n    for i := range distTo {\n        distTo[i] = make([]float64, width)\n        edgeTo[i] = make([]int, width)\n    }\n\n    for y := range energy[0] {\n        distTo[0][y] = energy[0][y]\n    }\n\n    for y := 1; y < height; y++ {\n        for x := 0; x < width; x++ {\n            minIdx := x\n            minEnergy := distTo[y-1][x]\n            if x > 0 && distTo[y-1][x-1] < minEnergy {\n                minIdx = x - 1\n                minEnergy = distTo[y-1][x-1]\n            }\n            if x < width-1 && distTo[y-1][x+1] < minEnergy {\n                minIdx = x + 1\n                minEnergy = distTo[y-1][x+1]\n            }\n            distTo[y][x] = energy[y][x] + minEnergy\n            edgeTo[y][x] = minIdx\n        }\n    }\n\n    minEnergyIdx := 0\n    minEnergy := distTo[height-1][0]\n    for x := 1; x < width; x++ {\n        if distTo[height-1][x] < minEnergy {\n            minEnergy = distTo[height-1][x]\n            minEnergyIdx = x\n        }\n    }\n\n    seam := make([]int, height)\n    seam[height-1] = minEnergyIdx\n    for y := height - 2; y >= 0; y-- {\n        seam[y] = edgeTo[y+1][minEnergyIdx]\n        minEnergyIdx = seam[y]\n    }\n\n    return seam\n}\n\nfunc removeVerticalSeam(img *image.RGBA, seam []int) {\n    bounds := img.Bounds()\n    height, width := bounds.Max.Y, bounds.Max.X-1\n\n    for y := 0; y < height; y++ {\n        copy(img.Pix[y*width+y:], img.Pix[y*width+seam[y]+1:])\n    }\n\n    img.Rect.Max.X -= 1\n}\n\nfunc resizeImage(img image.Image, newWidth int) image.Image {\n    bounds := img.Bounds()\n    width := bounds.Max.X\n\n    for width > newWidth {\n        energy := computeEnergy(img)\n        seam := findVerticalSeam(energy)\n        removeVerticalSeam(img.(*image.RGBA), seam)\n        width--\n    }\n\n    return img\n}\n',s="import java.awt.Color;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic class SeamCarving {\n\n  static class EnergyMatrix {\n    double[][] energy;\n\n    public EnergyMatrix(int height, int width) {\n      energy = new double[height][width];\n    }\n  }\n\n  public static BufferedImage resizeImage(BufferedImage image, int newWidth) {\n    int width = image.getWidth();\n    int height = image.getHeight();\n\n    while (width > newWidth) {\n      EnergyMatrix energyMatrix = computeEnergy(image);\n      int[] seam = findVerticalSeam(energyMatrix);\n\n      removeVerticalSeam(image, seam);\n\n      width--;\n    }\n\n    return image;\n  }\n\n  public static EnergyMatrix computeEnergy(BufferedImage image) {\n    int width = image.getWidth();\n    int height = image.getHeight();\n    EnergyMatrix energyMatrix = new EnergyMatrix(height, width);\n\n    for (int y = 0; y < height; y++) {\n      for (int x = 0; x < width; x++) {\n        double dx = getColorDelta(image, x - 1, y, x + 1, y);\n        double dy = getColorDelta(image, x, y - 1, x, y + 1);\n        energyMatrix.energy[y][x] = dx * dx + dy * dy;\n      }\n    }\n\n    return energyMatrix;\n  }\n\n  public static double getColorDelta(BufferedImage image, int x1, int y1, int x2, int y2) {\n    x1 = clamp(x1, 0, image.getWidth() - 1);\n    y1 = clamp(y1, 0, image.getHeight() - 1);\n    x2 = clamp(x2, 0, image.getWidth() - 1);\n    y2 = clamp(y2, 0, image.getHeight() - 1);\n\n    Color c1 = new Color(image.getRGB(x1, y1));\n    Color c2 = new Color(image.getRGB(x2, y2));\n\n    double dr = c1.getRed() - c2.getRed();\n    double dg = c1.getGreen() - c2.getGreen();\n    double db = c1.getBlue() - c2.getBlue();\n\n    return (dr * dr + dg * dg + db * db) / 3.0; // Taking average of the color differences\n  }\n\n  public static int clamp(int x, int min, int max) {\n    return Math.min(Math.max(x, min), max);\n  }\n\n  public static int[] findVerticalSeam(EnergyMatrix energyMatrix) {\n    int height = energyMatrix.energy.length;\n    int width = energyMatrix.energy[0].length;\n\n    double[][] distTo = new double[height][width];\n    int[][] edgeTo = new int[height][width];\n\n    for (int y = 0; y < height; y++) {\n      for (int x = 0; x < width; x++) {\n        distTo[y][x] = y == 0 ? energyMatrix.energy[y][x] : Double.MAX_VALUE;\n      }\n    }\n\n    for (int y = 0; y < height - 1; y++) {\n      for (int x = 0; x < width; x++) {\n        if (x > 0 && distTo[y + 1][x - 1] > distTo[y][x] + energyMatrix.energy[y + 1][x - 1]) {\n          distTo[y + 1][x - 1] = distTo[y][x] + energyMatrix.energy[y + 1][x - 1];\n          edgeTo[y + 1][x - 1] = x;\n        }\n        if (distTo[y + 1][x] > distTo[y][x] + energyMatrix.energy[y + 1][x]) {\n          distTo[y + 1][x] = distTo[y][x] + energyMatrix.energy[y + 1][x];\n          edgeTo[y + 1][x] = x;\n        }\n        if (x < width - 1 && distTo[y + 1][x + 1] > distTo[y][x] + energyMatrix.energy[y + 1][x + 1]) {\n          distTo[y + 1][x + 1] = distTo[y][x] + energyMatrix.energy[y + 1][x + 1];\n          edgeTo[y + 1][x + 1] = x;\n        }\n      }\n    }\n\n    int minEnergyIdx = 0;\n    double minEnergy = distTo[height - 1][0];\n    for (int x = 1; x < width; x++) {\n      if (distTo[height - 1][x] < minEnergy) {\n        minEnergy = distTo[height - 1][x];\n        minEnergyIdx = x;\n      }\n    }\n\n    int[] seam = new int[height];\n    seam[height - 1] = minEnergyIdx;\n    for (int y = height - 2; y >= 0; y--) {\n      seam[y] = edgeTo[y + 1][minEnergyIdx];\n      minEnergyIdx = seam[y];\n    }\n\n    return seam;\n  }\n\n  public static void removeVerticalSeam(BufferedImage image, int[] seam) {\n    int width = image.getWidth();\n    int height = image.getHeight();\n\n    for (int y = 0; y < height; y++) {\n      System.arraycopy(image.getRGB(seam[y] + 1, y, width - seam[y] - 1, 1, image.getRGB(seam[y], y, 1, 1),\n          0, width - seam[y] - 1);\n    }\n    image.getRaster().setWidth(width - 1);\n  }\n}\n",o='const fs = require("fs");\nconst { createCanvas, loadImage } = require("canvas");\n\nfunction getColorDelta(imgData, width, x1, y1, x2, y2) {\n  x1 = clamp(x1, 0, width - 1);\n  y1 = clamp(y1, 0, imgData.height - 1);\n  x2 = clamp(x2, 0, width - 1);\n  y2 = clamp(y2, 0, imgData.height - 1);\n\n  const idx1 = (y1 * width + x1) * 4;\n  const idx2 = (y2 * width + x2) * 4;\n\n  const dr = imgData.data[idx1] - imgData.data[idx2];\n  const dg = imgData.data[idx1 + 1] - imgData.data[idx2 + 1];\n  const db = imgData.data[idx1 + 2] - imgData.data[idx2 + 2];\n\n  return (dr * dr + dg * dg + db * db) / 3.0; // Taking average of the color differences\n}\n\nfunction computeEnergy(imgData, width) {\n  const energy = [];\n\n  for (let y = 0; y < imgData.height; y++) {\n    energy.push([]);\n    for (let x = 0; x < width; x++) {\n      const dx = getColorDelta(imgData, width, x - 1, y, x + 1, y);\n      const dy = getColorDelta(imgData, width, x, y - 1, x, y + 1);\n      energy[y].push(dx * dx + dy * dy);\n    }\n  }\n\n  return energy;\n}\n\nfunction findVerticalSeam(energy) {\n  const height = energy.length;\n  const width = energy[0].length;\n\n  const distTo = new Array(height)\n    .fill(null)\n    .map(() => new Array(width).fill(0));\n  const edgeTo = new Array(height)\n    .fill(null)\n    .map(() => new Array(width).fill(0));\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      distTo[y][x] = y === 0 ? energy[y][x] : Infinity;\n    }\n  }\n\n  for (let y = 0; y < height - 1; y++) {\n    for (let x = 0; x < width; x++) {\n      if (x > 0 && distTo[y + 1][x - 1] > distTo[y][x] + energy[y + 1][x - 1]) {\n        distTo[y + 1][x - 1] = distTo[y][x] + energy[y + 1][x - 1];\n        edgeTo[y + 1][x - 1] = x;\n      }\n      if (distTo[y + 1][x] > distTo[y][x] + energy[y + 1][x]) {\n        distTo[y + 1][x] = distTo[y][x] + energy[y + 1][x];\n        edgeTo[y + 1][x] = x;\n      }\n      if (\n        x < width - 1 &&\n        distTo[y + 1][x + 1] > distTo[y][x] + energy[y + 1][x + 1]\n      ) {\n        distTo[y + 1][x + 1] = distTo[y][x] + energy[y + 1][x + 1];\n        edgeTo[y + 1][x + 1] = x;\n      }\n    }\n  }\n\n  let minEnergyIdx = 0;\n  let minEnergy = distTo[height - 1][0];\n  for (let x = 1; x < width; x++) {\n    if (distTo[height - 1][x] < minEnergy) {\n      minEnergy = distTo[height - 1][x];\n      minEnergyIdx = x;\n    }\n  }\n\n  const seam = new Array(height).fill(0);\n  seam[height - 1] = minEnergyIdx;\n  for (let y = height - 2; y >= 0; y--) {\n    seam[y] = edgeTo[y + 1][minEnergyIdx];\n    minEnergyIdx = seam[y];\n  }\n\n  return seam;\n}\n\nfunction removeVerticalSeam(imageData, seam, width) {\n  const height = imageData.height;\n\n  for (let y = 0; y < height; y++) {\n    const idx = (y * width + seam[y]) * 4;\n    imageData.data.copyWithin(idx, idx + 4, idx + width * 4);\n  }\n\n  imageData.width = width;\n}\n\nfunction seamCarving(imagePath, outputPath, newWidth) {\n  loadImage(imagePath)\n    .then((image) => {\n      const canvas = createCanvas(image.width, image.height);\n      const ctx = canvas.getContext("2d");\n      ctx.drawImage(image, 0, 0);\n      const imageData = ctx.getImageData(0, 0, image.width, image.height);\n\n      while (image.width > newWidth) {\n        const energy = computeEnergy(imageData, image.width);\n        const seam = findVerticalSeam(energy);\n        removeVerticalSeam(imageData, seam, image.width - 1);\n      }\n\n      canvas.width = imageData.width;\n      canvas.height = imageData.height;\n      const newCtx = canvas.getContext("2d");\n      newCtx.putImageData(imageData, 0, 0);\n\n      const out = fs.createWriteStream(outputPath);\n      const stream = canvas.createJPEGStream();\n      stream.pipe(out);\n      out.on("finish", () => console.log("Image resized successfully!"));\n    })\n    .catch((err) => console.error(err));\n}\n',y="import java.awt.Color\nimport java.awt.image.BufferedImage\nimport java.io.File\nimport javax.imageio.ImageIO\n\nclass EnergyMatrix(val energy: Array<DoubleArray>)\n\nfun resizeImage(image: BufferedImage, newWidth: Int): BufferedImage {\n    var img = image\n    var width = img.width\n    var height = img.height\n\n    while (width > newWidth) {\n        val energyMatrix = computeEnergy(img)\n        val seam = findVerticalSeam(energyMatrix)\n        img = removeVerticalSeam(img, seam)\n        width--\n    }\n\n    return img\n}\n\nfun computeEnergy(image: BufferedImage): EnergyMatrix {\n    val width = image.width\n    val height = image.height\n    val energy = Array(height) { DoubleArray(width) }\n\n    for (y in 0 until height) {\n        for (x in 0 until width) {\n            val dx = getColorDelta(image, x - 1, y, x + 1, y)\n            val dy = getColorDelta(image, x, y - 1, x, y + 1)\n            energy[y][x] = dx * dx + dy * dy\n        }\n    }\n\n    return EnergyMatrix(energy)\n}\n\nfun getColorDelta(image: BufferedImage, x1: Int, y1: Int, x2: Int, y2: Int): Double {\n    val x1Clamped = x1.coerceIn(0 until image.width)\n    val y1Clamped = y1.coerceIn(0 until image.height)\n    val x2Clamped = x2.coerceIn(0 until image.width)\n    val y2Clamped = y2.coerceIn(0 until image.height)\n\n    val c1 = Color(image.getRGB(x1Clamped, y1Clamped))\n    val c2 = Color(image.getRGB(x2Clamped, y2Clamped))\n\n    val dr = c1.red - c2.red\n    val dg = c1.green - c2.green\n    val db = c1.blue - c2.blue\n\n    return (dr * dr + dg * dg + db * db) / 3.0 // Taking average of the color differences\n}\n\nfun findVerticalSeam(energyMatrix: EnergyMatrix): IntArray {\n    val height = energyMatrix.energy.size\n    val width = energyMatrix.energy[0].size\n\n    val distTo = Array(height) { DoubleArray(width) }\n    val edgeTo = Array(height) { IntArray(width) }\n\n    for (y in 0 until height) {\n        for (x in 0 until width) {\n            distTo[y][x] = if (y == 0) energyMatrix.energy[y][x] else Double.POSITIVE_INFINITY\n        }\n    }\n\n    for (y in 0 until height - 1) {\n        for (x in 0 until width) {\n            if (x > 0 && distTo[y + 1][x - 1] > distTo[y][x] + energyMatrix.energy[y + 1][x - 1]) {\n                distTo[y + 1][x - 1] = distTo[y][x] + energyMatrix.energy[y + 1][x - 1]\n                edgeTo[y + 1][x - 1] = x\n            }\n            if (distTo[y + 1][x] > distTo[y][x] + energyMatrix.energy[y + 1][x]) {\n                distTo[y + 1][x] = distTo[y][x] + energyMatrix.energy[y + 1][x]\n                edgeTo[y + 1][x] = x\n            }\n            if (x < width - 1 && distTo[y + 1][x + 1] > distTo[y][x] + energyMatrix.energy[y + 1][x + 1]) {\n                distTo[y + 1][x + 1] = distTo[y][x] + energyMatrix.energy[y + 1][x + 1]\n                edgeTo[y + 1][x + 1] = x\n            }\n        }\n    }\n\n    var minEnergyIdx = 0\n    var minEnergy = distTo[height - 1][0]\n    for (x in 1 until width) {\n        if (distTo[height - 1][x] < minEnergy) {\n            minEnergy = distTo[height - 1][x]\n            minEnergyIdx = x\n        }\n    }\n\n    val seam = IntArray(height)\n    seam[height - 1] = minEnergyIdx\n    for (y in height - 2 downTo 0) {\n        seam[y] = edgeTo[y + 1][minEnergyIdx]\n        minEnergyIdx = seam[y]\n    }\n\n    return seam\n}\n\nfun removeVerticalSeam(image: BufferedImage, seam: IntArray): BufferedImage {\n    val width = image.width\n    val height = image.height\n    val resizedImage = BufferedImage(width - 1, height, BufferedImage.TYPE_INT_RGB)\n\n    for (y in 0 until height) {\n        var destIndex = 0\n        for (x in 0 until width) {\n            if (x != seam[y]) {\n                resizedImage.setRGB(destIndex++, y, image.getRGB(x, y))\n            }\n        }\n    }\n\n    return resizedImage\n}\n",h='import numpy as np\nfrom PIL import Image\n\ndef compute_energy(image):\n    grayscale_image = image.convert("L")\n    grayscale_array = np.array(grayscale_image)\n\n    sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]])\n    sobel_y = np.array([[-1, -2, -1], [0, 0, 0], [1, 2, 1]])\n\n    dx = signal.convolve2d(grayscale_array, sobel_x, mode="same", boundary="symm")\n    dy = signal.convolve2d(grayscale_array, sobel_y, mode="same", boundary="symm")\n\n    energy = np.sqrt(dx**2 + dy**2)\n    return energy\n\ndef find_vertical_seam(energy):\n    height, width = energy.shape\n    cumulative_energy = energy.copy()\n\n    for i in range(1, height):\n        for j in range(width):\n            if j == 0:\n                cumulative_energy[i, j] += min(cumulative_energy[i-1, j], cumulative_energy[i-1, j+1])\n            elif j == width - 1:\n                cumulative_energy[i, j] += min(cumulative_energy[i-1, j-1], cumulative_energy[i-1, j])\n            else:\n                cumulative_energy[i, j] += min(cumulative_energy[i-1, j-1], cumulative_energy[i-1, j], cumulative_energy[i-1, j+1])\n\n    seam = []\n    j = np.argmin(cumulative_energy[-1])\n    seam.append(j)\n\n    for i in range(height - 2, -1, -1):\n        if j == 0:\n            j = np.argmin(cumulative_energy[i, j:j+2])\n        elif j == width - 1:\n            j = np.argmin(cumulative_energy[i, j-1:j+1]) + j - 1\n        else:\n            j = np.argmin(cumulative_energy[i, j-1:j+2]) + j - 1\n        seam.append(j)\n\n    seam.reverse()\n    return seam\n\ndef remove_vertical_seam(image, seam):\n    height, width = image.shape[:2]\n    new_image = np.zeros((height, width - 1, 3), dtype=np.uint8)\n\n    for i in range(height):\n        j = seam[i]\n        new_image[i, :, 0] = np.delete(image[i, :, 0], j)\n        new_image[i, :, 1] = np.delete(image[i, :, 1], j)\n        new_image[i, :, 2] = np.delete(image[i, :, 2], j)\n\n    return new_image\n\ndef seam_carving(input_image_path, output_image_path, new_width):\n    image = np.array(Image.open(input_image_path))\n\n    for _ in range(image.shape[1] - new_width):\n        energy = compute_energy(Image.fromarray(image))\n        seam = find_vertical_seam(energy)\n        image = remove_vertical_seam(image, seam)\n\n    Image.fromarray(image).save(output_image_path)\n    print("Image resized successfully!")\n',l="use image::{GenericImageView, DynamicImage, ImageBuffer, Rgba};\nuse std::cmp;\n\nfn compute_energy(image: &ImageBuffer<Rgba<u8>, Vec<u8>>) -> ImageBuffer<Rgba<u8>, Vec<u8>> {\n    let width = image.width() as usize;\n    let height = image.height() as usize;\n\n    let mut energy = ImageBuffer::new(width as u32, height as u32);\n\n    for y in 0..height {\n        for x in 0..width {\n            let dx = get_color_delta(image, x.saturating_sub(1), y, x.saturating_add(1), y);\n            let dy = get_color_delta(image, x, y.saturating_sub(1), x, y.saturating_add(1));\n            let energy_val = (dx * dx + dy * dy).sqrt() as u8;\n            energy.put_pixel(x as u32, y as u32, Rgba([energy_val, energy_val, energy_val, 255]));\n        }\n    }\n\n    energy\n}\n\nfn get_color_delta(image: &ImageBuffer<Rgba<u8>, Vec<u8>>, x1: usize, y1: usize, x2: usize, y2: usize) -> f64 {\n    let x1_clamped = cmp::min(cmp::max(x1, 0), image.width() as usize - 1);\n    let y1_clamped = cmp::min(cmp::max(y1, 0), image.height() as usize - 1);\n    let x2_clamped = cmp::min(cmp::max(x2, 0), image.width() as usize - 1);\n    let y2_clamped = cmp::min(cmp::max(y2, 0), image.height() as usize - 1);\n\n    let c1 = image.get_pixel(x1_clamped as u32, y1_clamped as u32);\n    let c2 = image.get_pixel(x2_clamped as u32, y2_clamped as u32);\n\n    let dr = (c1[0] as f64 - c2[0] as f64).powi(2);\n    let dg = (c1[1] as f64 - c2[1] as f64).powi(2);\n    let db = (c1[2] as f64 - c2[2] as f64).powi(2);\n\n    (dr + dg + db) / 3.0\n}\n\nfn find_vertical_seam(energy: &ImageBuffer<Rgba<u8>, Vec<u8>>) -> Vec<usize> {\n    let width = energy.width() as usize;\n    let height = energy.height() as usize;\n    let mut dist_to = vec![vec![0.0; width]; height];\n    let mut edge_to = vec![vec![0; width]; height];\n\n    for y in 0..height {\n        for x in 0..width {\n            dist_to[y][x] = if y == 0 {\n                energy.get_pixel(x as u32, y as u32)[0] as f64\n            } else {\n                std::f64::INFINITY\n            };\n        }\n    }\n\n    for y in 0..height - 1 {\n        for x in 0..width {\n            if x > 0 && dist_to[y + 1][x - 1] > dist_to[y][x] + energy.get_pixel(x as u32, (y + 1) as u32)[0] as f64 {\n                dist_to[y + 1][x - 1] = dist_to[y][x] + energy.get_pixel(x as u32, (y + 1) as u32)[0] as f64;\n                edge_to[y + 1][x - 1] = x;\n            }\n            if dist_to[y + 1][x] > dist_to[y][x] + energy.get_pixel(x as u32, (y + 1) as u32)[0] as f64 {\n                dist_to[y + 1][x] = dist_to[y][x] + energy.get_pixel(x as u32, (y + 1) as u32)[0] as f64;\n                edge_to[y + 1][x] = x;\n            }\n            if x < width - 1 && dist_to[y + 1][x + 1] > dist_to[y][x] + energy.get_pixel(x as u32, (y + 1) as u32)[0] as f64 {\n                dist_to[y + 1][x + 1] = dist_to[y][x] + energy.get_pixel(x as u32, (y + 1) as u32)[0] as f64;\n                edge_to[y + 1][x + 1] = x;\n            }\n        }\n    }\n\n    let mut min_energy_idx = 0;\n    let mut min_energy = dist_to[height - 1][0];\n    for x in 1..width {\n        if dist_to[height - 1][x] < min_energy {\n            min_energy = dist_to[height - 1][x];\n            min_energy_idx = x;\n        }\n    }\n\n    let mut seam = Vec::with_capacity(height);\n    seam.push(min_energy_idx);\n\n    for y in (0..height - 1).rev() {\n        min_energy_idx = edge_to[y + 1][min_energy_idx];\n        seam.push(min_energy_idx);\n    }\n\n    seam.reverse();\n    seam\n}\n\nfn remove_vertical_seam(image: &mut ImageBuffer<Rgba<u8>, Vec<u8>>, seam: &[usize]) {\n    let height = image.height() as usize;\n    let width = image.width() as usize;\n    for y in 0..height {\n        let mut x = seam[y];\n        while x < width - 1 {\n            image.put_pixel(x as u32, y as u32, *image.get_pixel((x + 1) as u32, y as u32));\n            x += 1;\n        }\n    }\n    image.resize(width as u32 - 1, height as u32, image::imageops::FilterType::Lanczos3);\n}\n",x='import { createCanvas, ImageData, loadImage } from "canvas";\n\nfunction getColorDelta(\n  imageData: ImageData,\n  width: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n): number {\n  x1 = Math.min(Math.max(x1, 0), width - 1);\n  y1 = Math.min(Math.max(y1, 0), imageData.height - 1);\n  x2 = Math.min(Math.max(x2, 0), width - 1);\n  y2 = Math.min(Math.max(y2, 0), imageData.height - 1);\n\n  const idx1 = (y1 * width + x1) * 4;\n  const idx2 = (y2 * width + x2) * 4;\n\n  const dr = imageData.data[idx1] - imageData.data[idx2];\n  const dg = imageData.data[idx1 + 1] - imageData.data[idx2 + 1];\n  const db = imageData.data[idx1 + 2] - imageData.data[idx2 + 2];\n\n  return (dr * dr + dg * dg + db * db) / 3.0; // Taking average of the color differences\n}\n\nfunction computeEnergy(imageData: ImageData, width: number): number[][] {\n  const energy: number[][] = [];\n\n  for (let y = 0; y < imageData.height; y++) {\n    energy.push([]);\n    for (let x = 0; x < width; x++) {\n      const dx = getColorDelta(imageData, width, x - 1, y, x + 1, y);\n      const dy = getColorDelta(imageData, width, x, y - 1, x, y + 1);\n      energy[y].push(dx * dx + dy * dy);\n    }\n  }\n\n  return energy;\n}\n\nfunction findVerticalSeam(energy: number[][]): number[] {\n  const height = energy.length;\n  const width = energy[0].length;\n\n  const distTo: number[][] = Array.from({ length: height }, () =>\n    Array(width).fill(0),\n  );\n  const edgeTo: number[][] = Array.from({ length: height }, () =>\n    Array(width).fill(0),\n  );\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      distTo[y][x] = y === 0 ? energy[y][x] : Infinity;\n    }\n  }\n\n  for (let y = 0; y < height - 1; y++) {\n    for (let x = 0; x < width; x++) {\n      if (x > 0 && distTo[y + 1][x - 1] > distTo[y][x] + energy[y + 1][x - 1]) {\n        distTo[y + 1][x - 1] = distTo[y][x] + energy[y + 1][x - 1];\n        edgeTo[y + 1][x - 1] = x;\n      }\n      if (distTo[y + 1][x] > distTo[y][x] + energy[y + 1][x]) {\n        distTo[y + 1][x] = distTo[y][x] + energy[y + 1][x];\n        edgeTo[y + 1][x] = x;\n      }\n      if (\n        x < width - 1 &&\n        distTo[y + 1][x + 1] > distTo[y][x] + energy[y + 1][x + 1]\n      ) {\n        distTo[y + 1][x + 1] = distTo[y][x] + energy[y + 1][x + 1];\n        edgeTo[y + 1][x + 1] = x;\n      }\n    }\n  }\n\n  let minEnergyIdx = 0;\n  let minEnergy = distTo[height - 1][0];\n  for (let x = 1; x < width; x++) {\n    if (distTo[height - 1][x] < minEnergy) {\n      minEnergy = distTo[height - 1][x];\n      minEnergyIdx = x;\n    }\n  }\n\n  const seam: number[] = [];\n  seam[height - 1] = minEnergyIdx;\n  for (let y = height - 2; y >= 0; y--) {\n    seam[y] = edgeTo[y + 1][minEnergyIdx];\n    minEnergyIdx = seam[y];\n  }\n\n  return seam;\n}\n\nfunction removeVerticalSeam(imageData: ImageData, seam: number[]): ImageData {\n  const width = imageData.width;\n  const height = imageData.height;\n  const newImageData = new ImageData(width - 1, height);\n\n  for (let y = 0; y < height; y++) {\n    let destIndex = 0;\n    for (let x = 0; x < width; x++) {\n      if (x !== seam[y]) {\n        newImageData.data[destIndex++] = imageData.data[y * width * 4 + x * 4];\n        newImageData.data[destIndex++] =\n          imageData.data[y * width * 4 + x * 4 + 1];\n        newImageData.data[destIndex++] =\n          imageData.data[y * width * 4 + x * 4 + 2];\n        newImageData.data[destIndex++] =\n          imageData.data[y * width * 4 + x * 4 + 3];\n      }\n    }\n  }\n\n  return newImageData;\n}\n\nasync function seamCarving(\n  inputImagePath: string,\n  outputImagePath: string,\n  newWidth: number,\n) {\n  const image = await loadImage(inputImagePath);\n  const canvas = createCanvas(image.width, image.height);\n  const ctx = canvas.getContext("2d");\n  ctx.drawImage(image, 0, 0);\n  const imageData = ctx.getImageData(0, 0, image.width, image.height);\n\n  while (imageData.width > newWidth) {\n    const energy = computeEnergy(imageData, imageData.width);\n    const seam = findVerticalSeam(energy);\n    imageData.width -= 1;\n    imageData.data = removeVerticalSeam(imageData, seam).data;\n  }\n\n  canvas.width = imageData.width;\n  const newCtx = canvas.getContext("2d");\n  newCtx.putImageData(imageData, 0, 0);\n\n  const buffer = canvas.toBuffer("image/jpeg");\n  require("fs").writeFileSync(outputImagePath, buffer);\n  console.log("Image resized successfully!");\n}\n',c={title:"Seam Carving",description:"Seam Carving",hide_table_of_contents:!0},u=void 0,f={id:"education/computer-science/algorithms/algo/seam-carving",title:"Seam Carving",description:"Seam Carving",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/seam-carving.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/seam-carving",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/seam-carving",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/seam-carving.mdx",tags:[],version:"current",frontMatter:{title:"Seam Carving",description:"Seam Carving",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Reverse Traversal",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/reverse-traversal"},next:{title:"Selection Sort",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/selection-sort"}},w={},p=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function _(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,t.jsxs)(r.A,{queryString:"primary",children:[(0,t.jsx)(g.A,{value:"definition",label:"Definition",children:(0,t.jsx)(n.p,{children:"Seam Carving Algorithm is a content-aware image resizing technique that intelligently removes or adds pixels from an image's least noticeable areas, rather than simply scaling it. This allows for resizing without distorting important features in the image"})}),(0,t.jsx)(g.A,{value:"how",label:"Explanation",children:(0,t.jsx)(n.p,{children:"Iteratively finding and removing or adding seams, which are connected paths of pixels with the least energy in the image. Energy is a measure of pixel importance, typically calculated based on gradients or contrast. Initially, the algorithm calculates the energy of each pixel in the image. Then, it identifies the lowest-energy seam, which represents the path of pixels that contributes the least to the overall image content. This seam is removed or duplicated, depending on whether the image needs to be reduced or enlarged. This process is repeated iteratively until the desired image size is achieved"})}),(0,t.jsx)(g.A,{value:"guidance",label:"Guidance",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Calculate the energy of each pixel in the image based on gradients or other relevant measures","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"compute the cumulative minimum energy map, which represents the minimum energy path from the top to each pixel in the image"}),"\n",(0,t.jsx)(n.li,{children:"identify the seam with the lowest energy by tracing back from the bottom row of the cumulative energy map"}),"\n",(0,t.jsx)(n.li,{children:"remove or duplicate the identified seam from the image"}),"\n",(0,t.jsx)(n.li,{children:"update the energy values of the pixels affected by the removal or addition of the seam"}),"\n",(0,t.jsx)(n.li,{children:"repeat steps until the desired image size is reached"}),"\n"]}),"\n"]}),"\n"]})}),(0,t.jsx)(g.A,{value:"tips",label:"Tips",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"consider parallelization techniques for faster processing, especially for large images"}),"\n",(0,t.jsx)(n.li,{children:"experiment with different energy functions and seam removal strategies to achieve desired resizing results"}),"\n",(0,t.jsx)(n.li,{children:"handle boundary cases carefully to ensure seamless resizing without artifacts"}),"\n"]})})]}),"\n",(0,t.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,t.jsxs)(r.A,{queryString:"primary",children:[(0,t.jsx)(g.A,{value:"practice",label:"Practice",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"seam_carving(image, new_width, new_height):\n  while image.width > new_width:\n    energy_map = calculate_energy_map(image)\n    cumulative_energy_map = calculate_cumulative_energy_map(energy_map)\n    seam = find_vertical_seam(cumulative_energy_map)\n    image = remove_vertical_seam(image, seam)\n\n  while image.height > new_height:\n    energy_map = calculate_energy_map(image)\n    cumulative_energy_map = calculate_cumulative_energy_map(energy_map)\n    seam = find_horizontal_seam(cumulative_energy_map)\n    image = remove_horizontal_seam(image, seam)\n\n  return image\n\nremove_vertical_seam(image, seam):\n  new_image = create_new_image(image.width - 1, image.height)\n  for row from 0 to image.height:\n    for col from 0 to image.width:\n      if col < seam[row]:\n        new_image[row][col] = image[row][col]\n      else if col > seam[row]:\n        new_image[row][col - 1] = image[row][col]\n  return new_image\n\nremove_horizontal_seam(image, seam):\n  new_image = create_new_image(image.width, image.height - 1)\n  for col from 0 to image.width:\n    for row from 0 to image.height:\n      if row < seam[col]:\n        new_image[row][col] = image[row][col]\n      else if row > seam[col]:\n        new_image[row - 1][col] = image[row][col]\n  return new_image\n"})})}),(0,t.jsx)(g.A,{value:"solution",label:"Solution",children:(0,t.jsxs)(r.A,{queryString:"code",children:[(0,t.jsx)(g.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,t.jsx)(m.A,{language:"go",children:d})}),(0,t.jsx)(g.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,t.jsx)(m.A,{language:"java",children:s})}),(0,t.jsx)(g.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,t.jsx)(m.A,{language:"js",children:o})}),(0,t.jsx)(g.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,t.jsx)(m.A,{language:"kotlin",children:y})}),(0,t.jsx)(g.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,t.jsx)(m.A,{language:"python",children:h})}),(0,t.jsx)(g.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,t.jsx)(m.A,{language:"rust",children:l})}),(0,t.jsx)(g.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,t.jsx)(m.A,{language:"ts",children:x})})]})})]})]})}function v(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(_,{...e})}):_(e)}}}]);