"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[9590],{5580:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>m,contentTitle:()=>S,default:()=>N,frontMatter:()=>p,metadata:()=>r,toc:()=>_});const r=JSON.parse('{"id":"education/computer-science/data-structures/basic/suffix-ttree","title":"Suffix Tree","description":"Suffix Tree Data Structure","source":"@site/docs/education/01-computer-science/09-data-structures/02-basic/15-suffix-ttree.mdx","sourceDirName":"education/01-computer-science/09-data-structures/02-basic","slug":"/education/computer-science/data-structures/basic/suffix-ttree","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/suffix-ttree","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/15-suffix-ttree.mdx","tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"title":"Suffix Tree","description":"Suffix Tree Data Structure","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Binary Indexed Tree","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/binary-indexed-tree"},"next":{"title":"R-Tree","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/r-tree"}}');var i=t(86070),s=t(15658),d=t(52421),c=t(74610),l=t(42953);const o='package main\n\ntype SuffixNode struct {\n\tchildren map[rune]*SuffixNode\n\tindex    int\n}\n\ntype SuffixTree struct {\n\troot *SuffixNode\n\ttext string\n}\n\nfunc NewSuffixNode() *SuffixNode {\n\treturn &SuffixNode{\n\t\tchildren: make(map[rune]*SuffixNode),\n\t\tindex:    -1,\n\t}\n}\n\nfunc NewSuffixTree(text string) *SuffixTree {\n\ttree := &SuffixTree{\n\t\troot: NewSuffixNode(),\n\t\ttext: text,\n\t}\n\ttree.buildSuffixTree()\n\treturn tree\n}\n\nfunc (st *SuffixTree) buildSuffixTree() {\n\tn := len(st.text)\n\tfor i := 0; i < n; i++ {\n\t\tst.addSuffix(i, st.root)\n\t}\n}\n\nfunc (st *SuffixTree) addSuffix(suffixStart int, node *SuffixNode) {\n\tif suffixStart == len(st.text) {\n\t\treturn\n\t}\n\n\tcurrentChar := rune(st.text[suffixStart])\n\tif _, ok := node.children[currentChar]; !ok {\n\t\tnode.children[currentChar] = NewSuffixNode()\n\t\tnode.children[currentChar].index = suffixStart\n\t} else {\n\t\texistingNode := node.children[currentChar]\n\t\tst.addSuffix(suffixStart+1, existingNode)\n\t}\n}\n\nfunc (st *SuffixTree) Insert(newText string) {\n\tst.text += newText\n\tn := len(st.text)\n\tfor i := n - len(newText); i < n; i++ {\n\t\tst.addSuffix(i, st.root)\n\t}\n}\n\nfunc (st *SuffixTree) Search(pattern string) bool {\n\tcurrentNode := st.root\n\tn := len(pattern)\n\ti := 0\n\n\tfor i < n {\n\t\tchar := rune(pattern[i])\n\t\tif child, ok := currentNode.children[char]; ok {\n\t\t\tcurrentNode = child\n\t\t\ti++\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (st *SuffixTree) Delete(pattern string) {\n\tif st.Search(pattern) {\n\t\tst.text = st.text[:len(st.text)-1]\n\t\tst.root = NewSuffixNode()\n\t\tst.buildSuffixTree()\n\t}\n}\n\nfunc (st *SuffixTree) LongestCommonSubstring() string {\n\tresult := []int{0, 0}\n\tst.longestCommonSubstringDFS(st.root, "", &result)\n\treturn st.text[result[0]:result[1]]\n}\n\nfunc (st *SuffixTree) longestCommonSubstringDFS(node *SuffixNode, currentSuffix string, result *[]int) {\n\tif len(node.children) == 0 {\n\t\treturn\n\t}\n\n\tfor _, child := range node.children {\n\t\tnewSuffix := currentSuffix + string(st.text[child.index])\n\n\t\tif len(newSuffix) > (*result)[1]-(*result)[0] {\n\t\t\t(*result)[0] = child.index - len(newSuffix) + 1\n\t\t\t(*result)[1] = child.index + 1\n\t\t}\n\n\t\tst.longestCommonSubstringDFS(child, newSuffix, result)\n\t}\n}\n\nfunc (st *SuffixTree) SubstringCount(node *SuffixNode) int {\n\tif node == nil {\n\t\tnode = st.root\n\t}\n\n\tcount := 1\n\tfor _, child := range node.children {\n\t\tcount += st.SubstringCount(child)\n\t}\n\n\treturn count\n}\n\nfunc (st *SuffixTree) PatternMatching(pattern string, node *SuffixNode) []int {\n\tif node == nil {\n\t\tnode = st.root\n\t}\n\n\tfor i, char := range pattern {\n\t\tif child, ok := node.children[char]; ok {\n\t\t\tnode = child\n\t\t} else {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn st.getLeafIndices(node)\n}\n\nfunc (st *SuffixTree) getLeafIndices(node *SuffixNode) []int {\n\tindices := make([]int, 0)\n\tif len(node.children) == 0 {\n\t\tindices = append(indices, node.index)\n\t}\n\n\tfor _, child := range node.children {\n\t\tindices = append(indices, st.getLeafIndices(child)...)\n\t}\n\n\treturn indices\n}\n\nfunc (st *SuffixTree) Traverse(node *SuffixNode, depth int) {\n\tif node == nil {\n\t\tnode = st.root\n\t}\n\tfmt.Printf("%sNode: %d\\n", "  ", node.index)\n\tfor char, child := range node.children {\n\t\tfmt.Printf("%sEdge: %c\\n", "  ", char)\n\t\tst.Traverse(child, depth+2)\n\t}\n}\n',f='import java.util.HashMap;\nimport java.util.Map;\n\nclass SuffixNode {\n\n  Map<Character, SuffixNode> children;\n  int index;\n\n  public SuffixNode() {\n    children = new HashMap<>();\n    index = -1;\n  }\n}\n\npublic class SuffixTree {\n\n  private SuffixNode root;\n  private String text;\n\n  public SuffixTree(String text) {\n    this.root = new SuffixNode();\n    this.text = text;\n    buildSuffixTree();\n  }\n\n  private void buildSuffixTree() {\n    int n = text.length();\n    for (int i = 0; i < n; i++) {\n      addSuffix(i, root);\n    }\n  }\n\n  private void addSuffix(int suffixStart, SuffixNode node) {\n    if (suffixStart == text.length()) {\n      return;\n    }\n\n    char currentChar = text.charAt(suffixStart);\n    if (!node.children.containsKey(currentChar)) {\n      node.children.put(currentChar, new SuffixNode());\n      node.children.get(currentChar).index = suffixStart;\n    } else {\n      SuffixNode existingNode = node.children.get(currentChar);\n      addSuffix(suffixStart + 1, existingNode);\n    }\n  }\n\n  public void insert(String newText) {\n    text += newText;\n    int n = text.length();\n    for (int i = n - newText.length(); i < n; i++) {\n      addSuffix(i, root);\n    }\n  }\n\n  public boolean search(String pattern) {\n    SuffixNode currentNode = root;\n    int n = pattern.length();\n    int i = 0;\n\n    while (i < n) {\n      char currentChar = pattern.charAt(i);\n      if (currentNode.children.containsKey(currentChar)) {\n        currentNode = currentNode.children.get(currentChar);\n        i++;\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public void delete(String pattern) {\n    if (search(pattern)) {\n      text = text.replaceFirst(pattern, "");\n      root = new SuffixNode();\n      buildSuffixTree();\n    }\n  }\n\n  public String longestCommonSubstring() {\n    int[] result = {0, 0};\n    longestCommonSubstringDFS(root, "", result);\n    return text.substring(result[0], result[1]);\n  }\n\n  private void longestCommonSubstringDFS(SuffixNode node, String currentSuffix, int[] result) {\n    if (node.children.isEmpty()) {\n      return;\n    }\n\n    for (SuffixNode child : node.children.values()) {\n      String newSuffix = currentSuffix + text.charAt(child.index);\n\n      if (newSuffix.length() > result[1] - result[0]) {\n        result[0] = child.index - newSuffix.length() + 1;\n        result[1] = child.index + 1;\n      }\n\n      longestCommonSubstringDFS(child, newSuffix, result);\n    }\n  }\n\n  public int substringCount(SuffixNode node) {\n    if (node == null) {\n      node = root;\n    }\n\n    int count = 1;\n    for (SuffixNode child : node.children.values()) {\n      count += substringCount(child);\n    }\n\n    return count;\n  }\n\n  public int[] patternMatching(String pattern, SuffixNode node) {\n    if (node == null) {\n      node = root;\n    }\n\n    for (int i = 0; i < pattern.length(); i++) {\n      char currentChar = pattern.charAt(i);\n      if (node.children.containsKey(currentChar)) {\n        node = node.children.get(currentChar);\n      } else {\n        return new int[0];\n      }\n    }\n\n    return getLeafIndices(node);\n  }\n\n  private int[] getLeafIndices(SuffixNode node) {\n    int[] indices = new int[0];\n    if (node.children.isEmpty()) {\n      indices = new int[]{node.index};\n    }\n\n    for (SuffixNode child : node.children.values()) {\n      int[] childIndices = getLeafIndices(child);\n      int[] combinedIndices = new int[indices.length + childIndices.length];\n      System.arraycopy(indices, 0, combinedIndices, 0, indices.length);\n      System.arraycopy(childIndices, 0, combinedIndices, indices.length, childIndices.length);\n      indices = combinedIndices;\n    }\n\n    return indices;\n  }\n\n  public void traverse(SuffixNode node, int depth) {\n    if (node == null) {\n      node = root;\n    }\n    System.out.printf("%sNode: %d%n", "  ".repeat(depth), node.index);\n    for (Map.Entry<Character, SuffixNode> entry : node.children.entrySet()) {\n      char charKey = entry.getKey();\n      SuffixNode child = entry.getValue();\n      System.out.printf("%sEdge: %c%n", "  ".repeat(depth + 1), charKey);\n      traverse(child, depth + 2);\n    }\n  }\n}\n',u='class SuffixNode {\n  constructor() {\n    this.children = {};\n    this.index = -1;\n  }\n}\n\nclass SuffixTree {\n  constructor(text) {\n    this.root = new SuffixNode();\n    this.text = text;\n    this.buildSuffixTree();\n  }\n\n  buildSuffixTree() {\n    const n = this.text.length;\n    for (let i = 0; i < n; i++) {\n      this._addSuffix(i, this.root);\n    }\n  }\n\n  _addSuffix(suffixStart, node) {\n    if (suffixStart === this.text.length) {\n      return;\n    }\n\n    const currentChar = this.text[suffixStart];\n    if (!node.children[currentChar]) {\n      node.children[currentChar] = new SuffixNode();\n      node.children[currentChar].index = suffixStart;\n    } else {\n      const existingNode = node.children[currentChar];\n      this._addSuffix(suffixStart + 1, existingNode);\n    }\n  }\n\n  insert(newText) {\n    this.text += newText;\n    const n = this.text.length;\n    for (let i = n - newText.length; i < n; i++) {\n      this._addSuffix(i, this.root);\n    }\n  }\n\n  search(pattern) {\n    let currentNode = this.root;\n    const n = pattern.length;\n    let i = 0;\n\n    while (i < n) {\n      const char = pattern[i];\n      if (currentNode.children[char]) {\n        currentNode = currentNode.children[char];\n        i++;\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  delete(pattern) {\n    if (this.search(pattern)) {\n      this.text = this.text.replace(pattern, "");\n      this.root = new SuffixNode();\n      this.buildSuffixTree();\n    }\n  }\n\n  longestCommonSubstring() {\n    const result = [0, 0];\n    this._longestCommonSubstringDFS(this.root, "", result);\n    return this.text.substring(result[0], result[1]);\n  }\n\n  _longestCommonSubstringDFS(node, currentSuffix, result) {\n    if (!Object.keys(node.children).length) {\n      return;\n    }\n\n    for (const child of Object.values(node.children)) {\n      const newSuffix = currentSuffix + this.text[child.index];\n\n      if (newSuffix.length > result[1] - result[0]) {\n        result[0] = child.index - newSuffix.length + 1;\n        result[1] = child.index + 1;\n      }\n\n      this._longestCommonSubstringDFS(child, newSuffix, result);\n    }\n  }\n\n  substringCount(node = null) {\n    if (!node) {\n      node = this.root;\n    }\n\n    let count = 1;\n    for (const child of Object.values(node.children)) {\n      count += this.substringCount(child);\n    }\n\n    return count;\n  }\n\n  patternMatching(pattern, node = null) {\n    if (!node) {\n      node = this.root;\n    }\n\n    for (let i = 0; i < pattern.length; i++) {\n      const char = pattern[i];\n      if (node.children[char]) {\n        node = node.children[char];\n      } else {\n        return [];\n      }\n    }\n\n    return this._getLeafIndices(node);\n  }\n\n  _getLeafIndices(node) {\n    let indices = [];\n    if (Object.keys(node.children).length === 0) {\n      indices.push(node.index);\n    }\n\n    for (const child of Object.values(node.children)) {\n      indices = indices.concat(this._getLeafIndices(child));\n    }\n\n    return indices;\n  }\n\n  traverse(node = null, depth = 0) {\n    if (!node) {\n      node = this.root;\n    }\n    console.log("  ".repeat(depth) + `Node: ${node.index}`);\n    for (const [char, child] of Object.entries(node.children)) {\n      console.log("  ".repeat(depth + 1) + `Edge: ${char}`);\n      this.traverse(child, depth + 2);\n    }\n  }\n}\n',a='class SuffixNode {\n    val children = mutableMapOf<Char, SuffixNode>()\n    var index = -1\n}\n\nclass SuffixTree(text: String) {\n    var root = SuffixNode()\n    var text = text\n\n    init {\n        buildSuffixTree()\n    }\n\n    private fun buildSuffixTree() {\n        val n = text.length\n        for (i in 0 until n) {\n            addSuffix(i, root)\n        }\n    }\n\n    private fun addSuffix(suffixStart: Int, node: SuffixNode) {\n        if (suffixStart == text.length) {\n            return\n        }\n\n        val currentChar = text[suffixStart]\n        if (!node.children.containsKey(currentChar)) {\n            node.children[currentChar] = SuffixNode()\n            node.children[currentChar]!!.index = suffixStart\n        } else {\n            val existingNode = node.children[currentChar]!!\n            addSuffix(suffixStart + 1, existingNode)\n        }\n    }\n\n    fun insert(newText: String) {\n        text += newText\n        val n = text.length\n        for (i in n - newText.length until n) {\n            addSuffix(i, root)\n        }\n    }\n\n    fun search(pattern: String): Boolean {\n        var currentNode = root\n        var i = 0\n\n        while (i < pattern.length) {\n            val char = pattern[i]\n            if (currentNode.children.containsKey(char)) {\n                currentNode = currentNode.children[char]!!\n                i++\n            } else {\n                return false\n            }\n        }\n\n        return true\n    }\n\n    fun delete(pattern: String) {\n        if (search(pattern)) {\n            text = text.replaceFirst(pattern, "")\n            root = SuffixNode()\n            buildSuffixTree()\n        }\n    }\n\n    fun longestCommonSubstring(): String {\n        val result = intArrayOf(0, 0)\n        longestCommonSubstringDFS(root, "", result)\n        return text.substring(result[0], result[1])\n    }\n\n    private fun longestCommonSubstringDFS(node: SuffixNode, currentSuffix: String, result: IntArray) {\n        if (node.children.isEmpty()) {\n            return\n        }\n\n        for ((_, child) in node.children) {\n            val newSuffix = currentSuffix + text[child.index]\n\n            if (newSuffix.length > result[1] - result[0]) {\n                result[0] = child.index - newSuffix.length + 1\n                result[1] = child.index + 1\n            }\n\n            longestCommonSubstringDFS(child, newSuffix, result)\n        }\n    }\n\n    fun substringCount(node: SuffixNode? = null): Int {\n        val currentNode = node ?: root\n        var count = 1\n        for (child in currentNode.children.values) {\n            count += substringCount(child)\n        }\n        return count\n    }\n\n    fun patternMatching(pattern: String, node: SuffixNode? = null): List<Int> {\n        val currentNode = node ?: root\n        var i = 0\n        for (char in pattern) {\n            if (currentNode.children.containsKey(char)) {\n                currentNode = currentNode.children[char]!!\n            } else {\n                return emptyList()\n            }\n        }\n        return getLeafIndices(currentNode)\n    }\n\n    private fun getLeafIndices(node: SuffixNode): List<Int> {\n        val indices = mutableListOf<Int>()\n        if (node.children.isEmpty()) {\n            indices.add(node.index)\n        }\n\n        for (child in node.children.values) {\n            indices.addAll(getLeafIndices(child))\n        }\n\n        return indices\n    }\n\n    fun traverse(node: SuffixNode? = null, depth: Int = 0) {\n        val currentNode = node ?: root\n        println("  ".repeat(depth) + "Node: ${currentNode.index}")\n        for ((char, child) in currentNode.children) {\n            println("  ".repeat(depth + 1) + "Edge: $char")\n            traverse(child, depth + 2)\n        }\n    }\n}\n',h='class SuffixTree:\n    def __init__(self, text):\n        self.root = SuffixNode()\n        self.text = text\n        self.build_suffix_tree()\n\n    def build_suffix_tree(self):\n        n = len(self.text)\n        for i in range(n):\n            self._add_suffix(i, self.root)\n\n    def _add_suffix(self, suffix_start, node):\n        if suffix_start == len(self.text):\n            return\n\n        current_char = self.text[suffix_start]\n        if current_char not in node.children:\n            node.children[current_char] = SuffixNode()\n            node.children[current_char].index = suffix_start\n        else:\n            existing_node = node.children[current_char]\n            self._add_suffix(suffix_start + 1, existing_node)\n\n    def insert(self, new_text):\n        self.text += new_text\n        n = len(self.text)\n        for i in range(n - len(new_text), n):\n            self._add_suffix(i, self.root)\n\n    def search(self, pattern):\n        current_node = self.root\n        n = len(pattern)\n        i = 0\n\n        while i < n:\n            char = pattern[i]\n            if char in current_node.children:\n                current_node = current_node.children[char]\n                i += 1\n            else:\n                return False\n\n        return True\n\n    def delete(self, pattern):\n        if self.search(pattern):\n            self.text = self.text.replace(pattern, "", 1)\n            self.root = SuffixNode()\n            self.build_suffix_tree()\n\n    def longest_common_substring(self):\n        result = [0, 0]\n        self._longest_common_substring_dfs(self.root, "", result)\n        return self.text[result[0]:result[1]]\n\n    def _longest_common_substring_dfs(self, node, current_suffix, result):\n        if not node.children:\n            return\n\n        for child in node.children.values():\n            new_suffix = current_suffix + self.text[child.index]\n\n            if len(new_suffix) > result[1] - result[0]:\n                result[0] = child.index - len(new_suffix) + 1\n                result[1] = child.index + 1\n\n            self._longest_common_substring_dfs(child, new_suffix, result)\n\n    def substring_count(self, node=None):\n        if node is None:\n            node = self.root\n\n        count = 1\n        for child in node.children.values():\n            count += self.substring_count(child)\n\n        return count\n\n    def pattern_matching(self, pattern, node=None):\n        if node is None:\n            node = self.root\n\n        for i, char in enumerate(pattern):\n            if char in node.children:\n                node = node.children[char]\n            else:\n                return []\n\n        return self._get_leaf_indices(node)\n\n    def _get_leaf_indices(self, node):\n        indices = []\n        if not node.children:\n            indices.append(node.index)\n\n        for child in node.children.values():\n            indices.extend(self._get_leaf_indices(child))\n\n        return indices\n\n    def traverse(self, node=None, depth=0):\n        if node is None:\n            node = self.root\n        print("  " * depth + f"Node: {node.index}")\n        for char, child in node.children.items():\n            print("  " * (depth + 1) + f"Edge: {char}")\n            self.traverse(child, depth + 2)\n',x='use std::collections::HashMap;\n\nstruct SuffixNode {\n    children: HashMap<char, SuffixNode>,\n    index: i32,\n}\n\nimpl SuffixNode {\n    fn new() -> Self {\n        SuffixNode {\n            children: HashMap::new(),\n            index: -1,\n        }\n    }\n}\n\nstruct SuffixTree {\n    root: SuffixNode,\n    text: String,\n}\n\nimpl SuffixTree {\n    fn new(text: &str) -> Self {\n        let mut tree = SuffixTree {\n            root: SuffixNode::new(),\n            text: text.to_string(),\n        };\n        tree.build_suffix_tree();\n        tree\n    }\n\n    fn build_suffix_tree(&mut self) {\n        let n = self.text.len();\n        for i in 0..n {\n            self.add_suffix(i, &mut self.root);\n        }\n    }\n\n    fn add_suffix(&mut self, suffix_start: usize, node: &mut SuffixNode) {\n        if suffix_start == self.text.len() {\n            return;\n        }\n\n        let current_char = self.text.chars().nth(suffix_start).unwrap();\n        if !node.children.contains_key(&current_char) {\n            node.children.insert(current_char, SuffixNode::new());\n            if let Some(child) = node.children.get_mut(&current_char) {\n                child.index = suffix_start as i32;\n            }\n        } else {\n            if let Some(existing_node) = node.children.get_mut(&current_char) {\n                self.add_suffix(suffix_start + 1, existing_node);\n            }\n        }\n    }\n\n    fn insert(&mut self, new_text: &str) {\n        self.text.push_str(new_text);\n        let n = self.text.len();\n        for i in n - new_text.len()..n {\n            self.add_suffix(i, &mut self.root);\n        }\n    }\n\n    fn search(&self, pattern: &str) -> bool {\n        let mut current_node = &self.root;\n        let mut i = 0;\n\n        while i < pattern.len() {\n            if let Some(char) = pattern.chars().nth(i) {\n                if let Some(child) = current_node.children.get(&char) {\n                    current_node = child;\n                    i += 1;\n                } else {\n                    return false;\n                }\n            }\n        }\n\n        true\n    }\n\n    fn delete(&mut self, pattern: &str) {\n        if self.search(pattern) {\n            self.text = self.text.replacen(pattern, "", 1);\n            self.root = SuffixNode::new();\n            self.build_suffix_tree();\n        }\n    }\n\n    fn longest_common_substring(&self) -> String {\n        let mut result = vec![0, 0];\n        self.longest_common_substring_dfs(&self.root, "", &mut result);\n        self.text[result[0] as usize..result[1] as usize].to_string()\n    }\n\n    fn longest_common_substring_dfs(&self, node: &SuffixNode, current_suffix: &str, result: &mut Vec<i32>) {\n        if node.children.is_empty() {\n            return;\n        }\n\n        for (_, child) in &node.children {\n            let new_suffix = format!("{}{}", current_suffix, &self.text[child.index as usize..(child.index + 1) as usize]);\n\n            if new_suffix.len() > (result[1] - result[0]) as usize {\n                result[0] = child.index - new_suffix.len() as i32 + 1;\n                result[1] = child.index + 1;\n            }\n\n            self.longest_common_substring_dfs(child, &new_suffix, result);\n        }\n    }\n\n    fn substring_count(&self, node: Option<&SuffixNode>) -> i32 {\n        let current_node = node.unwrap_or(&self.root);\n        let mut count = 1;\n        for (_, child) in &current_node.children {\n            count += self.substring_count(Some(child));\n        }\n        count\n    }\n\n    fn pattern_matching(&self, pattern: &str, node: Option<&SuffixNode>) -> Vec<i32> {\n        let mut current_node = node.unwrap_or(&self.root);\n        let mut i = 0;\n\n        for char in pattern.chars() {\n            if let Some(child) = current_node.children.get(&char) {\n                current_node = child;\n            } else {\n                return Vec::new();\n            }\n            i += 1;\n        }\n\n        self.get_leaf_indices(current_node)\n    }\n\n    fn get_leaf_indices(&self, node: &SuffixNode) -> Vec<i32> {\n        let mut indices = Vec::new();\n        if node.children.is_empty() {\n            indices.push(node.index);\n        }\n\n        for (_, child) in &node.children {\n            indices.extend(self.get_leaf_indices(child));\n        }\n\n        indices\n    }\n\n    fn traverse(&self, node: Option<&SuffixNode>, depth: i32) {\n        let current_node = node.unwrap_or(&self.root);\n        println!("{}Node: {}", "  ".repeat(depth as usize), current_node.index);\n        for (char, child) in &current_node.children {\n            println!("{}Edge: {}", "  ".repeat((depth + 1) as usize), char);\n            self.traverse(Some(child), depth + 2);\n        }\n    }\n}\n',g='class SuffixNode {\n  children: { [char: string]: SuffixNode };\n  index: number;\n\n  constructor() {\n    this.children = {};\n    this.index = -1;\n  }\n}\n\nclass SuffixTree {\n  root: SuffixNode;\n  text: string;\n\n  constructor(text: string) {\n    this.root = new SuffixNode();\n    this.text = text;\n    this.buildSuffixTree();\n  }\n\n  buildSuffixTree(): void {\n    const n = this.text.length;\n    for (let i = 0; i < n; i++) {\n      this.addSuffix(i, this.root);\n    }\n  }\n\n  insert(newText: string): void {\n    this.text += newText;\n    const n = this.text.length;\n    for (let i = n - newText.length; i < n; i++) {\n      this.addSuffix(i, this.root);\n    }\n  }\n\n  search(pattern: string): boolean {\n    let currentNode = this.root;\n    let i = 0;\n\n    while (i < pattern.length) {\n      const char = pattern[i];\n      if (char in currentNode.children) {\n        currentNode = currentNode.children[char];\n        i++;\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  delete(pattern: string): void {\n    if (this.search(pattern)) {\n      this.text = this.text.replace(pattern, "");\n      this.root = new SuffixNode();\n      this.buildSuffixTree();\n    }\n  }\n\n  longestCommonSubstring(): string {\n    const result: [number, number] = [0, 0];\n    this.longestCommonSubstringDFS(this.root, "", result);\n    return this.text.slice(result[0], result[1]);\n  }\n\n  substringCount(node?: SuffixNode): number {\n    const currentNode = node || this.root;\n    let count = 1;\n\n    for (const child of Object.values(currentNode.children)) {\n      count += this.substringCount(child);\n    }\n\n    return count;\n  }\n\n  patternMatching(pattern: string, node?: SuffixNode): number[] {\n    const currentNode = node || this.root;\n    let i = 0;\n\n    for (const char of pattern) {\n      if (char in currentNode.children) {\n        currentNode = currentNode.children[char];\n      } else {\n        return [];\n      }\n      i++;\n    }\n\n    return this.getLeafIndices(currentNode);\n  }\n\n  traverse(node?: SuffixNode, depth: number = 0): void {\n    const currentNode = node || this.root;\n    console.log("  ".repeat(depth) + `Node: ${currentNode.index}`);\n    for (const [char, child] of Object.entries(currentNode.children)) {\n      console.log("  ".repeat(depth + 1) + `Edge: ${char}`);\n      this.traverse(child, depth + 2);\n    }\n  }\n\n  private addSuffix(suffixStart: number, node: SuffixNode): void {\n    if (suffixStart === this.text.length) {\n      return;\n    }\n\n    const currentChar = this.text[suffixStart];\n    if (!(currentChar in node.children)) {\n      node.children[currentChar] = new SuffixNode();\n      node.children[currentChar].index = suffixStart;\n    } else {\n      const existingNode = node.children[currentChar];\n      this.addSuffix(suffixStart + 1, existingNode);\n    }\n  }\n\n  private longestCommonSubstringDFS(\n    node: SuffixNode,\n    currentSuffix: string,\n    result: [number, number],\n  ): void {\n    if (Object.keys(node.children).length === 0) {\n      return;\n    }\n\n    for (const child of Object.values(node.children)) {\n      const newSuffix = currentSuffix + this.text[child.index];\n\n      if (newSuffix.length > result[1] - result[0]) {\n        result[0] = child.index - newSuffix.length + 1;\n        result[1] = child.index + 1;\n      }\n\n      this.longestCommonSubstringDFS(child, newSuffix, result);\n    }\n  }\n\n  private getLeafIndices(node: SuffixNode): number[] {\n    const indices: number[] = [];\n    if (Object.keys(node.children).length === 0) {\n      indices.push(node.index);\n    }\n\n    for (const child of Object.values(node.children)) {\n      indices.push(...this.getLeafIndices(child));\n    }\n\n    return indices;\n  }\n}\n',p={title:"Suffix Tree",description:"Suffix Tree Data Structure",hide_table_of_contents:!0},S=void 0,m={},_=[{value:"Definition",id:"definition",level:2},{value:"Trie vs Suffix Tree",id:"trie-vs-suffix-tree",level:3},{value:"Searching Pattern",id:"searching-pattern",level:3},{value:"Compressed Trie",id:"compressed-trie",level:3},{value:"Practice",id:"practice",level:2}];function j(n){const e={code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components},{Details:r}=e;return r||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:t(4464).A+""})}),"\n",(0,i.jsxs)("table",{children:[(0,i.jsxs)("thead",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Implementation"}),(0,i.jsx)("th",{children:"Space"}),(0,i.jsx)("th",{colspan:"4",children:"Time"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{}),(0,i.jsx)("th",{}),(0,i.jsx)("th",{children:"Access"}),(0,i.jsx)("th",{children:"Lookup"}),(0,i.jsx)("th",{children:"Insertion"}),(0,i.jsx)("th",{children:"Deletion"})]})]}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Sibling lists / unsorted arrays"}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"fair",children:"O(n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"na",children:"N/A"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"fair",children:"O(n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"excellent",children:"O(1)"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Bitwise sibling trees"}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"fair",children:"O(n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"na",children:"N/A"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"good",children:"O(log n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"excellent",children:"O(1)"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Hash maps"}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"fair",children:"O(n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"na",children:"N/A"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"fair",children:"O(n)"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Balanced search tree"}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"fair",children:"O(n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"na",children:"N/A"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"good",children:"O(log n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"good",children:"O(log n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"good",children:"O(log n)"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Sorted arrays"}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"fair",children:"O(n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"na",children:"N/A"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"good",children:"O(log n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"fair",children:"O(n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"fair",children:"O(n)"})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Hash maps + sibling lists"}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"fair",children:"O(n)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"na",children:"N/A"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,i.jsx)("td",{children:(0,i.jsx)("code",{className:"excellent",children:"O(1)"})})]})]})]}),"\n",(0,i.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(d.A,{queryString:"primary",children:[(0,i.jsxs)(c.A,{value:"short",label:"Short",children:[(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Suffix Tree"})," is a tree-based data structure that efficiently represents all suffixes of a given string, enabling fast pattern matching and substring search algorithms"]}),(0,i.jsxs)(r,{children:[(0,i.jsx)("summary",{children:"Simplified"}),(0,i.jsx)(e.p,{children:"Imagine you have a giant book, and a Suffix Tree is like a smart index that helps you quickly find any word or phrase in the book without reading it all over again, making searches faster and more\nefficient"})]})]}),(0,i.jsxs)(c.A,{value:"detailed",label:"Detailed",children:[(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Suffix Tree"})," (also called ",(0,i.jsx)(e.strong,{children:"PAT Tree"})," or ",(0,i.jsx)(e.strong,{children:"Position Tree"}),") is a compressed trie containing all the suffixes of the given text as their keys and positions in the text as their values. Suffix\ntrees allow particularly fast implementations of many important string operations."]}),(0,i.jsx)(e.h3,{id:"trie-vs-suffix-tree",children:"Trie vs Suffix Tree"}),(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Suffix Tree"})," is a compressed and optimized version of a Trie, specifically designed for efficient storage and retrieval of all suffixes of a given string, making it more suitable for\ntext-related tasks such as pattern matching and substring searches"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Trie"})," is a tree-like data structure that stores a dynamic set of strings and allows efficient prefix searches"]}),"\n"]}),(0,i.jsx)(e.h3,{id:"searching-pattern",children:"Searching Pattern"}),(0,i.jsxs)(e.p,{children:["When searching for a pattern in a text, preprocessing the pattern can significantly improve search time. Various algorithms like KMP, Rabin Karp, Finite Automata, and Boyer Moore focus on\npreprocessing patterns. However, an alternative approach is to preprocess the text itself using a suffix tree. Suffix trees, built from the text, allow searching any pattern in ",(0,i.jsx)(e.code,{children:"O(m)"})," time, where\nm is the pattern length. This method is particularly efficient for fixed or infrequently changing texts."]}),(0,i.jsx)(e.p,{children:"To search a pattern in a built suffix tree, start from the root and iterate through each character of the pattern. For every character, follow the edge in the suffix tree if it exists. If not,\nconclude that the pattern doesn't exist in the text. If all characters of the pattern are processed, a path from the root for the pattern characters indicates a successful pattern search."}),(0,i.jsx)(e.h3,{id:"compressed-trie",children:"Compressed Trie"}),(0,i.jsx)(e.p,{children:"A suffix tree is essentially a compressed trie for all suffixes of a given text. Building a suffix tree involves generating all suffixes and constructing a compressed trie from them. This trie can\nbe further compressed by joining chains of single nodes, creating the final suffix tree."})]})]}),"\n",(0,i.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(d.A,{queryString:"primary",children:[(0,i.jsx)(c.A,{value:"practice",label:"Practice",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{children:"Pseudo Code"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Build Suffix Tree"}),(0,i.jsx)("td",{children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"build_suffix_tree():\n  for index in text.length:\n    _add_suffix(index, root)\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Add Suffix"}),(0,i.jsx)("td",{children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"add_suffix(suffix):\n  _add_suffix(0, root)\n\n_add_suffix(suffix_start, node):\n  if suffix_start == text.length:\n    return\n\n  current_char = text[suffix_start]\n  if current_char not in node.children:\n    node.children[current_char] = SuffixNode()\n    node.children[current_char].index = suffix_start\n  else:\n    existing_node = node.children[current_char]\n    _add_suffix(suffix_start + 1, existing_node)\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Insertion"}),(0,i.jsx)("td",{children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"insert(new_text):\n  text += new_text\n  for index in range(text.length - new_text.length, text.length):\n    _add_suffix(index, root)\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Search"}),(0,i.jsx)("td",{children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"search(pattern):\n  current_node = root\n  n = len(pattern)\n  i = 0\n\n  while i < n:\n    char = pattern[i]\n    if char in current_node.children:\n      current_node = current_node.children[char]\n      i += 1\n    else:\n      return False\n\n  return True\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Delete"}),(0,i.jsx)("td",{children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'delete(pattern):\n  if search(pattern):\n    text = text.replace(pattern, "", 1)\n    root = SuffixNode()\n    build_suffix_tree()\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Longest Common Substring"}),(0,i.jsx)("td",{children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'longest_common_substring():\n  result = [0, 0]\n  _longest_common_substring_dfs(root, "", result)\n  return text.substring(result[0], result[1])\n\n_longest_common_substring_dfs(node, current_suffix, result):\n  if not node.children:\n    return\n\n  for child in node.children.values():\n    new_suffix = current_suffix + text[child.index]\n\n    if len(new_suffix) > result[1] - result[0]:\n      result[0] = child.index - len(new_suffix) + 1\n      result[1] = child.index + 1\n\n    _longest_common_substring_dfs(child, new_suffix, result)\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Substring Count"}),(0,i.jsx)("td",{children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"substring_count(node=None):\n  if node is None:\n    node = root\n\n  count = 1\n  for child in node.children.values():\n    count += substring_count(child)\n\n  return count\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Pattern Matching"}),(0,i.jsx)("td",{children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:"pattern_matching(pattern, node=None):\n  if node is None:\n    node = root\n\n  for i, char in enumerate(pattern):\n    if char in node.children:\n      node = node.children[char]\n    else:\n      return []\n\n  return _get_leaf_indices(node)\n\n_get_leaf_indices(node):\n  indices = []\n  if not node.children:\n    indices.append(node.index)\n\n  for child in node.children.values():\n    indices.extend(_get_leaf_indices(child))\n\n  return indices\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Traverse"}),(0,i.jsx)("td",{children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{children:'traverse(node=None, depth=0):\n  if node is None:\n    node = root\n  print(" " * depth + "Node: " + node.index)\n  for char, child in node.children.items():\n    print(" " * (depth + 1) + "Edge: " + char)\n    traverse(child, depth + 2)\n'})})})]})]})]})}),(0,i.jsx)(c.A,{value:"solution",label:"Solution",children:(0,i.jsxs)(d.A,{queryString:"code",children:[(0,i.jsx)(c.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(l.A,{language:"go",children:o})}),(0,i.jsx)(c.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(l.A,{language:"java",children:f})}),(0,i.jsx)(c.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(l.A,{language:"js",children:u})}),(0,i.jsx)(c.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(l.A,{language:"kotlin",children:a})}),(0,i.jsx)(c.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(l.A,{language:"python",children:h})}),(0,i.jsx)(c.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(l.A,{language:"rust",children:x})}),(0,i.jsx)(c.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(l.A,{language:"ts",children:g})})]})})]})]})}function N(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(j,{...n})}):j(n)}},4464:(n,e,t)=>{t.d(e,{A:()=>r});const r=t.p+"assets/images/suffixTree-b46b4a6b1e00ddebe24e2b9d8e1c14b3.svg"}}]);