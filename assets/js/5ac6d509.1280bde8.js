"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[4006],{2525:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>y,contentTitle:()=>k,default:()=>S,frontMatter:()=>j,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"education/computer-science/data-structures/basic/disjoint-set","title":"Disjoint Set","description":"Disjoint Set Data Structure","source":"@site/docs/education/01-computer-science/09-data-structures/02-basic/18-disjoint-set.mdx","sourceDirName":"education/01-computer-science/09-data-structures/02-basic","slug":"/education/computer-science/data-structures/basic/disjoint-set","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/disjoint-set","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/18-disjoint-set.mdx","tags":[],"version":"current","sidebarPosition":18,"frontMatter":{"title":"Disjoint Set","description":"Disjoint Set Data Structure","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Graph","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/graph"},"next":{"title":"Bloom Filter","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/bloom-filter"}}');var r=t(86070),s=t(15658),o=t(33407),l=t(33903),a=t(68171);const c='package main\n\nimport (\n\t"errors"\n)\n\ntype DisjointSetItem struct {\n\tvalue       interface{}\n\tkeyCallback func(interface{}) interface{}\n\tparent      *DisjointSetItem\n\tchildren    map[interface{}]*DisjointSetItem\n}\n\nfunc NewDisjointSetItem(value interface{}, keyCallback func(interface{}) interface{}) *DisjointSetItem {\n\treturn &DisjointSetItem{\n\t\tvalue:       value,\n\t\tkeyCallback: keyCallback,\n\t\tchildren:    make(map[interface{}]*DisjointSetItem),\n\t}\n}\n\nfunc (item *DisjointSetItem) GetKey() interface{} {\n\tif item.keyCallback != nil {\n\t\treturn item.keyCallback(item.value)\n\t}\n\treturn item.value\n}\n\nfunc (item *DisjointSetItem) GetRoot() *DisjointSetItem {\n\tif item.isRoot() {\n\t\treturn item\n\t}\n\treturn item.parent.GetRoot()\n}\n\nfunc (item *DisjointSetItem) isRoot() bool {\n\treturn item.parent == nil\n}\n\nfunc (item *DisjointSetItem) GetRank() int {\n\tif len(item.GetChildren()) == 0 {\n\t\treturn 0\n\t}\n\n\trank := 0\n\n\tfor _, child := range item.GetChildren() {\n\t\trank += 1\n\t\trank += child.GetRank()\n\t}\n\n\treturn rank\n}\n\nfunc (item *DisjointSetItem) GetChildren() []*DisjointSetItem {\n\tchildren := make([]*DisjointSetItem, 0, len(item.children))\n\tfor _, child := range item.children {\n\t\tchildren = append(children, child)\n\t}\n\treturn children\n}\n\nfunc (item *DisjointSetItem) SetParent(parentItem *DisjointSetItem, forceSettingParentChild bool) *DisjointSetItem {\n\titem.parent = parentItem\n\tif forceSettingParentChild {\n\t\tparentItem.AddChild(item)\n\t}\n\treturn item\n}\n\nfunc (item *DisjointSetItem) AddChild(childItem *DisjointSetItem) *DisjointSetItem {\n\titem.children[childItem.GetKey()] = childItem\n\tchildItem.SetParent(item, false)\n\treturn item\n}\n\ntype DisjointSet struct {\n\tkeyCallback func(interface{}) interface{}\n\titems       map[interface{}]*DisjointSetItem\n}\n\nfunc NewDisjointSet(keyCallback func(interface{}) interface{}) *DisjointSet {\n\treturn &DisjointSet{\n\t\tkeyCallback: keyCallback,\n\t\titems:       make(map[interface{}]*DisjointSetItem),\n\t}\n}\n\nfunc (ds *DisjointSet) MakeSet(itemValue interface{}) *DisjointSet {\n\tdisjointSetItem := NewDisjointSetItem(itemValue, ds.keyCallback)\n\n\tif _, exists := ds.items[disjointSetItem.GetKey()]; !exists {\n\t\tds.items[disjointSetItem.GetKey()] = disjointSetItem\n\t}\n\n\treturn ds\n}\n\nfunc (ds *DisjointSet) Find(itemValue interface{}) (interface{}, error) {\n\ttemplateDisjointItem := NewDisjointSetItem(itemValue, ds.keyCallback)\n\trequiredDisjointItem, exists := ds.items[templateDisjointItem.GetKey()]\n\n\tif !exists {\n\t\treturn nil, nil\n\t}\n\n\treturn requiredDisjointItem.GetRoot().GetKey(), nil\n}\n\nfunc (ds *DisjointSet) Union(valueA, valueB interface{}) *DisjointSet {\n\trootKeyA, errA := ds.Find(valueA)\n\trootKeyB, errB := ds.Find(valueB)\n\n\tif errA != nil || errB != nil {\n\t\tpanic(errors.New("One or two values are not in sets"))\n\t}\n\n\tif rootKeyA == rootKeyB {\n\t\treturn ds\n\t}\n\n\trootA := ds.items[rootKeyA]\n\trootB := ds.items[rootKeyB]\n\n\tif rootA.GetRank() < rootB.GetRank() {\n\t\trootB.AddChild(rootA)\n\t\treturn ds\n\t}\n\n\trootA.AddChild(rootB)\n\n\treturn ds\n}\n\nfunc (ds *DisjointSet) InSameSet(valueA, valueB interface{}) (bool, error) {\n\trootKeyA, errA := ds.Find(valueA)\n\trootKeyB, errB := ds.Find(valueB)\n\n\tif errA != nil || errB != nil {\n\t\tpanic(errors.New("One or two values are not in sets"))\n\t}\n\n\treturn rootKeyA == rootKeyB, nil\n}\n',d='import java.util.HashMap;\nimport java.util.Map;\n\nclass DisjointSetItem<T> {\n\n  private T value;\n  private DisjointSetItem<T> parent;\n  private Map<T, DisjointSetItem<T>> children;\n\n  public DisjointSetItem(T value) {\n    this.value = value;\n    this.parent = null;\n    this.children = new HashMap<>();\n  }\n\n  public T getKey() {\n    return this.parent == null ? this.value : this.parent.getKey();\n  }\n\n  public DisjointSetItem<T> getRoot() {\n    return this.isRoot() ? this : this.parent.getRoot();\n  }\n\n  public boolean isRoot() {\n    return this.parent == null;\n  }\n\n  public int getRank() {\n    if (getChildren().isEmpty()) {\n      return 0;\n    }\n\n    int rank = 0;\n    for (DisjointSetItem<T> child : getChildren()) {\n      rank += 1;\n      rank += child.getRank();\n    }\n\n    return rank;\n  }\n\n  public Iterable<DisjointSetItem<T>> getChildren() {\n    return children.values();\n  }\n\n  public DisjointSetItem<T> setParent(DisjointSetItem<T> parentItem, boolean forceSettingParentChild) {\n    this.parent = parentItem;\n    if (forceSettingParentChild) {\n      parentItem.addChild(this);\n    }\n\n    return this;\n  }\n\n  public DisjointSetItem<T> addChild(DisjointSetItem<T> childItem) {\n    children.put(childItem.getKey(), childItem);\n    childItem.setParent(this, false);\n\n    return this;\n  }\n}\n\npublic class DisjointSet<T> {\n\n  private Map<T, DisjointSetItem<T>> items;\n  private KeyCallback<T> keyCallback;\n\n  public DisjointSet(KeyCallback<T> keyCallback) {\n    this.keyCallback = keyCallback;\n    this.items = new HashMap<>();\n  }\n\n  public DisjointSet<T> makeSet(T itemValue) {\n    DisjointSetItem<T> disjointSetItem = new DisjointSetItem<>(itemValue);\n\n    if (!items.containsKey(disjointSetItem.getKey())) {\n      items.put(disjointSetItem.getKey(), disjointSetItem);\n    }\n\n    return this;\n  }\n\n  public T find(T itemValue) {\n    DisjointSetItem<T> templateDisjointItem = new DisjointSetItem<>(itemValue);\n    DisjointSetItem<T> requiredDisjointItem = items.get(templateDisjointItem.getKey());\n\n    if (requiredDisjointItem == null) {\n      return null;\n    }\n\n    return requiredDisjointItem.getRoot().getKey();\n  }\n\n  public DisjointSet<T> union(T valueA, T valueB) {\n    T rootKeyA = find(valueA);\n    T rootKeyB = find(valueB);\n\n    if (rootKeyA == null || rootKeyB == null) {\n      throw new RuntimeException("One or two values are not in sets");\n    }\n\n    if (rootKeyA.equals(rootKeyB)) {\n      return this;\n    }\n\n    DisjointSetItem<T> rootA = items.get(rootKeyA);\n    DisjointSetItem<T> rootB = items.get(rootKeyB);\n\n    if (rootA.getRank() < rootB.getRank()) {\n      rootB.addChild(rootA);\n      return this;\n    }\n\n    rootA.addChild(rootB);\n\n    return this;\n  }\n\n  public boolean inSameSet(T valueA, T valueB) {\n    T rootKeyA = find(valueA);\n    T rootKeyB = find(valueB);\n\n    if (rootKeyA == null || rootKeyB == null) {\n      throw new RuntimeException("One or two values are not in sets");\n    }\n\n    return rootKeyA.equals(rootKeyB);\n  }\n\n  public interface KeyCallback<T> {\n\n    T getKey(T value);\n  }\n}\n',u='class DisjointSetItem {\n  constructor(value, keyCallback) {\n    this.value = value;\n    this.keyCallback = keyCallback;\n    this.parent = null;\n    this.children = {};\n  }\n\n  getKey() {\n    if (this.keyCallback) {\n      return this.keyCallback(this.value);\n    }\n    return this.value;\n  }\n\n  getRoot() {\n    return this.isRoot() ? this : this.parent.getRoot();\n  }\n\n  isRoot() {\n    return this.parent === null;\n  }\n\n  getRank() {\n    if (this.getChildren().length === 0) {\n      return 0;\n    }\n\n    let rank = 0;\n\n    this.getChildren().forEach((child) => {\n      rank += 1;\n      rank += child.getRank();\n    });\n\n    return rank;\n  }\n\n  getChildren() {\n    return Object.values(this.children);\n  }\n\n  setParent(parentItem, forceSettingParentChild = true) {\n    this.parent = parentItem;\n    if (forceSettingParentChild) {\n      parentItem.addChild(this);\n    }\n\n    return this;\n  }\n\n  addChild(childItem) {\n    this.children[childItem.getKey()] = childItem;\n    childItem.setParent(this, false);\n\n    return this;\n  }\n}\n\nclass DisjointSet {\n  constructor(keyCallback) {\n    this.keyCallback = keyCallback;\n    this.items = {};\n  }\n\n  makeSet(itemValue) {\n    const disjointSetItem = new DisjointSetItem(itemValue, this.keyCallback);\n\n    if (!this.items[disjointSetItem.getKey()]) {\n      this.items[disjointSetItem.getKey()] = disjointSetItem;\n    }\n\n    return this;\n  }\n\n  find(itemValue) {\n    const templateDisjointItem = new DisjointSetItem(\n      itemValue,\n      this.keyCallback,\n    );\n    const requiredDisjointItem = this.items[templateDisjointItem.getKey()];\n\n    if (!requiredDisjointItem) {\n      return null;\n    }\n\n    return requiredDisjointItem.getRoot().getKey();\n  }\n\n  union(valueA, valueB) {\n    const rootKeyA = this.find(valueA);\n    const rootKeyB = this.find(valueB);\n\n    if (rootKeyA === null || rootKeyB === null) {\n      throw new Error("One or two values are not in sets");\n    }\n\n    if (rootKeyA === rootKeyB) {\n      return this;\n    }\n\n    const rootA = this.items[rootKeyA];\n    const rootB = this.items[rootKeyB];\n\n    if (rootA.getRank() < rootB.getRank()) {\n      rootB.addChild(rootA);\n      return this;\n    }\n\n    rootA.addChild(rootB);\n\n    return this;\n  }\n\n  inSameSet(valueA, valueB) {\n    const rootKeyA = this.find(valueA);\n    const rootKeyB = this.find(valueB);\n\n    if (rootKeyA === null || rootKeyB === null) {\n      throw new Error("One or two values are not in sets");\n    }\n\n    return rootKeyA === rootKeyB;\n  }\n}\n',m='data class DisjointSetItem<T>(\n        val value: T,\n        val keyCallback: ((T) -> T)? = null,\n        var parent: DisjointSetItem<T>? = null,\n        val children: MutableMap<T, DisjointSetItem<T>> = mutableMapOf()\n) {\n    fun getKey(): T {\n        return parent?.getKey() ?: keyCallback?.invoke(value) ?: value\n    }\n\n    fun getRoot(): DisjointSetItem<T> {\n        return if (isRoot()) this else parent!!.getRoot()\n    }\n\n    fun isRoot(): Boolean {\n        return parent == null\n    }\n\n    fun getRank(): Int {\n        return if (getChildren().isEmpty()) {\n            0\n        } else {\n            getChildren().sumBy {\n                1 + it.getRank()\n            }\n        }\n    }\n\n    fun getChildren(): Collection<DisjointSetItem<T>> {\n        return children.values\n    }\n\n    fun setParent(parentItem: DisjointSetItem<T>, forceSettingParentChild: Boolean = true): DisjointSetItem<T> {\n        parent = parentItem\n        if (forceSettingParentChild) {\n            parentItem.addChild(this)\n        }\n        return this\n    }\n\n    fun addChild(childItem: DisjointSetItem<T>): DisjointSetItem<T> {\n        children[childItem.getKey()] = childItem\n        childItem.setParent(this, false)\n        return this\n    }\n}\n\nclass DisjointSet<T>(private val keyCallback: ((T) -> T)? = null) {\n    private val items: MutableMap<T, DisjointSetItem<T>> = mutableMapOf()\n\n    fun makeSet(itemValue: T): DisjointSet<T> {\n        val disjointSetItem = DisjointSetItem(itemValue, keyCallback)\n\n        if (!items.containsKey(disjointSetItem.getKey())) {\n            items[disjointSetItem.getKey()] = disjointSetItem\n        }\n\n        return this\n    }\n\n    fun find(itemValue: T): T? {\n        val templateDisjointItem = DisjointSetItem(itemValue, keyCallback)\n        val requiredDisjointItem = items[templateDisjointItem.getKey()]\n\n        return requiredDisjointItem?.getRoot()?.getKey()\n    }\n\n    fun union(valueA: T, valueB: T): DisjointSet<T> {\n        val rootKeyA = find(valueA)\n        val rootKeyB = find(valueB)\n\n        if (rootKeyA == null || rootKeyB == null) {\n            throw RuntimeException("One or two values are not in sets")\n        }\n\n        if (rootKeyA == rootKeyB) {\n            return this\n        }\n\n        val rootA = items[rootKeyA]!!\n        val rootB = items[rootKeyB]!!\n\n        if (rootA.getRank() < rootB.getRank()) {\n            rootB.addChild(rootA)\n        } else {\n            rootA.addChild(rootB)\n        }\n\n        return this\n    }\n\n    fun inSameSet(valueA: T, valueB: T): Boolean {\n        val rootKeyA = find(valueA)\n        val rootKeyB = find(valueB)\n\n        if (rootKeyA == null || rootKeyB == null) {\n            throw RuntimeException("One or two values are not in sets")\n        }\n\n        return rootKeyA == rootKeyB\n    }\n}\n',h='class DisjointSetItem:\n    def __init__(self, value, key_callback=None):\n        self.value = value\n        self.key_callback = key_callback\n        self.parent = None\n        self.children = {}\n\n    def get_key(self):\n        if self.key_callback:\n            return self.key_callback(self.value)\n        return self.value\n\n    def get_root(self):\n        return self if self.is_root() else self.parent.get_root()\n\n    def is_root(self):\n        return self.parent is None\n\n    def get_rank(self):\n        if not self.get_children():\n            return 0\n\n        rank = 0\n        for child in self.get_children():\n            rank += 1\n            rank += child.get_rank()\n\n        return rank\n\n    def get_children(self):\n        return list(self.children.values())\n\n    def set_parent(self, parent_item, force_setting_parent_child=True):\n        self.parent = parent_item\n        if force_setting_parent_child:\n            parent_item.add_child(self)\n        return self\n\n    def add_child(self, child_item):\n        self.children[child_item.get_key()] = child_item\n        child_item.set_parent(self, False)\n        return self\n\n\nclass DisjointSet:\n    def __init__(self, key_callback=None):\n        self.key_callback = key_callback\n        self.items = {}\n\n    def make_set(self, item_value):\n        disjoint_set_item = DisjointSetItem(item_value, self.key_callback)\n\n        if disjoint_set_item.get_key() not in self.items:\n            self.items[disjoint_set_item.get_key()] = disjoint_set_item\n\n        return self\n\n    def find(self, item_value):\n        template_disjoint_item = DisjointSetItem(item_value, self.key_callback)\n        required_disjoint_item = self.items.get(template_disjoint_item.get_key())\n\n        if not required_disjoint_item:\n            return None\n\n        return required_disjoint_item.get_root().get_key()\n\n    def union(self, value_a, value_b):\n        root_key_a = self.find(value_a)\n        root_key_b = self.find(value_b)\n\n        if root_key_a is None or root_key_b is None:\n            raise ValueError("One or two values are not in sets")\n\n        if root_key_a == root_key_b:\n            return self\n\n        root_a = self.items[root_key_a]\n        root_b = self.items[root_key_b]\n\n        if root_a.get_rank() < root_b.get_rank():\n            root_b.add_child(root_a)\n        else:\n            root_a.add_child(root_b)\n\n        return self\n\n    def in_same_set(self, value_a, value_b):\n        root_key_a = self.find(value_a)\n        root_key_b = self.find(value_b)\n\n        if root_key_a is None or root_key_b is None:\n            raise ValueError("One or two values are not in sets")\n\n        return root_key_a == root_key_b\n',_='use std::collections::HashMap;\n\nstruct DisjointSetItem<T> {\n    value: T,\n    key_callback: Option<Box<dyn Fn(&T) -> String>>,\n    parent: Option<Box<DisjointSetItem<T>>>,\n    children: HashMap<String, Box<DisjointSetItem<T>>>,\n}\n\nimpl<T> DisjointSetItem<T> {\n    fn new(value: T, key_callback: Option<Box<dyn Fn(&T) -> String>>) -> Self {\n        DisjointSetItem {\n            value,\n            key_callback,\n            parent: None,\n            children: HashMap::new(),\n        }\n    }\n\n    fn get_key(&self) -> String {\n        if let Some(callback) = &self.key_callback {\n            callback(&self.value)\n        } else {\n            format!("{:?}", &self.value)\n        }\n    }\n\n    fn get_root(&self) -> &DisjointSetItem<T> {\n        if self.is_root() {\n            self\n        } else {\n            self.parent.as_ref().unwrap().get_root()\n        }\n    }\n\n    fn is_root(&self) -> bool {\n        self.parent.is_none()\n    }\n\n    fn get_rank(&self) -> usize {\n        if self.get_children().is_empty() {\n            0\n        } else {\n            self.get_children().len() + self.get_children().iter().map(|child| child.get_rank()).sum::<usize>()\n        }\n    }\n\n    fn get_children(&self) -> Vec<&DisjointSetItem<T>> {\n        self.children.values().map(|child| child.as_ref()).collect()\n    }\n\n    fn set_parent(&mut self, parent_item: Box<DisjointSetItem<T>>, force_setting_parent_child: bool) {\n        self.parent = Some(parent_item);\n        if force_setting_parent_child {\n            self.parent.as_mut().unwrap().add_child(Box::new(self.clone()));\n        }\n    }\n\n    fn add_child(&mut self, child_item: Box<DisjointSetItem<T>>) {\n        self.children.insert(child_item.get_key(), child_item);\n    }\n}\n\nstruct DisjointSet<T> {\n    key_callback: Option<Box<dyn Fn(&T) -> String>>,\n    items: HashMap<String, Box<DisjointSetItem<T>>>,\n}\n\nimpl<T> DisjointSet<T> {\n    fn new(key_callback: Option<Box<dyn Fn(&T) -> String>>) -> Self {\n        DisjointSet {\n            key_callback,\n            items: HashMap::new(),\n        }\n    }\n\n    fn make_set(&mut self, item_value: T) {\n        let disjoint_set_item = Box::new(DisjointSetItem::new(item_value, self.key_callback.clone()));\n\n        if !self.items.contains_key(&disjoint_set_item.get_key()) {\n            self.items.insert(disjoint_set_item.get_key(), disjoint_set_item);\n        }\n    }\n\n    fn find(&self, item_value: T) -> Option<String> {\n        let template_disjoint_item = Box::new(DisjointSetItem::new(item_value, self.key_callback.clone()));\n        if let Some(required_disjoint_item) = self.items.get(&template_disjoint_item.get_key()) {\n            Some(required_disjoint_item.get_root().get_key())\n        } else {\n            None\n        }\n    }\n\n    fn union(&mut self, value_a: T, value_b: T) -> Result<(), &\'static str> {\n        let root_key_a = self.find(value_a).ok_or("One or two values are not in sets")?;\n        let root_key_b = self.find(value_b).ok_or("One or two values are not in sets")?;\n\n        if root_key_a == root_key_b {\n            return Ok(());\n        }\n\n        let root_a = self.items.get_mut(&root_key_a).unwrap();\n        let root_b = self.items.get_mut(&root_key_b).unwrap();\n\n        if root_a.get_rank() < root_b.get_rank() {\n            root_b.add_child(Box::new(root_a.clone()));\n        } else {\n            root_a.add_child(Box::new(root_b.clone()));\n        }\n\n        Ok(())\n    }\n\n    fn in_same_set(&self, value_a: T, value_b: T) -> Result<bool, &\'static str> {\n        let root_key_a = self.find(value_a).ok_or("One or two values are not in sets")?;\n        let root_key_b = self.find(value_b).ok_or("One or two values are not in sets")?;\n\n        Ok(root_key_a == root_key_b)\n    }\n}\n',f='class DisjointSetItem<T> {\n  value: T;\n  keyCallback: ((value: T) => string) | undefined;\n  parent: DisjointSetItem<T> | null;\n  children: { [key: string]: DisjointSetItem<T> };\n\n  constructor(value: T, keyCallback?: (value: T) => string) {\n    this.value = value;\n    this.keyCallback = keyCallback;\n    this.parent = null;\n    this.children = {};\n  }\n\n  getKey(): string {\n    if (this.keyCallback) {\n      return this.keyCallback(this.value);\n    }\n    return String(this.value);\n  }\n\n  getRoot(): DisjointSetItem<T> {\n    return this.isRoot() ? this : this.parent!.getRoot();\n  }\n\n  isRoot(): boolean {\n    return this.parent === null;\n  }\n\n  getRank(): number {\n    if (this.getChildren().length === 0) {\n      return 0;\n    }\n\n    let rank = 0;\n\n    this.getChildren().forEach((child) => {\n      rank += 1;\n      rank += child.getRank();\n    });\n\n    return rank;\n  }\n\n  getChildren(): DisjointSetItem<T>[] {\n    return Object.values(this.children);\n  }\n\n  setParent(\n    parentItem: DisjointSetItem<T>,\n    forceSettingParentChild: boolean = true,\n  ): this {\n    this.parent = parentItem;\n    if (forceSettingParentChild) {\n      parentItem.addChild(this);\n    }\n\n    return this;\n  }\n\n  addChild(childItem: DisjointSetItem<T>): this {\n    this.children[childItem.getKey()] = childItem;\n    childItem.setParent(this, false);\n\n    return this;\n  }\n}\n\nclass DisjointSet<T> {\n  keyCallback: ((value: T) => string) | undefined;\n  items: { [key: string]: DisjointSetItem<T> };\n\n  constructor(keyCallback?: (value: T) => string) {\n    this.keyCallback = keyCallback;\n    this.items = {};\n  }\n\n  makeSet(itemValue: T): this {\n    const disjointSetItem = new DisjointSetItem(itemValue, this.keyCallback);\n\n    if (!this.items[disjointSetItem.getKey()]) {\n      this.items[disjointSetItem.getKey()] = disjointSetItem;\n    }\n\n    return this;\n  }\n\n  find(itemValue: T): string | null {\n    const templateDisjointItem = new DisjointSetItem(\n      itemValue,\n      this.keyCallback,\n    );\n    const requiredDisjointItem = this.items[templateDisjointItem.getKey()];\n\n    if (!requiredDisjointItem) {\n      return null;\n    }\n\n    return requiredDisjointItem.getRoot().getKey();\n  }\n\n  union(valueA: T, valueB: T): this {\n    const rootKeyA = this.find(valueA);\n    const rootKeyB = this.find(valueB);\n\n    if (rootKeyA === null || rootKeyB === null) {\n      throw new Error("One or two values are not in sets");\n    }\n\n    if (rootKeyA === rootKeyB) {\n      return this;\n    }\n\n    const rootA = this.items[rootKeyA];\n    const rootB = this.items[rootKeyB];\n\n    if (rootA.getRank() < rootB.getRank()) {\n      rootB.addChild(rootA);\n    } else {\n      rootA.addChild(rootB);\n    }\n\n    return this;\n  }\n\n  inSameSet(valueA: T, valueB: T): boolean {\n    const rootKeyA = this.find(valueA);\n    const rootKeyB = this.find(valueB);\n\n    if (rootKeyA === null || rootKeyB === null) {\n      throw new Error("One or two values are not in sets");\n    }\n\n    return rootKeyA === rootKeyB;\n  }\n}\n',j={title:"Disjoint Set",description:"Disjoint Set Data Structure",hide_table_of_contents:!0},k=void 0,y={},p=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function g(e){const n={code:"code",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:t(85792).A+""})}),"\n",(0,r.jsxs)("table",{children:[(0,r.jsxs)("thead",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Space"}),(0,r.jsx)("th",{colspan:"4",children:"Time"})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{}),(0,r.jsx)("th",{children:"Access"}),(0,r.jsx)("th",{children:"Lookup"}),(0,r.jsx)("th",{children:"Insertion"}),(0,r.jsx)("th",{children:"Deletion"})]})]}),(0,r.jsx)("tbody",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"fair",children:"O(n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"fair",children:"O(n)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,r.jsx)("td",{children:(0,r.jsx)("code",{className:"excellent",children:"O(1)"})})]})})]}),"\n",(0,r.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(o.A,{queryString:"primary",children:[(0,r.jsxs)(l.A,{value:"short",label:"Short",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Disjoint Set"})," is a data structure that allows efficient union and find operations on a set of elements."]}),(0,r.jsxs)(i,{children:[(0,r.jsx)("summary",{children:"Simplified"}),(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Disjoint Set"})," is like a smart party organizer. It keeps track of distinct groups (like people at a party), can merge groups, and quickly answer if 2 people belong to the same group. It's a way\nto manage and query non-overlapping groups efficiently."]})]})]}),(0,r.jsx)(l.A,{value:"detailed",label:"Detailed",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Disjoint Set"}),", also known as a union-find or merge-find set, is a data structure that manages a collection of elements split into non-overlapping subsets. It enables near-instant operations for\ncreating new sets, merging existing ones, and checking if elements belong to the same set. These operations are crucial in various applications, including Kruskal's algorithm for determining a\ngraph's minimum spanning tree. The speed of these operations is limited by the inverse Ackermann function."]})})]}),"\n",(0,r.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(o.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"practice",label:"Practice",children:(0,r.jsxs)("table",{children:[(0,r.jsx)("thead",{children:(0,r.jsxs)("tr",{children:[(0,r.jsx)("th",{children:"Aspect"}),(0,r.jsx)("th",{children:"Pseudo Code"})]})}),(0,r.jsxs)("tbody",{children:[(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Disjoint Set Item"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"get_key():\n  return value\n\nget_root():\n  if is_root():\n    return this\n  return parent.get_root()\n\nis_root():\n  return parent == \xf8\n\nget_rank():\n  if length of get_children() == 0:\n    return 0\n  rank = 0\n  for each child in get_children():\n    rank += 1\n    rank += child.get_rank()\n  return rank\n\nget_children():\n  return values of children\n\nset_parent(parent_item, force_setting_parent_child):\n  parent = parent_item\n  if force_setting_parent_child == True:\n    parent_item.add_child(this)\n\nadd_child(child_item):\n  children[child_item.get_key()] = child_item\n  child_item.set_parent(this, false)\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Make Set"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"make_set(item_value):\n  disjoint_set_item = DisjointSetItem(item_value, keyCallback)\n  if items[disjoint_set_item.get_key()] == \xf8:\n    items[disjoint_set_item.get_key()] = disjoint_set_item\n  return this\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Find"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"find(item_value):\n  template_disjoint_item = DisjointSetItem(item_value, keyCallback)\n  required_disjoint_item = items[template_disjoint_item.get_key()]\n  if required_disjoint_item == \xf8:\n    return \xf8\n  return required_disjoint_item.get_root().get_key()\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"Union"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"union(value_a, value_b):\n  root_key_a = find(value_a)\n  root_key_b = find(value_b)\n  if root_key_a == \xf8 or root_key_b == \xf8:\n    'One or two values are not in sets'\n  if root_key_a == root_key_b:\n    return this\n  root_a = items[root_key_a]\n  root_b = items[root_key_b]\n  if root_a.get_rank() < root_b.get_rank():\n    root_b.add_child(root_a)\n    return this\n  root_a.add_child(root_b)\n  return this\n"})})})]}),(0,r.jsxs)("tr",{children:[(0,r.jsx)("td",{children:"In Same Set"}),(0,r.jsx)("td",{children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"in_same_set(value_a, value_b):\n  root_key_a = find(value_a)\n  root_key_b = find(value_b)\n  if root_key_a == \xf8 or root_key_b == \xf8:\n    'One or two values are not in sets'\n  return root_key_a == root_key_b\n"})})})]})]})]})}),(0,r.jsx)(l.A,{value:"solution",label:"Solution",children:(0,r.jsxs)(o.A,{queryString:"code",children:[(0,r.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(a.A,{language:"go",children:c})}),(0,r.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(a.A,{language:"java",children:d})}),(0,r.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(a.A,{language:"js",children:u})}),(0,r.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(a.A,{language:"kotlin",children:m})}),(0,r.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(a.A,{language:"python",children:h})}),(0,r.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(a.A,{language:"rust",children:_})}),(0,r.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(a.A,{language:"ts",children:f})})]})})]})]})}function S(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}},85792:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/disjointSet-d754021d332db2f422c7e9813229d121.svg"}}]);