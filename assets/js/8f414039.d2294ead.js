"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[1992],{28606:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>m,contentTitle:()=>f,default:()=>v,frontMatter:()=>x,metadata:()=>t,toc:()=>b});const t=JSON.parse('{"id":"education/computer-science/algorithms/algo/interpolation-search","title":"Interpolation Search","description":"Interpolation Search","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/interpolation-search.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/interpolation-search","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/interpolation-search","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/interpolation-search.mdx","tags":[],"version":"current","frontMatter":{"title":"Interpolation Search","description":"Interpolation Search","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Integer Partition","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/integer-partition"},"next":{"title":"Is Power of Two","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/is-power-of-two"}}');var i=r(86070),a=r(15658),l=r(52421),o=r(74610),h=r(42953);const s="package main\n\nfunc interpolationSearch(arr []int, x int) int {\n    low := 0\n    high := len(arr) - 1\n\n    for low <= high && x >= arr[low] && x <= arr[high] {\n        if low == high {\n            if arr[low] == x {\n                return low\n            }\n            return -1\n        }\n\n        pos := low + ((x - arr[low]) * (high - low) / (arr[high] - arr[low]))\n\n        if arr[pos] == x {\n            return pos\n        }\n\n        if arr[pos] < x {\n            low = pos + 1\n        } else {\n            high = pos - 1\n        }\n    }\n\n    return -1\n}\n",c="public class InterpolationSearch {\n\n  public static int interpolationSearch(int[] arr, int x) {\n    int low = 0;\n    int high = arr.length - 1;\n\n    while (low <= high && x >= arr[low] && x <= arr[high]) {\n      if (low == high) {\n        if (arr[low] == x) {\n          return low;\n        }\n        return -1;\n      }\n\n      int pos = low + ((x - arr[low]) * (high - low) / (arr[high] - arr[low]));\n\n      if (arr[pos] == x) {\n        return pos;\n      }\n\n      if (arr[pos] < x) {\n        low = pos + 1;\n      } else {\n        high = pos - 1;\n      }\n    }\n\n    return -1;\n  }\n}\n",u="function interpolationSearch(arr, x) {\n  let low = 0;\n  let high = arr.length - 1;\n\n  while (low <= high && x >= arr[low] && x <= arr[high]) {\n    if (low === high) {\n      if (arr[low] === x) {\n        return low;\n      }\n      return -1;\n    }\n\n    let pos =\n      low +\n      Math.floor(((x - arr[low]) * (high - low)) / (arr[high] - arr[low]));\n\n    if (arr[pos] === x) {\n      return pos;\n    }\n\n    if (arr[pos] < x) {\n      low = pos + 1;\n    } else {\n      high = pos - 1;\n    }\n  }\n\n  return -1;\n}\n",p="fun interpolationSearch(arr: IntArray, x: Int): Int {\n    var low = 0\n    var high = arr.size - 1\n\n    while (low <= high && x >= arr[low] && x <= arr[high]) {\n        if (low == high) {\n            return if (arr[low] == x) low else -1\n        }\n\n        val pos = low + ((x - arr[low]) * (high - low) / (arr[high] - arr[low]))\n\n        if (arr[pos] == x) return pos\n\n        if (arr[pos] < x) low = pos + 1\n        else high = pos - 1\n    }\n\n    return -1\n}\n",g="def interpolation_search(arr, x):\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high and x >= arr[low] and x <= arr[high]:\n        if low == high:\n            if arr[low] == x:\n                return low\n            return -1\n\n        pos = low + ((x - arr[low]) * (high - low) // (arr[high] - arr[low]))\n\n        if arr[pos] == x:\n            return pos\n\n        if arr[pos] < x:\n            low = pos + 1\n        else:\n            high = pos - 1\n\n    return -1\n",d="fn interpolation_search(arr: &[i32], x: i32) -> Option<usize> {\n    let mut low = 0;\n    let mut high = arr.len() - 1;\n\n    while low <= high && x >= arr[low] && x <= arr[high] {\n        if low == high {\n            return if arr[low] == x { Some(low) } else { None };\n        }\n\n        let pos = low + ((x - arr[low]) * (high - low) as i32 / (arr[high] - arr[low])) as usize;\n\n        if arr[pos] == x {\n            return Some(pos);\n        }\n\n        if arr[pos] < x {\n            low = pos + 1;\n        } else {\n            high = pos - 1;\n        }\n    }\n\n    None\n}\n",w="function interpolationSearch(arr: number[], x: number): number {\n  let low = 0;\n  let high = arr.length - 1;\n\n  while (low <= high && x >= arr[low] && x <= arr[high]) {\n    if (low === high) {\n      return arr[low] === x ? low : -1;\n    }\n\n    let pos =\n      low +\n      Math.floor(((x - arr[low]) * (high - low)) / (arr[high] - arr[low]));\n\n    if (arr[pos] === x) {\n      return pos;\n    }\n\n    if (arr[pos] < x) {\n      low = pos + 1;\n    } else {\n      high = pos - 1;\n    }\n  }\n\n  return -1;\n}\n",x={title:"Interpolation Search",description:"Interpolation Search",hide_table_of_contents:!0},f=void 0,m={},b=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function j(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(l.A,{queryString:"primary",children:[(0,i.jsx)(o.A,{value:"definition",label:"Definition",children:(0,i.jsx)(e.p,{children:"Interpolation Search is an efficient searching algorithm that works on sorted arrays. It improves on binary search by using interpolation to find the probable position of the target value"})}),(0,i.jsx)(o.A,{value:"how",label:"Explanation",children:(0,i.jsx)(e.p,{children:"Calculate the probable position of the target value using the interpolation formula. Then, compare the target value with the element located at this probable position. If they match, return the index of the element. If the target value is greater than the element at the probable position, continue the search in the right subarray. Conversely, if the target value is smaller, search the left subarray. Continue this process until the element is found or the subarray reduces to an empty array"})}),(0,i.jsx)(o.A,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"To find where the target value might be, consider where it falls between the lowest and highest values in the array"}),"\n",(0,i.jsx)(e.li,{children:"Check if the value at this estimated position matches the target value"}),"\n",(0,i.jsx)(e.li,{children:"If it does, you've found the target value"}),"\n",(0,i.jsx)(e.li,{children:"If the estimated value is greater than the target, look in the lower half of the remaining array"}),"\n",(0,i.jsx)(e.li,{children:"If the estimated value is smaller than the target, look in the upper half"}),"\n",(0,i.jsx)(e.li,{children:"Repeat these steps until you find the target or you've searched through the entire array without finding it"}),"\n"]})}),(0,i.jsx)(o.A,{value:"tips",label:"Tips",children:(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"interpolation Search performs well when the elements in the array are uniformly distributed"}),"\n",(0,i.jsx)(e.li,{children:"it's more effective on large arrays than binary search, particularly if the elements are evenly distributed"}),"\n"]})})]}),"\n",(0,i.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(l.A,{queryString:"primary",children:[(0,i.jsx)(o.A,{value:"practice",label:"Practice",children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"interpolationSearch(arr, x):\n  low = 0\n  high = length(arr) - 1\n\n  while low <= high and x >= arr[low] and x <= arr[high]:\n    pos = low + ((high - low) / (arr[high] - arr[low])) * (x - arr[low])\n\n    if arr[pos] == x:\n      return pos\n    elif arr[pos] < x:\n      low = pos + 1\n    else:\n      high = pos - 1\n\n  return -1\n"})})}),(0,i.jsx)(o.A,{value:"solution",label:"Solution",children:(0,i.jsxs)(l.A,{queryString:"code",children:[(0,i.jsx)(o.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(h.A,{language:"go",children:s})}),(0,i.jsx)(o.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(h.A,{language:"java",children:c})}),(0,i.jsx)(o.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(h.A,{language:"js",children:u})}),(0,i.jsx)(o.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(h.A,{language:"kotlin",children:p})}),(0,i.jsx)(o.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(h.A,{language:"python",children:g})}),(0,i.jsx)(o.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(h.A,{language:"rust",children:d})}),(0,i.jsx)(o.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(h.A,{language:"ts",children:w})})]})})]})]})}function v(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(j,{...n})}):j(n)}}}]);