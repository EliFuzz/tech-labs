"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[2814],{68810:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>N,contentTitle:()=>y,default:()=>_,frontMatter:()=>p,metadata:()=>g,toc:()=>v});var t=r(11527),o=r(84135),s=r(40521),u=r(74109),i=r(80035);const c="package main\n\ntype Node struct {\n\tKey   int\n\tLeft  *Node\n\tRight *Node\n}\n\ntype BinarySearchTree struct {\n\tRoot *Node\n}\n\nfunc (bst *BinarySearchTree) insert(root *Node, key int) *Node {\n\tif root == nil {\n\t\treturn &Node{Key: key}\n\t}\n\n\tif key < root.Key {\n\t\troot.Left = bst.insert(root.Left, key)\n\t} else if key > root.Key {\n\t\troot.Right = bst.insert(root.Right, key)\n\t}\n\n\treturn root\n}\n\nfunc (bst *BinarySearchTree) search(root *Node, key int) *Node {\n\tif root == nil || root.Key == key {\n\t\treturn root\n\t}\n\n\tif key < root.Key {\n\t\treturn bst.search(root.Left, key)\n\t} else {\n\t\treturn bst.search(root.Right, key)\n\t}\n}\n\nfunc (bst *BinarySearchTree) findMin(root *Node) *Node {\n\tcurrent := root\n\tfor current != nil && current.Left != nil {\n\t\tcurrent = current.Left\n\t}\n\treturn current\n}\n\nfunc (bst *BinarySearchTree) findMax(root *Node) *Node {\n\tcurrent := root\n\tfor current != nil && current.Right != nil {\n\t\tcurrent = current.Right\n\t}\n\treturn current\n}\n\nfunc (bst *BinarySearchTree) findSuccessor(root *Node, key int) *Node {\n\tif root == nil {\n\t\treturn nil\n\t}\n\n\tvar successor *Node\n\tcurrent := root\n\n\tfor current != nil {\n\t\tif key < current.Key {\n\t\t\tsuccessor = current\n\t\t\tcurrent = current.Left\n\t\t} else {\n\t\t\tcurrent = current.Right\n\t\t}\n\t}\n\n\treturn successor\n}\n\nfunc (bst *BinarySearchTree) findPredecessor(root *Node, key int) *Node {\n\tif root == nil {\n\t\treturn nil\n\t}\n\n\tvar predecessor *Node\n\tcurrent := root\n\n\tfor current != nil {\n\t\tif key > current.Key {\n\t\t\tpredecessor = current\n\t\t\tcurrent = current.Right\n\t\t} else {\n\t\t\tcurrent = current.Left\n\t\t}\n\t}\n\n\treturn predecessor\n}\n\nfunc (bst *BinarySearchTree) deleteNode(root *Node, key int) *Node {\n\tif root == nil {\n\t\treturn nil\n\t}\n\n\tif key < root.Key {\n\t\troot.Left = bst.deleteNode(root.Left, key)\n\t} else if key > root.Key {\n\t\troot.Right = bst.deleteNode(root.Right, key)\n\t} else {\n\t\tif root.Left == nil {\n\t\t\treturn root.Right\n\t\t} else if root.Right == nil {\n\t\t\treturn root.Left\n\t\t}\n\n\t\tsuccessor := bst.findMin(root.Right)\n\t\troot.Key = successor.Key\n\t\troot.Right = bst.deleteNode(root.Right, successor.Key)\n\t}\n\n\treturn root\n}\n\nfunc (bst *BinarySearchTree) bfsRecursive(root *Node) {\n\tif root == nil {\n\t\treturn\n\t}\n\n\tqueue := []*Node{root}\n\tbst.bfsHelper(queue)\n}\n\nfunc (bst *BinarySearchTree) bfsHelper(queue []*Node) {\n\tif len(queue) == 0 {\n\t\treturn\n\t}\n\n\tcurrent := queue[0]\n\tqueue = queue[1:]\n\tfmt.Println(current.Key)\n\n\tif current.Left != nil {\n\t\tqueue = append(queue, current.Left)\n\t}\n\tif current.Right != nil {\n\t\tqueue = append(queue, current.Right)\n\t}\n\n\tbst.bfsHelper(queue)\n}\n\nfunc (bst *BinarySearchTree) bfsIterative(root *Node) {\n\tif root == nil {\n\t\treturn\n\t}\n\n\tqueue := []*Node{root}\n\n\tfor len(queue) > 0 {\n\t\tcurrent := queue[0]\n\t\tqueue = queue[1:]\n\t\tfmt.Println(current.Key)\n\n\t\tif current.Left != nil {\n\t\t\tqueue = append(queue, current.Left)\n\t\t}\n\t\tif current.Right != nil {\n\t\t\tqueue = append(queue, current.Right)\n\t\t}\n\t}\n}\n\nfunc (bst *BinarySearchTree) dfsPreOrderRecursive(root *Node) {\n\tif root == nil {\n\t\treturn\n\t}\n\tfmt.Println(root.Key)\n\tbst.dfsPreOrderRecursive(root.Left)\n\tbst.dfsPreOrderRecursive(root.Right)\n}\n\nfunc (bst *BinarySearchTree) dfsPreOrderIterative(root *Node) {\n\tif root == nil {\n\t\treturn\n\t}\n\n\tstack := []*Node{root}\n\n\tfor len(stack) > 0 {\n\t\tcurrent := stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t\tfmt.Println(current.Key)\n\n\t\tif current.Right != nil {\n\t\t\tstack = append(stack, current.Right)\n\t\t}\n\t\tif current.Left != nil {\n\t\t\tstack = append(stack, current.Left)\n\t\t}\n\t}\n}\n\nfunc (bst *BinarySearchTree) dfsInOrderRecursive(root *Node) {\n\tif root == nil {\n\t\treturn\n\t}\n\tbst.dfsInOrderRecursive(root.Left)\n\tfmt.Println(root.Key)\n\tbst.dfsInOrderRecursive(root.Right)\n}\n\nfunc (bst *BinarySearchTree) dfsInOrderIterative(root *Node) {\n\tif root == nil {\n\t\treturn\n\t}\n\n\tstack := []*Node{}\n\tcurrent := root\n\n\tfor current != nil || len(stack) > 0 {\n\t\tfor current != nil {\n\t\t\tstack = append(stack, current)\n\t\t\tcurrent = current.Left\n\t\t}\n\n\t\tcurrent = stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\t\tfmt.Println(current.Key)\n\n\t\tcurrent = current.Right\n\t}\n}\n\nfunc (bst *BinarySearchTree) dfsPostOrderRecursive(root *Node) {\n\tif root == nil {\n\t\treturn\n\t}\n\tbst.dfsPostOrderRecursive(root.Left)\n\tbst.dfsPostOrderRecursive(root.Right)\n\tfmt.Println(root.Key)\n}\n\nfunc (bst *BinarySearchTree) dfsPostOrderIterative(root *Node) {\n\tif root == nil {\n\t\treturn\n\t}\n\n\tstack1 := []*Node{}\n\tstack2 := []*Node{root}\n\n\tfor len(stack2) > 0 {\n\t\tcurrent := stack2[len(stack2)-1]\n\t\tstack2 = stack2[:len(stack2)-1]\n\t\tstack1 = append(stack1, current)\n\n\t\tif current.Left != nil {\n\t\t\tstack2 = append(stack2, current.Left)\n\t\t}\n\t\tif current.Right != nil {\n\t\t\tstack2 = append(stack2, current.Right)\n\t\t}\n\t}\n\n\tfor len(stack1) > 0 {\n\t\tcurrent := stack1[len(stack1)-1]\n\t\tstack1 = stack1[:len(stack1)-1]\n\t\tfmt.Println(current.Key)\n\t}\n}\n",l="import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Stack;\n\npublic class BinarySearchTree {\n\n  private Node root;\n\n  public Node insert(Node root, int key) {\n    if (root == null) {\n      return new Node(key);\n    }\n\n    if (key < root.key) {\n      root.left = insert(root.left, key);\n    } else if (key > root.key) {\n      root.right = insert(root.right, key);\n    }\n\n    return root;\n  }\n\n  public Node search(Node root, int key) {\n    if (root == null || root.key == key) {\n      return root;\n    }\n\n    return (key < root.key) ? search(root.left, key) : search(root.right, key);\n  }\n\n  public Node findMin(Node root) {\n    Node current = root;\n    while (current != null && current.left != null) {\n      current = current.left;\n    }\n    return current;\n  }\n\n  public Node findMax(Node root) {\n    Node current = root;\n    while (current != null && current.right != null) {\n      current = current.right;\n    }\n    return current;\n  }\n\n  public Node findSuccessor(Node root, int key) {\n    if (root == null) {\n      return null;\n    }\n\n    Node current = root;\n    Node successor = null;\n\n    while (current != null) {\n      if (key < current.key) {\n        successor = current;\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n    }\n\n    return successor;\n  }\n\n  public Node findPredecessor(Node root, int key) {\n    if (root == null) {\n      return null;\n    }\n\n    Node current = root;\n    Node predecessor = null;\n\n    while (current != null) {\n      if (key > current.key) {\n        predecessor = current;\n        current = current.right;\n      } else {\n        current = current.left;\n      }\n    }\n\n    return predecessor;\n  }\n\n  public Node deleteNode(Node root, int key) {\n    if (root == null) {\n      return null;\n    }\n\n    if (key < root.key) {\n      root.left = deleteNode(root.left, key);\n    } else if (key > root.key) {\n      root.right = deleteNode(root.right, key);\n    } else {\n      if (root.left == null) {\n        return root.right;\n      } else if (root.right == null) {\n        return root.left;\n      }\n\n      Node successor = findMin(root.right);\n      root.key = successor.key;\n\n      root.right = deleteNode(root.right, successor.key);\n    }\n\n    return root;\n  }\n\n  public void bfsRecursive(Node root) {\n    if (root == null) {\n      return;\n    }\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.add(root);\n\n    bfsHelper(queue);\n  }\n\n  private void bfsHelper(Queue<Node> queue) {\n    if (queue.isEmpty()) {\n      return;\n    }\n\n    Node current = queue.poll();\n    System.out.println(current.key);\n\n    if (current.left != null) {\n      queue.add(current.left);\n    }\n    if (current.right != null) {\n      queue.add(current.right);\n    }\n\n    bfsHelper(queue);\n  }\n\n  public void bfsIterative(Node root) {\n    if (root == null) {\n      return;\n    }\n\n    Queue<Node> queue = new LinkedList<>();\n    queue.add(root);\n\n    while (!queue.isEmpty()) {\n      Node current = queue.poll();\n      System.out.println(current.key);\n\n      if (current.left != null) {\n        queue.add(current.left);\n      }\n      if (current.right != null) {\n        queue.add(current.right);\n      }\n    }\n  }\n\n  public void dfsPreOrderRecursive(Node root) {\n    if (root == null) {\n      return;\n    }\n\n    System.out.println(root.key);\n    dfsPreOrderRecursive(root.left);\n    dfsPreOrderRecursive(root.right);\n  }\n\n  public void dfsPreOrderIterative(Node root) {\n    if (root == null) {\n      return;\n    }\n\n    Stack<Node> stack = new Stack<>();\n    stack.push(root);\n\n    while (!stack.isEmpty()) {\n      Node current = stack.pop();\n      System.out.println(current.key);\n\n      if (current.right != null) {\n        stack.push(current.right);\n      }\n      if (current.left != null) {\n        stack.push(current.left);\n      }\n    }\n  }\n\n  public void dfsInOrderRecursive(Node root) {\n    if (root == null) {\n      return;\n    }\n\n    dfsInOrderRecursive(root.left);\n    System.out.println(root.key);\n    dfsInOrderRecursive(root.right);\n  }\n\n  public void dfsInOrderIterative(Node root) {\n    if (root == null) {\n      return;\n    }\n\n    Stack<Node> stack = new Stack<>();\n    Node current = root;\n\n    while (current != null || !stack.isEmpty()) {\n      while (current != null) {\n        stack.push(current);\n        current = current.left;\n      }\n\n      current = stack.pop();\n      System.out.println(current.key);\n      current = current.right;\n    }\n  }\n\n  public void dfsPostOrderRecursive(Node root) {\n    if (root == null) {\n      return;\n    }\n\n    dfsPostOrderRecursive(root.left);\n    dfsPostOrderRecursive(root.right);\n    System.out.println(root.key);\n  }\n\n  public void dfsPostOrderIterative(Node root) {\n    if (root == null) {\n      return;\n    }\n\n    Stack<Node> stack1 = new Stack<>();\n    Stack<Node> stack2 = new Stack<>();\n    stack1.push(root);\n\n    while (!stack1.isEmpty()) {\n      Node current = stack1.pop();\n      stack2.push(current);\n\n      if (current.left != null) {\n        stack1.push(current.left);\n      }\n      if (current.right != null) {\n        stack1.push(current.right);\n      }\n    }\n\n    while (!stack2.isEmpty()) {\n      System.out.println(stack2.pop().key);\n    }\n  }\n\n  public static class Node {\n\n    int key;\n    Node left;\n    Node right;\n\n    public Node(int key) {\n      this.key = key;\n    }\n  }\n}\n",d="class BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(root, key) {\n    if (root === null) {\n      return { key, left: null, right: null };\n    }\n\n    if (key < root.key) {\n      root.left = this.insert(root.left, key);\n    } else if (key > root.key) {\n      root.right = this.insert(root.right, key);\n    }\n\n    return root;\n  }\n\n  search(root, key) {\n    if (root === null || root.key === key) {\n      return root;\n    }\n\n    return key < root.key\n      ? this.search(root.left, key)\n      : this.search(root.right, key);\n  }\n\n  findMin(root) {\n    let current = root;\n    while (current && current.left !== null) {\n      current = current.left;\n    }\n    return current;\n  }\n\n  findMax(root) {\n    let current = root;\n    while (current && current.right !== null) {\n      current = current.right;\n    }\n    return current;\n  }\n\n  findSuccessor(root, key) {\n    if (root === null) {\n      return null;\n    }\n\n    let current = root;\n    let successor = null;\n\n    while (current !== null) {\n      if (key < current.key) {\n        successor = current;\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n    }\n\n    return successor;\n  }\n\n  findPredecessor(root, key) {\n    if (root === null) {\n      return null;\n    }\n\n    let current = root;\n    let predecessor = null;\n\n    while (current !== null) {\n      if (key > current.key) {\n        predecessor = current;\n        current = current.right;\n      } else {\n        current = current.left;\n      }\n    }\n\n    return predecessor;\n  }\n\n  deleteNode(root, key) {\n    if (root === null) {\n      return null;\n    }\n\n    if (key < root.key) {\n      root.left = this.deleteNode(root.left, key);\n    } else if (key > root.key) {\n      root.right = this.deleteNode(root.right, key);\n    } else {\n      if (root.left === null) {\n        return root.right;\n      } else if (root.right === null) {\n        return root.left;\n      }\n\n      const successor = this.findMin(root.right);\n      root.key = successor ? successor.key : 0;\n\n      root.right = this.deleteNode(root.right, successor ? successor.key : 0);\n    }\n\n    return root;\n  }\n\n  bfsRecursive(root) {\n    if (root === null) {\n      return;\n    }\n\n    const queue = [root];\n\n    this.bfsHelper(queue);\n  }\n\n  bfsHelper(queue) {\n    if (queue.length === 0) {\n      return;\n    }\n\n    const current = queue.shift();\n    console.log(current.key);\n\n    current.left && queue.push(current.left);\n    current.right && queue.push(current.right);\n\n    this.bfsHelper(queue);\n  }\n\n  bfsIterative(root) {\n    if (root === null) {\n      return;\n    }\n\n    const queue = [root];\n\n    while (queue.length > 0) {\n      const current = queue.shift();\n      console.log(current.key);\n\n      current.left && queue.push(current.left);\n      current.right && queue.push(current.right);\n    }\n  }\n\n  dfsPreOrderRecursive(root) {\n    if (root === null) {\n      return;\n    }\n    console.log(root.key);\n    this.dfsPreOrderRecursive(root.left);\n    this.dfsPreOrderRecursive(root.right);\n  }\n\n  dfsPreOrderIterative(root) {\n    if (root === null) {\n      return;\n    }\n\n    const stack = [root];\n\n    while (stack.length > 0) {\n      const current = stack.pop();\n      console.log(current.key);\n\n      current.right && stack.push(current.right);\n      current.left && stack.push(current.left);\n    }\n  }\n\n  dfsInOrderRecursive(root) {\n    if (root === null) {\n      return;\n    }\n    this.dfsInOrderRecursive(root.left);\n    console.log(root.key);\n    this.dfsInOrderRecursive(root.right);\n  }\n\n  dfsInOrderIterative(root) {\n    if (root === null) {\n      return;\n    }\n\n    const stack = [];\n    let current = root;\n\n    while (current !== null || stack.length > 0) {\n      while (current !== null) {\n        stack.push(current);\n        current = current.left;\n      }\n\n      current = stack.pop();\n      console.log(current.key);\n      current = current.right;\n    }\n  }\n\n  dfsPostOrderRecursive(root) {\n    if (root === null) {\n      return;\n    }\n    this.dfsPostOrderRecursive(root.left);\n    this.dfsPostOrderRecursive(root.right);\n    console.log(root.key);\n  }\n\n  dfsPostOrderIterative(root) {\n    if (root === null) {\n      return;\n    }\n\n    const stack1 = [];\n    const stack2 = [];\n    stack1.push(root);\n\n    while (stack1.length > 0) {\n      const current = stack1.pop();\n      stack2.push(current);\n\n      current.left && stack1.push(current.left);\n      current.right && stack1.push(current.right);\n    }\n\n    while (stack2.length > 0) {\n      console.log(stack2.pop().key);\n    }\n  }\n}\n",f="class BinarySearchTree {\n    data class Node(var key: Int, var left: Node? = null, var right: Node? = null)\n\n    var root: Node? = null\n\n    fun insert(root: Node?, key: Int): Node {\n        if (root == null) {\n            return Node(key)\n        }\n\n        if (key < root.key) {\n            root.left = insert(root.left, key)\n        } else if (key > root.key) {\n            root.right = insert(root.right, key)\n        }\n\n        return root\n    }\n\n    fun search(root: Node?, key: Int): Node? {\n        if (root == null || root.key == key) {\n            return root\n        }\n\n        return if (key < root.key) {\n            search(root.left, key)\n        } else {\n            search(root.right, key)\n        }\n    }\n\n    fun findMin(root: Node?): Node? {\n        var current = root\n        while (current?.left != null) {\n            current = current.left\n        }\n        return current\n    }\n\n    fun findMax(root: Node?): Node? {\n        var current = root\n        while (current?.right != null) {\n            current = current.right\n        }\n        return current\n    }\n\n    fun findSuccessor(root: Node?, key: Int): Node? {\n        if (root == null) {\n            return null\n        }\n\n        var current = root\n        var successor: Node? = null\n\n        while (current != null) {\n            if (key < current.key) {\n                successor = current\n                current = current.left\n            } else {\n                current = current.right\n            }\n        }\n\n        return successor\n    }\n\n    fun findPredecessor(root: Node?, key: Int): Node? {\n        if (root == null) {\n            return null\n        }\n\n        var current = root\n        var predecessor: Node? = null\n\n        while (current != null) {\n            if (key > current.key) {\n                predecessor = current\n                current = current.right\n            } else {\n                current = current.left\n            }\n        }\n\n        return predecessor\n    }\n\n    fun deleteNode(root: Node?, key: Int): Node? {\n        if (root == null) {\n            return null\n        }\n\n        if (key < root.key) {\n            root.left = deleteNode(root.left, key)\n        } else if (key > root.key) {\n            root.right = deleteNode(root.right, key)\n        } else {\n            if (root.left == null) {\n                return root.right\n            } else if (root.right == null) {\n                return root.left\n            }\n\n            val successor = findMin(root.right)\n            root.key = successor?.key ?: 0\n\n            root.right = deleteNode(root.right, successor?.key ?: 0)\n        }\n\n        return root\n    }\n\n    fun bfsRecursive(root: Node?) {\n        if (root == null) {\n            return\n        }\n\n        val queue = mutableListOf<Node?>()\n        queue.add(root)\n\n        bfsHelper(queue)\n    }\n\n    private fun bfsHelper(queue: MutableList<Node?>) {\n        if (queue.isEmpty()) {\n            return\n        }\n\n        val current = queue.removeAt(0)\n        println(it.key)\n\n        current?.left?.let { queue.add(it) }\n        current?.right?.let { queue.add(it) }\n\n        bfsHelper(queue)\n    }\n\n    fun bfsIterative(root: Node?) {\n        if (root == null) {\n            return\n        }\n\n        val queue = mutableListOf<Node?>()\n        queue.add(root)\n\n        while (queue.isNotEmpty()) {\n            val current = queue.removeAt(0)\n            println(it.key)\n\n            current?.left?.let { queue.add(it) }\n            current?.right?.let { queue.add(it) }\n        }\n    }\n\n    fun dfsPreOrderRecursive(root: Node?) {\n        if (root == null) {\n            return\n        }\n        println(it.key)\n        dfsPreOrderRecursive(root.left)\n        dfsPreOrderRecursive(root.right)\n    }\n\n    fun dfsPreOrderIterative(root: Node?) {\n        if (root == null) {\n            return\n        }\n\n        val stack = mutableListOf<Node?>()\n        stack.add(root)\n\n        while (stack.isNotEmpty()) {\n            val current = stack.removeAt(stack.size - 1)\n            println(it.key)\n\n            current?.right?.let { stack.add(it) }\n            current?.left?.let { stack.add(it) }\n        }\n    }\n\n    fun dfsInOrderRecursive(root: Node?) {\n        if (root == null) {\n            return\n        }\n        dfsInOrderRecursive(root.left)\n        println(it.key)\n        dfsInOrderRecursive(root.right)\n    }\n\n    fun dfsInOrderIterative(root: Node?) {\n        if (root == null) {\n            return\n        }\n\n        val stack = mutableListOf<Node?>()\n        var current = root\n\n        while (current != null || stack.isNotEmpty()) {\n            while (current != null) {\n                stack.add(current)\n                current = current.left\n            }\n\n            current = stack.removeAt(stack.size - 1)\n            println(it.key)\n            current = current.right\n        }\n    }\n\n    fun dfsPostOrderRecursive(root: Node?) {\n        if (root == null) {\n            return\n        }\n        dfsPostOrderRecursive(root.left)\n        dfsPostOrderRecursive(root.right)\n        println(it.key)\n    }\n\n    fun dfsPostOrderIterative(root: Node?) {\n        if (root == null) {\n            return\n        }\n\n        val stack1 = mutableListOf<Node?>()\n        val stack2 = mutableListOf<Node?>()\n        stack1.add(root)\n\n        while (stack1.isNotEmpty()) {\n            val current = stack1.removeAt(stack1.size - 1)\n            stack2.add(current)\n\n            current?.left?.let { stack1.add(it) }\n            current?.right?.let { stack1.add(it) }\n        }\n\n        while (stack2.isNotEmpty()) {\n            println(it.key)\n        }\n    }\n}\n",a="class BinarySearchTree:\n    class Node:\n        def __init__(self, key, left=None, right=None):\n            self.key = key\n            self.left = left\n            self.right = right\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, root, key):\n        if root is None:\n            return self.Node(key)\n\n        if key < root.key:\n            root.left = self.insert(root.left, key)\n        elif key > root.key:\n            root.right = self.insert(root.right, key)\n\n        return root\n\n    def search(self, root, key):\n        if root is None or root.key == key:\n            return root\n\n        return self.search(root.left, key) if key < root.key else self.search(root.right, key)\n\n    def find_min(self, root):\n        current = root\n        while current and current.left is not None:\n            current = current.left\n        return current\n\n    def find_max(self, root):\n        current = root\n        while current and current.right is not None:\n            current = current.right\n        return current\n\n    def find_successor(self, root, key):\n        if root is None:\n            return None\n\n        current, successor = root, None\n\n        while current is not None:\n            if key < current.key:\n                successor = current\n                current = current.left\n            else:\n                current = current.right\n\n        return successor\n\n    def find_predecessor(self, root, key):\n        if root is None:\n            return None\n\n        current, predecessor = root, None\n\n        while current is not None:\n            if key > current.key:\n                predecessor = current\n                current = current.right\n            else:\n                current = current.left\n\n        return predecessor\n\n    def delete_node(self, root, key):\n        if root is None:\n            return None\n\n        if key < root.key:\n            root.left = self.delete_node(root.left, key)\n        elif key > root.key:\n            root.right = self.delete_node(root.right, key)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n\n            successor = self.find_min(root.right)\n            root.key = successor.key\n\n            root.right = self.delete_node(root.right, successor.key)\n\n        return root\n\n    def bfs_recursive(self, root):\n        if root is None:\n            return\n\n        queue = [root]\n        self.bfs_helper(queue)\n\n    def bfs_helper(self, queue):\n        if not queue:\n            return\n\n        current = queue.pop(0)\n        print(current.key)\n\n        if current.left:\n            queue.append(current.left)\n        if current.right:\n            queue.append(current.right)\n\n        self.bfs_helper(queue)\n\n    def bfs_iterative(self, root):\n        if root is None:\n            return\n\n        queue = [root]\n\n        while queue:\n            current = queue.pop(0)\n            print(current.key)\n\n            if current.left:\n                queue.append(current.left)\n            if current.right:\n                queue.append(current.right)\n\n    def dfs_pre_order_recursive(self, root):\n        if root is None:\n            return\n\n        print(root.key)\n        self.dfs_pre_order_recursive(root.left)\n        self.dfs_pre_order_recursive(root.right)\n\n    def dfs_pre_order_iterative(self, root):\n        if root is None:\n            return\n\n        stack = [root]\n\n        while stack:\n            current = stack.pop()\n            print(current.key)\n\n            if current.right:\n                stack.append(current.right)\n            if current.left:\n                stack.append(current.left)\n\n    def dfs_in_order_recursive(self, root):\n        if root is None:\n            return\n\n        self.dfs_in_order_recursive(root.left)\n        print(root.key)\n        self.dfs_in_order_recursive(root.right)\n\n    def dfs_in_order_iterative(self, root):\n        if root is None:\n            return\n\n        stack = []\n        current = root\n\n        while current or stack:\n            while current:\n                stack.append(current)\n                current = current.left\n\n            current = stack.pop()\n            print(current.key)\n            current = current.right\n\n    def dfs_post_order_recursive(self, root):\n        if root is None:\n            return\n\n        self.dfs_post_order_recursive(root.left)\n        self.dfs_post_order_recursive(root.right)\n        print(root.key)\n\n    def dfs_post_order_iterative(self, root):\n        if root is None:\n            return\n\n        stack1 = []\n        stack2 = []\n        stack1.append(root)\n\n        while stack1:\n            current = stack1.pop()\n            stack2.append(current)\n\n            if current.left:\n                stack1.append(current.left)\n            if current.right:\n                stack1.append(current.right)\n\n        while stack2:\n            print(stack2.pop().key)\n",h='use std::collections::VecDeque;\n\n#[derive(Debug)]\nstruct Node {\n    key: i32,\n    left: Option<Box<Node>>,\n    right: Option<Box<Node>>,\n}\n\nimpl Node {\n    fn new(key: i32) -> Self {\n        Node {\n            key,\n            left: None,\n            right: None,\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct BinarySearchTree {\n    root: Option<Box<Node>>,\n}\n\nimpl BinarySearchTree {\n    fn new() -> Self {\n        BinarySearchTree { root: None }\n    }\n\n    fn insert(&mut self, root: Option<Box<Node>>, key: i32) -> Box<Node> {\n        if let Some(mut node) = root {\n            if key < node.key {\n                node.left = Some(self.insert(node.left.take(), key));\n            } else if key > node.key {\n                node.right = Some(self.insert(node.right.take(), key));\n            }\n            node\n        } else {\n            Box::new(Node::new(key))\n        }\n    }\n\n    fn search(&self, root: &Option<Box<Node>>, key: i32) -> Option<&Box<Node>> {\n        match root {\n            Some(node) => {\n                if node.key == key {\n                    Some(node)\n                } else if key < node.key {\n                    self.search(&node.left, key)\n                } else {\n                    self.search(&node.right, key)\n                }\n            }\n            None => None,\n        }\n    }\n\n    fn find_min(&self, root: &Option<Box<Node>>) -> Option<&Box<Node>> {\n        let mut current = root;\n        while let Some(node) = current {\n            if let Some(left_node) = &node.left {\n                current = Some(left_node);\n            } else {\n                return Some(node);\n            }\n        }\n        None\n    }\n\n    fn find_max(&self, root: &Option<Box<Node>>) -> Option<&Box<Node>> {\n        let mut current = root;\n        while let Some(node) = current {\n            if let Some(right_node) = &node.right {\n                current = Some(right_node);\n            } else {\n                return Some(node);\n            }\n        }\n        None\n    }\n\n    fn find_successor(&self, root: &Option<Box<Node>>, key: i32) -> Option<&Box<Node>> {\n        let mut current = root;\n        let mut successor = None;\n\n        while let Some(node) = current {\n            if key < node.key {\n                successor = Some(node);\n                current = Some(&node.left);\n            } else {\n                current = Some(&node.right);\n            }\n        }\n\n        successor\n    }\n\n    fn find_predecessor(&self, root: &Option<Box<Node>>, key: i32) -> Option<&Box<Node>> {\n        let mut current = root;\n        let mut predecessor = None;\n\n        while let Some(node) = current {\n            if key > node.key {\n                predecessor = Some(node);\n                current = Some(&node.right);\n            } else {\n                current = Some(&node.left);\n            }\n        }\n\n        predecessor\n    }\n\n    fn delete_node(&mut self, root: Option<Box<Node>>, key: i32) -> Option<Box<Node>> {\n        if let Some(mut node) = root {\n            if key < node.key {\n                node.left = self.delete_node(node.left.take(), key);\n            } else if key > node.key {\n                node.right = self.delete_node(node.right.take(), key);\n            } else {\n                if node.left.is_none() {\n                    return node.right;\n                } else if node.right.is_none() {\n                    return node.left;\n                }\n\n                if let Some(successor) = self.find_min(&node.right) {\n                    node.key = successor.key;\n                    node.right = self.delete_node(node.right.take(), successor.key);\n                }\n            }\n            Some(node)\n        } else {\n            None\n        }\n    }\n\n    fn bfs_recursive(&self, root: &Option<Box<Node>>) {\n        if let Some(node) = root {\n            let mut queue = VecDeque::new();\n            queue.push_back(node);\n\n            self.bfs_helper(&queue);\n        }\n    }\n\n    fn bfs_helper(&self, queue: &VecDeque<&Box<Node>>) {\n        let mut queue = queue.clone();\n        if let Some(current) = queue.pop_front() {\n            println!("{}", current.key);\n\n            if let Some(left_node) = &current.left {\n                queue.push_back(left_node);\n            }\n            if let Some(right_node) = &current.right {\n                queue.push_back(right_node);\n            }\n\n            self.bfs_helper(&queue);\n        }\n    }\n\n    fn bfs_iterative(&self, root: &Option<Box<Node>>) {\n        if let Some(node) = root {\n            let mut queue = VecDeque::new();\n            queue.push_back(node);\n\n            while let Some(current) = queue.pop_front() {\n                println!("{}", current.key);\n\n                if let Some(left_node) = &current.left {\n                    queue.push_back(left_node);\n                }\n                if let Some(right_node) = &current.right {\n                    queue.push_back(right_node);\n                }\n            }\n        }\n    }\n\n    fn dfs_pre_order_recursive(&self, root: &Option<Box<Node>>) {\n        if let Some(node) = root {\n            println!("{}", node.key);\n            self.dfs_pre_order_recursive(&node.left);\n            self.dfs_pre_order_recursive(&node.right);\n        }\n    }\n\n    fn dfs_pre_order_iterative(&self, root: &Option<Box<Node>>) {\n        if let Some(node) = root {\n            let mut stack = vec![node];\n\n            while let Some(current) = stack.pop() {\n                println!("{}", current.key);\n\n                if let Some(right_node) = &current.right {\n                    stack.push(right_node);\n                }\n                if let Some(left_node) = &current.left {\n                    stack.push(left_node);\n                }\n            }\n        }\n    }\n\n    fn dfs_in_order_recursive(&self, root: &Option<Box<Node>>) {\n        if let Some(node) = root {\n            self.dfs_in_order_recursive(&node.left);\n            println!("{}", node.key);\n            self.dfs_in_order_recursive(&node.right);\n        }\n    }\n\n    fn dfs_in_order_iterative(&self, root: &Option<Box<Node>>) {\n        let mut stack = Vec::new();\n        let mut current = root;\n\n        while let Some(node) = current {\n            stack.push(node);\n            current = &node.left;\n        }\n\n        while let Some(node) = stack.pop() {\n            println!("{}", node.key);\n            current = &node.right;\n\n            while let Some(node) = current {\n                stack.push(node);\n                current = &node.left;\n            }\n        }\n    }\n\n    fn dfs_post_order_recursive(&self, root: &Option<Box<Node>>) {\n        if let Some(node) = root {\n            self.dfs_post_order_recursive(&node.left);\n            self.dfs_post_order_recursive(&node.right);\n            println!("{}", node.key);\n        }\n    }\n\n    fn dfs_post_order_iterative(&self, root: &Option<Box<Node>>) {\n        if let Some(node) = root {\n            let mut stack1 = Vec::new();\n            let mut stack2 = Vec::new();\n            stack1.push(node);\n\n            while let Some(current) = stack1.pop() {\n                stack2.push(current.clone());\n\n                if let Some(left_node) = &current.left {\n                    stack1.push(left_node\n',k="class Node {\n  key: number;\n  left: Node | null;\n  right: Node | null;\n\n  constructor(\n    key: number,\n    left: Node | null = null,\n    right: Node | null = null,\n  ) {\n    this.key = key;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nclass BinarySearchTree {\n  root: Node | null;\n\n  constructor() {\n    this.root = null;\n  }\n\n  insert(root: Node | null, key: number): Node {\n    if (root === null) {\n      return new Node(key);\n    }\n\n    if (key < root.key) {\n      root.left = this.insert(root.left, key);\n    } else if (key > root.key) {\n      root.right = this.insert(root.right, key);\n    }\n\n    return root;\n  }\n\n  search(root: Node | null, key: number): Node | null {\n    if (root === null || root.key === key) {\n      return root;\n    }\n\n    return key < root.key\n      ? this.search(root.left, key)\n      : this.search(root.right, key);\n  }\n\n  findMin(root: Node | null): Node | null {\n    let current = root;\n    while (current?.left !== null) {\n      current = current.left;\n    }\n    return current;\n  }\n\n  findMax(root: Node | null): Node | null {\n    let current = root;\n    while (current?.right !== null) {\n      current = current.right;\n    }\n    return current;\n  }\n\n  findSuccessor(root: Node | null, key: number): Node | null {\n    if (root === null) {\n      return null;\n    }\n\n    let current: Node | null = root;\n    let successor: Node | null = null;\n\n    while (current !== null) {\n      if (key < current.key) {\n        successor = current;\n        current = current.left;\n      } else {\n        current = current.right;\n      }\n    }\n\n    return successor;\n  }\n\n  findPredecessor(root: Node | null, key: number): Node | null {\n    if (root === null) {\n      return null;\n    }\n\n    let current: Node | null = root;\n    let predecessor: Node | null = null;\n\n    while (current !== null) {\n      if (key > current.key) {\n        predecessor = current;\n        current = current.right;\n      } else {\n        current = current.left;\n      }\n    }\n\n    return predecessor;\n  }\n\n  deleteNode(root: Node | null, key: number): Node | null {\n    if (root === null) {\n      return null;\n    }\n\n    if (key < root.key) {\n      root.left = this.deleteNode(root.left, key);\n    } else if (key > root.key) {\n      root.right = this.deleteNode(root.right, key);\n    } else {\n      if (root.left === null) {\n        return root.right;\n      } else if (root.right === null) {\n        return root.left;\n      }\n\n      const successor = this.findMin(root.right);\n      root.key = successor?.key || 0;\n\n      root.right = this.deleteNode(root.right, successor?.key || 0);\n    }\n\n    return root;\n  }\n\n  bfsRecursive(root: Node | null): void {\n    if (root === null) {\n      return;\n    }\n\n    const queue: (Node | null)[] = [root];\n    this.bfsHelper(queue);\n  }\n\n  bfsIterative(root: Node | null): void {\n    if (root === null) {\n      return;\n    }\n\n    const queue: (Node | null)[] = [root];\n\n    while (queue.length > 0) {\n      const current = queue.shift();\n      if (current !== undefined) {\n        console.log(current.key);\n\n        if (current.left !== null) {\n          queue.push(current.left);\n        }\n        if (current.right !== null) {\n          queue.push(current.right);\n        }\n      }\n    }\n  }\n\n  dfsPreOrderRecursive(root: Node | null): void {\n    if (root === null) {\n      return;\n    }\n\n    console.log(root.key);\n    this.dfsPreOrderRecursive(root.left);\n    this.dfsPreOrderRecursive(root.right);\n  }\n\n  dfsPreOrderIterative(root: Node | null): void {\n    if (root === null) {\n      return;\n    }\n\n    const stack: (Node | null)[] = [root];\n\n    while (stack.length > 0) {\n      const current = stack.pop();\n      if (current !== undefined) {\n        console.log(current.key);\n\n        if (current.right !== null) {\n          stack.push(current.right);\n        }\n        if (current.left !== null) {\n          stack.push(current.left);\n        }\n      }\n    }\n  }\n\n  dfsInOrderRecursive(root: Node | null): void {\n    if (root === null) {\n      return;\n    }\n\n    this.dfsInOrderRecursive(root.left);\n    console.log(root.key);\n    this.dfsInOrderRecursive(root.right);\n  }\n\n  dfsInOrderIterative(root: Node | null): void {\n    if (root === null) {\n      return;\n    }\n\n    const stack: (Node | null)[] = [];\n    let current: Node | null = root;\n\n    while (current !== null || stack.length > 0) {\n      while (current !== null) {\n        stack.push(current);\n        current = current.left;\n      }\n\n      current = stack.pop();\n      if (current !== undefined) {\n        console.log(current.key);\n        current = current.right;\n      }\n    }\n  }\n\n  dfsPostOrderRecursive(root: Node | null): void {\n    if (root === null) {\n      return;\n    }\n\n    this.dfsPostOrderRecursive(root.left);\n    this.dfsPostOrderRecursive(root.right);\n    console.log(root.key);\n  }\n\n  dfsPostOrderIterative(root: Node | null): void {\n    if (root === null) {\n      return;\n    }\n\n    const stack1: (Node | null)[] = [];\n    const stack2: (Node | null)[] = [];\n    stack1.push(root);\n\n    while (stack1.length > 0) {\n      const current = stack1.pop();\n      if (current !== undefined) {\n        stack2.push(current);\n\n        if (current.left !== null) {\n          stack1.push(current.left);\n        }\n        if (current.right !== null) {\n          stack1.push(current.right);\n        }\n      }\n    }\n\n    while (stack2.length > 0) {\n      const current = stack2.pop();\n      if (current !== undefined) {\n        console.log(current.key);\n      }\n    }\n  }\n\n  private bfsHelper(queue: (Node | null)[]): void {\n    if (queue.length === 0) {\n      return;\n    }\n\n    const current = queue.shift();\n    if (current !== undefined) {\n      console.log(current.key);\n\n      if (current.left !== null) {\n        queue.push(current.left);\n      }\n      if (current.right !== null) {\n        queue.push(current.right);\n      }\n\n      this.bfsHelper(queue);\n    }\n  }\n}\n",p={title:"Binary Search Tree",description:"Binary Search Tree Data Structure",hide_table_of_contents:!0},y=void 0,g={id:"education/computer-science/data-structures/basic/binary-search-tree",title:"Binary Search Tree",description:"Binary Search Tree Data Structure",source:"@site/docs/education/01-computer-science/09-data-structures/02-basic/10-binary-search-tree.mdx",sourceDirName:"education/01-computer-science/09-data-structures/02-basic",slug:"/education/computer-science/data-structures/basic/binary-search-tree",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/binary-search-tree",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/10-binary-search-tree.mdx",tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"Binary Search Tree",description:"Binary Search Tree Data Structure",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Trie",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/trie"},next:{title:"AVL Tree",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/avl-tree"}},N={},v=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function m(e){const n={code:"code",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components},{Details:p}=n;return p||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:r(91970).Z+""})}),"\n",(0,t.jsxs)("table",{children:[(0,t.jsxs)("thead",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Space"}),(0,t.jsx)("th",{colspan:"4",children:"Time"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{}),(0,t.jsx)("th",{children:"Access"}),(0,t.jsx)("th",{children:"Lookup"}),(0,t.jsx)("th",{children:"Insertion"}),(0,t.jsx)("th",{children:"Deletion"})]})]}),(0,t.jsx)("tbody",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"fair",children:"O(n)"})}),(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"good",children:"O(log n)"})}),(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"good",children:"O(log n)"})}),(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"good",children:"O(log n)"})}),(0,t.jsx)("td",{children:(0,t.jsx)("code",{className:"good",children:"O(log n)"})})]})})]}),"\n",(0,t.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,t.jsxs)(s.Z,{queryString:"primary",children:[(0,t.jsxs)(u.Z,{value:"short",label:"Short",children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Binary Search Tree"})," is a data structure that organizes elements in a sorted manner, where each node can have at most 2 children: a left and a right child. This makes it efficient for searching,\ninsertion, and deletion operations."]}),(0,t.jsxs)(p,{children:[(0,t.jsx)("summary",{children:"Simplified"}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Binary Search Tree"}),' is like a library system. Each book (or "node") has a unique identifier and up to 2 related books. You start from a certain point (the "root") and go left if the book you\'re\nlooking for has a smaller identifier, right if it\'s larger. This way, you eliminate half of the remaining books with each step, making the search efficient.']})]})]}),(0,t.jsxs)(u.Z,{value:"detailed",label:"Detailed",children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Binary Search Trees (BSTs)"})," are data structures that store items like numbers or names in memory. They're used for quick lookup, addition, and removal of items, and can be used to create\ndynamic sets of items or lookup tables."]}),(0,t.jsx)(n.p,{children:"BSTs maintain their keys in sorted order, allowing operations to use binary search principles. When searching for a key or a place to insert a new key, they traverse the tree from root to leaf,\ncomparing keys stored in the nodes and deciding to continue searching in the left or right subtrees based on the comparison."}),(0,t.jsx)(n.p,{children:"On average, each comparison lets the operations skip about half of the tree, making each lookup, insertion, or deletion time proportional to the logarithm of the number of items in the tree. This\nis faster than the linear time needed to find items by key in an unsorted array, but slower than operations on hash tables."})]})]}),"\n",(0,t.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,t.jsxs)(s.Z,{queryString:"primary",children:[(0,t.jsx)(u.Z,{value:"practice",label:"Practice",children:(0,t.jsxs)("table",{children:[(0,t.jsx)("thead",{children:(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Aspect"}),(0,t.jsx)("th",{children:"Pseudo Code"})]})}),(0,t.jsxs)("tbody",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"Insertion"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"insert(root, key):\n  if root == \xf8:\n    return new Node(key)\n  if key < root.key:\n    root.left = insert(root.left, key)\n  else if key > root.key:\n    root.right = insert(root.right, key)\n  return root\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"Search Node"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"search(root, key):\n  if root == \xf8 or root.key == key:\n    return root\n  if key < root.key:\n    return search(root.left, key)\n  return search(root.right, key)\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"Find MIN"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"find_min(root):\n  while root.left != \xf8:\n    root = root.left\n  return root\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"Find MAX"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"find_max(root):\n  while root.right != \xf8:\n    root = root.right\n  return root\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"Find Successor"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"find_successor(root, key):\n  if root == \xf8:\n    return \xf8\n\n  successor = \xf8\n  while root != \xf8:\n    if key < root.key:\n      successor = root\n      root = root.left\n    else:\n      root = root.right\n\n  return successor\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"Find Predecessor"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"find_predecessor(root, key):\n  if root == \xf8:\n    return \xf8\n\n  predecessor = \xf8\n  while root != \xf8:\n    if key > root.key:\n      predecessor = root\n      root = root.right\n    else:\n      root = root.left\n\n  return predecessor\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"Deletion"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"delete_node(root, key):\n  if root \xf8:\n    return \xf8\n\n  // Locate the node to be deleted\n  if key < root.key:\n    root.left = delete_node(root.left, key)\n  else if key > root.key:\n    root.right = delete_node(root.right, key)\n  else:\n    // Node with the key is found\n    // Case 1: Node with only one child or no child\n    if root.left == \xf8:\n      return root.right\n    else if root.right == \xf8:\n      return root.left\n\n    // Case 2: Node with two children\n    // Find the inorder successor (smallest node in the right subtree)\n    successor = root.right\n    // Find MIN: Find the leftmost leaf in the right subtree\n    while successor.left != \xf8:\n      successor = successor.left\n    root.key = successor.key\n\n    // Delete the inorder successor\n    root.right = delete_node(root.right, successor.key)\n\n  return root\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"BFS Recursive"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"bfs_recursive(root):\n  if root == \xf8:\n    return\n\n  queue = Queue()\n  queue.enqueue(root)\n\n  bfs_helper(queue)\n\nbfs_helper(queue):\n  if queue == \xf8:\n    return\n\n  current = queue.dequeue()\n  process(current)\n\n  if current.left != \xf8:\n    queue.enqueue(current.left)\n  if current.right != \xf8:\n    queue.enqueue(current.right)\n\n  bfs_helper(queue)\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"BFS Iterative"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"bfs_iterative(root):\n  if root == \xf8:\n    return\n\n  queue = Queue()\n  queue.enqueue(root)\n\n  while queue != \xf8:\n    current = queue.dequeue()\n    process(current)\n\n    if current.left != \xf8:\n      queue.enqueue(current.left)\n    if current.right != \xf8:\n      queue.enqueue(current.right)\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"DFS PreOrder Recursive"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"dfs_pre_order_recursive(root):\n  if root == \xf8:\n    return\n  print root.value\n  dfs_pre_order_recursive(root.left)\n  dfs_pre_order_recursive(root.right)\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"DFS PreOrder Iterative"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"dfs_preorder_iterative(root):\n  if root == \xf8:\n    return\n\n  stack = Stack()\n  stack.push(root)\n\n  while stack != \xf8:\n    current = stack.pop()\n    process(current)\n\n    if current.right != \xf8:\n      stack.push(current.right)\n    if current.left != \xf8:\n      stack.push(current.left)\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"DFS InOrder Recursive"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"dfs_in_order_recursive(root):\n  if root == \xf8:\n    return\n  dfs_in_order_recursive(root.left)\n  print root.value\n  dfs_in_order_recursive(root.right)\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"DFS InOrder Iterative"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"dfs_inorder_iterative(root):\n  if root == \xf8:\n    return\n\n  stack = Stack()\n  current = root\n\n  while current != \xf8 or stack != \xf8:\n    while current != \xf8:\n      stack.push(current)\n      current = current.left\n\n    current = stack.pop()\n    process(current)\n    current = current.right\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"DFS PostOrder Recursive"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"dfs_post_order_recursive(root):\n  if root == \xf8:\n    return\n  dfs_post_order_recursive(root.left)\n  dfs_post_order_recursive(root.right)\n  print root.value\n"})})})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"DFS PostOrder Iterative"}),(0,t.jsx)("td",{children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"dfs_postorder_iterative(root):\n  if root == \xf8:\n    return\n\n  stack1 = Stack()\n  stack2 = Stack()\n  stack1.push(root)\n\n  while stack1 != \xf8:\n    current = stack1.pop()\n    stack2.push(current)\n\n    if current.left != \xf8:\n      stack1.push(current.left)\n    if current.right != \xf8:\n      stack1.push(current.right)\n\n  while stack2 != \xf8:\n    process(stack2.pop())\n"})})})]})]})]})}),(0,t.jsx)(u.Z,{value:"solution",label:"Solution",children:(0,t.jsxs)(s.Z,{queryString:"code",children:[(0,t.jsx)(u.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,t.jsx)(i.Z,{language:"go",children:c})}),(0,t.jsx)(u.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,t.jsx)(i.Z,{language:"java",children:l})}),(0,t.jsx)(u.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,t.jsx)(i.Z,{language:"js",children:d})}),(0,t.jsx)(u.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,t.jsx)(i.Z,{language:"kotlin",children:f})}),(0,t.jsx)(u.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,t.jsx)(i.Z,{language:"python",children:a})}),(0,t.jsx)(u.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,t.jsx)(i.Z,{language:"rust",children:h})}),(0,t.jsx)(u.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,t.jsx)(i.Z,{language:"ts",children:k})})]})})]})]})}function _(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},91970:(e,n,r)=>{r.d(n,{Z:()=>t});const t=r.p+"assets/images/binarySearchTree-7362c341d8e52a86cde9036a37aad048.svg"}}]);