"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[4439],{96604:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>B,contentTitle:()=>p,default:()=>y,frontMatter:()=>_,metadata:()=>f,toc:()=>m});var o=i(11527),t=i(88672),r=i(29140),d=i(52360),l=i(52296);const s='package main\n\nimport (\n\t"math"\n)\n\ntype RTreeNode struct {\n\tIsLeaf       bool\n\tChildren     []point\n\tBoundingBox  *BoundingBox\n}\n\ntype BoundingBox struct {\n\tMinX, MinY, MaxX, MaxY float64\n}\n\ntype point struct {\n\tX, Y float64\n}\n\ntype RTree struct {\n\tRoot         *RTreeNode\n\tMaxChildren  int\n}\n\nfunc NewRTreeNode(isLeaf bool) *RTreeNode {\n\treturn &RTreeNode{\n\t\tIsLeaf: isLeaf,\n\t\tChildren: make([]point, 0),\n\t\tBoundingBox: nil,\n\t}\n}\n\nfunc NewBoundingBox(minX, minY, maxX, maxY float64) *BoundingBox {\n\treturn &BoundingBox{\n\t\tMinX: minX,\n\t\tMinY: minY,\n\t\tMaxX: maxX,\n\t\tMaxY: maxY,\n\t}\n}\n\nfunc NewRTree(maxChildren int) *RTree {\n\troot := NewRTreeNode(true)\n\treturn &RTree{\n\t\tRoot:        root,\n\t\tMaxChildren: maxChildren,\n\t}\n}\n\nfunc (tree *RTree) Insert(point point) {\n\ttree.insertRecursive(tree.Root, point)\n}\n\nfunc (tree *RTree) insertRecursive(node *RTreeNode, point point) {\n\tif node.IsLeaf {\n\t\tnode.Children = append(node.Children, point)\n\t\tif len(node.Children) > tree.MaxChildren {\n\t\t\ttree.split(node)\n\t\t}\n\t} else {\n\t\tminIncrease := math.Inf(1)\n\t\tvar bestChild *RTreeNode\n\n\t\tfor _, child := range node.Children {\n\t\t\tchildBBox := calculateBoundingBox(child)\n\t\t\texpandedBBox := calculateExpandedBoundingBox(childBBox, point)\n\t\t\tincrease := calculateAreaIncrease(childBBox, expandedBBox)\n\n\t\t\tif increase < minIncrease {\n\t\t\t\tminIncrease = increase\n\t\t\t\tbestChild = &child\n\t\t\t}\n\t\t}\n\n\t\ttree.insertRecursive(bestChild, point)\n\t}\n}\n\nfunc calculateAreaIncrease(oldBBox, newBBox *BoundingBox) float64 {\n\toldArea := (oldBBox.MaxX - oldBBox.MinX) * (oldBBox.MaxY - oldBBox.MinY)\n\tnewArea := (newBBox.MaxX - newBBox.MinX) * (newBBox.MaxY - newBBox.MinY)\n\treturn newArea - oldArea\n}\n\nfunc calculateExpandedBoundingBox(oldBBox *BoundingBox, point point) *BoundingBox {\n\tnewMinX := math.Min(oldBBox.MinX, point.X)\n\tnewMinY := math.Min(oldBBox.MinY, point.Y)\n\tnewMaxX := math.Max(oldBBox.MaxX, point.X)\n\tnewMaxY := math.Max(oldBBox.MaxY, point.Y)\n\treturn NewBoundingBox(newMinX, newMinY, newMaxX, newMaxY)\n}\n\nfunc (tree *RTree) split(node *RTreeNode) {\n\tsplitPoint := len(node.Children) / 2\n\tnewNode := NewRTreeNode(node.IsLeaf)\n\tnewNode.Children = append(newNode.Children, node.Children[splitPoint:]...)\n\tnode.Children = node.Children[:splitPoint]\n\n\tnode.BoundingBox = calculateBoundingBox(node.Children)\n\tnewNode.BoundingBox = calculateBoundingBox(newNode.Children)\n\n\tif node == tree.Root {\n\t\tnewRoot := NewRTreeNode(false)\n\t\tnewRoot.Children = append(newRoot.Children, node, newNode)\n\t\tnewRoot.BoundingBox = calculateBoundingBox(newRoot.Children)\n\t\ttree.Root = newRoot\n\t}\n}\n\nfunc (tree *RTree) Delete(point point) {\n\ttree.deleteRecursive(tree.Root, point)\n}\n\nfunc (tree *RTree) deleteRecursive(node *RTreeNode, point point) {\n\tif node.IsLeaf {\n\t\tvar newChildren []point\n\t\tfor _, p := range node.Children {\n\t\t\tif p != point {\n\t\t\t\tnewChildren = append(newChildren, p)\n\t\t\t}\n\t\t}\n\t\tnode.Children = newChildren\n\t} else {\n\t\tfor _, child := range node.Children {\n\t\t\tchildBBox := calculateBoundingBox(child)\n\t\t\tif pointInBoundingBox(point, childBBox) {\n\t\t\t\ttree.deleteRecursive(&child, point)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tnode.BoundingBox = calculateBoundingBox(node.Children)\n\t}\n}\n\nfunc (tree *RTree) Search(queryBBox *BoundingBox) []point {\n\tresult := make([]point, 0)\n\ttree.searchRecursive(tree.Root, queryBBox, &result)\n\treturn result\n}\n\nfunc (tree *RTree) searchRecursive(node *RTreeNode, queryBBox *BoundingBox, result *[]point) {\n\tif node.IsLeaf {\n\t\tfor _, p := range node.Children {\n\t\t\tif pointInBoundingBox(p, queryBBox) {\n\t\t\t\t*result = append(*result, p)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor _, child := range node.Children {\n\t\t\tchildBBox := calculateBoundingBox(child)\n\t\t\tif bboxIntersectsQuery(childBBox, queryBBox) {\n\t\t\t\ttree.searchRecursive(&child, queryBBox, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (tree *RTree) NearestNeighbors(queryPoint point, k int) []point {\n\tresult := make([]point, 0)\n\ttree.nearestNeighborsRecursive(tree.Root, queryPoint, k, &result)\n\treturn result\n}\n\nfunc (tree *RTree) nearestNeighborsRecursive(node *RTreeNode, queryPoint point, k int, result *[]point) {\n\tif node.IsLeaf {\n\t\tfor _, p := range node.Children {\n\t\t\tupdateNearestNeighbors(queryPoint, p, k, result)\n\t\t}\n\t} else {\n\t\tsortedChildren := make([]RTreeNode, len(node.Children))\n\t\tcopy(sortedChildren, node.Children)\n\t\tsortChildren(sortedChildren, queryPoint)\n\n\t\tfor _, child := range sortedChildren {\n\t\t\tchildBBox := calculateBoundingBox(child)\n\t\t\tif distance(queryPoint, childBBox) < result[len(result)-1].X {\n\t\t\t\ttree.nearestNeighborsRecursive(&child, queryPoint, k, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc updateNearestNeighbors(queryPoint, point point, k int, result *[]point) {\n\tdistance := distance(queryPoint, point)\n\n\tif len(*result) < k {\n\t\t*result = append(*result, point)\n\t\tsort.Slice(*result, func(i, j int) bool {\n\t\t\treturn distance(queryPoint, calculateBoundingBox((*result)[i])) > distance(queryPoint, calculateBoundingBox((*result)[j]))\n\t\t})\n\t} else if distance < distance(queryPoint, calculateBoundingBox((*result)[0])) {\n\t\t(*result)[0] = point\n\t\tsort.Slice(*result, func(i, j int) bool {\n\t\t\treturn distance(queryPoint, calculateBoundingBox((*result)[i])) > distance(queryPoint, calculateBoundingBox((*result)[j]))\n\t\t})\n\t}\n}\n\nfunc distance(point point, bbox *BoundingBox) float64 {\n\treturn math.Sqrt(math.Pow(point.X-bbox.MinX, 2) + math.Pow(point.Y-bbox.MinY, 2))\n}\n\nfunc (tree *RTree) RangeQuery(queryBBox *BoundingBox) []point {\n\tresult := make([]point, 0)\n\ttree.rangeQueryRecursive(tree.Root, queryBBox, &result)\n\treturn result\n}\n\nfunc (tree *RTree) rangeQueryRecursive(node *RTreeNode, queryBBox *BoundingBox, result *[]point) {\n\tif node.IsLeaf {\n\t\tfor _, p := range node.Children {\n\t\t\tif pointInBoundingBox(p, queryBBox) {\n\t\t\t\t*result = append(*result, p)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor _, child := range node.Children {\n\t\t\tchildBBox := calculateBoundingBox(child)\n\t\t\tif bboxIntersectsQuery(childBBox, queryBBox) {\n\t\t\t\ttree.rangeQueryRecursive(&child, queryBBox, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (tree *RTree) WindowQuery(queryBBox *BoundingBox) []point {\n\tresult := make([]point, 0)\n\ttree.windowQueryRecursive(tree.Root, queryBBox, &result)\n\treturn result\n}\n\nfunc (tree *RTree) windowQueryRecursive(node *RTreeNode, queryBBox *BoundingBox, result *[]point) {\n\tif node.IsLeaf {\n\t\tfor _, p := range node.Children {\n\t\t\tif pointInBoundingBox(p, queryBBox) {\n\t\t\t\t*result = append(*result, p)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor _, child := range node.Children {\n\t\t\tchildBBox := calculateBoundingBox(child)\n\t\t\tif bboxFullyContained(childBBox, queryBBox) {\n\t\t\t\ttree.windowQueryRecursive(&child, queryBBox, result)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (tree *RTree) KNNQuery(queryPoint point, k int) []point {\n\tresult := make([]point, 0)\n\ttree.knnSearch(tree.Root, queryPoint, k, &result)\n\treturn result\n}\n\nfunc (tree *RTree) knnSearch(node *RTreeNode, queryPoint point, k int, result *[]point) {\n\tif node.IsLeaf {\n\t\tfor _, p := range node.Children {\n\t\t\t*result = append(*result, p)\n\t\t}\n\t} else {\n\t\tdistances := make([]struct {\n\t\t\tchild   *RTreeNode\n\t\t\tdistance float64\n\t\t}, len(node.Children))\n\t\tfor i, child := range node.Children {\n\t\t\tdistances[i] = struct {\n\t\t\t\tchild   *RTreeNode\n\t\t\t\tdistance float64\n\t\t\t}{&child, calculateMinDistance(queryPoint, calculateBoundingBox(child))}\n\t\t}\n\t\tsort.Slice(distances, func(i, j int) bool {\n\t\t\treturn distances[i].distance < distances[j].distance\n\t\t})\n\n\t\tfor _, d := range distances[:k] {\n\t\t\ttree.knnSearch(d.child, queryPoint, k, result)\n\t\t}\n\t}\n}\n\nfunc calculateMinDistance(point point, boundingBox *BoundingBox) float64 {\n\tminDistance := 0.0\n\n\tfor i := 0; i < 2; i++ {\n\t\tif point.X < boundingBox.MinX {\n\t\t\tminDistance += math.Pow(boundingBox.MinX-point.X, 2)\n\t\t} else if point.X > boundingBox.MaxX {\n\t\t\tminDistance += math.Pow(point.X-boundingBox.MaxX, 2)\n\t\t}\n\n\t\tif point.Y < boundingBox.MinY {\n\t\t\tminDistance += math.Pow(boundingBox.MinY-point.Y, 2)\n\t\t} else if point.Y > boundingBox.MaxY {\n\t\t\tminDistance += math.Pow(point.Y-boundingBox.MaxY, 2)\n\t\t}\n\t}\n\n\treturn math.Sqrt(minDistance)\n}\n\nfunc (tree *RTree) Update(oldPoint, newPoint point) {\n\ttree.recursiveUpdate(tree.Root, oldPoint, newPoint)\n}\n\nfunc (tree *RTree) recursiveUpdate(node *RTreeNode, oldPoint, newPoint point) {\n\tif node.IsLeaf {\n\t\tfor i, p := range node.Children {\n\t\t\tif p == oldPoint {\n\t\t\t\tnode.Children[i] = newPoint\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor _, child := range node.Children {\n\t\t\tif intersects(calculateBoundingBox(child), oldPoint) {\n\t\t\t\ttree.recursiveUpdate(&child, oldPoint, newPoint)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc intersects(box1 *BoundingBox, box2 point) bool {\n\treturn !(box1.MaxX < box2.X ||\n\t\tbox1.MinX > box2.X ||\n\t\tbox1.MaxY < box2.Y ||\n\t\tbox1.MinY > box2.Y)\n}\n\nfunc (tree *RTree) Traverse(visitFunc func(*RTreeNode)) {\n\ttree.recursiveTraverse(tree.Root, visitFunc)\n}\n\nfunc (tree *RTree) recursiveTraverse(node *RTreeNode, visitFunc func(*RTreeNode)) {\n\tvisitFunc(node)\n\tif !node.IsLeaf {\n\t\tfor _, child := range node.Children {\n\t\t\ttree.recursiveTraverse(&child, visitFunc)\n\t\t}\n\t}\n}\n\nfunc printNodeInfo(node *RTreeNode, depth int) {\n\tindentation := "  "\n\tif node.IsLeaf {\n\t\tfmt.Printf("%sLeaf Node Bounding Box: %v\\n", indentation, node.BoundingBox)\n\t} else {\n\t\tfmt.Printf("%sInternal Node Bounding Box: %v\\n", indentation, node.BoundingBox)\n\t}\n}\n',c='import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nclass RTreeNode {\n\n  boolean isLeaf;\n  List<double[]> children;\n  double[] boundingBox;\n\n  RTreeNode(boolean isLeaf) {\n    this.isLeaf = isLeaf;\n    this.children = new ArrayList<>();\n    this.boundingBox = null;\n  }\n}\n\npublic class RTree {\n\n  private RTreeNode root;\n  private int maxChildren;\n\n  public RTree(int maxChildren) {\n    this.root = new RTreeNode(true);\n    this.maxChildren = maxChildren;\n  }\n\n  public static void printNodeInfo(RTreeNode node, int depth) {\n    String indentation = "  ".repeat(depth);\n    if (node.isLeaf) {\n      System.out.println(indentation + "Leaf Node Bounding Box: " + Arrays.toString(node.boundingBox));\n    } else {\n      System.out.println(indentation + "Internal Node Bounding Box: " + Arrays.toString(node.boundingBox));\n    }\n  }\n\n  public void insert(double[] point) {\n    insertRecursive(root, point);\n  }\n\n  private void insertRecursive(RTreeNode node, double[] point) {\n    if (node.isLeaf) {\n      node.children.add(point);\n      if (node.children.size() > maxChildren) {\n        split(node);\n      }\n    } else {\n      double minIncrease = Double.POSITIVE_INFINITY;\n      double[] bestChild = null;\n\n      for (double[] child : node.children) {\n        double[] childBBox = calculateBoundingBox(child);\n        double[] expandedBBox = calculateExpandedBoundingBox(childBBox, point);\n        double increase = calculateAreaIncrease(childBBox, expandedBBox);\n\n        if (increase < minIncrease) {\n          minIncrease = increase;\n          bestChild = child;\n        }\n      }\n\n      insertRecursive(node, point);\n    }\n  }\n\n  private double calculateAreaIncrease(double[] oldBBox, double[] newBBox) {\n    double oldArea = (oldBBox[2] - oldBBox[0]) * (oldBBox[3] - oldBBox[1]);\n    double newArea = (newBBox[2] - newBBox[0]) * (newBBox[3] - newBBox[1]);\n    return newArea - oldArea;\n  }\n\n  private double[] calculateExpandedBoundingBox(double[] oldBBox, double[] point) {\n    double min_x = Math.min(oldBBox[0], point[0]);\n    double min_y = Math.min(oldBBox[1], point[1]);\n    double max_x = Math.max(oldBBox[2], point[0]);\n    double max_y = Math.max(oldBBox[3], point[1]);\n    return new double[]{min_x, min_y, max_x, max_y};\n  }\n\n  private void split(RTreeNode node) {\n    int splitPoint = node.children.size() / 2;\n    RTreeNode newNode = new RTreeNode(node.isLeaf);\n    newNode.children.addAll(node.children.subList(splitPoint, node.children.size()));\n    node.children.subList(0, splitPoint).clear();\n\n    node.boundingBox = calculateBoundingBox(node.children);\n    newNode.boundingBox = calculateBoundingBox(newNode.children);\n\n    if (node == root) {\n      RTreeNode newRoot = new RTreeNode(false);\n      newRoot.children.add(node);\n      newRoot.children.add(newNode);\n      newRoot.boundingBox = calculateBoundingBox(newRoot.children);\n      root = newRoot;\n    }\n  }\n\n  public void delete(double[] point) {\n    deleteRecursive(root, point);\n  }\n\n  private void deleteRecursive(RTreeNode node, double[] point) {\n    if (node.isLeaf) {\n      node.children.removeIf(p -> Arrays.equals(p, point));\n    } else {\n      for (double[] child : node.children) {\n        double[] childBBox = calculateBoundingBox(child);\n        if (pointInBoundingBox(point, childBBox)) {\n          deleteRecursive(child, point);\n          break;\n        }\n      }\n      node.boundingBox = calculateBoundingBox(node.children);\n    }\n  }\n\n  public List<double[]> search(double[] queryBBox) {\n    List<double[]> result = new ArrayList<>();\n    searchRecursive(root, queryBBox, result);\n    return result;\n  }\n\n  private void searchRecursive(RTreeNode node, double[] queryBBox, List<double[]> result) {\n    if (node.isLeaf) {\n      for (double[] point : node.children) {\n        if (pointInBoundingBox(point, queryBBox)) {\n          result.add(point);\n        }\n      }\n    } else {\n      for (double[] child : node.children) {\n        double[] childBBox = calculateBoundingBox(child);\n        if (bboxIntersectsQuery(childBBox, queryBBox)) {\n          searchRecursive(child, queryBBox, result);\n        }\n      }\n    }\n  }\n\n  public List<double[]> nearestNeighbors(double[] queryPoint, int k) {\n    List<double[]> result = new ArrayList<>();\n    nearestNeighborsRecursive(root, queryPoint, k, result);\n    Collections.sort(result, Comparator.comparingDouble(p -> p[0]));\n    return result.subList(0, Math.min(k, result.size()));\n  }\n\n  private void nearestNeighborsRecursive(RTreeNode node, double[] queryPoint, int k, List<double[]> result) {\n    if (node.isLeaf) {\n      for (double[] point : node.children) {\n        updateNearestNeighbors(queryPoint, point, k, result);\n      }\n    } else {\n      List<double[]> sortedChildren = new ArrayList<>(node.children);\n      sortedChildren.sort(Comparator.comparingDouble(child -> distance(queryPoint, calculateBoundingBox(child))));\n\n      for (double[] child : sortedChildren) {\n        double[] childBBox = calculateBoundingBox(child);\n        if (distance(queryPoint, childBBox) < result.get(result.size() - 1)[0]) {\n          nearestNeighborsRecursive(child, queryPoint, k, result);\n        }\n      }\n    }\n  }\n\n  private void updateNearestNeighbors(double[] queryPoint, double[] point, int k, List<double[]> result) {\n    double distance = distance(queryPoint, point);\n\n    if (result.size() < k) {\n      result.add(new double[]{distance, point[0], point[1]});\n      result.sort(Comparator.comparingDouble(p -> p[0]));\n    } else if (distance < result.get(result.size() - 1)[0]) {\n      result.set(result.size() - 1, new double[]{distance, point[0], point[1]});\n      result.sort(Comparator.comparingDouble(p -> p[0]));\n    }\n  }\n\n  public List<double[]> rangeQuery(double[] queryBBox) {\n    List<double[]> result = new ArrayList<>();\n    rangeQueryRecursive(root, queryBBox, result);\n    return result;\n  }\n\n  private void rangeQueryRecursive(RTreeNode node, double[] queryBBox, List<double[]> result) {\n    if (node.isLeaf) {\n      for (double[] point : node.children) {\n        if (pointInBoundingBox(point, queryBBox)) {\n          result.add(point);\n        }\n      }\n    } else {\n      for (double[] child : node.children) {\n        double[] childBBox = calculateBoundingBox(child);\n        if (bboxIntersectsQuery(childBBox, queryBBox)) {\n          rangeQueryRecursive(child, queryBBox, result);\n        }\n      }\n    }\n  }\n\n  public List<double[]> windowQuery(double[] queryBBox) {\n    List<double[]> result = new ArrayList<>();\n    windowQueryRecursive(root, queryBBox, result);\n    return result;\n  }\n\n  private void windowQueryRecursive(RTreeNode node, double[] queryBBox, List<double[]> result) {\n    if (node.isLeaf) {\n      for (double[] point : node.children) {\n        if (pointInBoundingBox(point, queryBBox)) {\n          result.add(point);\n        }\n      }\n    } else {\n      for (double[] child : node.children) {\n        double[] childBBox = calculateBoundingBox(child);\n        if (bboxFullyContained(childBBox, queryBBox)) {\n          windowQueryRecursive(child, queryBBox, result);\n        }\n      }\n    }\n  }\n\n  public List<double[]> knnQuery(double[] queryPoint, int k) {\n    List<double[]> result = new ArrayList<>();\n    knnSearch(root, queryPoint, k, result);\n    Collections.sort(result, Comparator.comparingDouble(p -> p[1]));\n    return result.subList(0, Math.min(k, result.size()));\n  }\n\n  private void knnSearch(RTreeNode node, double[] queryPoint, int k, List<double[]> result) {\n    if (node.isLeaf) {\n      for (double[] child : node.children) {\n        result.add(new double[]{distance(queryPoint, calculateBoundingBox(child)), child[0], child[1]});\n      }\n    } else {\n      List<double[]> distances = new ArrayList<>();\n      for (double[] child : node.children) {\n        double[] childBBox = calculateBoundingBox(child);\n        distances.add(new double[]{distance(queryPoint, childBBox)});\n      }\n      distances.sort(Comparator.comparingDouble(p -> p[1]));\n\n      for (double[] distance : distances.subList(0, Math.min(k, distances.size()))) {\n        knnSearch(node, queryPoint, k, result);\n      }\n    }\n  }\n\n  private double distance(double[] point1, double[] point2) {\n    return Math.sqrt(Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2));\n  }\n\n  public void update(double[] oldPoint, double[] newPoint) {\n    recursiveUpdate(root, oldPoint, newPoint);\n  }\n\n  private void recursiveUpdate(RTreeNode node, double[] oldPoint, double[] newPoint) {\n    if (node.isLeaf) {\n      for (int i = 0; i < node.children.size(); i++) {\n        double[] child = node.children.get(i);\n        if (Arrays.equals(child, oldPoint)) {\n          node.children.set(i, newPoint);\n          return;\n        }\n      }\n    } else {\n      for (RTreeNode child : node.children) {\n        if (intersects(child.boundingBox, oldPoint)) {\n          recursiveUpdate(child, oldPoint, newPoint);\n        }\n      }\n    }\n  }\n\n  private boolean intersects(double[] box1, double[] box2) {\n    return !(box1[2] < box2[0] || box1[0] > box2[2] || box1[3] < box2[1] || box1[1] > box2[3]);\n  }\n\n  public void traverse(VisitFunction visitFunction) {\n    recursiveTraverse(root, visitFunction);\n  }\n\n  private void recursiveTraverse(RTreeNode node, VisitFunction visitFunction) {\n    visitFunction.visit(node);\n    if (!node.isLeaf) {\n      for (RTreeNode child : node.children) {\n        recursiveTraverse(child, visitFunction);\n      }\n    }\n  }\n\n  public interface VisitFunction {\n\n    void visit(RTreeNode node);\n  }\n}\n',u='class RTreeNode {\n  constructor(isLeaf = true) {\n    this.isLeaf = isLeaf;\n    this.children = [];\n    this.boundingBox = null;\n  }\n}\n\nclass RTree {\n  constructor(maxChildren = 4) {\n    this.root = new RTreeNode();\n    this.maxChildren = maxChildren;\n  }\n\n  static printNodeInfo(node, depth) {\n    const indentation = "  ".repeat(depth);\n    if (node.isLeaf) {\n      console.log(\n        `${indentation}Leaf Node Bounding Box: [${node.boundingBox.join(\n          ", ",\n        )}]`,\n      );\n    } else {\n      console.log(\n        `${indentation}Internal Node Bounding Box: [${node.boundingBox.join(\n          ", ",\n        )}]`,\n      );\n    }\n  }\n\n  insert(point) {\n    this._insertRecursive(this.root, point);\n  }\n\n  _insertRecursive(node, point) {\n    if (node.isLeaf) {\n      node.children.push(point);\n      if (node.children.length > this.maxChildren) {\n        this._split(node);\n      }\n    } else {\n      let minIncrease = Infinity;\n      let bestChild = null;\n\n      for (const child of node.children) {\n        const childBBox = this._calculateBoundingBox(child);\n        const expandedBBox = this._calculateExpandedBBox(childBBox, point);\n        const increase = this._calculateAreaIncrease(childBBox, expandedBBox);\n\n        if (increase < minIncrease) {\n          minIncrease = increase;\n          bestChild = child;\n        }\n      }\n\n      this._insertRecursive(bestChild, point);\n    }\n  }\n\n  _calculateAreaIncrease(oldBBox, newBBox) {\n    const oldArea = (oldBBox[2] - oldBBox[0]) * (oldBBox[3] - oldBBox[1]);\n    const newArea = (newBBox[2] - newBBox[0]) * (newBBox[3] - newBBox[1]);\n    return newArea - oldArea;\n  }\n\n  _calculateExpandedBBox(oldBBox, point) {\n    const [minX, minY, maxX, maxY] = oldBBox;\n    const newMinX = Math.min(minX, point[0]);\n    const newMinY = Math.min(minY, point[1]);\n    const newMaxX = Math.max(maxX, point[0]);\n    const newMaxY = Math.max(maxY, point[1]);\n    return [newMinX, newMinY, newMaxX, newMaxY];\n  }\n\n  _split(node) {\n    const splitPoint = Math.floor(node.children.length / 2);\n    const newNode = new RTreeNode({ isLeaf: node.isLeaf });\n    newNode.children = node.children.slice(splitPoint);\n    node.children = node.children.slice(0, splitPoint);\n\n    node.boundingBox = this._calculateBoundingBox(node.children);\n    newNode.boundingBox = this._calculateBoundingBox(newNode.children);\n\n    if (node === this.root) {\n      const newRoot = new RTreeNode({ isLeaf: false });\n      newRoot.children = [node, newNode];\n      newRoot.boundingBox = this._calculateBoundingBox(newRoot.children);\n      this.root = newRoot;\n    }\n  }\n\n  _deleteRecursive(node, point) {\n    if (node.isLeaf) {\n      node.children = node.children.filter((p) => !this._pointsEqual(p, point));\n    } else {\n      for (const child of node.children) {\n        const childBBox = this._calculateBoundingBox(child);\n        if (this._pointInBoundingBox(point, childBBox)) {\n          this._deleteRecursive(child, point);\n          break;\n        }\n      }\n      node.boundingBox = this._calculateBoundingBox(node.children);\n    }\n  }\n\n  _searchRecursive(node, queryBBox, result) {\n    if (node.isLeaf) {\n      for (const point of node.children) {\n        if (this._pointInBoundingBox(point, queryBBox)) {\n          result.push(point);\n        }\n      }\n    } else {\n      for (const child of node.children) {\n        const childBBox = this._calculateBoundingBox(child);\n        if (this._bboxIntersectsQuery(childBBox, queryBBox)) {\n          this._searchRecursive(child, queryBBox, result);\n        }\n      }\n    }\n  }\n\n  _nearestNeighborsRecursive(node, queryPoint, k, result) {\n    if (node.isLeaf) {\n      for (const point of node.children) {\n        this._updateNearestNeighbors(queryPoint, point, k, result);\n      }\n    } else {\n      const sortedChildren = node.children\n        .slice()\n        .sort(\n          (a, b) =>\n            this._distance(queryPoint, this._calculateBoundingBox(a)) -\n            this._distance(queryPoint, this._calculateBoundingBox(b)),\n        );\n\n      for (const child of sortedChildren) {\n        const childBBox = this._calculateBoundingBox(child);\n        if (\n          this._distance(queryPoint, childBBox) < result[result.length - 1][0]\n        ) {\n          this._nearestNeighborsRecursive(child, queryPoint, k, result);\n        }\n      }\n    }\n  }\n\n  _updateNearestNeighbors(queryPoint, point, k, result) {\n    const distance = this._distance(queryPoint, point);\n\n    if (result.length < k) {\n      result.push([distance, point]);\n      result.sort((a, b) => b[0] - a[0]);\n    } else if (distance < result[0][0]) {\n      result[0] = [distance, point];\n      result.sort((a, b) => b[0] - a[0]);\n    }\n  }\n\n  _distance(point1, point2) {\n    return Math.sqrt(\n      Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2),\n    );\n  }\n\n  rangeQuery(queryBBox) {\n    const result = [];\n    this._rangeQueryRecursive(this.root, queryBBox, result);\n    return result;\n  }\n\n  _rangeQueryRecursive(node, queryBBox, result) {\n    if (node.isLeaf) {\n      for (const point of node.children) {\n        if (this._pointInBoundingBox(point, queryBBox)) {\n          result.push(point);\n        }\n      }\n    } else {\n      for (const child of node.children) {\n        const childBBox = this._calculateBoundingBox(child);\n        if (this._bboxIntersectsQuery(childBBox, queryBBox)) {\n          this._rangeQueryRecursive(child, queryBBox, result);\n        }\n      }\n    }\n  }\n\n  _bboxIntersectsQuery(bbox, queryBBox) {\n    return !(\n      bbox[2] < queryBBox[0] ||\n      bbox[0] > queryBBox[2] ||\n      bbox[3] < queryBBox[1] ||\n      bbox[1] > queryBBox[3]\n    );\n  }\n\n  _windowQueryRecursive(node, queryBBox, result) {\n    if (node.isLeaf) {\n      for (const point of node.children) {\n        if (this._pointInBoundingBox(point, queryBBox)) {\n          result.push(point);\n        }\n      }\n    } else {\n      for (const child of node.children) {\n        const childBBox = this._calculateBoundingBox(child);\n        if (this._bboxFullyContained(childBBox, queryBBox)) {\n          this._windowQueryRecursive(child, queryBBox, result);\n        }\n      }\n    }\n  }\n\n  _bboxFullyContained(bbox1, bbox2) {\n    return (\n      bbox1[0] >= bbox2[0] &&\n      bbox1[1] >= bbox2[1] &&\n      bbox1[2] <= bbox2[2] &&\n      bbox1[3] <= bbox2[3]\n    );\n  }\n\n  _pointInBoundingBox(point, bbox) {\n    return (\n      point[0] >= bbox[0] &&\n      point[0] <= bbox[2] &&\n      point[1] >= bbox[1] &&\n      point[1] <= bbox[3]\n    );\n  }\n\n  _calculateBoundingBox(points) {\n    const minX = Math.min(...points.map((p) => p[0]));\n    const minY = Math.min(...points.map((p) => p[1]));\n    const maxX = Math.max(...points.map((p) => p[0]));\n    const maxY = Math.max(...points.map((p) => p[1]));\n    return [minX, minY, maxX, maxY];\n  }\n\n  knnQuery(queryPoint, k) {\n    const result = [];\n    this._knnSearch(this.root, queryPoint, k, result);\n    result.sort((a, b) => a[1] - b[1]);\n    return result.slice(0, k);\n  }\n\n  _knnSearch(node, queryPoint, k, result) {\n    if (node.isLeaf) {\n      for (const child of node.children) {\n        result.push([\n          child,\n          this._distance(queryPoint, this._calculateBoundingBox(child)),\n        ]);\n      }\n    } else {\n      const distances = node.children.map((child) => [\n        child,\n        this._calculateMinDistance(\n          queryPoint,\n          this._calculateBoundingBox(child),\n        ),\n      ]);\n      distances.sort((a, b) => a[1] - b[1]);\n\n      for (const [child, _] of distances.slice(\n        0,\n        Math.min(k, distances.length),\n      )) {\n        this._knnSearch(child, queryPoint, k, result);\n      }\n    }\n  }\n\n  _calculateMinDistance(point, boundingBox) {\n    let minDistance = 0;\n\n    for (let i = 0; i < point.length; i++) {\n      if (point[i] < boundingBox[i]) {\n        minDistance += Math.pow(boundingBox[i] - point[i], 2);\n      } else if (point[i] > boundingBox[i + 2]) {\n        minDistance += Math.pow(point[i] - boundingBox[i + 2], 2);\n      }\n    }\n\n    return Math.sqrt(minDistance);\n  }\n\n  update(oldPoint, newPoint) {\n    this._recursiveUpdate(this.root, oldPoint, newPoint);\n  }\n\n  _recursiveUpdate(node, oldPoint, newPoint) {\n    if (node.isLeaf) {\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        if (this._pointsEqual(child, oldPoint)) {\n          node.children[i] = newPoint;\n          return;\n        }\n      }\n    } else {\n      for (const child of node.children) {\n        if (this._intersects(child.boundingBox, oldPoint)) {\n          this._recursiveUpdate(child, oldPoint, newPoint);\n        }\n      }\n    }\n  }\n\n  _intersects(box1, box2) {\n    return !(\n      box1[2] < box2[0] ||\n      box1[0] > box2[2] ||\n      box1[3] < box2[1] ||\n      box1[1] > box2[3]\n    );\n  }\n\n  traverse(visitFunction) {\n    this._recursiveTraverse(this.root, visitFunction);\n  }\n\n  _recursiveTraverse(node, visitFunction) {\n    visitFunction.visit(node);\n    if (!node.isLeaf) {\n      for (const child of node.children) {\n        this._recursiveTraverse(child, visitFunction);\n      }\n    }\n  }\n}\n',a='import kotlin.math.sqrt\n\ndata class RTreeNode(val isLeaf: Boolean = true, var children: MutableList<Pair<Double, Double>> = mutableListOf(), var boundingBox: Pair<Double, Double>? = null)\n\nclass RTree(private val maxChildren: Int = 4) {\n    var root = RTreeNode()\n        private set\n\n    fun insert(point: Pair<Double, Double>) {\n        insertRecursive(root, point)\n    }\n\n    private fun insertRecursive(node: RTreeNode, point: Pair<Double, Double>) {\n        if (node.isLeaf) {\n            node.children.add(point)\n            if (node.children.size > maxChildren) {\n                split(node)\n            }\n        } else {\n            var minIncrease = Double.POSITIVE_INFINITY\n            var bestChild: RTreeNode? = null\n\n            for (child in node.children) {\n                val childBBox = calculateBoundingBox(child)\n                val expandedBBox = calculateExpandedBoundingBox(childBBox, point)\n                val increase = calculateAreaIncrease(childBBox, expandedBBox)\n\n                if (increase < minIncrease) {\n                    minIncrease = increase\n                    bestChild = child\n                }\n            }\n\n            if (bestChild != null) {\n                insertRecursive(bestChild, point)\n            }\n        }\n    }\n\n    private fun calculateAreaIncrease(oldBBox: Pair<Double, Double>, newBBox: Pair<Double, Double>): Double {\n        val oldArea = (oldBBox.second - oldBBox.first) * (oldBBox.fourth - oldBBox.third)\n        val newArea = (newBBox.second - newBBox.first) * (newBBox.fourth - newBBox.third)\n        return newArea - oldArea\n    }\n\n    private fun calculateExpandedBoundingBox(oldBBox: Pair<Double, Double>, point: Pair<Double, Double>): Pair<Double, Double> {\n        val (minX, minY, maxX, maxY) = oldBBox\n        val newMinX = minOf(minX, point.first)\n        val newMinY = minOf(minY, point.second)\n        val newMaxX = maxOf(maxX, point.first)\n        val newMaxY = maxOf(maxY, point.second)\n        return Pair(newMinX, newMinY, newMaxX, newMaxY)\n    }\n\n    private fun split(node: RTreeNode) {\n        val splitPoint = node.children.size / 2\n        val newNode = RTreeNode(isLeaf = node.isLeaf)\n        newNode.children = node.children.subList(splitPoint, node.children.size).toMutableList()\n        node.children = node.children.subList(0, splitPoint).toMutableList()\n\n        node.boundingBox = calculateBoundingBox(node.children)\n        newNode.boundingBox = calculateBoundingBox(newNode.children)\n\n        if (node == root) {\n            val newRoot = RTreeNode(isLeaf = false)\n            newRoot.children = mutableListOf(node, newNode)\n            newRoot.boundingBox = calculateBoundingBox(newRoot.children)\n            root = newRoot\n        }\n    }\n\n    fun delete(point: Pair<Double, Double>) {\n        deleteRecursive(root, point)\n    }\n\n    private fun deleteRecursive(node: RTreeNode, point: Pair<Double, Double>) {\n        if (node.isLeaf) {\n            node.children.removeIf { it == point }\n        } else {\n            for (child in node.children) {\n                val childBBox = calculateBoundingBox(child)\n                if (pointInBoundingBox(point, childBBox)) {\n                    deleteRecursive(child, point)\n                    break\n                }\n            }\n            node.boundingBox = calculateBoundingBox(node.children)\n        }\n    }\n\n    fun search(queryBBox: Pair<Double, Double>): List<Pair<Double, Double>> {\n        val result = mutableListOf<Pair<Double, Double>>()\n        searchRecursive(root, queryBBox, result)\n        return result\n    }\n\n    private fun searchRecursive(node: RTreeNode, queryBBox: Pair<Double, Double>, result: MutableList<Pair<Double, Double>>) {\n        if (node.isLeaf) {\n            for (point in node.children) {\n                if (pointInBoundingBox(point, queryBBox)) {\n                    result.add(point)\n                }\n            }\n        } else {\n            for (child in node.children) {\n                val childBBox = calculateBoundingBox(child)\n                if (bboxIntersectsQuery(childBBox, queryBBox)) {\n                    searchRecursive(child, queryBBox, result)\n                }\n            }\n        }\n    }\n\n    fun nearestNeighbors(queryPoint: Pair<Double, Double>, k: Int): List<Pair<Double, Double>> {\n        val result = mutableListOf<Pair<Double, Double>>()\n        nearestNeighborsRecursive(root, queryPoint, k, result)\n        result.sortBy { it.first }\n        return result.take(k)\n    }\n\n    private fun nearestNeighborsRecursive(node: RTreeNode, queryPoint: Pair<Double, Double>, k: Int, result: MutableList<Pair<Double, Double>>) {\n        if (node.isLeaf) {\n            for (point in node.children) {\n                updateNearestNeighbors(queryPoint, point, k, result)\n            }\n        } else {\n            val sortedChildren = node.children.sortedBy { distance(queryPoint, calculateBoundingBox(it)) }\n\n            for (child in sortedChildren) {\n                val childBBox = calculateBoundingBox(child)\n                if (distance(queryPoint, childBBox) < result.lastOrNull()?.first ?: Double.POSITIVE_INFINITY) {\n                    nearestNeighborsRecursive(child, queryPoint, k, result)\n                }\n            }\n        }\n    }\n\n    private fun updateNearestNeighbors(queryPoint: Pair<Double, Double>, point: Pair<Double, Double>, k: Int, result: MutableList<Pair<Double, Double>>) {\n        val distance = distance(queryPoint, point)\n\n        if (result.size < k) {\n            result.add(distance to point)\n            result.sortByDescending { it.first }\n        } else if (distance < result.first().first) {\n            result[0] = distance to point\n            result.sortByDescending { it.first }\n        }\n    }\n\n    private fun distance(point1: Pair<Double, Double>, point2: Pair<Double, Double>): Double {\n        return sqrt((point1.first - point2.first).pow(2) + (point1.second - point2.second).pow(2))\n    }\n\n    fun rangeQuery(queryBBox: Pair<Double, Double>): List<Pair<Double, Double>> {\n        val result = mutableListOf<Pair<Double, Double>>()\n        rangeQueryRecursive(root, queryBBox, result)\n        return result\n    }\n\n    private fun rangeQueryRecursive(node: RTreeNode, queryBBox: Pair<Double, Double>, result: MutableList<Pair<Double, Double>>) {\n        if (node.isLeaf) {\n            for (point in node.children) {\n                if (pointInBoundingBox(point, queryBBox)) {\n                    result.add(point)\n                }\n            }\n        } else {\n            for (child in node.children) {\n                val childBBox = calculateBoundingBox(child)\n                if (bboxIntersectsQuery(childBBox, queryBBox)) {\n                    rangeQueryRecursive(child, queryBBox, result)\n                }\n            }\n        }\n    }\n\n    fun windowQuery(queryBBox: Pair<Double, Double>): List<Pair<Double, Double>> {\n        val result = mutableListOf<Pair<Double, Double>>()\n        windowQueryRecursive(root, queryBBox, result)\n        return result\n    }\n\n    private fun windowQueryRecursive(node: RTreeNode, queryBBox: Pair<Double, Double>, result: MutableList<Pair<Double, Double>>) {\n        if (node.isLeaf) {\n            for (point in node.children) {\n                if (pointInBoundingBox(point, queryBBox)) {\n                    result.add(point)\n                }\n            }\n        } else {\n            for (child in node.children) {\n                val childBBox = calculateBoundingBox(child)\n                if (bboxFullyContained(childBBox, queryBBox)) {\n                    windowQueryRecursive(child, queryBBox, result)\n                }\n            }\n        }\n    }\n\n    private fun bboxFullyContained(bbox1: Pair<Double, Double>, bbox2: Pair<Double, Double>): Boolean {\n        return bbox1.first >= bbox2.first && bbox1.second >= bbox2.second && bbox1.third <= bbox2.third && bbox1.fourth <= bbox2.fourth\n    }\n\n    private fun pointInBoundingBox(point: Pair<Double, Double>, bbox: Pair<Double, Double>): Boolean {\n        return bbox.first <= point.first && point.first <= bbox.third && bbox.second <= point.second && point.second <= bbox.fourth\n    }\n\n    private fun calculateBoundingBox(points: List<Pair<Double, Double>>): Pair<Double, Double> {\n        val minX = points.minOf { it.first }\n        val minY = points.minOf { it.second }\n        val maxX = points.maxOf { it.first }\n        val maxY = points.maxOf { it.second }\n        return Pair(minX, minY, maxX, maxY)\n    }\n\n    fun knnQuery(queryPoint: Pair<Double, Double>, k: Int): List<Pair<Double, Double>> {\n        val result = mutableListOf<Pair<Double, Double>>()\n        knnSearch(root, queryPoint, k, result)\n        result.sortBy { it.second }\n        return result.take(k)\n    }\n\n    private fun knnSearch(node: RTreeNode, queryPoint: Pair<Double, Double>, k: Int, result: MutableList<Pair<Double, Double>>) {\n        if (node.isLeaf) {\n            for (child in node.children) {\n                result.add(child to distance(queryPoint, calculateBoundingBox(child)))\n            }\n        } else {\n            val distances = node.children.map { child ->\n                child to calculateMinDistance(queryPoint, calculateBoundingBox(child))\n            }\n            distances.sortedBy { it.second }\n\n            for ((child, _) in distances.take(k)) {\n                knnSearch(child, queryPoint, k, result)\n            }\n        }\n    }\n\n    private fun calculateMinDistance(point: Pair<Double, Double>, boundingBox: Pair<Double, Double>): Double {\n        var minDistance = 0.0\n\n        for (i in 0 until point.component1().toInt()) {\n            if (point.first < boundingBox.first) {\n                minDistance += (boundingBox.first - point.first).pow(2)\n            } else if (point.first > boundingBox.third) {\n                minDistance += (point.first - boundingBox.third).pow(2)\n            }\n        }\n\n        for (i in 0 until point.component2().toInt()) {\n            if (point.second < boundingBox.second) {\n                minDistance += (boundingBox.second - point.second).pow(2)\n            } else if (point.second > boundingBox.fourth) {\n                minDistance += (point.second - boundingBox.fourth).pow(2)\n            }\n        }\n\n        return sqrt(minDistance)\n    }\n\n    fun update(oldPoint: Pair<Double, Double>, newPoint: Pair<Double, Double>) {\n        recursiveUpdate(root, oldPoint, newPoint)\n    }\n\n    private fun recursiveUpdate(node: RTreeNode, oldPoint: Pair<Double, Double>, newPoint: Pair<Double, Double>) {\n        if (node.isLeaf) {\n            for (i in node.children.indices) {\n                if (node.children[i] == oldPoint) {\n                    node.children[i] = newPoint\n                    return\n                }\n            }\n        } else {\n            for (child in node.children) {\n                if (intersects(child, oldPoint)) {\n                    recursiveUpdate(child, oldPoint, newPoint)\n                }\n            }\n        }\n    }\n\n    private fun intersects(box1: Pair<Double, Double>, box2: Pair<Double, Double>): Boolean {\n        return !(box1.third < box2.first || box1.first > box2.third || box1.fourth < box2.second || box1.second > box2.fourth)\n    }\n\n    fun traverse(visitFunc: (RTreeNode) -> Unit) {\n        recursiveTraverse(root, visitFunc)\n    }\n\n    private fun recursiveTraverse(node: RTreeNode, visitFunc: (RTreeNode) -> Unit) {\n        visitFunc(node)\n        if (!node.isLeaf) {\n            for (child in node.children) {\n                recursiveTraverse(child, visitFunc)\n            }\n        }\n    }\n\n    fun printNodeInfo(node: RTreeNode, depth: Int) {\n        val indentation = "  ".repeat(depth)\n        if (node.isLeaf) {\n            println("${indentation}Leaf Node Bounding Box: ${node.boundingBox}")\n        } else {\n            println("${indentation}Internal Node Bounding Box: ${node.boundingBox}")\n        }\n    }\n}\n',b='class RTreeNode:\n    def __init__(self, is_leaf=True):\n        self.is_leaf = is_leaf\n        self.children = []\n        self.bounding_box = None\n\n\nclass RTree:\n    def __init__(self, max_children=4):\n        self.root = RTreeNode()\n        self.max_children = max_children\n\n    def insert(self, point):\n        self._insert_recursive(self.root, point)\n\n    def _insert_recursive(self, node, point):\n        if node.is_leaf:\n            node.children.append(point)\n            if len(node.children) > self.max_children:\n                self._split(node)\n        else:\n            min_increase = float(\'inf\')\n            best_child = None\n\n            for child in node.children:\n                child_bbox = self._calculate_bounding_box(child)\n                expanded_bbox = self._calculate_expanded_bbox(child_bbox, point)\n                increase = self._calculate_area_increase(child_bbox, expanded_bbox)\n\n                if increase < min_increase:\n                    min_increase = increase\n                    best_child = child\n\n            self._insert_recursive(best_child, point)\n\n    def _calculate_area_increase(self, old_bbox, new_bbox):\n        old_area = (old_bbox[2] - old_bbox[0]) * (old_bbox[3] - old_bbox[1])\n        new_area = (new_bbox[2] - new_bbox[0]) * (new_bbox[3] - new_bbox[1])\n        return new_area - old_area\n\n    def _calculate_expanded_bbox(self, old_bbox, point):\n        min_x, min_y, max_x, max_y = old_bbox\n        new_min_x = min(min_x, point[0])\n        new_min_y = min(min_y, point[1])\n        new_max_x = max(max_x, point[0])\n        new_max_y = max(max_y, point[1])\n        return (new_min_x, new_min_y, new_max_x, new_max_y)\n\n    def _split(self, node):\n        split_point = len(node.children) // 2\n        new_node = RTreeNode(is_leaf=node.is_leaf)\n        new_node.children = node.children[split_point:]\n        node.children = node.children[:split_point]\n\n        node.bounding_box = self._calculate_bounding_box(node.children)\n        new_node.bounding_box = self._calculate_bounding_box(new_node.children)\n\n        if node == self.root:\n            new_root = RTreeNode(is_leaf=False)\n            new_root.children = [node, new_node]\n            new_root.bounding_box = self._calculate_bounding_box(new_root.children)\n            self.root = new_root\n\n    def _delete_recursive(self, node, point):\n        if node.is_leaf:\n            node.children = [p for p in node.children if p != point]\n        else:\n            for child in node.children:\n                child_bbox = self._calculate_bounding_box(child)\n                if self._point_in_bbox(point, child_bbox):\n                    self._delete_recursive(child, point)\n                    break\n            node.bounding_box = self._calculate_bounding_box(node.children)\n\n    def _search_recursive(self, node, query_bbox, result):\n        if node.is_leaf:\n            for point in node.children:\n                if self._point_in_bbox(point, query_bbox):\n                    result.append(point)\n        else:\n            for child in node.children:\n                child_bbox = self._calculate_bounding_box(child)\n                if self._bbox_intersects_query(child_bbox, query_bbox):\n                    self._search_recursive(child, query_bbox, result)\n\n    def _nearest_neighbors_recursive(self, node, query_point, k, result):\n        if node.is_leaf:\n            for point in node.children:\n                self._update_nearest_neighbors(query_point, point, k, result)\n        else:\n            sorted_children = sorted(node.children, key=lambda child: self._distance(query_point, self._calculate_bounding_box(child)))\n\n            for child in sorted_children:\n                child_bbox = self._calculate_bounding_box(child)\n                if self._distance(query_point, child_bbox) < result[-1][0]:\n                    self._nearest_neighbors_recursive(child, query_point, k, result)\n\n    def _update_nearest_neighbors(self, query_point, point, k, result):\n        distance = self._distance(query_point, point)\n\n        if len(result) < k:\n            result.append((distance, point))\n            result.sort(key=lambda x: x[0], reverse=True)\n        elif distance < result[0][0]:\n            result[0] = (distance, point)\n            result.sort(key=lambda x: x[0], reverse=True)\n\n    def _distance(self, point1, point2):\n        return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n\n    def range_query(self, query_bbox):\n        result = []\n        self._range_query_recursive(self.root, query_bbox, result)\n        return result\n\n    def _range_query_recursive(self, node, query_bbox, result):\n          if node.is_leaf:\n              for point in node.children:\n                  if self._point_in_bbox(point, query_bbox):\n                      result.append(point)\n          else:\n              for child in node.children:\n                  child_bbox = self._calculate_bounding_box(child)\n                  if self._bbox_intersects_query(child_bbox, query_bbox):\n                      self._range_query_recursive(child, query_bbox, result)\n\n    def _bbox_intersects_query(self, bbox, query_bbox):\n        return not (bbox[2] < query_bbox[0] or\n                    bbox[0] > query_bbox[2] or\n                    bbox[3] < query_bbox[1] or\n                    bbox[1] > query_bbox[3])\n\n    def _window_query_recursive(self, node, query_bbox, result):\n        if node.is_leaf:\n            for point in node.children:\n                if self._point_in_bbox(point, query_bbox):\n                    result.append(point)\n        else:\n            for child in node.children:\n                child_bbox = self._calculate_bounding_box(child)\n                if self._bbox_fully_contained(child_bbox, query_bbox):\n                    self._window_query_recursive(child, query_bbox, result)\n    def _bbox_fully_contained(self, bbox1, bbox2):\n        return bbox1[0] >= bbox2[0] and bbox1[1] >= bbox2[1] and bbox1[2] <= bbox2[2] and bbox1[3] <= bbox2[3]\n\n\n    def _point_in_bbox(self, point, bbox):\n            return bbox[0] <= point[0] <= bbox[2] and bbox[1] <= point[1] <= bbox[3]\n\n    def _calculate_bounding_box(self, points):\n        min_x = min(p[0] for p in points)\n        min_y = min(p[1] for p in points)\n        max_x = max(p[0] for p in points)\n        max_y = max(p[1] for p in points)\n        return (min_x, min_y, max_x, max_y)\n\n    def knn_query(self, query_point, k):\n        result = []\n\n        _knn_search(self.root, query_point, k)\n\n        result.sort(key=lambda x: x[1])\n        return result[:k]\n\n    def _knn_search(node, query_point, k):\n        if node.is_leaf:\n            for child in node.children:\n                result.append((child, _distance(query_point, child.bounding_box)))\n        else:\n            distances = [(child, self.calculate_min_distance(query_point, child.bounding_box)) for child in node.children]\n            distances.sort(key=lambda x: x[1])\n\n            for child, _ in distances[:k]:\n                knn_search(child, query_point, k)\n\n    def calculate_min_distance(self, point, bounding_box):\n        min_distance = 0\n\n        for i in range(len(point)):\n            if point[i] < bounding_box[i]:\n                min_distance += (bounding_box[i] - point[i])**2\n            elif point[i] > bounding_box[i + 2]:\n                min_distance += (point[i] - bounding_box[i + 2])**2\n\n        return math.sqrt(min_distance)\n\n    def update(self, old_point, new_point):\n        recursive_update(self.root, old_point, new_point)\n\n    def recursive_update(node, old_point, new_point):\n        if node.is_leaf:\n            for i, child in enumerate(node.children):\n                if child.bounding_box == old_point:\n                    node.children[i].bounding_box = new_point\n                    return\n        else:\n            for child in node.children:\n                if self._intersects(child.bounding_box, old_point):\n                    recursive_update(child, old_point, new_point)\n\n    def _intersects(self, box1, box2):\n          return not (box1[2] < box2[0] or\n                      box1[0] > box2[2] or\n                      box1[3] < box2[1] or\n                      box1[1] > box2[3])\n\n    def traverse(self, visit_func):\n        recursive_traverse(self.root, visit_func)\n\n    def recursive_traverse(node, visit_func):\n                visit_func(node)\n                if not node.is_leaf:\n                    for child in node.children:\n                        recursive_traverse(child, visit_func)\n\n    def print_node_info(node, depth):\n        indentation = "  " * depth\n        if node.is_leaf:\n            print(f"{indentation}Leaf Node Bounding Box:", node.bounding_box)\n        else:\n            print(f"{indentation}Internal Node Bounding Box:", node.bounding_box)\n',x='use std::cmp::{max, min};\n\n#[derive(Debug)]\nstruct RTreeNode {\n    is_leaf: bool,\n    children: Vec<(f64, f64)>,\n    bounding_box: Option<(f64, f64, f64, f64)>,\n}\n\nimpl RTreeNode {\n    fn new(is_leaf: bool) -> Self {\n        RTreeNode {\n            is_leaf,\n            children: Vec::new(),\n            bounding_box: None,\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct RTree {\n    root: RTreeNode,\n    max_children: usize,\n}\n\nimpl RTree {\n    fn new(max_children: usize) -> Self {\n        let root = RTreeNode::new(true);\n        RTree { root, max_children }\n    }\n\n    fn insert(&mut self, point: (f64, f64)) {\n        self.insert_recursive(&mut self.root, point);\n    }\n\n    fn insert_recursive(&mut self, node: &mut RTreeNode, point: (f64, f64)) {\n        if node.is_leaf {\n            node.children.push(point);\n            if node.children.len() > self.max_children {\n                self.split(node);\n            }\n        } else {\n            let mut min_increase = f64::INFINITY;\n            let mut best_child = None;\n\n            for child in &node.children {\n                let child_bbox = self.calculate_bounding_box(child);\n                let expanded_bbox = self.calculate_expanded_bbox(child_bbox, point);\n                let increase = self.calculate_area_increase(&child_bbox, &expanded_bbox);\n\n                if increase < min_increase {\n                    min_increase = increase;\n                    best_child = Some(child);\n                }\n            }\n\n            if let Some(best_child) = best_child {\n                self.insert_recursive(best_child, point);\n            }\n        }\n    }\n\n    fn calculate_area_increase(&self, old_bbox: &(f64, f64, f64, f64), new_bbox: &(f64, f64, f64, f64)) -> f64 {\n        let old_area = (old_bbox.2 - old_bbox.0) * (old_bbox.3 - old_bbox.1);\n        let new_area = (new_bbox.2 - new_bbox.0) * (new_bbox.3 - new_bbox.1);\n        new_area - old_area\n    }\n\n    fn calculate_expanded_bbox(&self, old_bbox: (f64, f64, f64, f64), point: (f64, f64)) -> (f64, f64, f64, f64) {\n        let (min_x, min_y, max_x, max_y) = old_bbox;\n        let new_min_x = min(min_x, point.0);\n        let new_min_y = min(min_y, point.1);\n        let new_max_x = max(max_x, point.0);\n        let new_max_y = max(max_y, point.1);\n        (new_min_x, new_min_y, new_max_x, new_max_y)\n    }\n\n    fn split(&mut self, node: &mut RTreeNode) {\n        let split_point = node.children.len() / 2;\n        let mut new_node = RTreeNode::new(node.is_leaf);\n        new_node.children = node.children.split_off(split_point);\n        node.bounding_box = Some(self.calculate_bounding_box(&node.children));\n        new_node.bounding_box = Some(self.calculate_bounding_box(&new_node.children));\n\n        if node.is_leaf {\n            let new_root = RTreeNode::new(false);\n            new_root.children.push(node.clone());\n            new_root.children.push(new_node);\n            new_root.bounding_box = Some(self.calculate_bounding_box(&new_root.children));\n            self.root = new_root;\n        } else {\n            let parent_bounding_box = self.calculate_bounding_box(&[&node.children, &new_node.children].concat());\n            node.bounding_box = Some(self.calculate_bounding_box(&node.children));\n            new_node.bounding_box = Some(self.calculate_bounding_box(&new_node.children));\n            let parent = &mut node.children;\n            parent.push(new_node);\n            node.bounding_box = Some(parent_bounding_box);\n        }\n    }\n\n    fn delete_recursive(&mut self, node: &mut RTreeNode, point: (f64, f64)) {\n        if node.is_leaf {\n            node.children.retain(|p| p != &point);\n        } else {\n            for child in &mut node.children {\n                let child_bbox = self.calculate_bounding_box(child);\n                if self.point_in_bbox(&point, &child_bbox) {\n                    self.delete_recursive(child, point);\n                    break;\n                }\n            }\n            node.bounding_box = Some(self.calculate_bounding_box(&node.children));\n        }\n    }\n\n    fn search_recursive(&self, node: &RTreeNode, query_bbox: (f64, f64, f64, f64), result: &mut Vec<(f64, f64)>) {\n        if node.is_leaf {\n            for point in &node.children {\n                if self.point_in_bbox(point, &query_bbox) {\n                    result.push(*point);\n                }\n            }\n        } else {\n            for child in &node.children {\n                let child_bbox = self.calculate_bounding_box(child);\n                if self.bbox_intersects_query(&child_bbox, &query_bbox) {\n                    self.search_recursive(child, query_bbox, result);\n                }\n            }\n        }\n    }\n\n    fn nearest_neighbors_recursive(&self, node: &RTreeNode, query_point: (f64, f64), k: usize, result: &mut Vec<(f64, (f64, f64))>) {\n        if node.is_leaf {\n            for point in &node.children {\n                self.update_nearest_neighbors(query_point, *point, k, result);\n            }\n        } else {\n            let mut sorted_children = node.children.clone();\n            sorted_children.sort_by(|a, b| {\n                let dist_a = self.distance(query_point, self.calculate_bounding_box(a));\n                let dist_b = self.distance(query_point, self.calculate_bounding_box(b));\n                dist_a.partial_cmp(&dist_b).unwrap()\n            });\n\n            for child in &sorted_children {\n                let child_bbox = self.calculate_bounding_box(child);\n                if self.distance(query_point, child_bbox) < result.last().map(|x| x.0).unwrap_or(f64::INFINITY) {\n                    self.nearest_neighbors_recursive(child, query_point, k, result);\n                }\n            }\n        }\n    }\n\n    fn update_nearest_neighbors(&self, query_point: (f64, f64), point: (f64, f64), k: usize, result: &mut Vec<(f64, (f64, f64))>) {\n        let distance = self.distance(query_point, point);\n\n        if result.len() < k {\n          result.push((distance, point));\n                  result.sort_by(|a, b| b.0.partial_cmp(&a.0).unwrap());\n              } else if distance < result[0].0 {\n                  result[0] = (distance, point);\n                  result.sort_by(|a, b| b.0.partial_cmp(&a.0).unwrap());\n              }\n          }\n\n    fn distance(&self, point1: (f64, f64), point2: (f64, f64)) -> f64 {\n        ((point1.0 - point2.0).powi(2) + (point1.1 - point2.1).powi(2)).sqrt()\n    }\n\n    fn range_query(&self, query_bbox: (f64, f64, f64, f64)) -> Vec<(f64, f64)> {\n        let mut result = Vec::new();\n        self.range_query_recursive(&self.root, query_bbox, &mut result);\n        result\n    }\n\n    fn range_query_recursive(&self, node: &RTreeNode, query_bbox: (f64, f64, f64, f64), result: &mut Vec<(f64, f64)>) {\n        if node.is_leaf {\n            for point in &node.children {\n                if self.point_in_bbox(point, &query_bbox) {\n                    result.push(*point);\n                }\n            }\n        } else {\n            for child in &node.children {\n                let child_bbox = self.calculate_bounding_box(child);\n                if self.bbox_intersects_query(&child_bbox, &query_bbox) {\n                    self.range_query_recursive(child, query_bbox, result);\n                }\n            }\n        }\n    }\n\n    fn bbox_intersects_query(&self, bbox: &(f64, f64, f64, f64), query_bbox: &(f64, f64, f64, f64)) -> bool {\n        !(bbox.2 < query_bbox.0 || bbox.0 > query_bbox.2 || bbox.3 < query_bbox.1 || bbox.1 > query_bbox.3)\n    }\n\n    fn window_query_recursive(&self, node: &RTreeNode, query_bbox: (f64, f64, f64, f64), result: &mut Vec<(f64, f64)>) {\n        if node.is_leaf {\n            for point in &node.children {\n                if self.point_in_bbox(point, &query_bbox) {\n                    result.push(*point);\n                }\n            }\n        } else {\n            for child in &node.children {\n                let child_bbox = self.calculate_bounding_box(child);\n                if self.bbox_fully_contained(&child_bbox, &query_bbox) {\n                    self.window_query_recursive(child, query_bbox, result);\n                }\n            }\n        }\n    }\n\n    fn bbox_fully_contained(&self, bbox1: &(f64, f64, f64, f64), bbox2: &(f64, f64, f64, f64)) -> bool {\n        bbox1.0 >= bbox2.0 && bbox1.1 >= bbox2.1 && bbox1.2 <= bbox2.2 && bbox1.3 <= bbox2.3\n    }\n\n    fn point_in_bbox(&self, point: &(f64, f64), bbox: &(f64, f64, f64, f64)) -> bool {\n        bbox.0 <= point.0 && point.0 <= bbox.2 && bbox.1 <= point.1 && point.1 <= bbox.3\n    }\n\n    fn calculate_bounding_box(&self, points: &[(f64, f64)]) -> (f64, f64, f64, f64) {\n        let min_x = points.iter().map(|p| p.0).fold(f64::INFINITY, f64::min);\n        let min_y = points.iter().map(|p| p.1).fold(f64::INFINITY, f64::min);\n        let max_x = points.iter().map(|p| p.0).fold(f64::NEG_INFINITY, f64::max);\n        let max_y = points.iter().map(|p| p.1).fold(f64::NEG_INFINITY, f64::max);\n        (min_x, min_y, max_x, max_y)\n    }\n\n    fn knn_query(&self, query_point: (f64, f64), k: usize) -> Vec<(f64, (f64, f64))> {\n        let mut result = Vec::new();\n        self.knn_search(&self.root, query_point, k, &mut result);\n        result.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());\n        result.truncate(k);\n        result\n    }\n\n    fn knn_search(&self, node: &RTreeNode, query_point: (f64, f64), k: usize, result: &mut Vec<(f64, (f64, f64))>) {\n        if node.is_leaf {\n            for child in &node.children {\n                result.push((self.distance(query_point, *child), *child));\n            }\n        } else {\n            let mut distances: Vec<_> = node.children.iter()\n                .map(|child| (child, self.calculate_min_distance(query_point, child)))\n                .collect();\n            distances.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());\n\n            for (child, _) in distances.iter().take(k) {\n                self.knn_search(child, query_point, k, result);\n            }\n        }\n    }\n\n    fn calculate_min_distance(&self, point: (f64, f64), bounding_box: &(f64, f64, f64, f64)) -> f64 {\n        let mut min_distance = 0.0;\n\n        for i in 0..2 {\n            if point.0 < bounding_box.0 {\n                min_distance += (bounding_box.0 - point.0).powi(2);\n            } else if point.0 > bounding_box.2 {\n                min_distance += (point.0 - bounding_box.2).powi(2);\n            }\n\n            if point.1 < bounding_box.1 {\n                min_distance += (bounding_box.1 - point.1).powi(2);\n            } else if point.1 > bounding_box.3 {\n                min_distance += (point.1 - bounding_box.3).powi(2);\n            }\n        }\n\n        min_distance.sqrt()\n    }\n\n    fn update(&mut self, old_point: (f64, f64), new_point: (f64, f64)) {\n        self.recursive_update(&mut self.root, old_point, new_point);\n    }\n\n    fn recursive_update(&mut self, node: &mut RTreeNode, old_point: (f64, f64), new_point: (f64, f64)) {\n        if node.is_leaf {\n            for i in 0..node.children.len() {\n                if node.children[i] == old_point {\n                    node.children[i] = new_point;\n                    return;\n                }\n            }\n        } else {\n            for child in &mut node.children {\n                if self.intersects(child, &old_point) {\n                    self.recursive_update(child, old_point, new_point);\n                    return;\n                }\n            }\n        }\n    }\n\n    fn intersects(&self, box1: &(f64, f64, f64, f64), box2: &(f64, f64)) -> bool {\n        !(box1.2 < box2.0 || box1.0 > box2.2 || box1.3 < box2.1 || box1.1 > box2.3)\n    }\n\n    fn traverse(&self, visit_func: impl FnMut(&RTreeNode)) {\n        self.recursive_traverse(&self.root, visit_func);\n    }\n\n    fn recursive_traverse(&self, node: &RTreeNode, mut visit_func: impl FnMut(&RTreeNode)) {\n        visit_func(node);\n        if !node.is_leaf {\n            for child in &node.children {\n                self.recursive_traverse(child, &mut visit_func);\n            }\n        }\n    }\n\n    fn print_node_info(&self, node: &RTreeNode, depth: usize) {\n        let indentation = "  ".repeat(depth);\n        if node.is_leaf {\n            println!("{indentation}Leaf Node Bounding Box: {:?}", node.bounding_box);\n        } else {\n            println!("{indentation}Internal Node Bounding Box: {:?}", node.bounding_box);\n        }\n    }\n}\n',h='class RTreeNode {\n  is_leaf: boolean;\n  children: any[];\n  bounding_box: number[] | null;\n\n  constructor(is_leaf: boolean = true) {\n    this.is_leaf = is_leaf;\n    this.children = [];\n    this.bounding_box = null;\n  }\n}\n\nclass RTree {\n  root: RTreeNode;\n  max_children: number;\n\n  constructor(max_children: number = 4) {\n    this.root = new RTreeNode();\n    this.max_children = max_children;\n  }\n\n  insert(point: number[]): void {\n    this._insertRecursive(this.root, point);\n  }\n\n  rangeQuery(queryBbox: number[]): number[][] {\n    const result: number[][] = [];\n    this._rangeQueryRecursive(this.root, queryBbox, result);\n    return result;\n  }\n\n  knnQuery(queryPoint: number[], k: number): [number, number][][] {\n    const result: [number, number][][] = [];\n    this._knnSearch(this.root, queryPoint, k, result);\n    result.sort((a, b) => a[1] - b[1]);\n    return result.slice(0, k);\n  }\n\n  calculateMinDistance(point: number[], boundingBox: number[]): number {\n    let minDistance = 0;\n\n    for (let i = 0; i < point.length; i++) {\n      if (point[i] < boundingBox[i]) {\n        minDistance += (boundingBox[i] - point[i]) ** 2;\n      } else if (point[i] > boundingBox[i + 2]) {\n        minDistance += (point[i] - boundingBox[i + 2]) ** 2;\n      }\n    }\n\n    return Math.sqrt(minDistance);\n  }\n\n  update(oldPoint: number[], newPoint: number[]): void {\n    this._recursiveUpdate(this.root, oldPoint, newPoint);\n  }\n\n  traverse(visitFunc: (node: RTreeNode) => void): void {\n    this._recursiveTraverse(this.root, visitFunc);\n  }\n\n  printNodeInfo(node: RTreeNode, depth: number): void {\n    const indentation = "  ".repeat(depth);\n    if (node.is_leaf) {\n      console.log(`${indentation}Leaf Node Bounding Box:`, node.bounding_box);\n    } else {\n      console.log(\n        `${indentation}Internal Node Bounding Box:`,\n        node.bounding_box,\n      );\n    }\n  }\n\n  private _insertRecursive(node: RTreeNode, point: number[]): void {\n    if (node.is_leaf) {\n      node.children.push(point);\n      if (node.children.length > this.max_children) {\n        this._split(node);\n      }\n    } else {\n      let min_increase = Infinity;\n      let best_child = null;\n\n      for (const child of node.children) {\n        const childBbox = this._calculateBoundingBox(child);\n        const expandedBbox = this._calculateExpandedBbox(childBbox, point);\n        const increase = this._calculateAreaIncrease(childBbox, expandedBbox);\n\n        if (increase < min_increase) {\n          min_increase = increase;\n          best_child = child;\n        }\n      }\n\n      if (best_child) {\n        this._insertRecursive(best_child, point);\n      }\n    }\n  }\n\n  private _calculateAreaIncrease(oldBbox: number[], newBbox: number[]): number {\n    const oldArea = (oldBbox[2] - oldBbox[0]) * (oldBbox[3] - oldBbox[1]);\n    const newArea = (newBbox[2] - newBbox[0]) * (newBbox[3] - newBbox[1]);\n    return newArea - oldArea;\n  }\n\n  private _calculateExpandedBbox(oldBbox: number[], point: number[]): number[] {\n    const [minX, minY, maxX, maxY] = oldBbox;\n    const newMinX = Math.min(minX, point[0]);\n    const newMinY = Math.min(minY, point[1]);\n    const newMaxX = Math.max(maxX, point[0]);\n    const newMaxY = Math.max(maxY, point[1]);\n    return [newMinX, newMinY, newMaxX, newMaxY];\n  }\n\n  private _split(node: RTreeNode): void {\n    const splitPoint = Math.floor(node.children.length / 2);\n    const newNode = new RTreeNode({ is_leaf: node.is_leaf });\n    newNode.children = node.children.slice(splitPoint);\n    node.children = node.children.slice(0, splitPoint);\n\n    node.bounding_box = this._calculateBoundingBox(node.children);\n    newNode.bounding_box = this._calculateBoundingBox(newNode.children);\n\n    if (node === this.root) {\n      const newRoot = new RTreeNode({ is_leaf: false });\n      newRoot.children = [node, newNode];\n      newRoot.bounding_box = this._calculateBoundingBox(newRoot.children);\n      this.root = newRoot;\n    }\n  }\n\n  private _deleteRecursive(node: RTreeNode, point: number[]): void {\n    if (node.is_leaf) {\n      node.children = node.children.filter((p) => p !== point);\n    } else {\n      for (const child of node.children) {\n        const childBbox = this._calculateBoundingBox(child);\n        if (this._pointInBbox(point, childBbox)) {\n          this._deleteRecursive(child, point);\n          break;\n        }\n      }\n      node.bounding_box = this._calculateBoundingBox(node.children);\n    }\n  }\n\n  private _searchRecursive(\n    node: RTreeNode,\n    queryBbox: number[],\n    result: number[][],\n  ): void {\n    if (node.is_leaf) {\n      for (const point of node.children) {\n        if (this._pointInBbox(point, queryBbox)) {\n          result.push(point);\n        }\n      }\n    } else {\n      for (const child of node.children) {\n        const childBbox = this._calculateBoundingBox(child);\n        if (this._bboxIntersectsQuery(childBbox, queryBbox)) {\n          this._searchRecursive(child, queryBbox, result);\n        }\n      }\n    }\n  }\n\n  private _nearestNeighborsRecursive(\n    node: RTreeNode,\n    queryPoint: number[],\n    k: number,\n    result: [number, number][],\n  ): void {\n    if (node.is_leaf) {\n      for (const point of node.children) {\n        this._updateNearestNeighbors(queryPoint, point, k, result);\n      }\n    } else {\n      const sortedChildren = node.children\n        .slice()\n        .sort(\n          (a, b) =>\n            this._distance(queryPoint, this._calculateBoundingBox(a)) -\n            this._distance(queryPoint, this._calculateBoundingBox(b)),\n        );\n\n      for (const child of sortedChildren) {\n        const childBbox = this._calculateBoundingBox(child);\n        if (\n          this._distance(queryPoint, childBbox) < result[result.length - 1][0]\n        ) {\n          this._nearestNeighborsRecursive(child, queryPoint, k, result);\n        }\n      }\n    }\n  }\n\n  private _updateNearestNeighbors(\n    queryPoint: number[],\n    point: number[],\n    k: number,\n    result: [number, number][],\n  ): void {\n    const distance = this._distance(queryPoint, point);\n\n    if (result.length < k) {\n      result.push([distance, ...point]);\n      result.sort((a, b) => b[0] - a[0]);\n    } else if (distance < result[0][0]) {\n      result[0] = [distance, ...point];\n      result.sort((a, b) => b[0] - a[0]);\n    }\n  }\n\n  private _distance(point1: number[], point2: number[]): number {\n    return Math.sqrt(\n      (point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2,\n    );\n  }\n\n  private _rangeQueryRecursive(\n    node: RTreeNode,\n    queryBbox: number[],\n    result: number[][],\n  ): void {\n    if (node.is_leaf) {\n      for (const point of node.children) {\n        if (this._pointInBbox(point, queryBbox)) {\n          result.push(point);\n        }\n      }\n    } else {\n      for (const child of node.children) {\n        const childBbox = this._calculateBoundingBox(child);\n        if (this._bboxIntersectsQuery(childBbox, queryBbox)) {\n          this._rangeQueryRecursive(child, queryBbox, result);\n        }\n      }\n    }\n  }\n\n  private _bboxIntersectsQuery(bbox: number[], queryBbox: number[]): boolean {\n    return !(\n      bbox[2] < queryBbox[0] ||\n      bbox[0] > queryBbox[2] ||\n      bbox[3] < queryBbox[1] ||\n      bbox[1] > queryBbox[3]\n    );\n  }\n\n  private _windowQueryRecursive(\n    node: RTreeNode,\n    queryBbox: number[],\n    result: number[][],\n  ): void {\n    if (node.is_leaf) {\n      for (const point of node.children) {\n        if (this._pointInBbox(point, queryBbox)) {\n          result.push(point);\n        }\n      }\n    } else {\n      for (const child of node.children) {\n        const childBbox = this._calculateBoundingBox(child);\n        if (this._bboxFullyContained(childBbox, queryBbox)) {\n          this._windowQueryRecursive(child, queryBbox, result);\n        }\n      }\n    }\n  }\n\n  private _bboxFullyContained(bbox1: number[], bbox2: number[]): boolean {\n    return (\n      bbox1[0] >= bbox2[0] &&\n      bbox1[1] >= bbox2[1] &&\n      bbox1[2] <= bbox2[2] &&\n      bbox1[3] <= bbox2[3]\n    );\n  }\n\n  private _pointInBbox(point: number[], bbox: number[]): boolean {\n    return (\n      bbox[0] <= point[0] &&\n      point[0] <= bbox[2] &&\n      bbox[1] <= point[1] &&\n      point[1] <= bbox[3]\n    );\n  }\n\n  private _calculateBoundingBox(points: number[][]): number[] {\n    const minX = Math.min(...points.map((p) => p[0]));\n    const minY = Math.min(...points.map((p) => p[1]));\n    const maxX = Math.max(...points.map((p) => p[0]));\n    const maxY = Math.max(...points.map((p) => p[1]));\n    return [minX, minY, maxX, maxY];\n  }\n\n  private _knnSearch(\n    node: RTreeNode,\n    queryPoint: number[],\n    k: number,\n    result: [number, number][][],\n  ): void {\n    if (node.is_leaf) {\n      for (const child of node.children) {\n        result.push([\n          child,\n          this._distance(queryPoint, this._calculateBoundingBox(child)),\n        ]);\n      }\n    } else {\n      const distances: [number[], number][] = node.children.map((child) => [\n        child,\n        this.calculateMinDistance(\n          queryPoint,\n          this._calculateBoundingBox(child),\n        ),\n      ]);\n\n      distances.sort((a, b) => a[1] - b[1]);\n\n      for (const [child, _] of distances.slice(0, k)) {\n        this._knnSearch(child, queryPoint, k, result);\n      }\n    }\n  }\n\n  private _recursiveUpdate(\n    node: RTreeNode,\n    oldPoint: number[],\n    newPoint: number[],\n  ): void {\n    if (node.is_leaf) {\n      for (let i = 0; i < node.children.length; i++) {\n        if (node.children[i].bounding_box.join(",") === oldPoint.join(",")) {\n          node.children[i].bounding_box = newPoint;\n          return;\n        }\n      }\n    } else {\n      for (const child of node.children) {\n        if (this._intersects(child.bounding_box, oldPoint)) {\n          this._recursiveUpdate(child, oldPoint, newPoint);\n        }\n      }\n    }\n  }\n\n  private _intersects(box1: number[], box2: number[]): boolean {\n    return !(\n      box1[2] < box2[0] ||\n      box1[0] > box2[2] ||\n      box1[3] < box2[1] ||\n      box1[1] > box2[3]\n    );\n  }\n\n  private _recursiveTraverse(\n    node: RTreeNode,\n    visitFunc: (node: RTreeNode) => void,\n  ): void {\n    visitFunc(node);\n    if (!node.is_leaf) {\n      for (const child of node.children) {\n        this._recursiveTraverse(child, visitFunc);\n      }\n    }\n  }\n}\n',_={title:"R-Tree",description:"R-Tree Data Structure",hide_table_of_contents:!0},p=void 0,f={id:"education/computer-science/data-structures/basic/r-tree",title:"R-Tree",description:"R-Tree Data Structure",source:"@site/docs/education/01-computer-science/09-data-structures/02-basic/16-r-tree.mdx",sourceDirName:"education/01-computer-science/09-data-structures/02-basic",slug:"/education/computer-science/data-structures/basic/r-tree",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/r-tree",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/16-r-tree.mdx",tags:[],version:"current",sidebarPosition:16,frontMatter:{title:"R-Tree",description:"R-Tree Data Structure",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Suffix Tree",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/suffix-ttree"},next:{title:"Graph",permalink:"/tech-labs/docs/education/computer-science/data-structures/basic/graph"}},B={},m=[{value:"Definition",id:"definition",level:2},{value:"Properties",id:"properties",level:3},{value:"Use Cases:",id:"use-cases",level:3},{value:"R*-Tree vs R-tree",id:"r-tree-vs-r-tree",level:3},{value:"Quad-Tree vs R-Tree",id:"quad-tree-vs-r-tree",level:3},{value:"Practice",id:"practice",level:2}];function g(n){const e={code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...n.components},{Details:_}=e;return _||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:(0,o.jsx)(e.img,{src:i(73069).Z+""})}),"\n",(0,o.jsxs)("table",{children:[(0,o.jsxs)("thead",{children:[(0,o.jsxs)("tr",{children:[(0,o.jsx)("th",{children:"Space"}),(0,o.jsx)("th",{colspan:"4",children:"Time"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("th",{}),(0,o.jsx)("th",{children:"Access"}),(0,o.jsx)("th",{children:"Lookup"}),(0,o.jsx)("th",{children:"Insertion"}),(0,o.jsx)("th",{children:"Deletion"})]})]}),(0,o.jsx)("tbody",{children:(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:(0,o.jsx)("code",{className:"fair",children:"O(n)"})}),(0,o.jsx)("td",{children:(0,o.jsx)("code",{className:"good",children:"O(log n)"})}),(0,o.jsx)("td",{children:(0,o.jsx)("code",{className:"good",children:"O(log n)"})}),(0,o.jsx)("td",{children:(0,o.jsx)("code",{className:"bad",children:"O(n log n)"})}),(0,o.jsx)("td",{children:(0,o.jsx)("code",{className:"good",children:"O(log n)"})})]})})]}),"\n",(0,o.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,o.jsxs)(r.Z,{children:[(0,o.jsxs)(d.Z,{value:"short",label:"Short",children:[(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"R-Tree"})," is a spatial index structure used in computer science and geographic information systems to efficiently organize and search spatial objects, facilitating operations like finding nearby\nlocations or detecting overlapping regions."]}),(0,o.jsxs)(_,{children:[(0,o.jsx)("summary",{children:"Simplified"}),(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"R-Tree"})," is like a smart index for digital maps, organizing locations into boxes for efficient searches. It helps quickly find specific places, like parks or restaurants, by guiding you to\nrelevant areas rather than scanning the entire map. In essence, it's an efficient guide for locating things on a digital map"]})]})]}),(0,o.jsxs)(d.Z,{value:"detailed",label:"Detailed",children:[(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:"R-Tree"})," is a spatial indexing data structure used for organizing and efficiently querying multidimensional spatial data. It arranges data in a hierarchical manner, with internal nodes\nrepresenting bounding rectangles of child nodes and leaves representing actual data objects within rectangles. R-Trees are designed to minimize overlap, optimize space, and enable fast retrieval\nof spatial information, making them useful in applications like geographic information systems and databases dealing with multidimensional data."]}),(0,o.jsx)(e.h3,{id:"properties",children:"Properties"}),(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Structure Components"}),": Consists of a single root, internal nodes, and leaf nodes"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Root Property"}),": The root contains a pointer to the largest region in the spatial domain"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Parent-Child Relationship"}),": Parent nodes contain pointers to their child nodes, where the region of child nodes completely overlaps the regions of parent nodes"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Leaf Node Information"}),": Leaf nodes contain data about the Minimum Bounding Region (MBR) for the current objects"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"MBR Definition"}),": Minimum Bounding Region, refers to the minimal bounding box parameter surrounding the region/object under consideration"]}),"\n"]}),(0,o.jsx)(e.h3,{id:"use-cases",children:"Use Cases:"}),(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Indexing multi-dimensional information"}),"\n",(0,o.jsx)(e.li,{children:"Handling geospatial coordinates"}),"\n",(0,o.jsx)(e.li,{children:"Implementation of virtual maps"}),"\n",(0,o.jsx)(e.li,{children:"Handling game data"}),"\n"]}),(0,o.jsx)(e.h3,{id:"r-tree-vs-r-tree",children:"R*-Tree vs R-tree"}),(0,o.jsxs)("table",{children:[(0,o.jsxs)("tr",{children:[(0,o.jsx)("th",{children:"Feature"}),(0,o.jsx)("th",{children:"R*-Tree"}),(0,o.jsx)("th",{children:"R-Tree"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Splitting Strategy"}),(0,o.jsx)("td",{children:"Optimized split strategy (e.g., R*-split)"}),(0,o.jsx)("td",{children:"Basic split strategy (e.g., linear split)"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Overlapping Nodes"}),(0,o.jsx)("td",{children:"Minimizes overlapping nodes for better performance"}),(0,o.jsx)("td",{children:"May have more overlapping nodes"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Node Overlap Reduction"}),(0,o.jsx)("td",{children:"Uses delayed reinsertion to reduce overlap"}),(0,o.jsx)("td",{children:"May not have sophisticated overlap reduction"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Node Overflow Handling"}),(0,o.jsx)("td",{children:"Utilizes quadratic split for overflow nodes"}),(0,o.jsx)("td",{children:"Utilizes basic split (e.g., linear split) for overflow nodes"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Node Utilization"}),(0,o.jsx)("td",{children:"More efficient space utilization"}),(0,o.jsx)("td",{children:"May have less efficient space utilization"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Query Performance"}),(0,o.jsx)("td",{children:"Generally better query performance"}),(0,o.jsx)("td",{children:"May have slightly lower query performance"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Insertion and Deletion"}),(0,o.jsx)("td",{children:"Improved insertion and deletion algorithms"}),(0,o.jsx)("td",{children:"May have simpler but less efficient algorithms"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Complexity of Implementation"}),(0,o.jsx)("td",{children:"More complex due to advanced strategies"}),(0,o.jsx)("td",{children:"Simpler and easier to implement"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"General Efficiency"}),(0,o.jsx)("td",{children:"Designed for better overall efficiency"}),(0,o.jsx)("td",{children:"Basic design with acceptable efficiency"})]})]}),(0,o.jsx)(e.h3,{id:"quad-tree-vs-r-tree",children:"Quad-Tree vs R-Tree"}),(0,o.jsxs)("table",{children:[(0,o.jsxs)("tr",{children:[(0,o.jsx)("th",{children:"Feature"}),(0,o.jsx)("th",{children:"Quad-Tree"}),(0,o.jsx)("th",{children:"R-Tree"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Tiling Level Optimization"}),(0,o.jsx)("td",{children:"Required"}),(0,o.jsx)("td",{children:"Optional"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Implementation on B-Tree"}),(0,o.jsx)("td",{children:"Can be implemented on top of an existing B-tree"}),(0,o.jsx)("td",{children:"Follows a different structure from a B-tree"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Spatial Index Creation Speed"}),(0,o.jsx)("td",{children:"Faster compared to R-Trees"}),(0,o.jsx)("td",{})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Performance in Nearest Neighbour Queries"}),(0,o.jsx)("td",{}),(0,o.jsx)("td",{children:"Faster than Quad-trees"})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Performance in Window Queries"}),(0,o.jsx)("td",{children:"Faster than R-Trees"}),(0,o.jsx)("td",{})]})]})]})]}),"\n",(0,o.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,o.jsxs)(r.Z,{children:[(0,o.jsx)(d.Z,{value:"practice",label:"Practice",children:(0,o.jsxs)("table",{children:[(0,o.jsx)("thead",{children:(0,o.jsxs)("tr",{children:[(0,o.jsx)("th",{children:"Aspect"}),(0,o.jsx)("th",{children:"Pseudo Code"})]})}),(0,o.jsxs)("tbody",{children:[(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Calculate Bounding Box"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"_calculate_bounding_box(points):\n  min_x = min(p[0] for p in points)\n  min_y = min(p[1] for p in points)\n  max_x = max(p[0] for p in points)\n  max_y = max(p[1] for p in points)\n  return (min_x, min_y, max_x, max_y)\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Calculate Expanded Bbox"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"_calculate_expanded_bbox(old_bbox, point):\n  min_x, min_y, max_x, max_y = old_bbox\n  new_min_x = min(min_x, point[0])\n  new_min_y = min(min_y, point[1])\n  new_max_x = max(max_x, point[0])\n  new_max_y = max(max_y, point[1])\n  return (new_min_x, new_min_y, new_max_x, new_max_y)\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Point In Bbox"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"_point_in_bbox(point, bbox):\n  return bbox[0] <= point[0] <= bbox[2] and bbox[1] <= point[1] <= bbox[3]\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Distance"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"_distance(point1, point2):\n  return sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Bbox Fully Contained"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"_bbox_fully_contained(bbox1, bbox2):\n  return bbox1[0] >= bbox2[0] and bbox1[1] >= bbox2[1] and bbox1[2] <= bbox2[2] and bbox1[3] <= bbox2[3]\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Bbox Intersects Query"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"_bbox_intersects_query(bbox, query_bbox):\n  return not (bbox[2] < query_bbox[0] or\n              bbox[0] > query_bbox[2] or\n              bbox[3] < query_bbox[1] or\n              bbox[1] > query_bbox[3])\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Split"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"_split(node):\n  split_point = len(node.children) // 2\n  new_node = RTreeNode(is_leaf=node.is_leaf)\n  new_node.children = node.children.split(split_point, node.children.length)\n  node.children = node.children.split(0, split_point)\n\n  node.bounding_box = _calculate_bounding_box(node.children)\n  new_node.bounding_box = _calculate_bounding_box(new_node.children)\n\n  if node == root:\n    new_root = RTreeNode(is_leaf=False)\n    new_root.children = [node, new_node]\n    new_root.bounding_box = _calculate_bounding_box(new_root.children)\n    root = new_root\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Calculate Area Increase"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"_calculate_area_increase(old_bbox, new_bbox):\n  old_area = (old_bbox[2] - old_bbox[0]) * (old_bbox[3] - old_bbox[1])\n  new_area = (new_bbox[2] - new_bbox[0]) * (new_bbox[3] - new_bbox[1])\n  return new_area - old_area\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Insertion"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"insert(point):\n  _insert_recursive(root, point)\n\n_insert_recursive(node, point):\n  if node.is_leaf:\n    node.children.append(point)\n    if len(node.children) > max_children:\n      _split(node)\n  else:\n    min_increase = \u221e\n    best_child = \xf8\n\n    for child in node.children:\n      child_bbox = _calculate_bounding_box(child)\n      expanded_bbox = _calculate_expanded_bbox(child_bbox, point)\n      increase = _calculate_area_increase(child_bbox, expanded_bbox)\n\n      if increase < min_increase:\n        min_increase=increase\n        best_child=child\n\n    _insert_recursive(best_child, point)\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Search Recursive"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"_search_recursive(node, query_bbox, result):\n  if node.is_leaf:\n    for point in node.children:\n      if _point_in_bbox(point, query_bbox):\n        result.append(point)\n  else:\n    for child in node.children:\n      child_bbox = _calculate_bounding_box(child)\n      if _bbox_intersects_query(child_bbox, query_bbox):\n        _search_recursive(child, query_bbox, result)\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Nearest Neighbors Recursive"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"nearest_neighbors_recursive(node, query_point, k, result):\n  if node.is_leaf:\n    for point in node.children:\n      _update_nearest_neighbors(query_point, point, k, result)\n  else:\n    sorted_children = sorted(node.children, key=lambda child: _distance(query_point, _calculate_bounding_box(child)))\n\n    for child in sorted_children:\n      child_bbox = _calculate_bounding_box(child)\n      if _distance(query_point, child_bbox) < result[-1][0]:\n        _nearest_neighbors_recursive(child, query_point, k, result)\n\n_update_nearest_neighbors(query_point, point, k, result):\n  distance = _distance(query_point, point)\n\n  if len(result) < k:\n    result.append((distance, point))\n    result.sort(key=lambda x: x[0], reverse=True)\n  elif distance < result[0][0]:\n    result[0] = (distance, point)\n    result.sort(key=lambda x: x[0], reverse=True)\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Delete Recursive"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"_delete_recursive(node, point):\n  if node.is_leaf:\n    node.children = [p for p in node.children if p != point]\n  else:\n    for child in node.children:\n      child_bbox = _calculate_bounding_box(child)\n      if _point_in_bbox(point, child_bbox):\n        _delete_recursive(child, point)\n        break\n    node.bounding_box = _calculate_bounding_box(node.children)\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Update"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"update(old_point, new_point):\n  _recursive_update(root, old_point, new_point)\n\n_recursive_update(node, old_point, new_point):\n  if node.is_leaf:\n    for i, child in enumerate(node.children):\n      if child.bounding_box == old_point:\n        node.children[i].bounding_box = new_point\n        return\n  else:\n    for child in node.children:\n      if _intersects(child.bounding_box, old_point):\n        _recursive_update(child, old_point, new_point)\n\n_intersects(box1, box2):\n  return not (box1[2] < box2[0] or\n              box1[0] > box2[2] or\n              box1[3] < box2[1] or\n              box1[1] > box2[3])\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Range Query"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"range_query(query_bbox):\n  result = []\n  _range_query_recursive(root, query_bbox, result)\n  return result\n\n_range_query_recursive(node, query_bbox, result):\n  if node.is_leaf:\n    for point in node.children:\n      if _point_in_bbox(point, query_bbox):\n        result.append(point)\n  else:\n    for child in node.children:\n      child_bbox = _calculate_bounding_box(child)\n      if _bbox_intersects_query(child_bbox, query_bbox):\n        _range_query_recursive(child, query_bbox, result)\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Window Query Recursive"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"window_query_recursive(node, query_bbox, result):\n  if node.is_leaf:\n    for point in node.children:\n      if _point_in_bbox(point, query_bbox):\n        result.append(point)\n  else:\n    for child in node.children:\n      child_bbox = _calculate_bounding_box(child)\n      if _bbox_fully_contained(child_bbox, query_bbox):\n        window_query_recursive(child, query_bbox, result)\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"kNN Query"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"knn_query(query_point, k):\n  result = []\n\n  _knn_search(root, query_point, k)\n\n  result.sort_based_on_second_element()\n  return result.split(0,k)\n\n_knn_search(node, query_point, k):\n  if node.is_leaf:\n    for child in node.children:\n      result.append((child, _distance(query_point, child.bounding_box)))\n  else:\n    distances = [(child, _calculate_min_distance(query_point, child.bounding_box)) for child in node.children]\n    distances.sort_based_on_second_element()\n\n    for child, _ in distances[:k]:\n      knn_search(child, query_point, k)\n\n_calculate_min_distance(point, bounding_box):\n  min_distance = 0\n  for i in range(len(point)):\n    if point[i] < bounding_box[i]:\n      min_distance += (bounding_box[i] - point[i])**2\n    elif point[i] > bounding_box[i + 2]:\n      min_distance += (point[i] - bounding_box[i + 2])**2\n  return sqrt(min_distance)\n"})})})]}),(0,o.jsxs)("tr",{children:[(0,o.jsx)("td",{children:"Traverse"}),(0,o.jsx)("td",{children:(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:'traverse(visit_func):\n  recursive_traverse(root, visit_func)\n\nrecursive_traverse(node, visit_func):\n  visit_func(node)\n  if not node.is_leaf:\n    for child in node.children:\n      recursive_traverse(child, visit_func)\n\nprint_node_info(node, depth):\n  indentation = " " * depth\n  if node.is_leaf:\n    print(indentation + "Leaf Node Bounding Box:", node.bounding_box)\n  else:\n    print(indentation + "Internal Node Bounding Box:", node.bounding_box)\n'})})})]})]})]})}),(0,o.jsx)(d.Z,{value:"solution",label:"Solution",children:(0,o.jsxs)(r.Z,{queryString:"code",children:[(0,o.jsx)(d.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,o.jsx)(l.Z,{language:"go",children:s})}),(0,o.jsx)(d.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,o.jsx)(l.Z,{language:"java",children:c})}),(0,o.jsx)(d.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,o.jsx)(l.Z,{language:"js",children:u})}),(0,o.jsx)(d.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,o.jsx)(l.Z,{language:"kotlin",children:a})}),(0,o.jsx)(d.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,o.jsx)(l.Z,{language:"python",children:b})}),(0,o.jsx)(d.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,o.jsx)(l.Z,{language:"rust",children:x})}),(0,o.jsx)(d.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,o.jsx)(l.Z,{language:"ts",children:h})})]})})]})]})}function y(n={}){const{wrapper:e}={...(0,t.a)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(g,{...n})}):g(n)}},73069:(n,e,i)=>{i.d(e,{Z:()=>o});const o=i.p+"assets/images/rTree-d845260a7a8888ad80411a720b6fd8dd.svg"}}]);