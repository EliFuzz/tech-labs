"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[7037],{50751:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>f,contentTitle:()=>w,default:()=>x,frontMatter:()=>v,metadata:()=>b,toc:()=>g});var r=a(11527),h=a(88672),s=a(29140),t=a(52360),l=a(52296);const o="package main\n\ntype SimplePolynomialHash struct {\n\tbase int\n}\n\nfunc NewSimplePolynomialHash(base int) *SimplePolynomialHash {\n\treturn &SimplePolynomialHash{base}\n}\n\nfunc (s *SimplePolynomialHash) Hash(word string) int {\n\thash := 0\n\tfor charIndex := 0; charIndex < len(word); charIndex++ {\n\t\thash += int(word[charIndex]) * pow(s.base, charIndex)\n\t}\n\treturn hash\n}\n\nfunc (s *SimplePolynomialHash) Roll(prevHash int, prevWord string, newWord string) int {\n\thash := prevHash\n\tprevValue := int(prevWord[0])\n\tnewValue := int(newWord[len(newWord)-1])\n\n\thash -= prevValue\n\thash /= s.base\n\thash += newValue * pow(s.base, len(newWord)-1)\n\n\treturn hash\n}\n\ntype PolynomialHash struct {\n\tbase    int\n\tmodulus int\n}\n\nfunc NewPolynomialHash(base, modulus int) *PolynomialHash {\n\treturn &PolynomialHash{base, modulus}\n}\n\nfunc (p *PolynomialHash) Hash(word string) int {\n\tcharCodes := make([]int, len(word))\n\tfor i, char := range word {\n\t\tcharCodes[i] = p.charToNumber(char)\n\t}\n\n\thash := 0\n\tfor _, charCode := range charCodes {\n\t\thash *= p.base\n\t\thash += charCode\n\t\thash %= p.modulus\n\t}\n\n\treturn hash\n}\n\nfunc (p *PolynomialHash) Roll(prevHash int, prevWord, newWord string) int {\n\thash := prevHash\n\tprevValue := p.charToNumber(rune(prevWord[0]))\n\tnewValue := p.charToNumber(rune(newWord[len(newWord)-1]))\n\n\tprevValueMultiplier := 1\n\tfor i := 1; i < len(prevWord); i++ {\n\t\tprevValueMultiplier *= p.base\n\t\tprevValueMultiplier %= p.modulus\n\t}\n\n\thash += p.modulus\n\thash -= (prevValue * prevValueMultiplier) % p.modulus\n\n\thash *= p.base\n\thash += newValue\n\thash %= p.modulus\n\n\treturn hash\n}\n\nfunc (p *PolynomialHash) charToNumber(char rune) int {\n\tcharCode := int(char)\n\tif surrogate := len(string(char)) == 2; surrogate {\n\t\tsurrogateShift := 1 << 16\n\t\tcharCode += int(char) * surrogateShift\n\t}\n\treturn charCode\n}\n\nfunc pow(x, n int) int {\n\tresult := 1\n\tfor i := 0; i < n; i++ {\n\t\tresult *= x\n\t}\n\treturn result\n}\n",i="import java.util.Arrays;\n\nclass SimplePolynomialHash {\n\n  private final int base;\n\n  SimplePolynomialHash(int base) {\n    this.base = base;\n  }\n\n  int hash(String word) {\n    int hash = 0;\n    for (int charIndex = 0; charIndex < word.length(); charIndex++) {\n      hash += word.charAt(charIndex) * Math.pow(base, charIndex);\n    }\n    return hash;\n  }\n\n  int roll(int prevHash, String prevWord, String newWord) {\n    int hash = prevHash;\n    int prevValue = prevWord.charAt(0);\n    int newValue = newWord.charAt(newWord.length() - 1);\n\n    hash -= prevValue;\n    hash /= base;\n    hash += newValue * Math.pow(base, newWord.length() - 1);\n\n    return hash;\n  }\n}\n\nclass PolynomialHash {\n\n  private final int base;\n  private final int modulus;\n\n  PolynomialHash() {\n    this.base = 37;\n    this.modulus = 101;\n  }\n\n  PolynomialHash(int base, int modulus) {\n    this.base = base;\n    this.modulus = modulus;\n  }\n\n  int hash(String word) {\n    int[] charCodes = word.chars().map(this::charToNumber).toArray();\n\n    int hash = 0;\n    for (int charIndex = 0; charIndex < charCodes.length; charIndex++) {\n      hash *= base;\n      hash += charCodes[charIndex];\n      hash %= modulus;\n    }\n\n    return hash;\n  }\n\n  int roll(int prevHash, String prevWord, String newWord) {\n    int hash = prevHash;\n    int prevValue = charToNumber(prevWord.charAt(0));\n    int newValue = charToNumber(newWord.charAt(newWord.length() - 1));\n\n    int prevValueMultiplier = 1;\n    for (int i = 1; i < prevWord.length(); i++) {\n      prevValueMultiplier *= base;\n      prevValueMultiplier %= modulus;\n    }\n\n    hash += modulus;\n    hash -= (prevValue * prevValueMultiplier) % modulus;\n\n    hash *= base;\n    hash += newValue;\n    hash %= modulus;\n\n    return hash;\n  }\n\n  private int charToNumber(int charCode) {\n    if (Character.charCount(charCode) == 2) {\n      int surrogateShift = 1 << 16;\n      charCode += Character.codePointAt(Character.toChars(charCode), 1) * surrogateShift;\n    }\n    return charCode;\n  }\n}\n",u="class SimplePolynomialHash {\n  constructor(base = 17) {\n    this.base = base;\n  }\n\n  hash(word) {\n    let hash = 0;\n    for (let charIndex = 0; charIndex < word.length; charIndex += 1) {\n      hash += word.charCodeAt(charIndex) * this.base ** charIndex;\n    }\n\n    return hash;\n  }\n\n  roll(prevHash, prevWord, newWord) {\n    let hash = prevHash;\n\n    const prevValue = prevWord.charCodeAt(0);\n    const newValue = newWord.charCodeAt(newWord.length - 1);\n\n    hash -= prevValue;\n    hash /= this.base;\n    hash += newValue * this.base ** (newWord.length - 1);\n\n    return hash;\n  }\n}\n\nclass PolynomialHash {\n  constructor({ base = 37, modulus = 101 } = {}) {\n    this.base = base;\n    this.modulus = modulus;\n  }\n\n  hash(word) {\n    const charCodes = Array.from(word).map((char) => this.charToNumber(char));\n\n    let hash = 0;\n    for (let charIndex = 0; charIndex < charCodes.length; charIndex += 1) {\n      hash *= this.base;\n      hash += charCodes[charIndex];\n      hash %= this.modulus;\n    }\n\n    return hash;\n  }\n\n  roll(prevHash, prevWord, newWord) {\n    let hash = prevHash;\n\n    const prevValue = this.charToNumber(prevWord[0]);\n    const newValue = this.charToNumber(newWord[newWord.length - 1]);\n\n    let prevValueMultiplier = 1;\n    for (let i = 1; i < prevWord.length; i += 1) {\n      prevValueMultiplier *= this.base;\n      prevValueMultiplier %= this.modulus;\n    }\n\n    hash += this.modulus;\n    hash -= (prevValue * prevValueMultiplier) % this.modulus;\n\n    hash *= this.base;\n    hash += newValue;\n    hash %= this.modulus;\n\n    return hash;\n  }\n\n  charToNumber(char) {\n    let charCode = char.codePointAt(0);\n\n    const surrogate = char.codePointAt(1);\n    if (surrogate !== undefined) {\n      const surrogateShift = 2 ** 16;\n      charCode += surrogate * surrogateShift;\n    }\n\n    return charCode;\n  }\n}\n",c="import kotlin.math.pow\n\nclass SimplePolynomialHash(private val base: Int = 17) {\n\n    fun hash(word: String): Int {\n        var hash = 0\n        for (charIndex in word.indices) {\n            hash += word[charIndex].toInt() * base.toDouble().pow(charIndex).toInt()\n        }\n        return hash\n    }\n\n    fun roll(prevHash: Int, prevWord: String, newWord: String): Int {\n        var hash = prevHash\n        val prevValue = prevWord[0].toInt()\n        val newValue = newWord[newWord.length - 1].toInt()\n\n        hash -= prevValue\n        hash /= base\n        hash += newValue * base.toDouble().pow(newWord.length - 1).toInt()\n\n        return hash\n    }\n}\n\nclass PolynomialHash(private val base: Int = 37, private val modulus: Int = 101) {\n\n    fun hash(word: String): Int {\n        val charCodes = word.map { charToNumber(it) }\n\n        var hash = 0\n        for (charCode in charCodes) {\n            hash *= base\n            hash += charCode\n            hash %= modulus\n        }\n\n        return hash\n    }\n\n    fun roll(prevHash: Int, prevWord: String, newWord: String): Int {\n        var hash = prevHash\n\n        val prevValue = charToNumber(prevWord[0])\n        val newValue = charToNumber(newWord[newWord.length - 1])\n\n        var prevValueMultiplier = 1\n        for (i in 1 until prevWord.length) {\n            prevValueMultiplier *= base\n            prevValueMultiplier %= modulus\n        }\n\n        hash += modulus\n        hash -= (prevValue * prevValueMultiplier) % modulus\n\n        hash *= base\n        hash += newValue\n        hash %= modulus\n\n        return hash\n    }\n\n    private fun charToNumber(char: Char): Int {\n        var charCode = char.code\n\n        val surrogate = char.code\n        if (Character.charCount(surrogate) == 2) {\n            val surrogateShift = 2.toDouble().pow(16).toInt()\n            charCode += Character.codePointAt(char.toString(), 1) * surrogateShift\n        }\n\n        return charCode\n    }\n}\n",d="class SimplePolynomialHash:\n    def __init__(self, base=17):\n        self.base = base\n\n    def hash(self, word):\n        hash_value = 0\n        for char_index in range(len(word)):\n            hash_value += ord(word[char_index]) * self.base ** char_index\n        return hash_value\n\n    def roll(self, prev_hash, prev_word, new_word):\n        hash_value = prev_hash\n        prev_value = ord(prev_word[0])\n        new_value = ord(new_word[-1])\n\n        hash_value -= prev_value\n        hash_value //= self.base\n        hash_value += new_value * self.base ** (len(new_word) - 1)\n\n        return hash_value\n\n\nclass PolynomialHash:\n    def __init__(self, base=37, modulus=101):\n        self.base = base\n        self.modulus = modulus\n\n    def hash(self, word):\n        char_codes = [self.char_to_number(char) for char in word]\n\n        hash_value = 0\n        for char_code in char_codes:\n            hash_value *= self.base\n            hash_value += char_code\n            hash_value %= self.modulus\n\n        return hash_value\n\n    def roll(self, prev_hash, prev_word, new_word):\n        hash_value = prev_hash\n\n        prev_value = self.char_to_number(prev_word[0])\n        new_value = self.char_to_number(new_word[-1])\n\n        prev_value_multiplier = 1\n        for i in range(1, len(prev_word)):\n            prev_value_multiplier *= self.base\n            prev_value_multiplier %= self.modulus\n\n        hash_value += self.modulus\n        hash_value -= (prev_value * prev_value_multiplier) % self.modulus\n\n        hash_value *= self.base\n        hash_value += new_value\n        hash_value %= self.modulus\n\n        return hash_value\n\n    def char_to_number(self, char):\n        char_code = ord(char)\n\n        surrogate = ord(char[1]) if len(char) == 2 else None\n        if surrogate is not None:\n            surrogate_shift = 2 ** 16\n            char_code += surrogate * surrogate_shift\n\n        return char_code\n",p="struct SimplePolynomialHash {\n    base: i32,\n}\n\nimpl SimplePolynomialHash {\n    fn new(base: i32) -> SimplePolynomialHash {\n        SimplePolynomialHash { base }\n    }\n\n    fn hash(&self, word: &str) -> i32 {\n        let mut hash = 0;\n        for (char_index, character) in word.chars().enumerate() {\n            hash += (character as i32) * self.base.pow(char_index as u32);\n        }\n        hash\n    }\n\n    fn roll(&self, prev_hash: i32, prev_word: &str, new_word: &str) -> i32 {\n        let mut hash = prev_hash;\n        let prev_value = prev_word.chars().nth(0).unwrap() as i32;\n        let new_value = new_word.chars().nth(new_word.len() - 1).unwrap() as i32;\n\n        hash -= prev_value;\n        hash /= self.base;\n        hash += new_value * self.base.pow((new_word.len() - 1) as u32);\n\n        hash\n    }\n}\n\nstruct PolynomialHash {\n    base: i32,\n    modulus: i32,\n}\n\nimpl PolynomialHash {\n    fn new(base: i32, modulus: i32) -> PolynomialHash {\n        PolynomialHash { base, modulus }\n    }\n\n    fn hash(&self, word: &str) -> i32 {\n        let char_codes: Vec<i32> = word.chars().map(|char| self.char_to_number(char)).collect();\n        let mut hash = 0;\n        for char_index in 0..char_codes.len() {\n            hash *= self.base;\n            hash += char_codes[char_index];\n            hash %= self.modulus;\n        }\n        hash\n    }\n\n    fn roll(&self, prev_hash: i32, prev_word: &str, new_word: &str) -> i32 {\n        let mut hash = prev_hash;\n        let prev_value = self.char_to_number(prev_word.chars().nth(0).unwrap());\n        let new_value = self.char_to_number(new_word.chars().nth(new_word.len() - 1).unwrap());\n\n        let mut prev_value_multiplier = 1;\n        for i in 1..prev_word.len() {\n            prev_value_multiplier *= self.base;\n            prev_value_multiplier %= self.modulus;\n        }\n\n        hash += self.modulus;\n        hash -= (prev_value * prev_value_multiplier) % self.modulus;\n\n        hash *= self.base;\n        hash += new_value;\n        hash %= self.modulus;\n\n        hash\n    }\n\n    fn char_to_number(&self, character: char) -> i32 {\n        let mut char_code = character as i32;\n        if let Some(surrogate) = character.encode_utf16().nth(1) {\n            let surrogate_shift = 2_i32.pow(16);\n            char_code += surrogate as i32 * surrogate_shift;\n        }\n        char_code\n    }\n}\n",m="class SimplePolynomialHash {\n  private base: number;\n\n  constructor(base: number = 17) {\n    this.base = base;\n  }\n\n  hash(word: string): number {\n    let hash = 0;\n    for (let charIndex = 0; charIndex < word.length; charIndex += 1) {\n      hash += word.charCodeAt(charIndex) * Math.pow(this.base, charIndex);\n    }\n    return hash;\n  }\n\n  roll(prevHash: number, prevWord: string, newWord: string): number {\n    let hash = prevHash;\n\n    const prevValue = prevWord.charCodeAt(0);\n    const newValue = newWord.charCodeAt(newWord.length - 1);\n\n    hash -= prevValue;\n    hash /= this.base;\n    hash += newValue * Math.pow(this.base, newWord.length - 1);\n\n    return hash;\n  }\n}\n\nclass PolynomialHash {\n  private base: number;\n  private modulus: number;\n\n  constructor({ base = 37, modulus = 101 } = {}) {\n    this.base = base;\n    this.modulus = modulus;\n  }\n\n  hash(word: string): number {\n    const charCodes = Array.from(word).map((char) => this.charToNumber(char));\n\n    let hash = 0;\n    for (let charIndex = 0; charIndex < charCodes.length; charIndex += 1) {\n      hash *= this.base;\n      hash += charCodes[charIndex];\n      hash %= this.modulus;\n    }\n\n    return hash;\n  }\n\n  roll(prevHash: number, prevWord: string, newWord: string): number {\n    let hash = prevHash;\n\n    const prevValue = this.charToNumber(prevWord[0]);\n    const newValue = this.charToNumber(newWord[newWord.length - 1]);\n\n    let prevValueMultiplier = 1;\n    for (let i = 1; i < prevWord.length; i += 1) {\n      prevValueMultiplier *= this.base;\n      prevValueMultiplier %= this.modulus;\n    }\n\n    hash += this.modulus;\n    hash -= (prevValue * prevValueMultiplier) % this.modulus;\n\n    hash *= this.base;\n    hash += newValue;\n    hash %= this.modulus;\n\n    return hash;\n  }\n\n  private charToNumber(char: string): number {\n    let charCode = char.codePointAt(0)!;\n\n    const surrogate = char.codePointAt(1);\n    if (surrogate !== undefined) {\n      const surrogateShift = 2 ** 16;\n      charCode += surrogate! * surrogateShift;\n    }\n\n    return charCode;\n  }\n}\n",v={title:"Polynomial Hash",description:"Polynomial Hash",hide_table_of_contents:!0},w=void 0,b={id:"education/computer-science/algorithms/algo/polynomial-hash",title:"Polynomial Hash",description:"Polynomial Hash",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/polynomial-hash.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/polynomial-hash",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/polynomial-hash",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/polynomial-hash.mdx",tags:[],version:"current",frontMatter:{title:"Polynomial Hash",description:"Polynomial Hash",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Permutations",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/permutations"},next:{title:"Power Set",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/power-set"}},f={},g=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function _(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,h.a)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(s.Z,{children:[(0,r.jsx)(t.Z,{value:"definition",label:"Definition",children:(0,r.jsx)(e.p,{children:"The Polynomial Hash Algorithm is a method used in computer science for hashing strings into unique numerical values. It involves treating the characters of a string as coefficients of a polynomial, evaluating this polynomial at a specific point, and taking the result modulo a prime number to avoid overflow and ensure uniform distribution of hash values"})}),(0,r.jsx)(t.Z,{value:"how",label:"Explanation",children:(0,r.jsx)(e.p,{children:"Set the hash value to zero. Next, examine each character in the given string individually. As you process each character, modify the hash value using a specific calculation method. Ensure the hash value remains within a defined range. Lastly, provide the resulting hash value as the output"})}),(0,r.jsx)(t.Z,{value:"guidance",label:"Guidance",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Start with a hash value set to ",(0,r.jsx)(e.code,{children:"0"})]}),"\n",(0,r.jsx)(e.li,{children:"Go through each letter in the string one by one"}),"\n",(0,r.jsx)(e.li,{children:"For each letter, add it to the hash value in a specific way"}),"\n",(0,r.jsx)(e.li,{children:"After considering all the letters, make sure the hash value stays within a certain range"}),"\n",(0,r.jsx)(e.li,{children:"Return resulting hash value"}),"\n"]})}),(0,r.jsx)(t.Z,{value:"tips",label:"Tips",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"choose a large prime number to minimize the chance of collisions"}),"\n",(0,r.jsx)(e.li,{children:"ensure the base is sufficiently large to cover the character set of the input string"}),"\n",(0,r.jsx)(e.li,{children:"consider using a rolling hash variant if dealing with large strings or streaming data, where the hash value can be efficiently updated with each character insertion or deletion"}),"\n"]})})]}),"\n",(0,r.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(s.Z,{children:[(0,r.jsx)(t.Z,{value:"practice",label:"Practice",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"polynomial_hash(input_string):\n  // Initialize variables\n  hash = 0\n  P = large_prime_number\n  B = base_value\n\n  // Iterate through each character in the input string\n  for each character c in input_string:\n    // Update hash using polynomial evaluation\n    hash = (hash * B + c) % P\n\n  // Return final hash value\n  return hash\n"})})}),(0,r.jsx)(t.Z,{value:"solution",label:"Solution",children:(0,r.jsxs)(s.Z,{queryString:"code",children:[(0,r.jsx)(t.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(l.Z,{language:"go",children:o})}),(0,r.jsx)(t.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(l.Z,{language:"java",children:i})}),(0,r.jsx)(t.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(l.Z,{language:"js",children:u})}),(0,r.jsx)(t.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(l.Z,{language:"kotlin",children:c})}),(0,r.jsx)(t.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(l.Z,{language:"python",children:d})}),(0,r.jsx)(t.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(l.Z,{language:"rust",children:p})}),(0,r.jsx)(t.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(l.Z,{language:"ts",children:m})})]})})]})]})}function x(n={}){const{wrapper:e}={...(0,h.a)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(_,{...n})}):_(n)}}}]);