"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[2085],{69772:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>x,contentTitle:()=>d,default:()=>v,frontMatter:()=>w,metadata:()=>f,toc:()=>R});var r=t(11527),a=t(88672),i=t(29140),o=t(52360),l=t(52296);const s="package main\n\nfunc regularExpressionMatching(str string, pattern string) bool {\n\tprevRow := make([]bool, len(pattern)+1)\n\tcurrentRow := make([]bool, len(pattern)+1)\n\n\tprevRow[0] = true\n\n\tfor j := 1; j <= len(pattern); j++ {\n\t\tif pattern[j-1] == '*' {\n\t\t\tcurrentRow[j] = prevRow[j-2]\n\t\t}\n\t}\n\n\tfor i := 1; i <= len(str); i++ {\n\t\tnextRow := make([]bool, 1)\n\t\tfor j := 1; j <= len(pattern); j++ {\n\t\t\tif pattern[j-1] == '*' {\n\t\t\t\tif prevRow[j] || (j > 1 && currentRow[j-2] && (pattern[j-2] == str[i-1] || pattern[j-2] == '.')) {\n\t\t\t\t\tcurrentRow[j] = true\n\t\t\t\t} else {\n\t\t\t\t\tcurrentRow[j] = false\n\t\t\t\t}\n\t\t\t} else if pattern[j-1] == str[i-1] || pattern[j-1] == '.' {\n\t\t\t\tcurrentRow[j] = prevRow[j-1]\n\t\t\t} else {\n\t\t\t\tcurrentRow[j] = false\n\t\t\t}\n\t\t\tnextRow = append(nextRow, currentRow[j])\n\t\t}\n\t\tcopy(prevRow, currentRow)\n\t\tcurrentRow = nextRow\n\t}\n\n\treturn prevRow[len(pattern)]\n}\n",c="public class Main {\n\n  public static boolean regularExpressionMatching(String str, String pattern) {\n    boolean[] prevRow = new boolean[pattern.length() + 1];\n    boolean[] currentRow = new boolean[pattern.length() + 1];\n\n    prevRow[0] = true;\n\n    for (int j = 1; j <= pattern.length(); j++) {\n      if (pattern.charAt(j - 1) == '*') {\n        currentRow[j] = prevRow[j - 2];\n      }\n    }\n\n    for (int i = 1; i <= str.length(); i++) {\n      boolean[] nextRow = new boolean[1];\n      for (int j = 1; j <= pattern.length(); j++) {\n        if (pattern.charAt(j - 1) == '*') {\n          if (prevRow[j] || (j > 1 && currentRow[j - 2] && (pattern.charAt(j - 2) == str.charAt(i - 1) || pattern.charAt(j - 2) == '.'))) {\n            currentRow[j] = true;\n          } else {\n            currentRow[j] = false;\n          }\n        } else if (pattern.charAt(j - 1) == str.charAt(i - 1) || pattern.charAt(j - 1) == '.') {\n          currentRow[j] = prevRow[j - 1];\n        } else {\n          currentRow[j] = false;\n        }\n        nextRow = Arrays.copyOf(nextRow, nextRow.length + 1);\n        nextRow[nextRow.length - 1] = currentRow[j];\n      }\n      System.arraycopy(currentRow, 0, prevRow, 0, prevRow.length);\n      currentRow = nextRow;\n    }\n\n    return prevRow[pattern.length()];\n  }\n}\n",p='function regularExpressionMatching(string, pattern) {\n  const prevRow = Array(pattern.length + 1).fill(false);\n  let currentRow = Array(pattern.length + 1).fill(false);\n\n  prevRow[0] = true;\n\n  for (let j = 1; j <= pattern.length; j++) {\n    if (pattern[j - 1] === "*") {\n      currentRow[j] = prevRow[j - 2];\n    }\n  }\n\n  for (let i = 1; i <= string.length; i++) {\n    const nextRow = [false];\n    for (let j = 1; j <= pattern.length; j++) {\n      if (pattern[j - 1] === "*") {\n        if (\n          prevRow[j] ||\n          (j > 1 &&\n            currentRow[j - 2] &&\n            (pattern[j - 2] === string[i - 1] || pattern[j - 2] === "."))\n        ) {\n          currentRow[j] = true;\n        } else {\n          currentRow[j] = false;\n        }\n      } else if (pattern[j - 1] === string[i - 1] || pattern[j - 1] === ".") {\n        currentRow[j] = prevRow[j - 1];\n      } else {\n        currentRow[j] = false;\n      }\n      nextRow.push(currentRow[j]);\n    }\n    prevRow.splice(0, prevRow.length, ...currentRow);\n    currentRow = nextRow;\n  }\n\n  return prevRow[pattern.length];\n}\n',u="fun regularExpressionMatching(str: String, pattern: String): Boolean {\n    var prevRow = BooleanArray(pattern.length + 1)\n    var currentRow = BooleanArray(pattern.length + 1)\n\n    prevRow[0] = true\n\n    for (j in 1..pattern.length) {\n        if (pattern[j - 1] == '*') {\n            currentRow[j] = prevRow[j - 2]\n        }\n    }\n\n    for (i in 1..str.length) {\n        var nextRow = booleanArrayOf()\n        for (j in 1..pattern.length) {\n            if (pattern[j - 1] == '*') {\n                if (prevRow[j] || (j > 1 && currentRow[j - 2] && (pattern[j - 2] == str[i - 1] || pattern[j - 2] == '.'))) {\n                    currentRow[j] = true\n                } else {\n                    currentRow[j] = false\n                }\n            } else if (pattern[j - 1] == str[i - 1] || pattern[j - 1] == '.') {\n                currentRow[j] = prevRow[j - 1]\n            } else {\n                currentRow[j] = false\n            }\n            nextRow += currentRow[j]\n        }\n        prevRow = currentRow.copyOf()\n        currentRow = nextRow.toBooleanArray()\n    }\n\n    return prevRow[pattern.length]\n}\n",h="def regular_expression_matching(string, pattern):\n    prev_row = [False] * (len(pattern) + 1)\n    current_row = [False] * (len(pattern) + 1)\n\n    prev_row[0] = True\n\n    for j in range(1, len(pattern) + 1):\n        if pattern[j - 1] == '*':\n            current_row[j] = prev_row[j - 2]\n\n    for i in range(1, len(string) + 1):\n        next_row = [False]\n        for j in range(1, len(pattern) + 1):\n            if pattern[j - 1] == '*':\n                if prev_row[j] or (j > 1 and current_row[j - 2] and (pattern[j - 2] == string[i - 1] or pattern[j - 2] == '.')):\n                    current_row[j] = True\n                else:\n                    current_row[j] = False\n            elif pattern[j - 1] == string[i - 1] or pattern[j - 1] == '.':\n                current_row[j] = prev_row[j - 1]\n            else:\n                current_row[j] = False\n            next_row.append(current_row[j])\n        prev_row = current_row[:]\n        current_row = next_row\n\n    return prev_row[len(pattern)]\n",j="fn regular_expression_matching(string: &str, pattern: &str) -> bool {\n    let mut prev_row = vec![false; pattern.len() + 1];\n    let mut current_row = vec![false; pattern.len() + 1];\n\n    prev_row[0] = true;\n\n    for j in 1..=pattern.len() {\n        if pattern.chars().nth(j - 1) == Some('*') {\n            current_row[j] = prev_row[j - 2];\n        }\n    }\n\n    for (i, ch) in string.chars().enumerate() {\n        let mut next_row = vec![false; 1];\n        for j in 1..=pattern.len() {\n            if pattern.chars().nth(j - 1) == Some('*') {\n                if prev_row[j] || (j > 1 && current_row[j - 2] && (pattern.chars().nth(j - 2) == Some(ch) || pattern.chars().nth(j - 2) == Some('.'))) {\n                    current_row[j] = true;\n                } else {\n                    current_row[j] = false;\n                }\n            } else if pattern.chars().nth(j - 1) == Some(ch) || pattern.chars().nth(j - 1) == Some('.') {\n                current_row[j] = prev_row[j - 1];\n            } else {\n                current_row[j] = false;\n            }\n            next_row.push(current_row[j]);\n        }\n        prev_row = current_row.clone();\n        current_row = next_row;\n    }\n\n    prev_row[pattern.len()]\n}\n",g='function regularExpressionMatching(string: string, pattern: string): boolean {\n  let prevRow: boolean[] = new Array<boolean>(pattern.length + 1).fill(false);\n  let currentRow: boolean[] = new Array<boolean>(pattern.length + 1).fill(\n    false,\n  );\n\n  prevRow[0] = true;\n\n  for (let j = 1; j <= pattern.length; j++) {\n    if (pattern[j - 1] === "*") {\n      currentRow[j] = prevRow[j - 2];\n    }\n  }\n\n  for (let i = 1; i <= string.length; i++) {\n    let nextRow: boolean[] = [false];\n    for (let j = 1; j <= pattern.length; j++) {\n      if (pattern[j - 1] === "*") {\n        if (\n          prevRow[j] ||\n          (j > 1 &&\n            currentRow[j - 2] &&\n            (pattern[j - 2] === string[i - 1] || pattern[j - 2] === "."))\n        ) {\n          currentRow[j] = true;\n        } else {\n          currentRow[j] = false;\n        }\n      } else if (pattern[j - 1] === string[i - 1] || pattern[j - 1] === ".") {\n        currentRow[j] = prevRow[j - 1];\n      } else {\n        currentRow[j] = false;\n      }\n      nextRow.push(currentRow[j]);\n    }\n    prevRow.splice(0, prevRow.length, ...currentRow);\n    currentRow = nextRow;\n  }\n\n  return prevRow[pattern.length];\n}\n',w={title:"Regular Expression Matching",description:"Regular Expression Matching",hide_table_of_contents:!0},d=void 0,f={id:"education/computer-science/algorithms/algo/regular-expression-matching",title:"Regular Expression Matching",description:"Regular Expression Matching",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/regular-expression-matching.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/regular-expression-matching",permalink:"/docs/education/computer-science/algorithms/algo/regular-expression-matching",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/regular-expression-matching.mdx",tags:[],version:"current",frontMatter:{title:"Regular Expression Matching",description:"Regular Expression Matching",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Recursive Staircase",permalink:"/docs/education/computer-science/algorithms/algo/recursive-staircase"},next:{title:"Reverse Traversal",permalink:"/docs/education/computer-science/algorithms/algo/reverse-traversal"}},x={},R=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function m(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.a)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(i.Z,{children:[(0,r.jsx)(o.Z,{value:"definition",label:"Definition",children:(0,r.jsx)(e.p,{children:"The Regular Expression Matching is a computational method used to determine whether a given string matches a pattern defined by a regular expression. It involves parsing the regular expression and the input string, and then applying matching rules iteratively to determine if there's a match."})}),(0,r.jsx)(o.Z,{value:"how",label:"Explanation",children:(0,r.jsx)(e.p,{children:"Starts by parsing the regular expression and the input string. Then, it iterates through each character in the input string and matches it with the corresponding regular expression pattern. It uses techniques like backtracking and dynamic programming to handle complex patterns efficiently"})}),(0,r.jsx)(o.Z,{value:"guidance",label:"Guidance",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Parse the regular expression into a data structure that represents its components (e.g., characters, wildcards, quantifiers)"}),"\n",(0,r.jsx)(e.li,{children:"Iterate through each character in the input string"}),"\n",(0,r.jsx)(e.li,{children:"For each character, compare it with the corresponding pattern in the regular expression"}),"\n",(0,r.jsx)(e.li,{children:"Apply matching rules based on the pattern, considering characters, wildcards, and quantifiers"}),"\n",(0,r.jsx)(e.li,{children:"If a match is found, move to the next character in both the input string and the regular expression"}),"\n",(0,r.jsx)(e.li,{children:"If a mismatch occurs, backtrack or try alternative paths if applicable"}),"\n",(0,r.jsx)(e.li,{children:"Continue this process until the end of the input string is reached or a match is found"}),"\n"]})}),(0,r.jsx)(o.Z,{value:"tips",label:"Tips",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"implement techniques like memoization to avoid redundant computations"}),"\n",(0,r.jsx)(e.li,{children:"handle special cases efficiently, such as empty strings and complex patterns with nested quantifiers"}),"\n"]})})]}),"\n",(0,r.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(i.Z,{children:[(0,r.jsx)(o.Z,{value:"practice",label:"Practice",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"isMatch(input: string, pattern: string) -> boolean:\n  # Start matching from the beginning of input and pattern\n  return matchHelper(0, 0)\n\n# Function to recursively match the pattern with the input string\nfunction matchHelper(inputIndex: integer, patternIndex: integer) -> boolean:\n  # Base case: both input and pattern are exhausted\n  if inputIndex == length(input) and patternIndex == length(pattern):\n    return true\n  # Base case: pattern is exhausted, but input is not\n  if patternIndex == length(pattern):\n    return false\n  # Check if the current characters match or pattern has wildcard\n  currentMatch = inputIndex < length(input) and (input[inputIndex] == pattern[patternIndex] or pattern[patternIndex] == '.')\n  # Check if next character in pattern is a quantifier\n  if patternIndex + 1 < length(pattern) and pattern[patternIndex + 1] == '*':\n    # If pattern has a wildcard, try matching input with pattern after wildcard\n    return matchHelper(inputIndex, patternIndex + 2) or (currentMatch and matchHelper(inputIndex + 1, patternIndex))\n  # If characters match, move to next character in both input and pattern\n  if currentMatch:\n    return matchHelper(inputIndex + 1, patternIndex + 1)\n  return false\n"})})}),(0,r.jsx)(o.Z,{value:"solution",label:"Solution",children:(0,r.jsxs)(i.Z,{queryString:"code",children:[(0,r.jsx)(o.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(l.Z,{language:"go",children:s})}),(0,r.jsx)(o.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(l.Z,{language:"java",children:c})}),(0,r.jsx)(o.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(l.Z,{language:"js",children:p})}),(0,r.jsx)(o.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(l.Z,{language:"kotlin",children:u})}),(0,r.jsx)(o.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(l.Z,{language:"python",children:h})}),(0,r.jsx)(o.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(l.Z,{language:"rust",children:j})}),(0,r.jsx)(o.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(l.Z,{language:"ts",children:g})})]})})]})]})}function v(n={}){const{wrapper:e}={...(0,a.a)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(m,{...n})}):m(n)}}}]);