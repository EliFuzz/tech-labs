"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[2312],{5975:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>f,contentTitle:()=>j,default:()=>v,frontMatter:()=>p,metadata:()=>x,toc:()=>b});var t=i(86070),s=i(27468),a=i(78826),l=i(28437),r=i(41634);const c="package main\n\nfunc lengthOfLIS(nums []int) int {\n    n := len(nums)\n    if n == 0 {\n        return 0\n    }\n    dp := make([]int, n)\n    dp[0] = 1\n    maxLen := 1\n    for i := 1; i < n; i++ {\n        dp[i] = 1\n        for j := 0; j < i; j++ {\n            if nums[i] > nums[j] && dp[i] < dp[j]+1 {\n                dp[i] = dp[j] + 1\n            }\n        }\n        if dp[i] > maxLen {\n            maxLen = dp[i]\n        }\n    }\n    return maxLen\n}\n",o="public class LongestIncreasingSubsequence {\n\n  public static int lengthOfLIS(int[] nums) {\n    int n = nums.length;\n    if (n == 0) {\n      return 0;\n    }\n    int[] dp = new int[n];\n    dp[0] = 1;\n    int maxLen = 1;\n    for (int i = 1; i < n; i++) {\n      dp[i] = 1;\n      for (int j = 0; j < i; j++) {\n        if (nums[i] > nums[j] && dp[i] < dp[j] + 1) {\n          dp[i] = dp[j] + 1;\n        }\n      }\n      if (dp[i] > maxLen) {\n        maxLen = dp[i];\n      }\n    }\n    return maxLen;\n  }\n}\n",d="function lengthOfLIS(nums) {\n  const n = nums.length;\n  if (n === 0) {\n    return 0;\n  }\n  const dp = new Array(n).fill(1);\n  let maxLen = 1;\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[i] > nums[j] && dp[i] < dp[j] + 1) {\n        dp[i] = dp[j] + 1;\n      }\n    }\n    if (dp[i] > maxLen) {\n      maxLen = dp[i];\n    }\n  }\n  return maxLen;\n}\n",u="fun lengthOfLIS(nums: IntArray): Int {\n    val n = nums.size\n    if (n == 0) return 0\n    val dp = IntArray(n) { 1 }\n    var maxLen = 1\n    for (i in 1 until n) {\n        for (j in 0 until i) {\n            if (nums[i] > nums[j] && dp[i] < dp[j] + 1) {\n                dp[i] = dp[j] + 1\n            }\n        }\n        if (dp[i] > maxLen) {\n            maxLen = dp[i]\n        }\n    }\n    return maxLen\n}\n",h="def lengthOfLIS(nums):\n    n = len(nums)\n    if n == 0:\n        return 0\n    dp = [1] * n\n    maxLen = 1\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] > nums[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n        if dp[i] > maxLen:\n            maxLen = dp[i]\n    return maxLen\n",m="fn length_of_lis(nums: Vec<i32>) -> i32 {\n    let n = nums.len();\n    if n == 0 {\n        return 0;\n    }\n    let mut dp = vec![1; n];\n    let mut max_len = 1;\n    for i in 1..n {\n        for j in 0..i {\n            if nums[i] > nums[j] && dp[i] < dp[j] + 1 {\n                dp[i] = dp[j] + 1;\n            }\n        }\n        if dp[i] > max_len {\n            max_len = dp[i];\n        }\n    }\n    max_len\n}\n",g="function lengthOfLIS(nums: number[]): number {\n  const n = nums.length;\n  if (n === 0) return 0;\n  const dp: number[] = new Array(n).fill(1);\n  let maxLen = 1;\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[i] > nums[j] && dp[i] < dp[j] + 1) {\n        dp[i] = dp[j] + 1;\n      }\n    }\n    if (dp[i] > maxLen) {\n      maxLen = dp[i];\n    }\n  }\n  return maxLen;\n}\n",p={title:"Longest Increasing Subsequence (LIS)",description:"Longest Increasing Subsequence (LIS)",hide_table_of_contents:!0},j=void 0,x={id:"education/computer-science/algorithms/algo/longest-increasing-subsequence",title:"Longest Increasing Subsequence (LIS)",description:"Longest Increasing Subsequence (LIS)",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/longest-increasing-subsequence.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/longest-increasing-subsequence",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/longest-increasing-subsequence",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/longest-increasing-subsequence.mdx",tags:[],version:"current",frontMatter:{title:"Longest Increasing Subsequence (LIS)",description:"Longest Increasing Subsequence (LIS)",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Longest Common Substring (LCS)",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/longest-common-substring"},next:{title:"Matrices",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/matrices"}},f={},b=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function L(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,t.jsxs)(a.A,{queryString:"primary",children:[(0,t.jsx)(l.A,{value:"definition",label:"Definition",children:(0,t.jsx)(e.p,{children:"The Longest Increasing Subsequence (LIS) algorithm is a dynamic programming approach used to find the longest subsequence in an array where the elements are in increasing order"})}),(0,t.jsx)(l.A,{value:"how",label:"Explanation",children:(0,t.jsx)(e.p,{children:"The LIS algorithm works by iterating through each element in the given array and maintaining a separate array to store the length of the longest increasing subsequence ending at each index. At each step, the algorithm compares the current element with all previous elements to find the longest increasing subsequence ending at the current element. It updates the length of the longest increasing subsequence for the current element based on the maximum length found so far. Finally, the algorithm returns the maximum length of the longest increasing subsequence"})}),(0,t.jsx)(l.A,{value:"guidance",label:"Guidance",children:(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Initialize an array ",(0,t.jsx)(e.code,{children:"dp"})," of size equal to the length of the input array, where ",(0,t.jsx)(e.code,{children:"dp[i]"})," will store the length of the longest increasing subsequence ending at index ",(0,t.jsx)(e.code,{children:"i"})]}),"\n",(0,t.jsxs)(e.li,{children:["Set all elements of ",(0,t.jsx)(e.code,{children:"dp"})," to 1 initially, as the minimum length of any subsequence is 1 (which is the element itself)"]}),"\n",(0,t.jsxs)(e.li,{children:["Iterate through each element ",(0,t.jsx)(e.code,{children:"arr[i]"})," in the input array"]}),"\n",(0,t.jsxs)(e.li,{children:["For each element, iterate through all previous elements ",(0,t.jsx)(e.code,{children:"arr[j]"})," where ",(0,t.jsx)(e.code,{children:"j < i"})]}),"\n",(0,t.jsxs)(e.li,{children:["If ",(0,t.jsx)(e.code,{children:"arr[j] < arr[i]"}),", meaning the current element can be part of the increasing subsequence ending at index ",(0,t.jsx)(e.code,{children:"i"}),", update ",(0,t.jsx)(e.code,{children:"dp[i]"})," to ",(0,t.jsx)(e.code,{children:"max(dp[i], dp[j] + 1)"})]}),"\n",(0,t.jsxs)(e.li,{children:["After iterating through all previous elements, ",(0,t.jsx)(e.code,{children:"dp[i]"})," will hold the length of the longest increasing subsequence ending at index ",(0,t.jsx)(e.code,{children:"i"})]}),"\n",(0,t.jsxs)(e.li,{children:["Find the maximum value in the ",(0,t.jsx)(e.code,{children:"dp"})," array, which represents the length of the longest increasing subsequence"]}),"\n",(0,t.jsx)(e.li,{children:"This maximum value is the result"}),"\n"]})}),(0,t.jsx)(l.A,{value:"tips",label:"Tips",children:(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"utilize dynamic programming to efficiently solve the problem by breaking it down into smaller subproblems"}),"\n",(0,t.jsx)(e.li,{children:"optimize the algorithm by using binary search to reduce the time complexity"}),"\n",(0,t.jsx)(e.li,{children:"pay attention to the indices while updating the dp array to correctly compute the length of the longest increasing subsequence ending at each index"}),"\n"]})})]}),"\n",(0,t.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,t.jsxs)(a.A,{queryString:"primary",children:[(0,t.jsx)(l.A,{value:"practice",label:"Practice",children:(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"lis(arr):\n  # Initialize an array dp to store lengths of longest increasing subsequences\n  dp = array of length equal to size of arr, initialized with 1s\n  for i from 0 to length of arr - 1:\n    for j from 0 to i - 1:\n      if arr[j] < arr[i]:\n        # Update the length of longest increasing subsequence ending at index i\n        dp[i] = max(dp[i], dp[j] + 1)\n  # Find the maximum value in dp\n  max_length = maximum value in dp\n  return max_length\n"})})}),(0,t.jsx)(l.A,{value:"solution",label:"Solution",children:(0,t.jsxs)(a.A,{queryString:"code",children:[(0,t.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,t.jsx)(r.A,{language:"go",children:c})}),(0,t.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,t.jsx)(r.A,{language:"java",children:o})}),(0,t.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,t.jsx)(r.A,{language:"js",children:d})}),(0,t.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,t.jsx)(r.A,{language:"kotlin",children:u})}),(0,t.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,t.jsx)(r.A,{language:"python",children:h})}),(0,t.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,t.jsx)(r.A,{language:"rust",children:m})}),(0,t.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,t.jsx)(r.A,{language:"ts",children:g})})]})})]})]})}function v(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(L,{...n})}):L(n)}}}]);