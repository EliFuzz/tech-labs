"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[4896],{45017:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>p,contentTitle:()=>_,default:()=>v,frontMatter:()=>N,metadata:()=>t,toc:()=>w});const t=JSON.parse('{"id":"education/computer-science/data-structures/basic/trie","title":"Trie","description":"Trie Data Structure","source":"@site/docs/education/01-computer-science/09-data-structures/02-basic/09-trie.mdx","sourceDirName":"education/01-computer-science/09-data-structures/02-basic","slug":"/education/computer-science/data-structures/basic/trie","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/trie","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/09-trie.mdx","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"title":"Trie","description":"Trie Data Structure","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Priority Queue","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/priority-queue"},"next":{"title":"Binary Search Tree","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/binary-search-tree"}}');var d=r(86070),o=r(15658),i=r(33407),s=r(33903),c=r(68171);const a="package main\n\ntype TrieNode struct {\n\tchildren     map[rune]*TrieNode\n\tisEndOfWord  bool\n}\n\ntype Trie struct {\n\troot *TrieNode\n}\n\nfunc NewTrie() *Trie {\n\treturn &Trie{\n\t\troot: &TrieNode{\n\t\t\tchildren: make(map[rune]*TrieNode),\n\t\t},\n\t}\n}\n\nfunc (t *Trie) addWord(word string) {\n\tcurrentNode := t.root\n\tfor _, char := range word {\n\t\tif _, exists := currentNode.children[char]; !exists {\n\t\t\tcurrentNode.children[char] = &TrieNode{\n\t\t\t\tchildren: make(map[rune]*TrieNode),\n\t\t\t}\n\t\t}\n\t\tcurrentNode = currentNode.children[char]\n\t}\n\tcurrentNode.isEndOfWord = true\n}\n\nfunc (t *Trie) deleteWord(word string) {\n\tt.depthFirstDelete(t.root, word, 0)\n}\n\nfunc (t *Trie) depthFirstDelete(currentNode *TrieNode, word string, index int) {\n\tif currentNode == nil {\n\t\treturn\n\t}\n\n\tif index == len(word) {\n\t\tif !currentNode.isEndOfWord {\n\t\t\treturn\n\t\t}\n\t\tcurrentNode.isEndOfWord = false\n\t\tif len(currentNode.children) == 0 {\n\t\t\tdelete(currentNode.children, rune(word[index-1]))\n\t\t}\n\t\treturn\n\t}\n\n\tchar := rune(word[index])\n\tnextNode, exists := currentNode.children[char]\n\n\tif !exists {\n\t\treturn\n\t}\n\n\tt.depthFirstDelete(nextNode, word, index+1)\n\n\tif len(nextNode.children) == 0 && !nextNode.isEndOfWord {\n\t\tdelete(currentNode.children, char)\n\t}\n}\n\nfunc (t *Trie) DeleteWordIterative(word string) {\n\tcurrentNode := t.root\n\tindex := 0\n\tvar nodesStack []struct {\n\t\tnode  *TrieNode\n\t\tindex int\n\t}\n\n\tfor index < len(word) {\n\t\tchar := rune(word[index])\n\t\tnextNode, exists := currentNode.children[char]\n\n\t\tif !exists {\n\t\t\treturn\n\t\t}\n\n\t\tnodesStack = append(nodesStack, struct {\n\t\t\tnode  *TrieNode\n\t\t\tindex int\n\t\t}{node: currentNode, index: index})\n\n\t\tcurrentNode = nextNode\n\t\tindex++\n\t}\n\n\tcurrentNode.isEndOfWord = false\n\n\tfor len(nodesStack) > 0 {\n\t\tnodeWithIndex := nodesStack[len(nodesStack)-1]\n\t\tnodesStack = nodesStack[:len(nodesStack)-1]\n\n\t\tif len(currentNode.children) == 0 && !currentNode.isEndOfWord {\n\t\t\tdelete(nodeWithIndex.node.children, rune(word[nodeWithIndex.index-1]))\n\t\t}\n\n\t\tcurrentNode = nodeWithIndex.node\n\t}\n}\n\nfunc (t *Trie) suggestNextCharacters(prefix string) []rune {\n\tlastNode := t.getLastCharacterNode(prefix)\n\tvar suggestions []rune\n\n\tif lastNode != nil {\n\t\tt.suggestNextCharacters(lastNode, []rune(prefix), &suggestions)\n\t}\n\n\treturn suggestions\n}\n\nfunc (t *Trie) suggestNextCharactersIterative(prefix string) []rune {\n\tvar suggestions []rune\n\tcurrentNode := t.root\n\tvar currentPrefix []rune\n\n\tfor _, char := range prefix {\n\t\tnextNode, exists := currentNode.children[char]\n\t\tif !exists {\n\t\t\treturn suggestions\n\t\t}\n\t\tcurrentNode = nextNode\n\t\tcurrentPrefix = append(currentPrefix, char)\n\t}\n\n\tstack := []struct {\n\t\tnode    *TrieNode\n\t\tcurrent []rune\n\t}{\n\t\t{node: currentNode, current: currentPrefix},\n\t}\n\n\tfor len(stack) > 0 {\n\t\tnodeWithPrefix := stack[len(stack)-1]\n\t\tstack = stack[:len(stack)-1]\n\n\t\tif nodeWithPrefix.node.isEndOfWord {\n\t\t\tsuggestions = append(suggestions, nodeWithPrefix.current[len(nodeWithPrefix.current)-1])\n\t\t}\n\n\t\tfor char, childNode := range nodeWithPrefix.node.children {\n\t\t\tstack = append(stack, struct {\n\t\t\t\tnode    *TrieNode\n\t\t\t\tcurrent []rune\n\t\t\t}{node: childNode, current: append(nodeWithPrefix.current, char)})\n\t\t}\n\t}\n\n\treturn suggestions\n}\n\nfunc (t *Trie) suggestNextCharacters(node *TrieNode, currentPrefix []rune, suggestions *[]rune) {\n\tif node.isEndOfWord {\n\t\t*suggestions = append(*suggestions, currentPrefix[len(currentPrefix)-1])\n\t}\n\n\tfor char, childNode := range node.children {\n\t\tt.suggestNextCharacters(childNode, append(currentPrefix, char), suggestions)\n\t}\n}\n\nfunc (t *Trie) doesWordExist(word string) bool {\n\tlastNode := t.getLastCharacterNode(word)\n\treturn lastNode != nil && lastNode.isEndOfWord\n}\n\nfunc (t *Trie) getLastCharacterNode(prefix string) *TrieNode {\n\tcurrentNode := t.root\n\n\tfor _, char := range prefix {\n\t\tnextNode, exists := currentNode.children[char]\n\t\tif !exists {\n\t\t\treturn nil\n\t\t}\n\t\tcurrentNode = nextNode\n\t}\n\n\treturn currentNode\n}\n\nfunc (t *Trie) startsWith(prefix string) bool {\n\treturn t.getLastCharacterNode(prefix) != nil\n}\n",u="import java.util.*;\n\npublic class Trie {\n\n  private TrieNode root;\n\n  public Trie() {\n    this.root = new TrieNode();\n  }\n\n  public void addWord(String word) {\n    TrieNode currentNode = root;\n    for (char ch : word.toCharArray()) {\n      currentNode.children.computeIfAbsent(ch, k -> new TrieNode());\n      currentNode = currentNode.children.get(ch);\n    }\n    currentNode.isEndOfWord = true;\n  }\n\n  public void deleteWord(String word) {\n    depthFirstDelete(root, word, 0);\n  }\n\n  private boolean depthFirstDelete(TrieNode currentNode, String word, int index) {\n    if (currentNode == null) {\n      return false;\n    }\n\n    if (index == word.length()) {\n      if (!currentNode.isEndOfWord) {\n        return false;\n      }\n      currentNode.isEndOfWord = false;\n      return currentNode.children.isEmpty();\n    }\n\n    char ch = word.charAt(index);\n    TrieNode nextNode = currentNode.children.get(ch);\n\n    if (nextNode == null) {\n      return false;\n    }\n\n    boolean shouldDeleteCurrentNode = depthFirstDelete(nextNode, word, index + 1);\n\n    if (shouldDeleteCurrentNode) {\n      currentNode.children.remove(ch);\n      return currentNode.children.isEmpty();\n    }\n\n    return false;\n  }\n\n  public void DeleteWordIterative(String word) {\n    TrieNode currentNode = root;\n    int index = 0;\n    Deque<Pair<TrieNode, Integer>> nodesStack = new ArrayDeque<>();\n\n    while (index < word.length()) {\n      char ch = word.charAt(index);\n      TrieNode nextNode = currentNode.children.get(ch);\n\n      if (nextNode == null) {\n        return;\n      }\n\n      nodesStack.push(new Pair<>(currentNode, index));\n      currentNode = nextNode;\n      index++;\n    }\n\n    currentNode.isEndOfWord = false;\n\n    while (!nodesStack.isEmpty()) {\n      Pair<TrieNode, Integer> nodeWithIndex = nodesStack.pop();\n      TrieNode parentNode = nodeWithIndex.getFirst();\n      int parentIndex = nodeWithIndex.getSecond();\n\n      if (currentNode.children.isEmpty() && !currentNode.isEndOfWord) {\n        Objects.requireNonNull(parentNode).children.remove(word.charAt(parentIndex));\n      }\n\n      currentNode = parentNode;\n    }\n  }\n\n  public List<Character> suggestNextCharacters(String prefix) {\n    TrieNode lastNode = getLastCharacterNode(prefix);\n    List<Character> suggestions = new ArrayList<>();\n    if (lastNode != null) {\n      suggestNextCharacters(lastNode, prefix, suggestions);\n    }\n    return suggestions;\n  }\n\n  private void suggestNextCharacters(TrieNode node, String currentPrefix, List<Character> suggestions) {\n    if (node.isEndOfWord) {\n      suggestions.add(currentPrefix.charAt(currentPrefix.length() - 1));\n    }\n\n    for (Map.Entry<Character, TrieNode> entry : node.children.entrySet()) {\n      suggestNextCharacters(entry.getValue(), currentPrefix + entry.getKey(), suggestions);\n    }\n  }\n\n  public List<Character> suggestNextCharactersIterative(String prefix) {\n    List<Character> suggestions = new ArrayList<>();\n    TrieNode currentNode = root;\n    StringBuilder currentPrefix = new StringBuilder();\n\n    for (char ch : prefix.toCharArray()) {\n      if (!currentNode.children.containsKey(ch)) {\n        return suggestions;\n      }\n      currentNode = currentNode.children.get(ch);\n      currentPrefix.append(ch);\n    }\n\n    Deque<Pair<TrieNode, String>> stack = new ArrayDeque<>();\n    stack.push(new Pair<>(currentNode, currentPrefix.toString()));\n\n    while (!stack.isEmpty()) {\n      Pair<TrieNode, String> nodeWithPrefix = stack.pop();\n      TrieNode node = nodeWithPrefix.getFirst();\n      String current = nodeWithPrefix.getSecond();\n\n      if (node.isEndOfWord) {\n        suggestions.add(current.charAt(current.length() - 1));\n      }\n\n      for (Map.Entry<Character, TrieNode> entry : node.children.entrySet()) {\n        stack.push(new Pair<>(entry.getValue(), current + entry.getKey()));\n      }\n    }\n\n    return suggestions;\n  }\n\n  public boolean doesWordExist(String word) {\n    TrieNode lastNode = getLastCharacterNode(word);\n    return lastNode != null && lastNode.isEndOfWord;\n  }\n\n  private TrieNode getLastCharacterNode(String prefix) {\n    TrieNode currentNode = root;\n    for (char ch : prefix.toCharArray()) {\n      if (!currentNode.children.containsKey(ch)) {\n        return null;\n      }\n      currentNode = currentNode.children.get(ch);\n    }\n    return currentNode;\n  }\n\n  public boolean startsWith(String prefix) {\n    return getLastCharacterNode(prefix) != null;\n  }\n\n  static class TrieNode {\n\n    Map<Character, TrieNode> children;\n    boolean isEndOfWord;\n\n    TrieNode() {\n      this.children = new HashMap<>();\n      this.isEndOfWord = false;\n    }\n  }\n}\n",l='class Trie {\n  constructor() {\n    this.root = { children: new Map(), isEndOfWord: false };\n  }\n\n  addWord(word) {\n    let currentNode = this.root;\n    for (const char of word) {\n      currentNode = currentNode.children.set(\n        char,\n        currentNode.children.get(char) || {\n          children: new Map(),\n          isEndOfWord: false,\n        },\n      );\n    }\n    currentNode.isEndOfWord = true;\n  }\n\n  deleteWord(word) {\n    this.depthFirstDelete(this.root, word, 0);\n  }\n\n  depthFirstDelete(currentNode, word, index) {\n    if (!currentNode) {\n      return false;\n    }\n\n    if (index === word.length) {\n      if (!currentNode.isEndOfWord) {\n        return false;\n      }\n      currentNode.isEndOfWord = false;\n      return currentNode.children.size === 0;\n    }\n\n    const char = word[index];\n    const nextNode = currentNode.children.get(char);\n\n    if (!nextNode) {\n      return false;\n    }\n\n    const shouldDeleteCurrentNode = this.depthFirstDelete(\n      nextNode,\n      word,\n      index + 1,\n    );\n\n    if (shouldDeleteCurrentNode) {\n      currentNode.children.delete(char);\n      return currentNode.children.size === 0;\n    }\n\n    return false;\n  }\n\n  DeleteWordIterative(word) {\n    let currentNode = this.root;\n    let index = 0;\n    const nodesStack = [];\n\n    while (index < word.length) {\n      const char = word[index];\n      const nextNode = currentNode.children.get(char);\n\n      if (!nextNode) {\n        return;\n      }\n\n      nodesStack.push([currentNode, index]);\n      currentNode = nextNode;\n      index++;\n    }\n\n    currentNode.isEndOfWord = false;\n\n    while (nodesStack.length > 0) {\n      const [parentNode, parentIndex] = nodesStack.pop();\n\n      if (currentNode.children.size === 0 && !currentNode.isEndOfWord) {\n        parentNode.children.delete(word[parentIndex]);\n      }\n\n      currentNode = parentNode;\n    }\n  }\n\n  suggestNextCharacters(prefix) {\n    const lastNode = this.getLastCharacterNode(prefix);\n    const suggestions = [];\n    if (lastNode) {\n      this.suggestNextCharacters(lastNode, prefix, suggestions);\n    }\n    return suggestions;\n  }\n\n  suggestNextCharactersIterative(prefix) {\n    const suggestions = [];\n    let currentNode = this.root;\n    let currentPrefix = "";\n\n    for (const char of prefix) {\n      if (!currentNode.children.has(char)) {\n        return suggestions;\n      }\n      currentNode = currentNode.children.get(char);\n      currentPrefix += char;\n    }\n\n    const stack = [[currentNode, currentPrefix]];\n\n    while (stack.length > 0) {\n      const [node, current] = stack.pop();\n\n      if (node.isEndOfWord) {\n        suggestions.push(current.charAt(current.length - 1));\n      }\n\n      for (const [char, childNode] of node.children) {\n        stack.push([childNode, current + char]);\n      }\n    }\n\n    return suggestions;\n  }\n\n  doesWordExist(word) {\n    const lastNode = this.getLastCharacterNode(word);\n    return lastNode && lastNode.isEndOfWord;\n  }\n\n  getLastCharacterNode(prefix) {\n    let currentNode = this.root;\n    for (const char of prefix) {\n      if (!currentNode.children.has(char)) {\n        return null;\n      }\n      currentNode = currentNode.children.get(char);\n    }\n    return currentNode;\n  }\n\n  startsWith(prefix) {\n    return this.getLastCharacterNode(prefix) !== null;\n  }\n}\n',h="import java.lang.StringBuilder\n\nclass Trie {\n    data class TrieNode(val children = mutableMapOf<Char, TrieNode>(), var isEndOfWord = false)\n\n    private val root = TrieNode()\n\n    fun addWord(word: String) {\n        var currentNode = root\n        for (char in word) {\n            currentNode = currentNode.children.computeIfAbsent(char) { TrieNode() }\n        }\n        currentNode.isEndOfWord = true\n    }\n\n    fun deleteWord(word: String) {\n        deleteWord(root, word, 0)\n    }\n\n    private fun deleteWord(currentNode: TrieNode?, word: String, index: Int): Boolean {\n        if (currentNode == null) {\n            return false\n        }\n\n        if (index == word.length) {\n            if (!currentNode.isEndOfWord) {\n                return false\n            }\n            currentNode.isEndOfWord = false\n            return currentNode.children.isEmpty()\n        }\n\n        val char = word[index]\n        val nextNode = currentNode.children[char] ?: return false\n\n        val shouldDeleteCurrentNode = deleteWord(nextNode, word, index + 1)\n\n        if (shouldDeleteCurrentNode) {\n            currentNode.children.remove(char)\n            return currentNode.children.isEmpty()\n        }\n\n        return false\n    }\n\n    fun DeleteWordIterative(word: String) {\n        var currentNode = root\n        var index = 0\n        val nodesStack = mutableListOf<Pair<TrieNode, Int>>()\n\n        while (index < word.length) {\n            val char = word[index]\n            val nextNode = currentNode.children[char]\n\n            if (nextNode == null) {\n                return\n            }\n\n            nodesStack.add(Pair(currentNode, index))\n            currentNode = nextNode\n            index++\n        }\n\n        currentNode.isEndOfWord = false\n\n        while (nodesStack.isNotEmpty()) {\n            val (parentNode, parentIndex) = nodesStack.removeAt(nodesStack.size - 1)\n\n            if (currentNode.children.isEmpty() && !currentNode.isEndOfWord) {\n                parentNode.children.remove(word[parentIndex])\n            }\n\n            currentNode = parentNode\n        }\n    }\n\n    fun depthFirstDelete(word: String) {\n        depthFirstDelete(root, word, 0)\n    }\n\n    private fun depthFirstDelete(currentNode: TrieNode, word: String, index: Int) {\n        if (index == word.length) {\n            currentNode.isEndOfWord = false\n            return\n        }\n\n        val char = word[index]\n        val nextNode = currentNode.children[char] ?: return\n\n        depthFirstDelete(nextNode, word, index + 1)\n\n        if (nextNode.children.isEmpty() && !nextNode.isEndOfWord) {\n            currentNode.children.remove(char)\n        }\n    }\n\n    fun DeleteWordIterative(word: String) {\n        var currentNode = root\n        var index = 0\n        val nodesStack = mutableListOf<Pair<TrieNode, Int>>()\n\n        while (index < word.length) {\n            val char = word[index]\n            val nextNode = currentNode.children[char]\n\n            if (nextNode == null) {\n                return\n            }\n\n            nodesStack.add(Pair(currentNode, index))\n            currentNode = nextNode\n            index++\n        }\n\n        currentNode.isEndOfWord = false\n\n        while (nodesStack.isNotEmpty()) {\n            val (parentNode, parentIndex) = nodesStack.removeAt(nodesStack.size - 1)\n\n            if (currentNode.children.isEmpty() && !currentNode.isEndOfWord) {\n                parentNode.children.remove(word[parentIndex])\n            }\n\n            currentNode = parentNode\n        }\n    }\n\n    fun suggestNextCharacters(prefix: String): List<Char> {\n        val lastNode = getLastCharacterNode(prefix)\n        val suggestions = mutableListOf<Char>()\n        if (lastNode != null) {\n            suggestNextCharacters(lastNode, prefix, suggestions)\n        }\n        return suggestions\n    }\n\n    private fun suggestNextCharacters(node: TrieNode, currentPrefix: String, suggestions: MutableList<Char>) {\n        if (node.isEndOfWord) {\n            suggestions.add(currentPrefix.last())\n        }\n\n        for ((char, childNode) in node.children) {\n            suggestNextCharacters(childNode, currentPrefix + char, suggestions)\n        }\n    }\n\n    fun suggestNextCharactersIterative(prefix: String): List<Char> {\n        val suggestions = mutableListOf<Char>()\n        var currentNode = root\n        var currentPrefix = StringBuilder()\n\n        for (char in prefix) {\n            currentNode = currentNode.children[char] ?: return suggestions\n            currentPrefix.append(char)\n        }\n\n        val stack = mutableListOf<Pair<TrieNode, String>>()\n        stack.add(Pair(currentNode, currentPrefix.toString()))\n\n        while (stack.isNotEmpty()) {\n            val (node, current) = stack.removeAt(stack.size - 1)\n\n            if (node.isEndOfWord) {\n                suggestions.add(current.last())\n            }\n\n            for ((char, childNode) in node.children) {\n                stack.add(Pair(childNode, current + char))\n            }\n        }\n\n        return suggestions\n    }\n\n    fun doesWordExist(word: String): Boolean {\n        val lastNode = getLastCharacterNode(word)\n        return lastNode?.isEndOfWord ?: false\n    }\n\n    private fun getLastCharacterNode(prefix: String): TrieNode? {\n        var currentNode = root\n        for (char in prefix) {\n            currentNode = currentNode.children[char] ?: return null\n        }\n        return currentNode\n    }\n\n    fun startsWith(prefix: String): Boolean {\n        return getLastCharacterNode(prefix) != null\n    }\n}\n",f='class Trie:\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_end_of_word = False\n\n    def __init__(self):\n        self.root = self.TrieNode()\n\n    def add_word(self, word):\n        current_node = self.root\n        for char in word:\n            current_node = current_node.children.setdefault(char, self.TrieNode())\n        current_node.is_end_of_word = True\n\n    def delete_word(self, word):\n        self.depth_first_delete(self.root, word, 0)\n\n    def depth_first_delete(self, current_node, word, index):\n        if current_node is None:\n            return False\n\n        if index == len(word):\n            if not current_node.is_end_of_word:\n                return False\n            current_node.is_end_of_word = False\n            return len(current_node.children) == 0\n\n        char = word[index]\n        next_node = current_node.children.get(char)\n\n        if not next_node:\n            return False\n\n        should_delete_current_node = self.depth_first_delete(next_node, word, index + 1)\n\n        if should_delete_current_node:\n            del current_node.children[char]\n            return len(current_node.children) == 0\n\n        return False\n\n    def depth_first_delete_iterative(self, word):\n        current_node = self.root\n        index = 0\n        nodes_stack = []\n\n        while index < len(word):\n            char = word[index]\n            next_node = current_node.children.get(char)\n\n            if not next_node:\n                return\n\n            nodes_stack.append((current_node, index))\n            current_node = next_node\n            index += 1\n\n        current_node.is_end_of_word = False\n\n        while nodes_stack:\n            parent_node, parent_index = nodes_stack.pop()\n\n            if not current_node.children and not current_node.is_end_of_word:\n                del parent_node.children[word[parent_index]]\n\n            current_node = parent_node\n\n    def suggest_next_characters(self, prefix):\n        last_node = self.get_last_character_node(prefix)\n        suggestions = []\n        if last_node:\n            self.suggest_next_characters_recursive(last_node, prefix, suggestions)\n        return suggestions\n\n    def suggest_next_characters_recursive(self, node, current_prefix, suggestions):\n        if node.is_end_of_word:\n            suggestions.append(current_prefix[-1])\n\n        for char, child_node in node.children.items():\n            self.suggest_next_characters_recursive(child_node, current_prefix + char, suggestions)\n\n    def suggest_next_characters_iterative(self, prefix):\n        suggestions = []\n        current_node = self.root\n        current_prefix = ""\n\n        for char in prefix:\n            if char not in current_node.children:\n                return suggestions\n            current_node = current_node.children[char]\n            current_prefix += char\n\n        stack = [(current_node, current_prefix)]\n\n        while stack:\n            node, current = stack.pop()\n\n            if node.is_end_of_word:\n                suggestions.append(current[-1])\n\n            for char, child_node in node.children.items():\n                stack.append((child_node, current + char))\n\n        return suggestions\n\n    def does_word_exist(self, word):\n        last_node = self.get_last_character_node(word)\n        return last_node and last_node.is_end_of_word\n\n    def get_last_character_node(self, prefix):\n        current_node = self.root\n        for char in prefix:\n            if char not in current_node.children:\n                return None\n            current_node = current_node.children[char]\n        return current_node\n\n    def starts_with(self, prefix):\n        return self.get_last_character_node(prefix) is not None\n',x="use std::collections::HashMap;\n\nstruct TrieNode {\n    children: HashMap<char, TrieNode>,\n    is_end_of_word: bool,\n}\n\nimpl TrieNode {\n    fn new() -> TrieNode {\n        TrieNode {\n            children: HashMap::new(),\n            is_end_of_word: false,\n        }\n    }\n}\n\npub struct Trie {\n    root: TrieNode,\n}\n\nimpl Trie {\n    pub fn new() -> Trie {\n        Trie { root: TrieNode::new() }\n    }\n\n    pub fn add_word(&mut self, word: &str) {\n        let mut current_node = &mut self.root;\n        for char in word.chars() {\n            current_node = current_node.children.entry(char).or_insert(TrieNode::new());\n        }\n        current_node.is_end_of_word = true;\n    }\n\n    pub fn delete_word(&mut self, word: &str) {\n        self.depth_first_delete(&mut self.root, word, 0);\n    }\n\n    fn depth_first_delete(&mut self, current_node: &mut TrieNode, word: &str, index: usize) -> bool {\n        if index == word.len() {\n            if !current_node.is_end_of_word {\n                return false;\n            }\n            current_node.is_end_of_word = false;\n            return current_node.children.is_empty();\n        }\n\n        let char = word.chars().nth(index).unwrap();\n        let next_node = current_node.children.get_mut(&char);\n\n        if let Some(next_node) = next_node {\n            let should_delete_current_node = self.depth_first_delete(next_node, word, index + 1);\n\n            if should_delete_current_node {\n                current_node.children.remove(&char);\n                return current_node.children.is_empty();\n            }\n        }\n\n        false\n    }\n\n    pub fn depth_first_delete_iterative(&mut self, word: &str) {\n        let mut current_node = &mut self.root;\n        let mut index = 0;\n        let mut nodes_stack: Vec<(&mut TrieNode, usize)> = Vec::new();\n\n        while index < word.len() {\n            if let Some(char) = word.chars().nth(index) {\n                let next_node = current_node.children.get_mut(&char);\n\n                if let Some(next_node) = next_node {\n                    nodes_stack.push((current_node, index));\n                    current_node = next_node;\n                    index += 1;\n                } else {\n                    return;\n                }\n            }\n        }\n\n        current_node.is_end_of_word = false;\n\n        while let Some((parent_node, parent_index)) = nodes_stack.pop() {\n            if current_node.children.is_empty() && !current_node.is_end_of_word {\n                parent_node.children.remove(&word.chars().nth(parent_index).unwrap());\n            }\n\n            current_node = parent_node;\n        }\n    }\n\n    pub fn suggest_next_characters(&self, prefix: &str) -> Vec<char> {\n        let last_node = self.get_last_character_node(prefix);\n        let mut suggestions = Vec::new();\n        if let Some(last_node) = last_node {\n            self.suggest_next_characters_recursive(&last_node, prefix, &mut suggestions);\n        }\n        suggestions\n    }\n\n    fn suggest_next_characters_recursive(&self, node: &TrieNode, current_prefix: &str, suggestions: &mut Vec<char>) {\n        if node.is_end_of_word {\n            suggestions.push(current_prefix.chars().last().unwrap());\n        }\n\n        for (char, child_node) in &node.children {\n            self.suggest_next_characters_recursive(child_node, &(current_prefix.to_owned() + char), suggestions);\n        }\n    }\n\n    pub fn suggest_next_characters_iterative(&self, prefix: &str) -> Vec<char> {\n        let mut suggestions = Vec::new();\n        let mut current_node = &self.root;\n        let mut current_prefix = String::new();\n\n        for char in prefix.chars() {\n            if let Some(next_node) = current_node.children.get(&char) {\n                current_node = next_node;\n                current_prefix.push(char);\n            } else {\n                return suggestions;\n            }\n        }\n\n        let mut stack: Vec<(&TrieNode, String)> = Vec::new();\n        stack.push((current_node, current_prefix.clone()));\n\n        while let Some((node, current)) = stack.pop() {\n            if node.is_end_of_word {\n                suggestions.push(current.chars().last().unwrap());\n            }\n\n            for (char, child_node) in &node.children {\n                stack.push((child_node, current.clone() + char));\n            }\n        }\n\n        suggestions\n    }\n\n    pub fn does_word_exist(&self, word: &str) -> bool {\n        let last_node = self.get_last_character_node(word);\n        last_node.map_or(false, |node| node.is_end_of_word)\n    }\n\n    fn get_last_character_node(&self, prefix: &str) -> Option<&TrieNode> {\n        let mut current_node = &self.root;\n        for char in prefix.chars() {\n            if let Some(next_node) = current_node.children.get(&char) {\n                current_node = next_node;\n            } else {\n                return None;\n            }\n        }\n        Some(current_node)\n    }\n\n    pub fn starts_with(&self, prefix: &str) -> bool {\n        self.get_last_character_node(prefix).is_some()\n    }\n}\n",g='class Trie {\n  private root: TrieNode;\n\n  constructor() {\n    this.root = new TrieNode();\n  }\n\n  addWord(word: string): void {\n    let currentNode: TrieNode = this.root;\n    for (const char of word) {\n      currentNode = currentNode.children[char] ??= new TrieNode();\n    }\n    currentNode.isEndOfWord = true;\n  }\n\n  deleteWord(word: string): void {\n    this.deleteWordRecursive(this.root, word, 0);\n  }\n\n  DeleteWordIterative(word: string): void {\n    let currentNode: TrieNode = this.root;\n    let index = 0;\n    const nodesStack: Array<[TrieNode, number]> = [];\n\n    while (index < word.length) {\n      const char = word[index];\n      const nextNode = currentNode.children[char];\n\n      if (!nextNode) {\n        return;\n      }\n\n      nodesStack.push([currentNode, index]);\n      currentNode = nextNode;\n      index++;\n    }\n\n    currentNode.isEndOfWord = false;\n\n    while (nodesStack.length > 0) {\n      const [parentNode, parentIndex] = nodesStack.pop()!;\n\n      if (\n        Object.keys(currentNode.children).length === 0 &&\n        !currentNode.isEndOfWord\n      ) {\n        delete parentNode.children[word[parentIndex]];\n      }\n\n      currentNode = parentNode;\n    }\n  }\n\n  depthFirstDelete(word: string): void {\n    this.depthFirstDeleteRecursive(this.root, word, 0);\n  }\n\n  DeleteWordIterative(word: string): void {\n    let currentNode: TrieNode = this.root;\n    let index = 0;\n    const nodesStack: Array<[TrieNode, number]> = [];\n\n    while (index < word.length) {\n      const char = word[index];\n      const nextNode = currentNode.children[char];\n\n      if (!nextNode) {\n        return;\n      }\n\n      nodesStack.push([currentNode, index]);\n      currentNode = nextNode;\n      index++;\n    }\n\n    currentNode.isEndOfWord = false;\n\n    while (nodesStack.length > 0) {\n      const [parentNode, parentIndex] = nodesStack.pop()!;\n\n      if (\n        Object.keys(currentNode.children).length === 0 &&\n        !currentNode.isEndOfWord\n      ) {\n        delete parentNode.children[word[parentIndex]];\n      }\n\n      currentNode = parentNode;\n    }\n  }\n\n  suggestNextCharacters(prefix: string): string[] {\n    const lastNode = this.getLastCharacterNode(prefix);\n    const suggestions: string[] = [];\n    if (lastNode) {\n      this.suggestNextCharactersRecursive(lastNode, prefix, suggestions);\n    }\n    return suggestions;\n  }\n\n  suggestNextCharactersIterative(prefix: string): string[] {\n    const suggestions: string[] = [];\n    let currentNode: TrieNode = this.root;\n    let currentPrefix = "";\n\n    for (const char of prefix) {\n      currentNode = currentNode.children[char];\n      if (!currentNode) {\n        return suggestions;\n      }\n      currentPrefix += char;\n    }\n\n    const stack: Array<[TrieNode, string]> = [[currentNode, currentPrefix]];\n\n    while (stack.length > 0) {\n      const [node, current] = stack.pop()!;\n\n      if (node.isEndOfWord) {\n        suggestions.push(current.charAt(current.length - 1));\n      }\n\n      for (const [char, childNode] of Object.entries(node.children)) {\n        stack.push([childNode, current + char]);\n      }\n    }\n\n    return suggestions;\n  }\n\n  doesWordExist(word: string): boolean {\n    const lastNode = this.getLastCharacterNode(word);\n    return lastNode?.isEndOfWord ?? false;\n  }\n\n  startsWith(prefix: string): boolean {\n    return this.getLastCharacterNode(prefix) !== undefined;\n  }\n\n  private deleteWordRecursive(\n    currentNode: TrieNode | undefined,\n    word: string,\n    index: number,\n  ): boolean {\n    if (!currentNode) {\n      return false;\n    }\n\n    if (index === word.length) {\n      if (!currentNode.isEndOfWord) {\n        return false;\n      }\n      currentNode.isEndOfWord = false;\n      return Object.keys(currentNode.children).length === 0;\n    }\n\n    const char = word[index];\n    const nextNode = currentNode.children[char];\n\n    if (!nextNode) {\n      return false;\n    }\n\n    const shouldDeleteCurrentNode = this.deleteWordRecursive(\n      nextNode,\n      word,\n      index + 1,\n    );\n\n    if (shouldDeleteCurrentNode) {\n      delete currentNode.children[char];\n      return Object.keys(currentNode.children).length === 0;\n    }\n\n    return false;\n  }\n\n  private depthFirstDeleteRecursive(\n    currentNode: TrieNode,\n    word: string,\n    index: number,\n  ): void {\n    if (index === word.length) {\n      currentNode.isEndOfWord = false;\n      return;\n    }\n\n    const char = word[index];\n    const nextNode = currentNode.children[char];\n\n    if (!nextNode) {\n      return;\n    }\n\n    this.depthFirstDeleteRecursive(nextNode, word, index + 1);\n\n    if (Object.keys(nextNode.children).length === 0 && !nextNode.isEndOfWord) {\n      delete currentNode.children[char];\n    }\n  }\n\n  private suggestNextCharactersRecursive(\n    node: TrieNode,\n    currentPrefix: string,\n    suggestions: string[],\n  ): void {\n    if (node.isEndOfWord) {\n      suggestions.push(currentPrefix.charAt(currentPrefix.length - 1));\n    }\n\n    for (const [char, childNode] of Object.entries(node.children)) {\n      this.suggestNextCharactersRecursive(\n        childNode,\n        currentPrefix + char,\n        suggestions,\n      );\n    }\n  }\n\n  private getLastCharacterNode(prefix: string): TrieNode | undefined {\n    let currentNode: TrieNode = this.root;\n    for (const char of prefix) {\n      currentNode = currentNode.children[char];\n      if (!currentNode) {\n        return undefined;\n      }\n    }\n    return currentNode;\n  }\n}\n\nclass TrieNode {\n  children: Record<string, TrieNode>;\n  isEndOfWord: boolean;\n\n  constructor() {\n    this.children = {};\n    this.isEndOfWord = false;\n  }\n}\n',N={title:"Trie",description:"Trie Data Structure",hide_table_of_contents:!0},_=void 0,p={},w=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function m(e){const n={code:"code",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.p,{children:(0,d.jsx)(n.img,{src:r(50846).A+""})}),"\n",(0,d.jsxs)("table",{children:[(0,d.jsxs)("thead",{children:[(0,d.jsxs)("tr",{children:[(0,d.jsx)("th",{children:"Space"}),(0,d.jsx)("th",{colspan:"6",children:"Time"})]}),(0,d.jsxs)("tr",{children:[(0,d.jsx)("th",{}),(0,d.jsx)("th",{children:"Access"}),(0,d.jsx)("th",{children:"Lookup"}),(0,d.jsx)("th",{children:"Insertion"}),(0,d.jsx)("th",{children:"Deletion"})]})]}),(0,d.jsx)("tbody",{children:(0,d.jsxs)("tr",{children:[(0,d.jsx)("td",{children:(0,d.jsx)("code",{className:"fair",children:"O(n)"})}),(0,d.jsx)("td",{children:(0,d.jsx)("code",{className:"na",children:"N/A"})}),(0,d.jsx)("td",{children:(0,d.jsx)("code",{className:"fair",children:"O(n)"})}),(0,d.jsx)("td",{children:(0,d.jsx)("code",{className:"fair",children:"O(n)"})}),(0,d.jsx)("td",{children:(0,d.jsx)("code",{className:"fair",children:"O(n)"})})]})})]}),"\n",(0,d.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,d.jsxs)(i.A,{queryString:"primary",children:[(0,d.jsxs)(s.A,{value:"short",label:"Short",children:[(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.strong,{children:"Trie"})," is a tree-like data structure used to store and efficiently retrieve strings."]}),(0,d.jsxs)(t,{children:[(0,d.jsx)("summary",{children:"Simplified"}),(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.strong,{children:"Trie"})," as a kind of magical tree. But instead of having fruits or leaves, this tree has letters on each branch. Now, suppose you want to find a word. You start at the root of the tree and follow\nthe branches that have the letters of your word in order. If you can reach the end of your word by following the branches, voila, the word is in the tree!"]}),(0,d.jsx)(n.p,{children:"For example, if you're looking for the word \"cat\", you'd start at the root, find a branch with the letter 'c', then from there find a branch with 'a', and finally a branch with 't'. If all these\nbranches exist in the correct order, the word \"cat\" is in your tree."}),(0,d.jsx)(n.p,{children:"This magical tree is super efficient and can help you find words really quickly, even if you have a dictionary's worth of words in your tree. That's why it's used in software engineering,\nespecially in tasks like word suggestions and spell checks. It's like having a super-powered dictionary."})]})]}),(0,d.jsx)(s.A,{value:"detailed",label:"Detailed",children:(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.strong,{children:"Trie"}),", also known as a digital or prefix tree, is a search tree used in computer science. It's an ordered tree data structure for storing dynamic sets or associative arrays where keys are\ntypically strings. Unlike binary search trees, the key isn't stored in the node, but is defined by the node's position in the tree. All descendants of a node share a common prefix of the string\nassociated with that node, with the root associated with an empty string. Values are usually associated with leaves and some inner nodes that correspond to keys of interest. A compact prefix tree\nis a space-optimized version of a trie."]})})]}),"\n",(0,d.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,d.jsxs)(i.A,{queryString:"primary",children:[(0,d.jsx)(s.A,{value:"practice",label:"Practice",children:(0,d.jsxs)("table",{children:[(0,d.jsx)("thead",{children:(0,d.jsxs)("tr",{children:[(0,d.jsx)("th",{children:"Aspect"}),(0,d.jsx)("th",{children:"Pseudo Code"})]})}),(0,d.jsxs)("tbody",{children:[(0,d.jsxs)("tr",{children:[(0,d.jsx)("td",{children:"Insertion"}),(0,d.jsx)("td",{children:(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"add_word(word)\n  current_node = root\n  for char in word:\n    current_node = current_node.children[char] ?: TrieNode()\n  current_node.is_end_of_word = True\n"})})})]}),(0,d.jsxs)("tr",{children:[(0,d.jsx)("td",{children:"Deletion Recursive"}),(0,d.jsx)("td",{children:(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"delete_word(word)\n  delete_word(root, word, 0)\n\ndelete_word(current_node, word, index)\n  if current_node == \xf8:\n    return False\n  if index == word.length:\n    if !current_node.is_end_of_word:\n      return False\n    current_node.is_end_of_word = false\n    return current_node.children == \xf8\n  char = word[index]\n  next_node = current_node.children[char] ?: return false\n  should_delete_current_node = delete_word(next_node, word, index + 1)\n  if should_delete_current_node:\n    current_node.children.remove(char)\n  return current_node.children == \xf8\n"})})})]}),(0,d.jsxs)("tr",{children:[(0,d.jsx)("td",{children:"Deletion Iterative"}),(0,d.jsx)("td",{children:(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"delete_word_iterative(word)\n  current_node = root\n  index = 0\n  nodes_stack = Stack<Pair<TrieNode, Int>>()\n\n  while index < word.length:\n    char = word[index]\n    next_node = current_node.children[char]\n\n    if next_node == \xf8:\n      return\n\n    nodes_stack.add(Pair(current_node, index))\n    current_node = next_node\n    index++\n\n  current_node.is_end_of_word = false\n\n  while nodes_stack != \xf8:\n    parentNode, parentIndex = nodes_stack.pop()\n\n    if current_node.children == \xf8 and not current_node.is_end_of_word:\n      parentNode.children.remove(word[parentIndex])\n\n    current_node = parentNode\n"})})})]}),(0,d.jsxs)("tr",{children:[(0,d.jsx)("td",{children:"Suggest Next Characters Recursive"}),(0,d.jsx)("td",{children:(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"suggest_next_characters(prefix)\n  lastNode = get_last_character_node(prefix)\n  suggestions = List<Char>()\n\n  if lastNode != \xf8:\n    suggest_next_characters(lastNode, prefix, suggestions)\n\n  return suggestions\n\nsuggest_next_characters(node, currentPrefix, suggestions)\n  if node.is_end_of_word:\n    suggestions.add(currentPrefix[currentPrefix.length - 1])\n\n  for char, child_node in node.children:\n    suggest_next_characters(child_node, currentPrefix + char, suggestions)\n"})})})]}),(0,d.jsxs)("tr",{children:[(0,d.jsx)("td",{children:"Suggest Next Characters Iterative"}),(0,d.jsx)("td",{children:(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:'suggest_next_characters_iterative(prefix)\n  suggestions = List<Char>()\n  current_node = root\n  currentPrefix = ""\n\n  for char in prefix:\n    current_node = current_node.children[char] ?: return suggestions\n    currentPrefix += char\n\n  stack = Stack<Pair<TrieNode, String>>()\n  stack.add(Pair(current_node, currentPrefix))\n\n  while stack != \xf8:\n    node, current = stack.pop()\n\n    if node.is_end_of_word:\n      suggestions.add(current.last())\n\n    for char, child_node in node.children:\n      stack.add(Pair(child_node, current + char))\n\n  return suggestions\n'})})})]}),(0,d.jsxs)("tr",{children:[(0,d.jsx)("td",{children:"Search"}),(0,d.jsx)("td",{children:(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"does_word_exist(word)\n  lastNode = get_last_character_node(word)\n  return lastNode?.is_end_of_word ?: false\n"})})})]}),(0,d.jsxs)("tr",{children:[(0,d.jsx)("td",{children:"Starts with"}),(0,d.jsx)("td",{children:(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"starts_with(prefix)\n  return get_last_character_node(prefix) != \xf8\n\nget_last_character_node(prefix)\n  current_node = root\n\n  for char in prefix:\n    current_node = current_node.children[char] ?: return \xf8\n\n  return current_node\n"})})})]})]})]})}),(0,d.jsx)(s.A,{value:"solution",label:"Solution",children:(0,d.jsxs)(i.A,{queryString:"code",children:[(0,d.jsx)(s.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,d.jsx)(c.A,{language:"go",children:a})}),(0,d.jsx)(s.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,d.jsx)(c.A,{language:"java",children:u})}),(0,d.jsx)(s.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,d.jsx)(c.A,{language:"js",children:l})}),(0,d.jsx)(s.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,d.jsx)(c.A,{language:"kotlin",children:h})}),(0,d.jsx)(s.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,d.jsx)(c.A,{language:"python",children:f})}),(0,d.jsx)(s.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,d.jsx)(c.A,{language:"rust",children:x})}),(0,d.jsx)(s.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,d.jsx)(c.A,{language:"ts",children:g})})]})})]})]})}function v(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(m,{...e})}):m(e)}},50846:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/trie-c50265f98bfa6c2a0c5e4d6cd4776595.svg"}}]);