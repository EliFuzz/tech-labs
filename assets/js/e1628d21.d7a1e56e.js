"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[4986],{98298:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>w,contentTitle:()=>m,default:()=>q,frontMatter:()=>f,metadata:()=>x,toc:()=>v});var i=t(86070),s=t(25710),d=t(98459),a=t(37515),r=t(18792);const l='package main\n\nimport (\n    "container/heap"\n    "math"\n)\n\ntype Edge struct {\n    to     int\n    weight int\n}\n\ntype Node struct {\n    id   int\n    dist int\n}\n\ntype PriorityQueue []*Node\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\nfunc (pq PriorityQueue) Less(i, j int) bool {\n    return pq[i].dist < pq[j].dist\n}\nfunc (pq PriorityQueue) Swap(i, j int) {\n    pq[i], pq[j] = pq[j], pq[i]\n}\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    item := x.(*Node)\n    *pq = append(*pq, item)\n}\nfunc (pq *PriorityQueue) Pop() interface{} {\n    old := *pq\n    n := len(old)\n    item := old[n-1]\n    *pq = old[0 : n-1]\n    return item\n}\n\nfunc dijkstra(graph [][]Edge, source int) []int {\n    n := len(graph)\n    dist := make([]int, n)\n    for i := range dist {\n        dist[i] = math.MaxInt32\n    }\n    dist[source] = 0\n\n    pq := make(PriorityQueue, 0)\n    heap.Init(&pq)\n    heap.Push(&pq, &Node{source, 0})\n\n    for pq.Len() > 0 {\n        node := heap.Pop(&pq).(*Node)\n        u := node.id\n        if dist[u] < node.dist {\n            continue\n        }\n        for _, edge := range graph[u] {\n            if alt := dist[u] + edge.weight; alt < dist[edge.to] {\n                dist[edge.to] = alt\n                heap.Push(&pq, &Node{edge.to, alt})\n            }\n        }\n    }\n    return dist\n}\n',o="import java.util.*;\n\nclass Dijkstra {\n\n  static int[] dijkstra(List<List<Edge>> graph, int source) {\n    int n = graph.size();\n    int[] dist = new int[n];\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[source] = 0;\n\n    PriorityQueue<Node> pq = new PriorityQueue<>();\n    pq.add(new Node(source, 0));\n\n    while (!pq.isEmpty()) {\n      Node node = pq.poll();\n      int u = node.id;\n      if (dist[u] < node.dist) {\n        continue;\n      }\n      for (Edge edge : graph.get(u)) {\n        int alt = dist[u] + edge.weight;\n        if (alt < dist[edge.to]) {\n          dist[edge.to] = alt;\n          pq.add(new Node(edge.to, alt));\n        }\n      }\n    }\n    return dist;\n  }\n\n  static class Edge {\n\n    int to, weight;\n\n    Edge(int to, int weight) {\n      this.to = to;\n      this.weight = weight;\n    }\n  }\n\n  static class Node implements Comparable<Node> {\n\n    int id, dist;\n\n    Node(int id, int dist) {\n      this.id = id;\n      this.dist = dist;\n    }\n\n    public int compareTo(Node other) {\n      return Integer.compare(this.dist, other.dist);\n    }\n  }\n}\n",h="class PriorityQueue {\n  constructor() {\n    this.heap = [];\n  }\n\n  enqueue(node) {\n    this.heap.push(node);\n    this.bubbleUp();\n  }\n\n  dequeue() {\n    const min = this.heap[0];\n    const end = this.heap.pop();\n    if (this.heap.length > 0) {\n      this.heap[0] = end;\n      this.sinkDown();\n    }\n    return min;\n  }\n\n  bubbleUp() {\n    let index = this.heap.length - 1;\n    const node = this.heap[index];\n    while (index > 0) {\n      let parentIndex = Math.floor((index - 1) / 2);\n      let parent = this.heap[parentIndex];\n      if (node.dist >= parent.dist) {\n        break;\n      }\n      this.heap[parentIndex] = node;\n      this.heap[index] = parent;\n      index = parentIndex;\n    }\n  }\n\n  sinkDown() {\n    let index = 0;\n    const length = this.heap.length;\n    const node = this.heap[0];\n    while (true) {\n      let leftChildIndex = 2 * index + 1;\n      let rightChildIndex = 2 * index + 2;\n      let leftChild, rightChild;\n      let swap = null;\n\n      if (leftChildIndex < length) {\n        leftChild = this.heap[leftChildIndex];\n        if (leftChild.dist < node.dist) {\n          swap = leftChildIndex;\n        }\n      }\n      if (rightChildIndex < length) {\n        rightChild = this.heap[rightChildIndex];\n        if (\n          (swap === null && rightChild.dist < node.dist) ||\n          (swap !== null && rightChild.dist < leftChild.dist)\n        ) {\n          swap = rightChildIndex;\n        }\n      }\n      if (swap === null) {\n        break;\n      }\n      this.heap[index] = this.heap[swap];\n      this.heap[swap] = node;\n      index = swap;\n    }\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n}\n\nclass Dijkstra {\n  constructor() {\n    this.graph = [];\n  }\n\n  addEdge(from, to, weight) {\n    if (!this.graph[from]) {\n      this.graph[from] = [];\n    }\n    this.graph[from].push({ to, weight });\n  }\n\n  dijkstra(source) {\n    const n = this.graph.length;\n    const dist = Array(n).fill(Infinity);\n    dist[source] = 0;\n\n    const pq = new PriorityQueue();\n    pq.enqueue({ id: source, dist: 0 });\n\n    while (!pq.isEmpty()) {\n      const node = pq.dequeue();\n      const u = node.id;\n      if (dist[u] < node.dist) {\n        continue;\n      }\n      for (const edge of this.graph[u] || []) {\n        const alt = dist[u] + edge.weight;\n        if (alt < dist[edge.to]) {\n          dist[edge.to] = alt;\n          pq.enqueue({ id: edge.to, dist: alt });\n        }\n      }\n    }\n    return dist;\n  }\n}\n",c="import java.util.*\n\nclass Edge(val to: Int, val weight: Int)\n\nclass Node(val id: Int, val dist: Int) : Comparable<Node> {\n    override fun compareTo(other: Node): Int {\n        return this.dist.compareTo(other.dist)\n    }\n}\n\nfun dijkstra(graph: List<List<Edge>>, source: Int): IntArray {\n    val n = graph.size\n    val dist = IntArray(n) { Int.MAX_VALUE }\n    dist[source] = 0\n\n    val pq = PriorityQueue<Node>()\n    pq.add(Node(source, 0))\n\n    while (pq.isNotEmpty()) {\n        val node = pq.poll()\n        val u = node.id\n        if (dist[u] < node.dist) continue\n        for (edge in graph[u]) {\n            val alt = dist[u] + edge.weight\n            if (alt < dist[edge.to]) {\n                dist[edge.to] = alt\n                pq.add(Node(edge.to, alt))\n            }\n        }\n    }\n    return dist\n}\n",u="import heapq\n\nclass Dijkstra:\n    def __init__(self):\n        self.graph = []\n\n    def add_edge(self, frm, to, weight):\n        if len(self.graph) <= frm:\n            self.graph += [[]] * (frm - len(self.graph) + 1)\n        self.graph[frm].append((to, weight))\n\n    def dijkstra(self, source):\n        n = len(self.graph)\n        dist = [float('inf')] * n\n        dist[source] = 0\n\n        pq = [(0, source)]\n\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in self.graph[u]:\n                if alt := dist[u] + w < dist[v]:\n                    dist[v] = alt\n                    heapq.heappush(pq, (alt, v))\n        return dist\n",p="use std::cmp::Ordering;\nuse std::collections::BinaryHeap;\n\n#[derive(Debug, Clone, Copy, Eq, PartialEq)]\nstruct Edge {\n    to: usize,\n    weight: i32,\n}\n\n#[derive(Debug, Clone, Copy, Eq, PartialEq)]\nstruct Node {\n    id: usize,\n    dist: i32,\n}\n\nimpl Ord for Node {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.dist.cmp(&self.dist)\n    }\n}\n\nimpl PartialOrd for Node {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nfn dijkstra(graph: &[Vec<Edge>], source: usize) -> Vec<i32> {\n    let n = graph.len();\n    let mut dist = vec![i32::MAX; n];\n    dist[source] = 0;\n\n    let mut pq = BinaryHeap::new();\n    pq.push(Node { id: source, dist: 0 });\n\n    while let Some(Node { id: u, dist: _ }) = pq.pop() {\n        for edge in &graph[u] {\n            let alt = dist[u] + edge.weight;\n            if alt < dist[edge.to] {\n                dist[edge.to] = alt;\n                pq.push(Node { id: edge.to, dist: alt });\n            }\n        }\n    }\n    dist\n}\n",g="class PriorityQueue<T> {\n  heap: { dist: number; node: T }[];\n\n  constructor() {\n    this.heap = [];\n  }\n\n  enqueue(node: T, dist: number) {\n    this.heap.push({ dist, node });\n    this.bubbleUp();\n  }\n\n  dequeue() {\n    const min = this.heap[0];\n    const end = this.heap.pop();\n    if (this.heap.length > 0) {\n      this.heap[0] = end;\n      this.sinkDown();\n    }\n    return min?.node;\n  }\n\n  bubbleUp() {\n    let index = this.heap.length - 1;\n    const node = this.heap[index];\n    while (index > 0) {\n      let parentIndex = Math.floor((index - 1) / 2);\n      let parent = this.heap[parentIndex];\n      if (node.dist >= parent.dist) break;\n      this.heap[parentIndex] = node;\n      this.heap[index] = parent;\n      index = parentIndex;\n    }\n  }\n\n  sinkDown() {\n    let index = 0;\n    const length = this.heap.length;\n    const node = this.heap[0];\n    while (true) {\n      let leftChildIndex = 2 * index + 1;\n      let rightChildIndex = 2 * index + 2;\n      let leftChild, rightChild;\n      let swap = null;\n\n      if (leftChildIndex < length) {\n        leftChild = this.heap[leftChildIndex];\n        if (leftChild.dist < node.dist) {\n          swap = leftChildIndex;\n        }\n      }\n      if (rightChildIndex < length) {\n        rightChild = this.heap[rightChildIndex];\n        if (\n          (swap === null && rightChild.dist < node.dist) ||\n          (swap !== null && rightChild.dist < leftChild.dist)\n        ) {\n          swap = rightChildIndex;\n        }\n      }\n      if (swap === null) break;\n      this.heap[index] = this.heap[swap];\n      this.heap[swap] = node;\n      index = swap;\n    }\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n}\n\nclass Dijkstra {\n  graph: { to: number; weight: number }[][];\n\n  constructor() {\n    this.graph = [];\n  }\n\n  addEdge(from: number, to: number, weight: number) {\n    if (!this.graph[from]) {\n      this.graph[from] = [];\n    }\n    this.graph[from].push({ to, weight });\n  }\n\n  dijkstra(source: number): number[] {\n    const n = this.graph.length;\n    const dist = Array(n).fill(Infinity);\n    dist[source] = 0;\n\n    const pq = new PriorityQueue<number>();\n    pq.enqueue(source, 0);\n\n    while (!pq.isEmpty()) {\n      const { node: u, dist: d } = pq.dequeue()!;\n      if (d > dist[u]) continue;\n      for (const edge of this.graph[u] || []) {\n        const alt = dist[u] + edge.weight;\n        if (alt < dist[edge.to]) {\n          dist[edge.to] = alt;\n          pq.enqueue(edge.to, alt);\n        }\n      }\n    }\n    return dist;\n  }\n}\n",f={title:"Dijkstra Algorithm",description:"Dijkstra Algorithm",hide_table_of_contents:!0},m=void 0,x={id:"education/computer-science/algorithms/algo/dijkstra-algorithm",title:"Dijkstra Algorithm",description:"Dijkstra Algorithm",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/dijkstra-algorithm.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/dijkstra-algorithm",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/dijkstra-algorithm",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/dijkstra-algorithm.mdx",tags:[],version:"current",frontMatter:{title:"Dijkstra Algorithm",description:"Dijkstra Algorithm",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Detect Graph Cycle",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/detect-graph-cycle"},next:{title:"Discrete Fourier Transform",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/discrete-fourier-transform"}},w={},v=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function j(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(d.A,{queryString:"primary",children:[(0,i.jsx)(a.A,{value:"definition",label:"Definition",children:(0,i.jsx)(e.p,{children:"Dijkstra's algorithm is a graph search algorithm that finds the shortest path between nodes in a graph, particularly for graphs with non-negative edge weights"})}),(0,i.jsx)(a.A,{value:"how",label:"Explanation",children:(0,i.jsx)(e.p,{children:"Set the distance from the start node to all other nodes as infinite, and the distance to itself as 0. We mark all nodes as unvisited and set the initial node as the current node. Then, for the current node, we assess each of its neighbors and compute their tentative distances through the current node. We compare these newly calculated tentative distances to the current assigned values and update them if a smaller distance is found. Afterward, we mark the current node as visited and remove it from the unvisited set. We check if the destination node has been visited or if the smallest tentative distance among the unvisited nodes is infinite; if so, the algorithm stops. Otherwise, we select the unvisited node with the smallest tentative distance, set it as the new current node, and repeat the process"})}),(0,i.jsx)(a.A,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Start from the source node"}),"\n",(0,i.jsx)(e.li,{children:"Assign tentative distances to all nodes. Initialize the source node distance as 0 and all others as infinite"}),"\n",(0,i.jsx)(e.li,{children:"Mark all nodes as unvisited"}),"\n",(0,i.jsx)(e.li,{children:"Set the current node as the source node"}),"\n",(0,i.jsxs)(e.li,{children:["For each neighboring node of the current node","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"calculate the tentative distance from the source node through the current node"}),"\n",(0,i.jsx)(e.li,{children:"if this distance is less than the current assigned distance, update it"}),"\n",(0,i.jsx)(e.li,{children:"Mark the current node as visited"}),"\n",(0,i.jsx)(e.li,{children:"If the destination node has been visited or if the smallest tentative distance among the unvisited nodes is infinite, stop. Otherwise, select the unvisited node with the smallest tentative distance as the new current node and repeat"}),"\n"]}),"\n"]}),"\n"]})}),(0,i.jsx)(a.A,{value:"tips",label:"Tips",children:(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"keep track of the shortest distance from the source node to each node"}),"\n",(0,i.jsx)(e.li,{children:"use a priority queue or heap to efficiently select the node with the smallest tentative distance"}),"\n",(0,i.jsx)(e.li,{children:"ensure that the graph doesn't contain negative edge weights, as Dijkstra's algorithm doesn't work correctly with negative weights"}),"\n"]})})]}),"\n",(0,i.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(d.A,{queryString:"primary",children:[(0,i.jsx)(a.A,{value:"practice",label:"Practice",children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:"Dijkstra(Graph, source):\n    dist[source] := 0\n    for each vertex v in Graph:\n        if v \u2260 source\n            dist[v] := infinity\n        add v to unvisited set\n\n    while unvisited set is not empty:\n        current := vertex in unvisited set with smallest distance\n        remove current from unvisited set\n        for each neighbor v of current:\n            alt := dist[current] + weight(current, v)\n            if alt < dist[v]:\n                dist[v] := alt\n\n    return dist\n"})})}),(0,i.jsx)(a.A,{value:"solution",label:"Solution",children:(0,i.jsxs)(d.A,{queryString:"code",children:[(0,i.jsx)(a.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(r.A,{language:"go",children:l})}),(0,i.jsx)(a.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(r.A,{language:"java",children:o})}),(0,i.jsx)(a.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(r.A,{language:"js",children:h})}),(0,i.jsx)(a.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(r.A,{language:"kotlin",children:c})}),(0,i.jsx)(a.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(r.A,{language:"python",children:u})}),(0,i.jsx)(a.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(r.A,{language:"rust",children:p})}),(0,i.jsx)(a.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(r.A,{language:"ts",children:g})})]})})]})]})}function q(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(j,{...n})}):j(n)}}}]);