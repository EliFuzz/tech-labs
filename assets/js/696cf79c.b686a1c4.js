"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[2464],{67887:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"education/tech-stack/frontend/graphql/federation","title":"Federation","description":"GraphQL Federation","source":"@site/docs/education/02-tech-stack/02-frontend/02-graphql/02-federation.mdx","sourceDirName":"education/02-tech-stack/02-frontend/02-graphql","slug":"/education/tech-stack/frontend/graphql/federation","permalink":"/tech-labs/docs/education/tech-stack/frontend/graphql/federation","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/02-tech-stack/02-frontend/02-graphql/02-federation.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Federation","description":"GraphQL Federation","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Basics","permalink":"/tech-labs/docs/education/tech-stack/frontend/graphql/Basics"},"next":{"title":"Advanced","permalink":"/tech-labs/docs/education/tech-stack/frontend/graphql/advanced"}}');var i=r(23420),t=r(38906),d=r(20007),l=r(31519);const a={title:"Federation",description:"GraphQL Federation",hide_table_of_contents:!0},c=void 0,o={},h=[];function p(e){const n={a:"a",code:"code",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(l.A,{queryString:"primary",children:[(0,i.jsxs)(d.A,{value:"query-execution",label:"Query Execution",children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Query Planning"})}),(0,i.jsx)(n.p,{children:"Router analyzes incoming queries and creates an execution plan:"}),(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parse Query"}),": break down the query into field selections"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Identify Entities"}),": determine which entities need to be resolved"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Plan Execution"}),": create optimal execution order"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Execute Subqueries"}),": send requests to appropriate subgraphs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compose Response"}),": merge responses into final result"]}),"\n"]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Query Execution"})}),(0,i.jsx)(n.p,{children:"Based on the query execution plan generated by the router, the query could be executed sequentially or in parallel across multiple subgraphs. The router orchestrates the execution, ensuring that dependencies are resolved correctly."}),(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant Router\n    participant User Preferences\n    participant User Activity\n    participant User Notifications\n\n    Client->>Router: GraphQL query\n    Router->>Router: parse & plan query\n\n    Router->>User Preferences: fetch user preferences\n    User Preferences->>Router: return user preferences\n\n    par User Activity\n        Router->>User Activity: fetch user activity\n    and User Notifications\n        Router->>User Notifications: fetch user notifications\n    end\n\n    User Activity->>Router: return user activity\n    User Notifications->>Router: return user notifications\n\n    Router->>Router: compose final response\n    Router->>Client: complete response"})]}),(0,i.jsxs)(d.A,{value:"schema-composition",label:"Schema Composition",children:[(0,i.jsx)(n.mermaid,{value:"graph BT\n    Sales(Sales) --\x3e Composer(Schema Composer)\n    Inventory(Inventory) --\x3e Composer\n    Shipping(Shipping) --\x3e Composer\n    Composer --\x3e Schema(Supergraph Schema)\n    Schema --\x3e Router(Router Configuration)"}),(0,i.jsxs)("table",{className:"text_vertical",children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{children:"Rule"}),(0,i.jsx)("th",{children:"Details"}),(0,i.jsx)("th",{children:"Example"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Type Merging"})}),(0,i.jsx)("td",{children:(0,i.jsxs)(n.p,{children:["Types (",(0,i.jsx)(n.code,{children:"objects"}),", ",(0,i.jsx)(n.code,{children:"interfaces"}),", ",(0,i.jsx)(n.code,{children:"enums"}),", ",(0,i.jsx)(n.code,{children:"scalars"}),", ",(0,i.jsx)(n.code,{children:"unions"}),",\n",(0,i.jsx)(n.code,{children:"inputs"}),") with the\n",(0,i.jsx)("a",{href:"https://www.apollographql.com/docs/graphos/schema-design/federated-schemas/reference/composition-rules#merging-types-from-multiple-subgraphs",children:"same name across different subgraphs are merged into a single,\nunified type in the Supergraph schema"}),"."]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Fields"}),": fields within merged object types are additive.\nIf multiple subgraphs define the same type, all unique fields\nfrom those types are combined."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Conflict Resolution"}),": if 2 subgraphs define fields with\nthe same name on a merged type but with different types, this\nresults in a composition error. The field type must be\nconsistent across all subgraphs that define it."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Directives"}),": directives applied to merged types or their\nfields are also merged. Conflicts arise if the same directive is\napplied with conflicting arguments."]})})]})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"# if Subgraph A defines\ntype Product {\n    id: ID!\n    name: String!\n}\n\n# and Subgraph B defines\ntype Product {\n    id: ID!\n    price: Float!\n}\n\n# the merged Supergraph type will be\ntype Product {\n    id: ID!\n    name: String!\n    price: Float!\n}\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Field Uniqueness and Ownership"})}),(0,i.jsx)("td",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("a",{href:"https://www.apollographql.com/docs/graphos/schema-design/federated-schemas/entities/resolve-another-subgraphs-fields",children:'Each field on an object type must be "owned" by exactly one\nsubgraph'}),", unless it's a ",(0,i.jsx)(n.code,{children:"@shareable"})," field."]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Single Source of Truth"}),': this rule ensures a single source\nof truth for a field\'s resolution logic. If multiple subgraphs\ndefine the same field on a type, only one subgraph is designated\nas the "owner" responsible for resolving that field.']})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsxs)("b",{children:[(0,i.jsx)(n.code,{children:"@shareable"})," Directive"]}),": fields marked with the\n",(0,i.jsx)(n.code,{children:"@shareable"})," directive can be defined and owned by multiple\nsubgraphs. This is typically used for fields that are stable and\ncan be resolved identically by different services (e.g., ID\nfields, static data)."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Composition Errors"}),": if a non-shareable field is defined\nin multiple subgraphs without explicit ownership delegation\n(e.g., through ",(0,i.jsx)(n.code,{children:"@external"})," and ",(0,i.jsx)(n.code,{children:"@provides"})," or ",(0,i.jsx)(n.code,{children:"@requires"}),"), it\nwill lead to a composition error."]})})]})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'type Product @key(fields: "id") {\n    id: ID!\n    # provided by one subgraph\n    name: String! @external\n    # provided by another subgraph\n    # using `@external` on the consuming subgraph\n    price: Float!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Entity Extensions"})}),(0,i.jsx)("td",{children:(0,i.jsxs)(n.p,{children:["Entities (types marked with ",(0,i.jsx)(n.code,{children:"@key"}),") can be extended across multiple\nsubgraphs. This allows different services to contribute fields to\nthe same entity."]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsxs)("b",{children:[(0,i.jsx)(n.code,{children:"@key"})," Directive"]}),": defines the primary key(s) for an\nentity, allowing the Supergraph to uniquely identify instances\nof that type."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsxs)("b",{children:[(0,i.jsx)(n.code,{children:"@extends"})," Directive"]}),': used in a subgraph to indicate that\na type is an extension of an entity defined in another subgraph.\nThe subgraph adding the extension does not "own" the base\nentity, but rather contributes additional fields to it.']})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsxs)("b",{children:[(0,i.jsx)(n.code,{children:"@external"})," Directive"]}),": marks a field as being defined in\nanother subgraph. This is used in conjunction with ",(0,i.jsx)(n.code,{children:"@extends"})," to\ndeclare fields that are part of the entity's key or are required\nfrom another subgraph to resolve local fields."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsxs)("b",{children:[(0,i.jsx)(n.code,{children:"@requires"})," Directive"]}),": specifies that a field's\nresolution depends on the values of other external fields from\nthe same entity."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsxs)("b",{children:[(0,i.jsx)(n.code,{children:"@provides"})," Directive"]}),": used to declare that a subgraph\ncan resolve a field from a federated entity even if it's not the\nprimary owner, typically for optimizing query plans."]})})]})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# Subgraph A defines User\ntype User @key(fields: "id") {\n    id: ID!\n    name: String!\n}\n\n# Subgraph B extends User\nextend type User @key(fields: "id") {\n    id: ID! @external\n    reviews: [Review!]! @requires(fields: "id")\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Directive Validation"})}),(0,i.jsx)("td",{children:(0,i.jsxs)(n.p,{children:["Federation-specific directives (",(0,i.jsx)(n.code,{children:"@key"}),", ",(0,i.jsx)(n.code,{children:"@extends"}),", ",(0,i.jsx)(n.code,{children:"@external"}),",\n",(0,i.jsx)(n.code,{children:"@requires"}),", ",(0,i.jsx)(n.code,{children:"@provides"}),", ",(0,i.jsx)(n.code,{children:"@shareable"}),", ",(0,i.jsx)(n.code,{children:"@inaccessible"}),", ",(0,i.jsx)(n.code,{children:"@tag"}),",\n",(0,i.jsx)(n.code,{children:"@override"}),", etc.) are rigorously validated during composition to\nensure correct usage and prevent inconsistencies."]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Placement"}),": directives must be applied to the correct\nschema locations (e.g., ",(0,i.jsx)(n.code,{children:"@key"})," on object types, ",(0,i.jsx)(n.code,{children:"@external"})," on\nfields)."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Arguments"}),": directive arguments must be valid and adhere\nto their definitions (e.g., ",(0,i.jsx)(n.code,{children:"fields"})," argument of ",(0,i.jsx)(n.code,{children:"@key"})," must\nrefer to existing fields)."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Semantic Checks"}),": the composer performs semantic checks,\nsuch as ensuring that ",(0,i.jsx)(n.code,{children:"@requires"})," fields are also marked\n",(0,i.jsx)(n.code,{children:"@external"})," and that key fields are always available for\nresolution."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Composition Errors"}),": invalid directive usage or conflicts\nin directive application will result in composition errors,\npreventing the Supergraph schema from being built."]})})]})}),(0,i.jsx)("td",{})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Root Operation Type Merging (Query, Mutation, Subscription)"})}),(0,i.jsx)("td",{children:(0,i.jsxs)(n.p,{children:["Root operation types (",(0,i.jsx)(n.code,{children:"Query"}),", ",(0,i.jsx)(n.code,{children:"Mutation"}),", ",(0,i.jsx)(n.code,{children:"Subscription"}),") are\nspecial: they are always merged, and their fields are additive\nacross all subgraphs."]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Additive Fields"}),": if multiple subgraphs define fields on\n",(0,i.jsx)(n.code,{children:"Query"}),", ",(0,i.jsx)(n.code,{children:"Mutation"}),", or ",(0,i.jsx)(n.code,{children:"Subscription"}),", all unique fields are\ncombined into a single root type in the Supergraph."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"No Ownership Conflict"}),": unlike regular object fields,\nfields on root operation types do not have ownership conflicts,\nas each subgraph provides its own set of root fields."]})})]})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"# Subgraph A has\ntype Query {\n    users: [User!]!\n}\n\n# Subgraph B has\ntype Query {\n    products: [Product!]!\n}\n\n# Supergraph Query will have both\ntype Query {\n    users: [User!]!\n    products: [Product!]!\n}\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Interface and Union Type Compatibility"})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.p,{children:"When an interface or union type is merged or extended, all\nimplementing types or member types must be resolvable and consistent\nacross subgraphs."})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Implementations"}),": if an interface is implemented by a type\nthat is also part of the Supergraph, that type must adhere to\nthe interface contract."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Union Members"}),": all member types of a union must be\nresolvable entity types within the Supergraph."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Composition Errors"}),": inconsistencies in type\nimplementations or unresolved union members will lead to\ncomposition errors."]})})]})}),(0,i.jsx)("td",{})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Enum and Scalar Type Consistency"})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.p,{children:"Enum and scalar types with the same name must have identical\ndefinitions (values for enums, and underlying\nserialization/deserialization logic for scalars) across all\nsubgraphs."})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Exact Match"}),": for enums, the set of values must be an\nexact match. Any discrepancy in values or their order will cause\na composition error."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Standard Scalars"}),": standard GraphQL scalars (ID, String,\nInt, Float, Boolean) are implicitly consistent."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Custom Scalars"}),": custom scalars require careful\ncoordination to ensure their serialization and deserialization\nlogic is consistent across all subgraphs that define or use\nthem."]})})]})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"# Subgraph A defines\nenum Status {\n    ACTIVE\n    INACTIVE\n}\n\n# Subgraph B defines\nenum Status {\n    ACTIVE\n    PENDING\n}\n\n# this will cause a composition error\n# due to inconsistent enum values\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Schema Directives and Metadata"})}),(0,i.jsx)("td",{children:(0,i.jsxs)(n.p,{children:["Directives defined at the schema level and other schema-level\nmetadata (like ",(0,i.jsx)(n.code,{children:"@link"}),") are also composed, with rules for merging\nand conflict resolution."]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsxs)("b",{children:[(0,i.jsx)(n.code,{children:"@link"})," Directive"]}),": used to declare the usage of external\nschema specifications (like ",(0,i.jsx)(n.code,{children:"@federation"})," from\n",(0,i.jsx)(n.code,{children:"https://specs.apollo.dev/federation/v2.0"}),"). Conflicts can arise\nif linked specifications clash."]})}),(0,i.jsx)("li",{children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)("b",{children:"Additive Behavior"}),": generally, schema-level directives and\nextensions (e.g., ",(0,i.jsx)(n.code,{children:"extend schema"}),") are additive, but conflicts\nin arguments or contradictory definitions can lead to\ncomposition errors."]})})]})}),(0,i.jsx)("td",{})]})]})]})]}),(0,i.jsxs)(d.A,{value:"query-optimization",label:"Query Optimization",children:[(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Query Planning"}),": optimize execution order"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Parallel Execution"}),": execute independent subqueries in parallel"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Query Deduplication"}),": cache and reuse identical queries"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Field Selection"}),": only fetch requested fields"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Minimize Operations Spanning Multiple Subgraphs"}),": design schemas to keep most queries within single subgraphs when possible, as cross-subgraph operations add query plan complexity and increase latency"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Overusing of @shareable and Shared Types"}),": the ",(0,i.jsx)(n.code,{children:"@shareable"})," directive enables multiple subgraphs to resolve the same entities or fields, offering query planner flexibility. However, overusing ",(0,i.jsx)(n.code,{children:"@shareable"})," can exponentially increase potential query paths, which degrades performance. Use it primarily where consistency between subgraphs is guaranteed and necessary"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Schema Evolution and Compatibility"}),": changes to fields and directives like ",(0,i.jsx)(n.code,{children:"@requires"})," can impact current query plans and introduce latency. Manage schema migrations carefully, deploying them atomically to avoid disruptions or performance regressions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Query Caching"}),": use caching mechanisms to store query for frequently static executed queries ",(0,i.jsx)(n.a,{href:"https://www.apollographql.com/docs/apollo-server/performance/apq",children:"APQ (Automatic Persisted Queries)"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Query Complexity Analysis"}),": analyze query complexity to prevent overly complex queries that can degrade performance. Implement limits on query depth and breadth"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Database Indexes"}),": ensure that database queries are optimized with appropriate indexes to speed up data retrieval"]}),"\n"]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Subgraph Caching"})}),(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{children:"DataLoader"}),(0,i.jsx)("th",{children:"Redis"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Scope"}),(0,i.jsx)("td",{children:"Per-request, in-memory"}),(0,i.jsx)("td",{children:"Cross-request, distributed"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Pros"}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"N+1 Query Problem"}),": use DataLoader within resolvers when your subgraph needs to fetch related data that causes multiple roundtrips to backend services or databases due to GraphQL's nested query patterns"]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"Optimizing Per-Request Data Fetching"}),": to cache and reuse fetched entities within a single request context"]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"Field-Level Data Fetching Efficiency"}),": use when different fields in your schema (resolved separately) require data from the same resource (e.g., batched loading of products, categories, or user profiles), ensuring single batched reads"]})]})}),(0,i.jsx)("td",{children:(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"Cross-Service (Distributed) Caching"}),": cache entities or frequently-requested subgraph query results across all instances and requests in clustered or horizontally scaled environments"]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"Pub/Sub for Subscriptions and Realtime Updates"}),": when your subgraph needs to support real-time updates (GraphQL subscriptions) at scale, distributing events among multiple subgraph or server instances so that all clients receive relevant updates, regardless of the processing node"]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("b",{children:"Message Brokering Across Microservices"}),": leverage for message passing or notification delivery between distinct microservices or subgraph instances, ensuring that each microservice can communicate asynchronously and efficiently, especially in event-driven architectures"]})]})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Use Case"}),(0,i.jsx)("td",{children:"Batching and caching per-request data-fetch operations"}),(0,i.jsx)("td",{children:"Cross-service caching, Pub/Sub for subscriptions, message brokering"})]})]})]})]}),(0,i.jsx)(d.A,{value:"common-types",label:"Common Types",children:(0,i.jsxs)("table",{children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Field"}),(0,i.jsx)("th",{children:"Description"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("code",{children:"scalar ID"})}),(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{href:"https://www.apollographql.com/docs/apollo-server/schema/custom-scalars",children:"Scalar type"})," used to represent a unique identifier for a resource"]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("code",{children:"enum CountryCode"})}),(0,i.jsxs)("td",{children:["2 letter ",(0,i.jsx)("a",{href:"https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes",children:"ISO 3166"})," code representing a country"]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("code",{children:"enum LanguageCode"})}),(0,i.jsxs)("td",{children:["2 letter ",(0,i.jsx)("a",{href:"https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes",children:"ISO 639"})," code representing a language"]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("code",{children:"input PageInput"})}),(0,i.jsxs)("td",{children:[(0,i.jsx)("a",{href:"https://relay.dev/graphql/connections.htm#sec-Arguments",children:"Input type"})," for ",(0,i.jsx)("a",{href:"https://graphql.org/learn/pagination/",children:"pagination"})," parameters"]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("code",{children:"type PageInfo"})}),(0,i.jsxs)("td",{children:["Contains information about ",(0,i.jsx)("a",{href:"https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo",children:"pagination"}),", such as total count and whether there are more pages available"]})]})]})]})}),(0,i.jsx)(d.A,{value:"entity-relationships",label:"Entity Relationships",children:(0,i.jsxs)("table",{className:"text_vertical",children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{children:"Definition"}),(0,i.jsx)("th",{children:"Example"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Entity Definition and Keys"})}),(0,i.jsx)("td",{children:"Entities are the core building blocks of federation. They represent business objects that can span multiple subgraphs"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# Primary entity definition (Users subgraph)\ntype User @key(fields: "id") {\n    id: ID!\n    username: String!\n    email: String!\n    createdAt: String!\n}\n\n# Entity with multiple keys (Products subgraph)\ntype Product @key(fields: "id") @key(fields: "sku") {\n    id: ID!\n    sku: String!\n    name: String!\n    price: Float!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Entity Extensions"})}),(0,i.jsx)("td",{children:"Other subgraphs can extend entities to add domain-specific fields"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# Orders subgraph extends User\nextend type User @key(fields: "id") {\n    id: ID! @external\n    orders: [Order!]!\n    totalSpent: Float!\n    loyaltyLevel: LoyaltyLevel!\n}\n\n# Reviews subgraph extends Product\nextend type Product @key(fields: "id") {\n    id: ID! @external\n    reviews: [Review!]!\n    averageRating: Float!\n    reviewCount: Int!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Single Subgraph One-to-One"})}),(0,i.jsx)("td",{children:"Within a single subgraph, one entity can directly reference another entity"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# User Profile (1:1 relationship)\ntype User @key(fields: "id") {\n    id: ID!\n    username: String!\n    profile: UserProfile\n}\n\ntype UserProfile {\n    id: ID!\n    user: User!\n    firstName: String\n    lastName: String\n    avatar: String\n    bio: String\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cross-Subgraph One-to-One"})}),(0,i.jsxs)("td",{children:["One entity in one subgraph can reference an entity in another subgraph using the ",(0,i.jsx)(n.code,{children:"@external"})," directive"]}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# User subgraph\ntype User @key(fields: "id") {\n    id: ID!\n    username: String!\n    email: String!\n}\n\n# Profile subgraph extends User\nextend type User @key(fields: "id") {\n    id: ID! @external\n    profile: UserProfile!\n}\n\ntype UserProfile {\n    id: ID!\n    firstName: String\n    lastName: String\n    avatar: String\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Single Subgraph One-to-Many"})}),(0,i.jsx)("td",{children:"Within a single subgraph, one entity can have multiple related entities"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# User has many posts\ntype User @key(fields: "id") {\n    id: ID!\n    username: String!\n    posts: [Post!]!\n}\n\ntype Post @key(fields: "id") {\n    id: ID!\n    title: String!\n    content: String!\n    author: User!\n    createdAt: String!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Paginated One-to-Many"})}),(0,i.jsx)("td",{children:"When one entity has many related entities, pagination is often used to efficiently fetch large sets of data"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# User has many orders (paginated)\nextend type User @key(fields: "id") {\n    id: ID! @external\n    orders(\n        first: Int\n        after: String\n        status: OrderStatus\n        dateRange: DateRangeInput\n    ): OrderConnection!\n}\n\ntype OrderConnection {\n    edges: [OrderEdge!]!\n    pageInfo: PageInfo!\n    totalCount: Int!\n}\n\ntype OrderEdge {\n    node: Order!\n    cursor: String!\n}\n\ntype Order @key(fields: "id") {\n    id: ID!\n    user: User!\n    status: OrderStatus!\n    total: Money!\n    createdAt: String!\n}\n\ninput DateRangeInput {\n    from: String!\n    to: String!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Single Subgraph Many-to-Many"})}),(0,i.jsx)("td",{children:"Within a single subgraph, one entity can be related to multiple instances of another entity"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# Products and Categories\ntype Product @key(fields: "id") {\n    id: ID!\n    name: String!\n    categories: [Category!]!\n}\n\ntype Category @key(fields: "id") {\n    id: ID!\n    name: String!\n    products: [Product!]!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Many-to-Many with Junction Table"})}),(0,i.jsx)("td",{children:" In many-to-many relationships, a junction table is often used to represent the relationship between 2` entities"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# Users and Roles with permissions\ntype User @key(fields: "id") {\n    id: ID!\n    username: String!\n    roleAssignments: [UserRoleAssignment!]!\n    roles: [Role!]!\n}\n\ntype Role @key(fields: "id") {\n    id: ID!\n    name: String!\n    permissions: [Permission!]!\n    userAssignments: [UserRoleAssignment!]!\n}\n\ntype UserRoleAssignment {\n    id: ID!\n    user: User!\n    role: Role!\n    assignedAt: String!\n    assignedBy: User!\n    expiresAt: String\n}\n\ntype Permission {\n    id: ID!\n    name: String!\n    resource: String!\n    action: String!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cross-Subgraph Entity Extension Pattern"})}),(0,i.jsx)("td",{children:"Allows entities to be extended across subgraphs, enabling more flexible and modular architecture"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# Users subgraph (primary definition)\ntype User @key(fields: "id") {\n    id: ID!\n    username: String!\n    email: String!\n}\n\n# Orders subgraph (extends User)\nextend type User @key(fields: "id") {\n    id: ID! @external\n    orders: [Order!]!\n    totalOrderValue: Float!\n}\n\n# Reviews subgraph (extends User)\nextend type User @key(fields: "id") {\n    id: ID! @external\n    reviews: [Review!]!\n    reviewCount: Int!\n    averageRating: Float!\n}\n\n# Wishlist subgraph (extends User)\nextend type User @key(fields: "id") {\n    id: ID! @external\n    wishlist: Wishlist!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Cross-Subgraph Reference Resolution"})}),(0,i.jsxs)("td",{children:["Enables one subgraph to reference entities from another subgraph using a representation (primary key + typename). The ",(0,i.jsx)(n.code,{children:"_resolveReference"})," resolver in each subgraph handles this, allowing distributed services to compose a unified API"]}),(0,i.jsxs)("td",{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Entity Definition and Key in the Products Subgraph"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# products subgraph (schema)\ntype Product @key(fields: "upc") {\n    upc: String!\n    name: String\n    price: Int\n}\n'})}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Reference Resolver in the Products Subgraph"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'Product: {\n    // this resolver is called when an entity of type Product\n    // is referenced by another subgraph\n    // given only an identifying key (like "upc")\n    __resolveReference(reference: ProductReference) {\n        // Find product by upc\n        return fetchProductByUPC(reference.upc);\n    }\n}\n'})}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Representing the Reference in the Reviews Subgraph"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// when the Reviews subgraph needs to provide a Product\n// (for example, for a Review.product field)\n// it must issue a representation\n// this tells the gateway and the entity resolver\n// that the referenced entity is a Product identified\n// by its upc\nReview: {\n    product(review: Review) {\n        return { __typename: "Product", upc: review.upc };\n    }\n}\n'})}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"End-to-End Query"})}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"# Router composes these subgraphs, allowing a client to run\nquery {\n    reviews {\n        product {\n            name\n            price\n        }\n    }\n}\n"})})]})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Required Fields Pattern"})}),(0,i.jsxs)("td",{children:["When an entity is extended across subgraphs, some fields may be required for resolution. The ",(0,i.jsx)(n.code,{children:"@requires"})," directive specifies which fields must be available from the base entity to resolve the extended fields"]}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# Analytics subgraph\nextend type User @key(fields: "id") {\n    id: ID! @external\n    username: String! @external\n    email: String! @external\n\n    # Field that requires external data\n    displayName: String! @requires(fields: "username")\n    emailDomain: String! @requires(fields: "email")\n    userMetrics: UserMetrics! @requires(fields: "username email")\n}\n\ntype UserMetrics {\n    username: String!\n    totalLogins: Int!\n    lastLoginAt: String\n    emailDomain: String!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Interface-Based Polymorphism"})}),(0,i.jsx)("td",{children:"Interfaces allow different subgraphs to define types that share a common contract, enabling polymorphic relationships"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# Content management system\ninterface Content {\n    id: ID!\n    title: String!\n    author: User!\n    createdAt: String!\n    updatedAt: String!\n}\n\ntype Article implements Content @key(fields: "id") {\n    id: ID!\n    title: String!\n    author: User!\n    createdAt: String!\n    updatedAt: String!\n    # Article-specific fields\n    body: String!\n    summary: String!\n    tags: [Tag!]!\n}\n\ntype Video implements Content @key(fields: "id") {\n    id: ID!\n    title: String!\n    author: User!\n    createdAt: String!\n    updatedAt: String!\n    # Video-specific fields\n    duration: Int!\n    videoUrl: String!\n    thumbnail: String!\n}\n\n# User can create different types of content\nextend type User @key(fields: "id") {\n    id: ID! @external\n    content: [Content!]!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Union-Based Polymorphism"})}),(0,i.jsx)("td",{children:"Unions allow a field to return different types, enabling flexible relationships where the type is not known until runtime"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"# Search results can be different types\nunion SearchResult = Product | Article | User | Category\n\ntype SearchResponse {\n    query: String!\n    total: Int!\n    results: [SearchResult!]!\n}\n\ntype Query {\n    search(query: String!, types: [SearchType!]): SearchResponse!\n}\n\nenum SearchType {\n    PRODUCT\n    ARTICLE\n    USER\n    CATEGORY\n}\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Conditional Access Control"})}),(0,i.jsx)("td",{children:"Allows for fine-grained authorization based on user roles and permissions"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'directive @hasRole(role: String!) on FIELD_DEFINITION\n\ntype Query {\n    me: User! @hasRole(role: "USER")\n    adminPanel: Admin! @hasRole(role: "ADMIN")\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Dynamic Relationships"})}),(0,i.jsx)("td",{children:"Relationships that depend on the current user context or other runtime conditions"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# Recommendations based on user behavior\nextend type Product @key(fields: "id") {\n    id: ID! @external\n    # Dynamic relationship based on current user\n    recommendedProducts: [Product!]!\n    userRecommendationScore: Float\n}\n'})})})]})]})]})}),(0,i.jsx)(d.A,{value:"best-practices",label:"Best Practices",children:(0,i.jsxs)("table",{className:"text_vertical",children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{children:"Definition"}),(0,i.jsx)("th",{children:"Example"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Entity Keys"})}),(0,i.jsx)("td",{children:"Always use stable, immutable identifiers as entity keys"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# \u2705 Good: Use stable IDs\ntype User @key(fields: "id") {\n    id: ID!\n    username: String!\n}\n\n# \u274c Bad: Avoid mutable fields as keys\ntype User @key(fields: "email") {\n    email: String!\n    username: String!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Multiple Keys"})}),(0,i.jsx)("td",{children:"Provide multiple key options for flexibility"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# \u2705 Good: Multiple keys for different use cases\ntype Product @key(fields: "id") @key(fields: "sku") {\n    id: ID!\n    sku: String!\n    name: String!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Design Minimal Entity Representations"})}),(0,i.jsx)("td",{children:"Keep entity key fields minimal and avoid large objects"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# \u2705 Good: Minimal key\ntype User @key(fields: "id") {\n    id: ID!\n    # other fields...\n}\n\n# \u274c Bad: Complex key\ntype User @key(fields: "id profile { firstName lastName }") {\n    id: ID!\n    profile: UserProfile!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Field's single Source of Truth"})}),(0,i.jsx)("td",{children:"Each field should have a clear owner"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# Users subgraph owns identity\ntype User @key(fields: "id") {\n    id: ID!\n    username: String!\n    email: String!\n}\n\n# Profile subgraph owns profile data\nextend type User @key(fields: "id") {\n    id: ID! @external\n    profile: UserProfile!\n    preferences: UserPreferences!\n}\n\n# Orders subgraph owns order data\nextend type User @key(fields: "id") {\n    id: ID! @external\n    orders: [Order!]!\n    totalSpent: Float!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsxs)("b",{children:["Use ",(0,i.jsx)(n.code,{children:"@shareable"})," Judiciously"]})}),(0,i.jsxs)("td",{children:["Only mark fields as ",(0,i.jsx)(n.code,{children:"@shareable"})," when they truly can be computed by multiple subgraphs"]}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# \u2705 Good: Computed field that both subgraphs can derive\ntype Product @key(fields: "id") {\n    id: ID!\n    name: String! @shareable\n    price: Float!\n}\n\n# \u274c Bad: Database field shared between subgraphs\ntype User @key(fields: "id") {\n    id: ID!\n    email: String! @shareable # This creates data consistency issues\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Schema Evolution: Use Deprecation Before Removal"})}),(0,i.jsx)("td",{children:"Always deprecate fields before removing them"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'type User @key(fields: "id") {\n    id: ID!\n    name: String! @deprecated(reason: "Use firstName and lastName instead")\n    firstName: String!\n    lastName: String!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Additive Changes Only"})}),(0,i.jsx)("td",{children:"Make only additive changes to maintain compatibility"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# \u2705 Good: Adding new fields\ntype User @key(fields: "id") {\n    id: ID!\n    username: String!\n    email: String!\n    createdAt: String! # New field added\n    lastLoginAt: String # New optional field\n}\n\n# \u274c Bad: Removing or changing existing fields\ntype User @key(fields: "id") {\n    id: ID!\n    # username: String!    # Don\'t remove fields\n    email: Int! # Don\'t change field types\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Use Relay-Style Connections"})}),(0,i.jsx)("td",{children:"Implement consistent pagination"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'type User @key(fields: "id") {\n    id: ID!\n    orders(input: PageInput): OrderConnection!\n}\n\ninput PageInput {\n    first: Int = 10\n    after: String\n    last: Int\n    before: String\n}\n\ntype OrderConnection {\n    edges: [OrderEdge!]!\n    pageInfo: PageInfo!\n    totalCount: Int!\n}\n\ntype OrderEdge {\n    node: Order!\n    cursor: String!\n}\n\ntype PageInfo {\n    hasNextPage: Boolean!\n    hasPreviousPage: Boolean!\n    startCursor: String\n    endCursor: String\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Domain-Driven Design Schema"})}),(0,i.jsx)("td",{children:"Design your subgraph schemas around business domains, not technical boundaries"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# \u2705 Good: User domain focuses on identity and profile\n# Users subgraph\ntype User @key(fields: "id") {\n    id: ID!\n    username: String!\n    email: String!\n    profile: UserProfile!\n    preferences: UserPreferences!\n}\n\ntype UserProfile {\n    firstName: String\n    lastName: String\n    avatar: String\n}\n\ntype UserPreferences {\n    language: String!\n    timezone: String!\n    notifications: NotificationSettings!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("b",{children:"Single Responsibility Principle"})}),(0,i.jsx)("td",{children:"Each subgraph should own a specific set of related types and fields"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# \u2705 Good: Clear ownership boundaries\n# Inventory subgraph owns stock-related data\nextend type Product @key(fields: "id") {\n    id: ID! @external\n    inventory: ProductInventory!\n    availability: AvailabilityStatus!\n    stockLevel: Int!\n}\n\ntype ProductInventory {\n    warehouse: String!\n    quantity: Int!\n    reserved: Int!\n    available: Int!\n}\n\nenum AvailabilityStatus {\n    IN_STOCK\n    LOW_STOCK\n    OUT_OF_STOCK\n    DISCONTINUED\n}\n'})})})]})]})]})}),(0,i.jsxs)(d.A,{value:"troubleshooting",label:"Troubleshooting",children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Schema Composition Issues"})}),(0,i.jsxs)("table",{className:"text_vertical",children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Category"}),(0,i.jsx)("th",{children:"Issue"}),(0,i.jsx)("th",{children:"Solution"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{rowSpan:"4",children:(0,i.jsx)("b",{children:"Schema Composition"})}),(0,i.jsx)("td",{children:"Invalid Federation Directives"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# \u274c Problem: Missing @key directive\ntype User {\n    id: ID!\n    username: String!\n}\n\n# \u2705 Solution: Add @key directive\ntype User @key(fields: "id") {\n    id: ID!\n    username: String!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Inconsistent Entity Definitions"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# \u274c Problem: Different key fields across subgraphs\n# Subgraph A\ntype User @key(fields: "id") {\n    id: ID!\n}\n\n# Subgraph B\nextend type User @key(fields: "userId") {\n    userId: ID! @external\n}\n\n# \u2705 Solution: Use consistent key fields\n# Both subgraphs\ntype User @key(fields: "id") {\n    id: ID!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsxs)("b",{children:["Missing ",(0,i.jsx)(n.code,{children:"@external"})," Directive"]})}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# \u274c Problem: Extended field not marked as external\nextend type User @key(fields: "id") {\n    id: ID!  # Missing @external\n    orders: [Order!]!\n}\n\n# \u2705 Solution: Mark external fields\nextend type User @key(fields: "id") {\n    id: ID! @external\n    orders: [Order!]!\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Conflicting Field Definitions"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:'# \u274c Problem: Same field defined differently\n# Subgraph A\ntype Product @key(fields: "id") {\n    id: ID!\n    name: String!\n}\n\n# Subgraph B\ntype Product @key(fields: "id") {\n    id: ID!\n    name: String  # Different nullability\n}\n\n# \u2705 Solution: Make fields consistent or use @shareable\ntype Product @key(fields: "id") {\n    id: ID!\n    name: String! @shareable\n}\n'})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{rowSpan:"3",children:(0,i.jsx)("b",{children:"Reference Resolution"})}),(0,i.jsx)("td",{children:"Missing Reference Resolver"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Problem: No __resolveReference implementation\nconst resolvers = {\n    User: {\n        // Missing __resolveReference\n        orders: async (user) => { /* ... */ }\n    }\n};\n\n// \u2705 Solution: Implement __resolveReference\nconst resolvers = {\n    User: {\n        __resolveReference: async (user: { id: string }) => {\n            return await UserService.findById(user.id);\n        },\n        orders: async (user) => { /* ... */ }\n    }\n};\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Reference Resolver Returns Null"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Problem: Returns null for valid reference\nUser: {\n    __resolveReference: async (user: { id: string }) => {\n        const userData = await UserService.findById(user.id);\n        return userData; // null if not found\n    }\n}\n\n// \u2705 Solution: Handle missing entities appropriately\nUser: {\n    __resolveReference: async (user: { id: string }) => {\n        const userData = await UserService.findById(user.id);\n        if (!userData) {\n            throw new Error(`User with id ${user.id} not found`);\n        }\n        return userData;\n    }\n}\n"})})})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:"Incorrect Key Field Mapping"}),(0,i.jsx)("td",{children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// \u274c Problem: Wrong key field in reference\nUser: {\n    __resolveReference: async (user: { userId: string }) => {\n        // Entity key is 'id' but resolver expects 'userId'\n        return await UserService.findById(user.userId);\n    }\n}\n\n// \u2705 Solution: Use correct key field\nUser: {\n    __resolveReference: async (user: { id: string }) => {\n        return await UserService.findById(user.id);\n    }\n}\n"})})})]})]})]})]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}}}]);