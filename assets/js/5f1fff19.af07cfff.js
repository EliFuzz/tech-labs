"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[9997],{24405:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>p,contentTitle:()=>w,default:()=>v,frontMatter:()=>m,metadata:()=>j,toc:()=>g});var t=r(86070),o=r(27468),i=r(78826),a=r(28437),l=r(41634);const s="package main\n\nfunc solveNQueens(n int) [][]string {\n\tvar result [][]string\n\tboard := make([][]rune, n)\n\tfor i := range board {\n\t\tboard[i] = make([]rune, n)\n\t\tfor j := range board[i] {\n\t\t\tboard[i][j] = '.'\n\t\t}\n\t}\n\tbacktrack(&result, board, 0)\n\treturn result\n}\n\nfunc backtrack(result *[][]string, board [][]rune, row int) {\n\tif row == len(board) {\n\t\tvar temp []string\n\t\tfor i := 0; i < len(board); i++ {\n\t\t\ttemp = append(temp, string(board[i]))\n\t\t}\n\t\t*result = append(*result, temp)\n\t\treturn\n\t}\n\n\tfor col := 0; col < len(board); col++ {\n\t\tif isValid(board, row, col) {\n\t\t\tboard[row][col] = 'Q'\n\t\t\tbacktrack(result, board, row+1)\n\t\t\tboard[row][col] = '.'\n\t\t}\n\t}\n}\n\nfunc isValid(board [][]rune, row, col int) bool {\n\tfor i := 0; i < row; i++ {\n\t\tif board[i][col] == 'Q' {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tfor i, j := row-1, col-1; i >= 0 && j >= 0; i, j = i-1, j-1 {\n\t\tif board[i][j] == 'Q' {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tfor i, j := row-1, col+1; i >= 0 && j < len(board); i, j = i-1, j+1 {\n\t\tif board[i][j] == 'Q' {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n",c="import java.util.ArrayList;\nimport java.util.List;\n\npublic class NQueens {\n\n  public List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    char[][] board = new char[n][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        board[i][j] = '.';\n      }\n    }\n    backtrack(result, board, 0);\n    return result;\n  }\n\n  private void backtrack(List<List<String>> result, char[][] board, int row) {\n    if (row == board.length) {\n      List<String> temp = new ArrayList<>();\n      for (char[] rowArray : board) {\n        temp.add(String.valueOf(rowArray));\n      }\n      result.add(temp);\n      return;\n    }\n\n    for (int col = 0; col < board.length; col++) {\n      if (isValid(board, row, col)) {\n        board[row][col] = 'Q';\n        backtrack(result, board, row + 1);\n        board[row][col] = '.';\n      }\n    }\n  }\n\n  private boolean isValid(char[][] board, int row, int col) {\n    for (int i = 0; i < row; i++) {\n      if (board[i][col] == 'Q') {\n        return false;\n      }\n    }\n    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n      if (board[i][j] == 'Q') {\n        return false;\n      }\n    }\n    for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\n      if (board[i][j] == 'Q') {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n",u='const solveNQueens = function (n) {\n  const result = [];\n  const board = Array.from({ length: n }, () =>\n    Array.from({ length: n }, () => "."),\n  );\n\n  const backtrack = (row) => {\n    if (row === n) {\n      result.push(board.map((row) => row.join("")));\n      return;\n    }\n\n    for (let col = 0; col < n; col++) {\n      if (isValid(row, col)) {\n        board[row][col] = "Q";\n        backtrack(row + 1);\n        board[row][col] = ".";\n      }\n    }\n  };\n\n  const isValid = (row, col) => {\n    for (let i = 0; i < row; i++) {\n      if (board[i][col] === "Q") {\n        return false;\n      }\n    }\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n      if (board[i][j] === "Q") {\n        return false;\n      }\n    }\n    for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n      if (board[i][j] === "Q") {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  backtrack(0);\n  return result;\n};\n',d="fun solveNQueens(n: Int): List<List<String>> {\n    val result = mutableListOf<List<String>>()\n    val board = Array(n) { CharArray(n) { '.' } }\n\n    fun backtrack(row: Int) {\n        if (row == n) {\n            result.add(board.map { it.joinToString(\"\") })\n            return\n        }\n        for (col in board.indices) {\n            if (isValid(row, col)) {\n                board[row][col] = 'Q'\n                backtrack(row + 1)\n                board[row][col] = '.'\n            }\n        }\n    }\n\n    fun isValid(row: Int, col: Int): Boolean {\n        for (i in 0 until row) {\n            if (board[i][col] == 'Q') return false\n        }\n        var i = row - 1\n        var j = col - 1\n        while (i >= 0 && j >= 0) {\n            if (board[i--][j--] == 'Q') return false\n        }\n        i = row - 1\n        j = col + 1\n        while (i >= 0 && j < n) {\n            if (board[i--][j++] == 'Q') return false\n        }\n        return true\n    }\n\n    backtrack(0)\n    return result\n}\n",b="def solveNQueens(n):\n    result = []\n\n    def backtrack(board, row):\n        if row == n:\n            result.append([''.join(row) for row in board])\n            return\n        for col in range(n):\n            if isValid(board, row, col):\n                board[row][col] = 'Q'\n                backtrack(board, row + 1)\n                board[row][col] = '.'\n\n    def isValid(board, row, col):\n        for i in range(row):\n            if board[i][col] == 'Q':\n                return False\n        i, j = row - 1, col - 1\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q':\n                return False\n            i, j = i - 1, j - 1\n        i, j = row - 1, col + 1\n        while i >= 0 and j < n:\n            if board[i][j] == 'Q':\n                return False\n            i, j = i - 1, j + 1\n        return True\n\n    board = [['.'] * n for _ in range(n)]\n    backtrack(board, 0)\n    return result\n",f="fn solve_n_queens(n: i32) -> Vec<Vec<String>> {\n    let mut result = Vec::new();\n    let mut board = vec![vec!['.'; n as usize]; n as usize];\n\n    fn backtrack(result: &mut Vec<Vec<String>>, board: &mut Vec<Vec<char>>, row: usize) {\n        let n = board.len();\n        if row == n {\n            result.push(board.iter().map(|r| r.iter().collect()).collect());\n            return;\n        }\n\n        for col in 0..n {\n            if is_valid(&board, row, col) {\n                board[row][col] = 'Q';\n                backtrack(result, board, row + 1);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    fn is_valid(board: &Vec<Vec<char>>, row: usize, col: usize) -> bool {\n        let n = board.len();\n        for i in 0..row {\n            if board[i][col] == 'Q' {\n                return false;\n            }\n        }\n        let (mut i, mut j) = (row as i32 - 1, col as i32 - 1);\n        while i >= 0 && j >= 0 {\n            if board[i as usize][j as usize] == 'Q' {\n                return false;\n            }\n            i -= 1;\n            j -= 1;\n        }\n        let (mut i, mut j) = (row as i32 - 1, col as i32 + 1);\n        while i >= 0 && j < n as i32 {\n            if board[i as usize][j as usize] == 'Q' {\n                return false;\n            }\n            i -= 1;\n            j += 1;\n        }\n        true\n    }\n\n    backtrack(&mut result, &mut board, 0);\n    result\n}\n",h='function solveNQueens(n: number): string[][] {\n  const result: string[][] = [];\n  const board: string[][] = Array.from({ length: n }, () =>\n    Array.from({ length: n }, () => "."),\n  );\n\n  function backtrack(row: number): void {\n    if (row === n) {\n      result.push(board.map((row) => row.join("")));\n      return;\n    }\n\n    for (let col = 0; col < n; col++) {\n      if (isValid(row, col)) {\n        board[row][col] = "Q";\n        backtrack(row + 1);\n        board[row][col] = ".";\n      }\n    }\n  }\n\n  function isValid(row: number, col: number): boolean {\n    for (let i = 0; i < row; i++) {\n      if (board[i][col] === "Q") return false;\n    }\n    for (let i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n      if (board[i][j] === "Q") return false;\n    }\n    for (let i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n      if (board[i][j] === "Q") return false;\n    }\n    return true;\n  }\n\n  backtrack(0);\n  return result;\n}\n',m={title:"N-Queens Problem",description:"N-Queens Problem",hide_table_of_contents:!0},w=void 0,j={id:"education/computer-science/algorithms/algo/n-queens-problem",title:"N-Queens Problem",description:"N-Queens Problem",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/n-queens-problem.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/n-queens-problem",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/n-queens-problem",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/n-queens-problem.mdx",tags:[],version:"current",frontMatter:{title:"N-Queens Problem",description:"N-Queens Problem",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Merge Sort",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/merge-sort"},next:{title:"NanoNeuron",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/nano-neuron"}},p={},g=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function k(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,t.jsxs)(i.A,{queryString:"primary",children:[(0,t.jsx)(a.A,{value:"definition",label:"Definition",children:(0,t.jsx)(e.p,{children:"The N-Queens Problem is a classic computer science problem where the task is to place N chess queens on an NxN chessboard in such a way that no two queens threaten each other. This means that no two queens share the same row, column, or diagonal"})}),(0,t.jsx)(a.A,{value:"how",label:"Explanation",children:(0,t.jsx)(e.p,{children:"Recursively placing queens on the board and backtracking when a solution cannot be found. It begins by placing a queen in the first row of the first column and then attempts to place subsequent queens in the next rows, ensuring that no two queens threaten each other. If a conflict arises, the algorithm backtracks and tries a different position for the queen"})}),(0,t.jsx)(a.A,{value:"guidance",label:"Guidance",children:(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Start with an empty chessboard"}),"\n",(0,t.jsx)(e.li,{children:"Place the first queen in the first row and first column"}),"\n",(0,t.jsxs)(e.li,{children:["Move to the next row","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Check if the queen can be placed in the current column without conflicting with existing queens"}),"\n",(0,t.jsx)(e.li,{children:"If it can be placed, mark the position and move to the next row"}),"\n",(0,t.jsx)(e.li,{children:"Repeat steps until all queens are placed"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.li,{children:"If a conflict arises or all positions in the current row are tried, backtrack to the previous row and try the next available position"}),"\n",(0,t.jsx)(e.li,{children:"Continue this process until a solution is found or all possibilities are exhausted"}),"\n"]})}),(0,t.jsx)(a.A,{value:"tips",label:"Tips",children:(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"use efficient data structures to represent the chessboard and track queen positions"}),"\n",(0,t.jsx)(e.li,{children:"implement pruning techniques to reduce the search space and improve performance"}),"\n",(0,t.jsx)(e.li,{children:"optimize the algorithm by considering symmetries and avoiding redundant calculations"}),"\n",(0,t.jsx)(e.li,{children:"test the algorithm with different board sizes to ensure its correctness and scalability"}),"\n"]})})]}),"\n",(0,t.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,t.jsxs)(i.A,{queryString:"primary",children:[(0,t.jsx)(a.A,{value:"practice",label:"Practice",children:(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"solveNQueens(board, row):\n  if row == size_of_board:\n    return true // all queens are placed successfully\n  for each column in size_of_board:\n    if isSafe(board, row, column):\n      placeQueen(board, row, column)\n      if solveNQueens(board, row + 1):\n        return true\n      removeQueen(board, row, column)\n  return false // no solution found\n\nisSafe(board, row, column):\n  for i from 0 to row - 1:\n    if board[i][column] == true:\n      return false // queen threatens in the same column\n    if column - (row - i) >= 0 and board[i][column - (row - i)] == true:\n      return false // queen threatens in the left diagonal\n    if size_of_board > column + (row - i) and board[i][column + (row - i)] == true:\n      return false // queen threatens in the right diagonal\n  return true\n\nplaceQueen(board, row, column):\n  board[row][column] = true\n\nremoveQueen(board, row, column):\n  board[row][column] = false\n"})})}),(0,t.jsx)(a.A,{value:"solution",label:"Solution",children:(0,t.jsxs)(i.A,{queryString:"code",children:[(0,t.jsx)(a.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,t.jsx)(l.A,{language:"go",children:s})}),(0,t.jsx)(a.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,t.jsx)(l.A,{language:"java",children:c})}),(0,t.jsx)(a.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,t.jsx)(l.A,{language:"js",children:u})}),(0,t.jsx)(a.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,t.jsx)(l.A,{language:"kotlin",children:d})}),(0,t.jsx)(a.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,t.jsx)(l.A,{language:"python",children:b})}),(0,t.jsx)(a.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,t.jsx)(l.A,{language:"rust",children:f})}),(0,t.jsx)(a.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,t.jsx)(l.A,{language:"ts",children:h})})]})})]})]})}function v(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(k,{...n})}):k(n)}}}]);