"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[214],{42621:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>x,contentTitle:()=>y,default:()=>v,frontMatter:()=>m,metadata:()=>a,toc:()=>j});const a=JSON.parse('{"id":"education/computer-science/algorithms/algo/heap-sort","title":"Heap Sort","description":"Heap Sort","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/heap-sort.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/heap-sort","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/heap-sort","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/heap-sort.mdx","tags":[],"version":"current","frontMatter":{"title":"Heap Sort","description":"Heap Sort","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Hamming Distance","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/hamming-distance"},"next":{"title":"Hill Cipher","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/hill-cipher"}}');var i=e(86070),t=e(15658),l=e(52421),s=e(74610),h=e(42953);const o="package main\n\nfunc heapify(arr []int, n, i int) {\n    largest := i\n    left := 2*i + 1\n    right := 2*i + 2\n\n    if left < n && arr[left] > arr[largest] {\n        largest = left\n    }\n\n    if right < n && arr[right] > arr[largest] {\n        largest = right\n    }\n\n    if largest != i {\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n    }\n}\n\nfunc heapSort(arr []int) {\n    n := len(arr)\n\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(arr, n, i)\n    }\n\n    for i := n - 1; i > 0; i-- {\n        arr[0], arr[i] = arr[i], arr[0]\n        heapify(arr, i, 0)\n    }\n}\n",c="public class HeapSort {\n\n  public void sort(int arr[]) {\n    int n = arr.length;\n\n    for (int i = n / 2 - 1; i >= 0; i--) {\n      heapify(arr, n, i);\n    }\n\n    for (int i = n - 1; i > 0; i--) {\n      int temp = arr[0];\n      arr[0] = arr[i];\n      arr[i] = temp;\n\n      heapify(arr, i, 0);\n    }\n  }\n\n  void heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2 * i + 1;\n    int right = 2 * i + 2;\n\n    if (left < n && arr[left] > arr[largest]) {\n      largest = left;\n    }\n\n    if (right < n && arr[right] > arr[largest]) {\n      largest = right;\n    }\n\n    if (largest != i) {\n      int swap = arr[i];\n      arr[i] = arr[largest];\n      arr[largest] = swap;\n\n      heapify(arr, n, largest);\n    }\n  }\n}\n",g="function heapify(arr, n, i) {\n  let largest = i;\n  const left = 2 * i + 1;\n  const right = 2 * i + 2;\n\n  if (left < n && arr[left] > arr[largest]) {\n    largest = left;\n  }\n\n  if (right < n && arr[right] > arr[largest]) {\n    largest = right;\n  }\n\n  if (largest !== i) {\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    heapify(arr, n, largest);\n  }\n}\n\nfunction heapSort(arr) {\n  const n = arr.length;\n\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(arr, n, i);\n  }\n\n  for (let i = n - 1; i > 0; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    heapify(arr, i, 0);\n  }\n  return arr;\n}\n",p="fun heapify(arr: IntArray, n: Int, i: Int) {\n    var largest = i\n    val left = 2 * i + 1\n    val right = 2 * i + 2\n\n    if (left < n && arr[left] > arr[largest]) {\n        largest = left\n    }\n\n    if (right < n && arr[right] > arr[largest]) {\n        largest = right\n    }\n\n    if (largest != i) {\n        arr[i] = arr[largest].also { arr[largest] = arr[i] }\n        heapify(arr, n, largest)\n    }\n}\n\nfun heapSort(arr: IntArray) {\n    val n = arr.size\n\n    for (i in n / 2 - 1 downTo 0) {\n        heapify(arr, n, i)\n    }\n\n    for (i in n - 1 downTo 1) {\n        arr[0] = arr[i].also { arr[i] = arr[0] }\n        heapify(arr, i, 0)\n    }\n}\n",d="def heapify(arr, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\ndef heapSort(arr):\n    n = len(arr)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heapify(arr, i, 0)\n",f="fn heapify(arr: &mut [i32], n: usize, i: usize) {\n    let mut largest = i;\n    let left = 2 * i + 1;\n    let right = 2 * i + 2;\n\n    if left < n && arr[left] > arr[largest] {\n        largest = left;\n    }\n\n    if right < n && arr[right] > arr[largest] {\n        largest = right;\n    }\n\n    if largest != i {\n        arr.swap(i, largest);\n        heapify(arr, n, largest);\n    }\n}\n\nfn heap_sort(arr: &mut [i32]) {\n    let n = arr.len();\n\n    for i in (0..=n / 2).rev() {\n        heapify(arr, n, i);\n    }\n\n    for i in (1..n).rev() {\n        arr.swap(0, i);\n        heapify(arr, i, 0);\n    }\n}\n",u="function heapify(arr: number[], n: number, i: number): void {\n  let largest: number = i;\n  const left: number = 2 * i + 1;\n  const right: number = 2 * i + 2;\n\n  if (left < n && arr[left] > arr[largest]) {\n    largest = left;\n  }\n\n  if (right < n && arr[right] > arr[largest]) {\n    largest = right;\n  }\n\n  if (largest !== i) {\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    heapify(arr, n, largest);\n  }\n}\n\nfunction heapSort(arr: number[]): void {\n  const n: number = arr.length;\n\n  for (let i: number = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(arr, n, i);\n  }\n\n  for (let i: number = n - 1; i > 0; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    heapify(arr, i, 0);\n  }\n}\n",m={title:"Heap Sort",description:"Heap Sort",hide_table_of_contents:!0},y=void 0,x={},j=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function b(r){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...r.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(l.A,{queryString:"primary",children:[(0,i.jsx)(s.A,{value:"definition",label:"Definition",children:(0,i.jsx)(n.p,{children:"Heap Sort is a comparison-based sorting algorithm that operates by converting the array into a binary heap structure, then repeatedly removing the maximum element from the heap and rebuilding the heap"})}),(0,i.jsx)(s.A,{value:"how",label:"Explanation",children:(0,i.jsx)(n.p,{children:"To initiate Heap Sort, first, convert the given array into a max heap, ensuring each parent node is greater than or equal to its children. Then, proceed to repeatedly remove the maximum element, which is the root of the heap, while preserving the heap property through heapify operations. This process continues until the heap is empty, ultimately yielding a sorted array"})}),(0,i.jsx)(s.A,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Build Max Heap","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Start from the last non-leaf node (index n/2 - 1) to the root (index 0)"}),"\n",(0,i.jsx)(n.li,{children:"For each node, compare it with its children and swap if necessary to maintain the heap property"}),"\n",(0,i.jsx)(n.li,{children:"Continue this process until the entire array satisfies the heap property"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Heapify","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Remove the root element (maximum value) from the heap and replace it with the last element of the heap"}),"\n",(0,i.jsx)(n.li,{children:"Reduce the size of the heap by one"}),"\n",(0,i.jsx)(n.li,{children:"Heapify the remaining elements to maintain the heap property"}),"\n",(0,i.jsx)(n.li,{children:"Repeat steps until the heap size becomes 1, resulting in a sorted array"}),"\n"]}),"\n"]}),"\n"]})}),(0,i.jsx)(s.A,{value:"tips",label:"Tips",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ensure you understand the heap data structure and its properties before implementing Heap Sort"}),"\n",(0,i.jsx)(n.li,{children:"efficiently utilize the heapify process to maintain the heap property after each removal of the maximum element"}),"\n",(0,i.jsx)(n.li,{children:"be mindful of the array indexing, especially when dealing with parent-child relationships in the heap"}),"\n"]})})]}),"\n",(0,i.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(l.A,{queryString:"primary",children:[(0,i.jsx)(s.A,{value:"practice",label:"Practice",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"procedure heapSort(array)\n    n := length(array)\n\n    // Build Max Heap\n    for i from n/2 - 1 down to 0 do\n        heapify(array, n, i)\n\n    // Heapify and Extract Maximum\n    for i from n - 1 down to 0 do\n        swap(array[0], array[i])   // Move current root to end\n        heapify(array, i, 0)       // Heapify the reduced heap\n\nprocedure heapify(array, heapSize, index)\n    largest := index\n    leftChild := 2 * index + 1\n    rightChild := 2 * index + 2\n\n    // Find the largest element among root, left child, and right child\n    if heapSize > leftChild and array[leftChild] > array[largest] then\n        largest := leftChild\n    if heapSize > rightChild and array[rightChild] > array[largest] then\n        largest := rightChild\n\n    // Swap and continue heapifying if necessary\n    if largest != index then\n        swap(array[index], array[largest])\n        heapify(array, heapSize, largest)\n"})})}),(0,i.jsx)(s.A,{value:"solution",label:"Solution",children:(0,i.jsxs)(l.A,{queryString:"code",children:[(0,i.jsx)(s.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(h.A,{language:"go",children:o})}),(0,i.jsx)(s.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(h.A,{language:"java",children:c})}),(0,i.jsx)(s.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(h.A,{language:"js",children:g})}),(0,i.jsx)(s.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(h.A,{language:"kotlin",children:p})}),(0,i.jsx)(s.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(h.A,{language:"python",children:d})}),(0,i.jsx)(s.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(h.A,{language:"rust",children:f})}),(0,i.jsx)(s.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(h.A,{language:"ts",children:u})})]})})]})]})}function v(r={}){const{wrapper:n}={...(0,t.R)(),...r.components};return n?(0,i.jsx)(n,{...r,children:(0,i.jsx)(b,{...r})}):b(r)}}}]);