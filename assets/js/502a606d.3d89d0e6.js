"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[11],{13724:(n,e,t)=>{t.d(e,{A:()=>r});const r=t.p+"assets/images/doublyLinkedList-270cc639812b3bad9df5fcb80720be44.svg"},19338:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>N,contentTitle:()=>m,default:()=>b,frontMatter:()=>v,metadata:()=>r,toc:()=>j});const r=JSON.parse('{"id":"education/computer-science/data-structures/basic/linked-list","title":"Linked List","description":"Linked List Data Structure","source":"@site/docs/education/01-computer-science/09-data-structures/02-basic/02-linked-list.mdx","sourceDirName":"education/01-computer-science/09-data-structures/02-basic","slug":"/education/computer-science/data-structures/basic/linked-list","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/linked-list","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/09-data-structures/02-basic/02-linked-list.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Linked List","description":"Linked List Data Structure","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Array","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/array"},"next":{"title":"Doubly Linked List","permalink":"/tech-labs/docs/education/computer-science/data-structures/basic/doubly-linked-list"}}');var a=t(23420),d=t(38906),u=t(31519),l=t(20007),i=t(20636);const c='package main\n\ntype Node struct {\n\tdata interface{}\n\tnext *Node\n}\n\ntype LinkedList struct {\n\thead *Node\n}\n\nfunc (l *LinkedList) prepend(data interface{}) {\n\tl.head = &Node{data: data, next: l.head}\n}\n\nfunc (l *LinkedList) insertBefore(value interface{}, data interface{}) {\n\tif l.head == nil {\n\t\treturn\n\t}\n\n\tif l.head.data == value {\n\t\tl.head = &Node{data: data, next: l.head}\n\t\treturn\n\t}\n\n\tcurrent := l.head\n\tfor current.next != nil && current.next.data != value {\n\t\tcurrent = current.next\n\t}\n\n\tif current.next != nil {\n\t\tcurrent.next = &Node{data: data, next: current.next}\n\t}\n}\n\nfunc (l *LinkedList) insertAfter(value interface{}, data interface{}) {\n\tcurrent := l.head\n\tfor current != nil && current.data != value {\n\t\tcurrent = current.next\n\t}\n\n\tif current != nil {\n\t\tcurrent.next = &Node{data: data, next: current.next}\n\t}\n}\n\nfunc (l *LinkedList) insertAt(index int, data interface{}) {\n\tif index < 0 {\n\t\tpanic("Index must be greater than or equal to 0")\n\t}\n\n\tif index == 0 {\n\t\tl.head = &Node{data: data, next: l.head}\n\t\treturn\n\t}\n\n\tcurrent := l.head\n\tcurrentIndex := 0\n\tfor current != nil && currentIndex < index-1 {\n\t\tcurrent = current.next\n\t\tcurrentIndex++\n\t}\n\n\tif current == nil {\n\t\tpanic("Index exceeds the size of the list")\n\t}\n\n\tcurrent.next = &Node{data: data, next: current.next}\n}\n\nfunc (l *LinkedList) append(data interface{}) {\n\tif l.head == nil {\n\t\tl.head = &Node{data: data}\n\t} else {\n\t\tcurrent := l.head\n\t\tfor current.next != nil {\n\t\t\tcurrent = current.next\n\t\t}\n\t\tcurrent.next = &Node{data: data}\n\t}\n}\n\nfunc (l *LinkedList) find(value interface{}) *Node {\n\tcurrent := l.head\n\tfor current != nil && current.data != value {\n\t\tcurrent = current.next\n\t}\n\treturn current\n}\n\nfunc (l *LinkedList) deleteHead() {\n\tif l.head != nil {\n\t\tl.head = l.head.next\n\t}\n}\n\nfunc (l *LinkedList) delete(value interface{}) {\n\tif l.head == nil {\n\t\treturn\n\t}\n\n\tif l.head.data == value {\n\t\tl.head = l.head.next\n\t\treturn\n\t}\n\n\tcurrent := l.head\n\tfor current.next != nil && current.next.data != value {\n\t\tcurrent = current.next\n\t}\n\n\tif current.next != nil {\n\t\tcurrent.next = current.next.next\n\t}\n}\n\nfunc (l *LinkedList) deleteLast() {\n\tif l.head == nil {\n\t\treturn\n\t}\n\n\tif l.head.next == nil {\n\t\tl.head = nil\n\t\treturn\n\t}\n\n\tcurrent := l.head\n\tfor current.next.next != nil {\n\t\tcurrent = current.next\n\t}\n\tcurrent.next = nil\n}\n\nfunc (l *LinkedList) reverse() {\n\tvar prev *Node\n\tcurrent := l.head\n\tvar next *Node\n\tfor current != nil {\n\t\tnext = current.next\n\t\tcurrent.next = prev\n\t\tprev = current\n\t\tcurrent = next\n\t}\n\tl.head = prev\n}\n\nfunc (l *LinkedList) traverse() {\n\tcurrent := l.head\n\tfor current != nil {\n\t\tfmt.Println(current.data)\n\t\tcurrent = current.next\n\t}\n}\n',s='public class LinkedList<T> {\n\n  private Node<T> head = null;\n\n  public void prepend(T data) {\n    head = new Node<>(data, head);\n  }\n\n  public void insertBefore(T value, T data) {\n    if (head == null) {\n      return;\n    }\n\n    if (head.data.equals(value)) {\n      head = new Node<>(data, head);\n      return;\n    }\n\n    Node<T> current = head;\n    while (current.next != null && !current.next.data.equals(value)) {\n      current = current.next;\n    }\n\n    if (current.next != null) {\n      current.next = new Node<>(data, current.next);\n    }\n  }\n\n  public void insertAfter(T value, T data) {\n    Node<T> current = head;\n    while (current != null && !current.data.equals(value)) {\n      current = current.next;\n    }\n\n    if (current != null) {\n      current.next = new Node<>(data, current.next);\n    }\n  }\n\n  public void insertAt(int index, T data) {\n    if (index < 0) {\n      throw new IndexOutOfBoundsException("Index must be greater than or equal to 0");\n    }\n\n    if (index == 0) {\n      head = new Node<>(data, head);\n      return;\n    }\n\n    Node<T> current = head;\n    int currentIndex = 0;\n    while (current != null && currentIndex < index - 1) {\n      current = current.next;\n      currentIndex++;\n    }\n\n    if (current == null) {\n      throw new IndexOutOfBoundsException("Index exceeds the size of the list");\n    }\n\n    current.next = new Node<>(data, current.next);\n  }\n\n  public void append(T data) {\n    if (head == null) {\n      head = new Node<>(data);\n    } else {\n      Node<T> current = head;\n      while (current.next != null) {\n        current = current.next;\n      }\n      current.next = new Node<>(data);\n    }\n  }\n\n  public T find(T value) {\n    Node<T> current = head;\n    while (current != null && !current.data.equals(value)) {\n      current = current.next;\n    }\n    return current != null ? current.data : null;\n  }\n\n  public void deleteHead() {\n    if (head != null) {\n      head = head.next;\n    }\n  }\n\n  public void delete(T value) {\n    if (head == null) {\n      return;\n    }\n\n    if (head.data.equals(value)) {\n      head = head.next;\n      return;\n    }\n\n    Node<T> current = head;\n    while (current.next != null && !current.next.data.equals(value)) {\n      current = current.next;\n    }\n\n    if (current.next != null) {\n      current.next = current.next.next;\n    }\n  }\n\n  public void deleteLast() {\n    if (head == null) {\n      return;\n    }\n\n    if (head.next == null) {\n      head = null;\n      return;\n    }\n\n    Node<T> current = head;\n    while (current.next.next != null) {\n      current = current.next;\n    }\n\n    current.next = null;\n  }\n\n  public void reverse() {\n    Node<T> prev = null;\n    Node<T> current = head;\n    Node<T> next;\n    while (current != null) {\n      next = current.next;\n      current.next = prev;\n      prev = current;\n      current = next;\n    }\n    head = prev;\n  }\n\n  public void traverse() {\n    Node<T> current = head;\n    while (current != null) {\n      System.out.println(current.data);\n      current = current.next;\n    }\n  }\n\n  private class Node<T> {\n\n    T data;\n    Node<T> next;\n\n    Node(T data) {\n      this.data = data;\n    }\n\n    Node(T data, Node<T> next) {\n      this.data = data;\n      this.next = next;\n    }\n  }\n}\n',h='class Node {\n  constructor(data, next = null) {\n    this.data = data;\n    this.next = next;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n\n  prepend(data) {\n    this.head = new Node(data, this.head);\n  }\n\n  insertBefore(value, data) {\n    if (this.head === null) {\n      return;\n    }\n\n    if (this.head.data === value) {\n      this.head = new Node(data, this.head);\n      return;\n    }\n\n    let current = this.head;\n    while (current.next !== null && current.next.data !== value) {\n      current = current.next;\n    }\n\n    if (current.next !== null) {\n      current.next = new Node(data, current.next);\n    }\n  }\n\n  insertAfter(value, data) {\n    let current = this.head;\n    while (current !== null && current.data !== value) {\n      current = current.next;\n    }\n\n    if (current !== null) {\n      current.next = new Node(data, current.next);\n    }\n  }\n\n  insertAt(index, data) {\n    if (index < 0) {\n      throw new Error("Index must be greater than or equal to 0");\n    }\n\n    if (index === 0) {\n      this.head = new Node(data, this.head);\n      return;\n    }\n\n    let current = this.head;\n    let currentIndex = 0;\n    while (current !== null && currentIndex < index - 1) {\n      current = current.next;\n      currentIndex++;\n    }\n\n    if (current === null) {\n      throw new Error("Index exceeds the size of the list");\n    }\n\n    current.next = new Node(data, current.next);\n  }\n\n  append(data) {\n    if (this.head === null) {\n      this.head = new Node(data);\n    } else {\n      let current = this.head;\n      while (current.next !== null) {\n        current = current.next;\n      }\n      current.next = new Node(data);\n    }\n  }\n\n  find(value) {\n    let current = this.head;\n    while (current !== null && current.data !== value) {\n      current = current.next;\n    }\n    return current ? current.data : null;\n  }\n\n  deleteHead() {\n    if (this.head !== null) {\n      this.head = this.head.next;\n    }\n  }\n\n  deleteNode(value) {\n    if (this.head === null) {\n      return;\n    }\n\n    if (this.head.data === value) {\n      this.head = this.head.next;\n      return;\n    }\n\n    let current = this.head;\n    while (current.next !== null && current.next.data !== value) {\n      current = current.next;\n    }\n\n    if (current.next !== null) {\n      current.next = current.next.next;\n    }\n  }\n\n  deleteLast() {\n    if (this.head === null) {\n      return;\n    }\n\n    if (this.head.next === null) {\n      this.head = null;\n      return;\n    }\n\n    let current = this.head;\n    while (current.next.next !== null) {\n      current = current.next;\n    }\n\n    current.next = null;\n  }\n\n  reverse() {\n    let prev = null;\n    let current = this.head;\n    let next = null;\n    while (current !== null) {\n      next = current.next;\n      current.next = prev;\n      prev = current;\n      current = next;\n    }\n    this.head = prev;\n  }\n\n  traverse() {\n    let current = this.head;\n    while (current !== null) {\n      console.log(current.data);\n      current = current.next;\n    }\n  }\n}\n',o='class LinkedList<T> {\n    class Node<T>(var data: T, var next: Node<T>? = null)\n\n    private var head: Node<T>? = null\n\n    fun prepend(data: T) {\n        head = Node(data, head)\n    }\n\n    fun insertBefore(value: T, data: T) {\n        if (head == null) {\n            return\n        }\n\n        if (head?.data == value) {\n            head = Node(data, head)\n            return\n        }\n\n        var current = head\n        while (current?.next != null && current.next?.data != value) {\n            current = current.next\n        }\n\n        if (current?.next != null) {\n            current.next = Node(data, current.next)\n        }\n    }\n\n    fun insertAfter(value: T, data: T) {\n        var current = head\n        while (current != null && current.data != value) {\n            current = current.next\n        }\n\n        if (current != null) {\n            current.next = Node(data, current.next)\n        }\n    }\n\n    fun insertAt(index: Int, data: T) {\n        if (index < 0) {\n            throw IndexOutOfBoundsException("Index must be greater than or equal to 0")\n        }\n\n        if (index == 0) {\n            head = Node(data, head)\n            return\n        }\n\n        var current = head\n        var currentIndex = 0\n        while (current != null && currentIndex < index - 1) {\n            current = current.next\n            currentIndex++\n        }\n\n        if (current == null) {\n            throw IndexOutOfBoundsException("Index exceeds the size of the list")\n        }\n\n        current.next = Node(data, current.next)\n    }\n\n    fun append(data: T) {\n        if (head == null) {\n            head = Node(data)\n        } else {\n            var current = head\n            while (current?.next != null) {\n                current = current.next\n            }\n            current?.next = Node(data)\n        }\n    }\n\n    fun find(value: T): Node<T>? {\n        var current = head\n        while (current != null && current.data != value) {\n            current = current.next\n        }\n        return current?.data\n    }\n\n    fun deleteHead() {\n        if (head != null) {\n            head = head?.next\n        }\n    }\n\n    fun delete(value: T) {\n        if (head == null) {\n            return\n        }\n\n        if (head?.data == value) {\n            head = head?.next\n            return\n        }\n\n        var current = head\n        while (current?.next != null && current.next?.data != value) {\n            current = current.next\n        }\n\n        if (current?.next != null) {\n            current.next = current.next?.next\n        }\n    }\n\n    fun deleteLast() {\n        if (head == null) {\n            return\n        }\n\n        if (head?.next == null) {\n            head = null\n            return\n        }\n\n        var current = head\n        while (current?.next?.next != null) {\n            current = current.next\n        }\n\n        current?.next = null\n    }\n\n    fun reverse() {\n        var prev: Node<T>?\n        var current = head\n        var next: Node<T>?\n        while (current != null) {\n            next = current.next\n            current.next = prev\n            prev = current\n            current = next\n        }\n        head = prev\n    }\n\n    fun traverse() {\n        var current = head\n        while (current != null) {\n            println(current.data)\n            current = current.next\n        }\n    }\n}\n',x='class LinkedList:\n    class Node:\n        def __init__(self, data, next=None):\n            self.data = data\n            self.next = next\n\n    def __init__(self):\n        self.head = None\n\n    def prepend(self, data):\n        self.head = self.Node(data, self.head)\n\n    def insert_before(self, value, data):\n        if self.head is None:\n            return\n\n        if self.head.data == value:\n            self.head = self.Node(data, self.head)\n            return\n\n        current = self.head\n        while current.next is not None and current.next.data != value:\n            current = current.next\n\n        if current.next is not None:\n            current.next = self.Node(data, current.next)\n\n    def insert_after(self, value, data):\n        current = self.head\n        while current is not None and current.data != value:\n            current = current.next\n\n        if current is not None:\n            current.next = self.Node(data, current.next)\n\n    def insert_at(self, index, data):\n        if index < 0:\n            raise IndexError("Index must be greater than or equal to 0")\n\n        if index == 0:\n            self.head = self.Node(data, self.head)\n            return\n\n        current = self.head\n        current_index = 0\n        while current is not None and current_index < index - 1:\n            current = current.next\n            current_index += 1\n\n        if current is None:\n            raise IndexError("Index exceeds the size of the list")\n\n        current.next = self.Node(data, current.next)\n\n    def append(self, data):\n        if self.head is None:\n            self.head = self.Node(data)\n        else:\n            current = self.head\n            while current.next is not None:\n                current = current.next\n            current.next = self.Node(data)\n\n    def find(self, value):\n        current = self.head\n        while current is not None and current.data != value:\n            current = current.next\n        return current.data if current else None\n\n    def delete_head(self):\n        if self.head is not None:\n            self.head = self.head.next\n\n    def delete(self, value):\n        if self.head is None:\n            return\n\n        if self.head.data == value:\n            self.head = self.head.next\n            return\n\n        current = self.head\n        while current.next is not None and current.next.data != value:\n            current = current.next\n\n        if current.next is not None:\n            current.next = current.next.next\n\n    def delete_last(self):\n        if self.head is None:\n            return\n\n        if self.head.next is None:\n            self.head = None\n            return\n\n        current = self.head\n        while current.next.next is not None:\n            current = current.next\n\n        current.next = None\n\n    def reverse(self):\n        prev = None\n        current = self.head\n        while current is not None:\n            next = current.next\n            current.next = prev\n            prev = current\n            current = next\n        self.head = prev\n\n    def traverse(self):\n        current = self.head\n        while current is not None:\n            print(current.data)\n            current = current.next\n',f='pub struct Node<T> {\n    data: T,\n    next: Option<Box<Node<T>>>,\n}\n\npub struct LinkedList<T> {\n    head: Option<Box<Node<T>>>,\n}\n\nimpl<T: std::cmp::PartialEq + std::clone::Clone> LinkedList<T> {\n    pub fn new() -> Self {\n        LinkedList { head: None }\n    }\n\n    pub fn prepend(&mut self, data: T) {\n        let new_node = Box::new(Node {\n            data,\n            next: self.head.take(),\n        });\n\n        self.head = Some(new_node);\n    }\n\n    pub fn insert_before(&mut self, value: T, data: T) {\n        let mut current = &mut self.head;\n        while current.is_some() && current.as_ref().unwrap().data != value {\n            current = &mut current.as_mut().unwrap().next;\n        }\n        *current = Some(Box::new(Node {\n            data,\n            next: current.take(),\n        }));\n    }\n\n    pub fn insert_after(&mut self, value: T, data: T) {\n        let mut current = &mut self.head;\n        while current.is_some() && current.as_ref().unwrap().data != value {\n            current = &mut current.as_mut().unwrap().next;\n        }\n        let next = current.as_mut().unwrap().next.take();\n        current.as_mut().unwrap().next = Some(Box::new(Node {\n            data,\n            next,\n        }));\n    }\n\n    pub fn insert_at(&mut self, index: usize, data: T) {\n        let mut current = &mut self.head;\n        for _ in 0..index {\n            current = &mut current.as_mut().unwrap().next;\n        }\n        *current = Some(Box::new(Node {\n            data,\n            next: current.take(),\n        }));\n    }\n\n    pub fn append(&mut self, data: T) {\n        let mut current = &mut self.head;\n        while current.is_some() {\n            current = &mut current.as_mut().unwrap().next;\n        }\n        *current = Some(Box::new(Node {\n            data,\n            next: None,\n        }));\n    }\n\n    pub fn find(&self, value: T) -> Option<T> {\n        let mut current = &self.head;\n        while current.is_some() && current.as_ref().unwrap().data != value {\n            current = &current.as_ref().unwrap().next;\n        }\n        current.as_ref().map(|node| node.data.clone())\n    }\n\n    pub fn delete_head(&mut self) {\n        self.head = self.head.take().and_then(|node| node.next);\n    }\n\n    pub fn delete(&mut self, value: T) {\n        let mut current = &mut self.head;\n        while current.is_some() && current.as_ref().unwrap().data != value {\n            current = &mut current.as_mut().unwrap().next;\n        }\n        *current = current.take().and_then(|node| node.next);\n    }\n\n    pub fn delete_last(&mut self) {\n        let mut current = &mut self.head;\n        while current.is_some() && current.as_mut().unwrap().next.is_some() {\n            current = &mut current.as_mut().unwrap().next;\n        }\n        *current = None;\n    }\n\n    pub fn reverse(&mut self) {\n        let mut prev = None;\n        let mut current = self.head.take();\n        while let Some(mut node) = current {\n            let next = node.next.take();\n            node.next = prev;\n            prev = Some(node);\n            current = next;\n        }\n        self.head = prev;\n    }\n\n    pub fn traverse(&self) {\n        let mut current = &self.head;\n        while let Some(node) = current {\n            println!("{:?}", node.data);\n            current = &node.next;\n        }\n    }\n}\n',p='class LinkedList<T> {\n  class Node<T> {\n    constructor(public data: T, public next: Node<T> | null = null) {}\n  }\n\n  private head: Node<T> | null = null;\n\n  prepend(data: T) {\n    this.head = new Node(data, this.head);\n  }\n\n  insertBefore(value: T, data: T) {\n    if (this.head === null) {\n      return;\n    }\n\n    if (this.head.data === value) {\n      this.head = new Node(data, this.head);\n      return;\n    }\n\n    let current = this.head;\n    while (current.next !== null && current.next.data !== value) {\n      current = current.next;\n    }\n\n    if (current.next !== null) {\n      current.next = new Node(data, current.next);\n    }\n  }\n\n  insertAfter(value: T, data: T) {\n    let current = this.head;\n    while (current !== null && current.data !== value) {\n      current = current.next;\n    }\n\n    if (current !== null) {\n      current.next = new Node(data, current.next);\n    }\n  }\n\n  insertAt(index: number, data: T) {\n    if (index < 0) {\n      throw new Error("Index must be greater than or equal to 0");\n    }\n\n    if (index === 0) {\n      this.head = new Node(data, this.head);\n      return;\n    }\n\n    let current = this.head;\n    let currentIndex = 0;\n    while (current !== null && currentIndex < index - 1) {\n      current = current.next;\n      currentIndex++;\n    }\n\n    if (current === null) {\n      throw new Error("Index exceeds the size of the list");\n    }\n\n    current.next = new Node(data, current.next);\n  }\n\n  append(data: T) {\n    if (this.head === null) {\n      this.head = new Node(data);\n    } else {\n      let current = this.head;\n      while (current.next !== null) {\n        current = current.next;\n      }\n      current.next = new Node(data);\n    }\n  }\n\n  find(value: T): Node<T> | null {\n    let current = this.head;\n    while (current !== null && current.data !== value) {\n      current = current.next;\n    }\n    return current;\n  }\n\n  deleteHead() {\n    if (this.head !== null) {\n      this.head = this.head.next;\n    }\n  }\n\n  delete(value: T) {\n    if (this.head === null) {\n      return;\n    }\n\n    if (this.head.data === value) {\n      this.head = this.head.next;\n      return;\n    }\n\n    let current = this.head;\n    while (current.next !== null && current.next.data !== value) {\n      current = current.next;\n    }\n\n    if (current.next !== null) {\n      current.next = current.next.next;\n    }\n  }\n\n  deleteLast() {\n    if (this.head === null) {\n      return;\n    }\n\n    if (this.head.next === null) {\n      this.head = null;\n      return;\n    }\n\n    let current = this.head;\n    while (current.next?.next !== null) {\n      current = current.next;\n    }\n\n    current.next = null;\n  }\n\n  reverse() {\n    let prev: Node<T> | null = null;\n    let current = this.head;\n    let next: Node<T> | null = null;\n    while (current !== null) {\n      next = current.next;\n      current.next = prev;\n      prev = current;\n      current = next;\n    }\n    this.head = prev;\n  }\n\n  traverse() {\n    let current = this.head;\n    while (current !== null) {\n      console.log(current.data);\n      current = current.next;\n    }\n  }\n}\n',v={title:"Linked List",description:"Linked List Data Structure",hide_table_of_contents:!0},m=void 0,N={},j=[{value:"Definition",id:"definition",level:2},{value:"Variants",id:"variants",level:3},{value:"Singly-Linked List",id:"singly-linked-list",level:4},{value:"Doubly Linked List",id:"doubly-linked-list",level:4},{value:"Circular Linked List",id:"circular-linked-list",level:4},{value:"Doubly Circular Linked List",id:"doubly-circular-linked-list",level:4},{value:"Practice",id:"practice",level:2}];function w(n){const e={code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",p:"p",pre:"pre",strong:"strong",...(0,d.R)(),...n.components},{Details:r}=e;return r||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{src:t(72311).A+""})}),"\n",(0,a.jsxs)("table",{children:[(0,a.jsxs)("thead",{children:[(0,a.jsxs)("tr",{children:[(0,a.jsx)("th",{children:"Space"}),(0,a.jsx)("th",{colspan:"6",children:"Time"})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("th",{}),(0,a.jsx)("th",{children:"Access"}),(0,a.jsx)("th",{children:"Lookup"}),(0,a.jsx)("th",{children:"Insertion"}),(0,a.jsx)("th",{children:"Deletion"})]})]}),(0,a.jsx)("tbody",{children:(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:(0,a.jsx)("code",{className:"fair",children:"O(n)"})}),(0,a.jsx)("td",{children:(0,a.jsx)("code",{className:"fair",children:"O(n)"})}),(0,a.jsx)("td",{children:(0,a.jsx)("code",{className:"fair",children:"O(n)"})}),(0,a.jsx)("td",{children:(0,a.jsx)("code",{className:"excellent",children:"O(1)"})}),(0,a.jsx)("td",{children:(0,a.jsx)("code",{className:"excellent",children:"O(1)"})})]})})]}),"\n",(0,a.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,a.jsxs)(u.A,{queryString:"primary",children:[(0,a.jsxs)(l.A,{value:"short",label:"Short",children:[(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Linked List"})," is a dynamic data structure that consists of nodes, each containing data and a reference to the next node in the sequence."]}),(0,a.jsxs)(r,{children:[(0,a.jsx)("summary",{children:"Simplified"}),(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Linked List"})," is like a treasure hunt game. You start at the 'head' node and follow links to other nodes, each holding data and a link to the next node. The last node, or 'tail', has no link.\nJust\nlike the game, you traverse the list to find your 'treasure' or data."]})]})]}),(0,a.jsxs)(l.A,{value:"detailed",label:"Detailed",children:[(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Linked list"})," is a dynamic structure organizing elements linearly via pointers, not physical memory locations like arrays. Each element, or node, holds data and a link to the next node. This\nallows efficient element addition or deletion during iteration. Advanced linked lists have extra links for efficient element insertion or removal from any reference point. However, linked lists\nhave\nlinear access time, making operations like random access challenging. While arrays have better cache locality, the flexibility of linked lists makes them useful in many computer science areas."]}),(0,a.jsx)(e.h3,{id:"variants",children:"Variants"}),(0,a.jsx)(e.h4,{id:"singly-linked-list",children:"Singly-Linked List"}),(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{src:t(72311).A+""})}),(0,a.jsx)(e.p,{children:"Linear data structure where elements, each containing data and a reference to the next element, form a sequence. It begins with a head node, and the last node has a null reference. Singly-linked\nlists are useful for dynamic memory allocation."}),(0,a.jsx)(e.h4,{id:"doubly-linked-list",children:"Doubly Linked List"}),(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{src:t(13724).A+""})}),(0,a.jsx)(e.p,{children:"Linear data structure where nodes contain data and 2 pointers, one pointing to the next node and another to the previous node, allowing for bidirectional traversal."}),(0,a.jsx)(e.h4,{id:"circular-linked-list",children:"Circular Linked List"}),(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{src:t(74568).A+""})}),(0,a.jsx)(e.p,{children:"Variation of a Linked List where the last node points back to the first, forming a closed loop. It facilitates continuous traversal and is useful for scenarios requiring repetitive processing or\nindefinite iteration through a sequence."}),(0,a.jsx)(e.h4,{id:"doubly-circular-linked-list",children:"Doubly Circular Linked List"}),(0,a.jsx)(e.p,{children:(0,a.jsx)(e.img,{src:t(64707).A+""})}),(0,a.jsx)(e.p,{children:"Data structure where each node has data, a pointer to the next node, and a pointer to the previous node, forming bidirectional links. The last node connects back to the first, creating a closed\nloop. This structure enables both forward and backward traversal and is useful for scenarios requiring bidirectional navigation with continuous iteration."})]})]}),"\n",(0,a.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,a.jsxs)(u.A,{queryString:"primary",children:[(0,a.jsx)(l.A,{value:"practice",label:"Practice",children:(0,a.jsxs)("table",{children:[(0,a.jsx)("thead",{children:(0,a.jsxs)("tr",{children:[(0,a.jsx)("th",{children:"Aspect"}),(0,a.jsx)("th",{children:"Pseudo Code"})]})}),(0,a.jsxs)("tbody",{children:[(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Prepend"}),(0,a.jsx)("td",{children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"prepend(data)\n  node = Node(data, head)\n  head = node\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Insert Before"}),(0,a.jsx)("td",{children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"insert_before(value, data)\n  if head == \xf8:\n    return\n  if data.head == value:\n    node = Node(data, head)\n    head = node\n    return\n  current = head\n  while current.next != \xf8 and current.next.data != value:\n    current = current.next\n  if current.next != \xf8:\n    current.next = Node(data, current.next)\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Insert After"}),(0,a.jsx)("td",{children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"insert_after(value, data)\n  current = head\n  while current != \xf8 and current.data != value:\n    current = current.next\n  if current != \xf8:\n    current.next = Node(data, current.next)\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Insert at Index"}),(0,a.jsx)("td",{children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:'insert_at(index, data)\n  if index < 0:\n    throw error "Index must be greater than or equal to 0"\n  if index == 0:\n    node = Node(data, head)\n    head = node\n    return\n  current = head\n  current_index = 0\n  while current != \xf8 and index - 1 > current_index:\n    current = current.next\n    current_index++\n  if current == \xf8:\n    throw error "Index exceeds the size of the list"\n  current.next = Node(data, current.next)\n'})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Append"}),(0,a.jsx)("td",{children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"append(data)\n  if head == \xf8:\n    head = Node(data)\n  else:\n    current = head\n    while current.next != \xf8:\n      current = current.next\n    current.next = Node(data)\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Find"}),(0,a.jsx)("td",{children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"find(value)\n  current = head\n  while current != \xf8 and current.data != value:\n    current = current.next\n  return current.data\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Delete Head"}),(0,a.jsx)("td",{children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"delete_head()\n  if head != \xf8:\n    head = head.next\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Remove Node"}),(0,a.jsx)("td",{children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"delete(value)\n  if head == \xf8:\n    return\n  if head.data == value:\n    head = head.next\n    return\n  current = head\n  while current.next != \xf8 and current.next.data != value:\n    current = current.next\n  if current.next != \xf8:\n    current.next = current.next.next\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Delete Tail"}),(0,a.jsx)("td",{children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"delete_last()\n  if head == \xf8:\n    return\n  if head.next == \xf8:\n    head = \xf8\n    return\n  current = head\n  while current.next.next != \xf8:\n    current = current.next\n  current.next = \xf8\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Reverse"}),(0,a.jsx)("td",{children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"reverse()\n  prev = \xf8\n  current = head\n  while current != \xf8:\n    next = current.next\n    current.next = prev\n    prev = current\n    current = next\n  head = prev\n"})})})]}),(0,a.jsxs)("tr",{children:[(0,a.jsx)("td",{children:"Traverse"}),(0,a.jsx)("td",{children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"traverse()\n  current = head\n  while current != \xf8:\n    yield current.data\n    current = current.next\n"})})})]})]})]})}),(0,a.jsx)(l.A,{value:"solution",label:"Solution",children:(0,a.jsxs)(u.A,{queryString:"code",children:[(0,a.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,a.jsx)(i.A,{language:"go",children:c})}),(0,a.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,a.jsx)(i.A,{language:"java",children:s})}),(0,a.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,a.jsx)(i.A,{language:"js",children:h})}),(0,a.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,a.jsx)(i.A,{language:"kotlin",children:o})}),(0,a.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,a.jsx)(i.A,{language:"python",children:x})}),(0,a.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,a.jsx)(i.A,{language:"rust",children:f})}),(0,a.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,a.jsx)(i.A,{language:"ts",children:p})})]})})]})]})}function b(n={}){const{wrapper:e}={...(0,d.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(w,{...n})}):w(n)}},64707:(n,e,t)=>{t.d(e,{A:()=>r});const r=t.p+"assets/images/circularDoublyLinkedList-9a20e13a0e92f059ad7656d5f4d7c63e.svg"},72311:(n,e,t)=>{t.d(e,{A:()=>r});const r=t.p+"assets/images/linkedList-c38171b1f0fc1d73fa6038b0e7fce4bc.svg"},74568:(n,e,t)=>{t.d(e,{A:()=>r});const r=t.p+"assets/images/circularLinkedList-63608641311474474cebca1c07796112.svg"}}]);