"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[9327],{9254:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>b,contentTitle:()=>p,default:()=>y,frontMatter:()=>f,metadata:()=>m,toc:()=>w});var t=i(86070),s=i(27468),r=i(20301),d=i(35379),a=i(81895);const l="package main\n\ntype Graph struct {\n    vertices int\n    edges    map[int][]int\n}\n\nfunc NewGraph(v int) *Graph {\n    return &Graph{\n        vertices: v,\n        edges:    make(map[int][]int),\n    }\n}\n\nfunc (g *Graph) addEdge(u, v int) {\n    g.edges[u] = append(g.edges[u], v)\n    g.edges[v] = append(g.edges[v], u)\n}\n\nfunc dfs(u, parent int, disc, low []int, visited []bool, bridges *[][]int, time *int, g *Graph) {\n    visited[u] = true\n    disc[u] = *time\n    low[u] = *time\n    *time++\n\n    for _, v := range g.edges[u] {\n        if !visited[v] {\n            dfs(v, u, disc, low, visited, bridges, time, g)\n            low[u] = min(low[u], low[v])\n            if low[v] > disc[u] {\n                *bridges = append(*bridges, []int{u, v})\n            }\n        } else if v != parent {\n            low[u] = min(low[u], disc[v])\n        }\n    }\n}\n\nfunc findBridges(g *Graph) [][]int {\n    disc := make([]int, g.vertices)\n    low := make([]int, g.vertices)\n    visited := make([]bool, g.vertices)\n    bridges := [][]int{}\n    time := 0\n\n    for i := 0; i < g.vertices; i++ {\n        if !visited[i] {\n            dfs(i, -1, disc, low, visited, &bridges, &time, g)\n        }\n    }\n    return bridges\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n",o="import java.util.ArrayList;\nimport java.util.List;\n\nclass Graph {\n\n  int vertices;\n  List<List<Integer>> edges;\n\n  Graph(int v) {\n    vertices = v;\n    edges = new ArrayList<>();\n    for (int i = 0; i < v; i++) {\n      edges.add(new ArrayList<>());\n    }\n  }\n\n  void addEdge(int u, int v) {\n    edges.get(u).add(v);\n    edges.get(v).add(u);\n  }\n}\n\npublic class BridgeInGraph {\n\n  static int time = 0;\n\n  static void dfs(int u, int parent, int[] disc, int[] low, boolean[] visited, List<List<Integer>> bridges, Graph g) {\n    visited[u] = true;\n    disc[u] = time;\n    low[u] = time;\n    time++;\n\n    for (int v : g.edges.get(u)) {\n      if (!visited[v]) {\n        dfs(v, u, disc, low, visited, bridges, g);\n        low[u] = Math.min(low[u], low[v]);\n        if (low[v] > disc[u]) {\n          bridges.add(List.of(u, v));\n        }\n      } else if (v != parent) {\n        low[u] = Math.min(low[u], disc[v]);\n      }\n    }\n  }\n\n  static List<List<Integer>> findBridges(Graph g) {\n    int[] disc = new int[g.vertices];\n    int[] low = new int[g.vertices];\n    boolean[] visited = new boolean[g.vertices];\n    List<List<Integer>> bridges = new ArrayList<>();\n\n    for (int i = 0; i < g.vertices; i++) {\n      if (!visited[i]) {\n        dfs(i, -1, disc, low, visited, bridges, g);\n      }\n    }\n    return bridges;\n  }\n}\n",c="class Graph {\n  constructor(vertices) {\n    this.vertices = vertices;\n    this.edges = new Array(vertices).fill().map(() => []);\n  }\n\n  addEdge(u, v) {\n    this.edges[u].push(v);\n    this.edges[v].push(u);\n  }\n}\n\nlet time = 0;\n\nfunction dfs(u, parent, disc, low, visited, bridges, g) {\n  visited[u] = true;\n  disc[u] = time;\n  low[u] = time;\n  time++;\n\n  for (let v of g.edges[u]) {\n    if (!visited[v]) {\n      dfs(v, u, disc, low, visited, bridges, g);\n      low[u] = Math.min(low[u], low[v]);\n      if (low[v] > disc[u]) {\n        bridges.push([u, v]);\n      }\n    } else if (v !== parent) {\n      low[u] = Math.min(low[u], disc[v]);\n    }\n  }\n}\n\nfunction findBridges(g) {\n  const disc = new Array(g.vertices).fill(0);\n  const low = new Array(g.vertices).fill(0);\n  const visited = new Array(g.vertices).fill(false);\n  const bridges = [];\n\n  for (let i = 0; i < g.vertices; i++) {\n    if (!visited[i]) {\n      dfs(i, -1, disc, low, visited, bridges, g);\n    }\n  }\n  return bridges;\n}\n",u="class Graph(private val vertices: Int) {\n    private val edges: Array<MutableList<Int>> = Array(vertices) { mutableListOf() }\n\n    fun addEdge(u: Int, v: Int) {\n        edges[u].add(v)\n        edges[v].add(u)\n    }\n\n    fun getEdges(): Array<MutableList<Int>> {\n        return edges\n    }\n}\n\nvar time = 0\n\nfun dfs(u: Int, parent: Int, disc: IntArray, low: IntArray, visited: BooleanArray, bridges: MutableList<List<Int>>, g: Graph) {\n    visited[u] = true\n    disc[u] = time\n    low[u] = time\n    time++\n\n    for (v in g.getEdges()[u]) {\n        if (!visited[v]) {\n            dfs(v, u, disc, low, visited, bridges, g)\n            low[u] = minOf(low[u], low[v])\n            if (low[v] > disc[u]) {\n                bridges.add(listOf(u, v))\n            }\n        } else if (v != parent) {\n            low[u] = minOf(low[u], disc[v])\n        }\n    }\n}\n\nfun findBridges(g: Graph): List<List<Int>> {\n    val disc = IntArray(g.vertices) { 0 }\n    val low = IntArray(g.vertices) { 0 }\n    val visited = BooleanArray(g.vertices) { false }\n    val bridges = mutableListOf<List<Int>>()\n\n    for (i in 0 until g.vertices) {\n        if (!visited[i]) {\n            dfs(i, -1, disc, low, visited, bridges, g)\n        }\n    }\n    return bridges\n}\n",g="class Graph:\n    def __init__(self, vertices):\n        self.vertices = vertices\n        self.edges = [[] for _ in range(vertices)]\n\n    def add_edge(self, u, v):\n        self.edges[u].append(v)\n        self.edges[v].append(u)\n\ndef dfs(u, parent, disc, low, visited, bridges, g):\n    global time\n    visited[u] = True\n    disc[u] = time\n    low[u] = time\n    time += 1\n\n    for v in g.edges[u]:\n        if not visited[v]:\n            dfs(v, u, disc, low, visited, bridges, g)\n            low[u] = min(low[u], low[v])\n            if low[v] > disc[u]:\n                bridges.append([u, v])\n        elif v != parent:\n            low[u] = min(low[u], disc[v])\n\ndef find_bridges(g):\n    global time\n    disc = [0] * g.vertices\n    low = [0] * g.vertices\n    visited = [False] * g.vertices\n    bridges = []\n    time = 0\n\n    for i in range(g.vertices):\n        if not visited[i]:\n            dfs(i, -1, disc, low, visited, bridges, g)\n    return bridges\n",v="struct Graph {\n    vertices: usize,\n    edges: Vec<Vec<usize>>,\n}\n\nimpl Graph {\n    fn new(vertices: usize) -> Graph {\n        Graph {\n            vertices,\n            edges: vec![Vec::new(); vertices],\n        }\n    }\n\n    fn add_edge(&mut self, u: usize, v: usize) {\n        self.edges[u].push(v);\n        self.edges[v].push(u);\n    }\n}\n\nstatic mut TIME: usize = 0;\n\nfn dfs(u: usize, parent: isize, disc: &mut [usize], low: &mut [usize], visited: &mut [bool], bridges: &mut Vec<Vec<usize>>, g: &Graph) {\n    unsafe {\n        visited[u] = true;\n        disc[u] = TIME;\n        low[u] = TIME;\n        TIME += 1;\n\n        for &v in &g.edges[u] {\n            if !visited[v] {\n                dfs(v, u as isize, disc, low, visited, bridges, g);\n                low[u] = std::cmp::min(low[u], low[v]);\n                if low[v] > disc[u] {\n                    bridges.push(vec![u, v]);\n                }\n            } else if v != parent as usize {\n                low[u] = std::cmp::min(low[u], disc[v]);\n            }\n        }\n    }\n}\n\nfn find_bridges(g: &Graph) -> Vec<Vec<usize>> {\n    let mut disc = vec![0; g.vertices];\n    let mut low = vec![0; g.vertices];\n    let mut visited = vec![false; g.vertices];\n    let mut bridges = Vec::new();\n    unsafe {\n        TIME = 0;\n    }\n\n    for i in 0..g.vertices {\n        if !visited[i] {\n            dfs(i, -1, &mut disc, &mut low, &mut visited, &mut bridges, g);\n        }\n    }\n    bridges\n}\n",h="class Graph {\n  vertices: number;\n  edges: number[][];\n\n  constructor(vertices: number) {\n    this.vertices = vertices;\n    this.edges = new Array(vertices).fill(null).map(() => []);\n  }\n\n  addEdge(u: number, v: number) {\n    this.edges[u].push(v);\n    this.edges[v].push(u);\n  }\n}\n\nlet time = 0;\n\nfunction dfs(\n  u: number,\n  parent: number,\n  disc: number[],\n  low: number[],\n  visited: boolean[],\n  bridges: number[][],\n  g: Graph,\n) {\n  visited[u] = true;\n  disc[u] = time;\n  low[u] = time;\n  time++;\n\n  for (let v of g.edges[u]) {\n    if (!visited[v]) {\n      dfs(v, u, disc, low, visited, bridges, g);\n      low[u] = Math.min(low[u], low[v]);\n      if (low[v] > disc[u]) {\n        bridges.push([u, v]);\n      }\n    } else if (v !== parent) {\n      low[u] = Math.min(low[u], disc[v]);\n    }\n  }\n}\n\nfunction findBridges(g: Graph): number[][] {\n  const disc: number[] = Array(g.vertices).fill(0);\n  const low: number[] = Array(g.vertices).fill(0);\n  const visited: boolean[] = Array(g.vertices).fill(false);\n  const bridges: number[][] = [];\n\n  for (let i = 0; i < g.vertices; i++) {\n    if (!visited[i]) {\n      dfs(i, -1, disc, low, visited, bridges, g);\n    }\n  }\n  return bridges;\n}\n",f={title:"Bridges",description:"Bridges",hide_table_of_contents:!0},p=void 0,m={id:"education/computer-science/algorithms/algo/bridges",title:"Bridges",description:"Bridges",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/bridges.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/bridges",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/bridges",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/bridges.mdx",tags:[],version:"current",frontMatter:{title:"Bridges",description:"Bridges",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Breadth-First Search (BFS)",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/breadth-first-search"},next:{title:"Bubble Sort",permalink:"/tech-labs/docs/education/computer-science/algorithms/algo/bubble-sort"}},b={},w=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function x(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,t.jsxs)(r.A,{queryString:"primary",children:[(0,t.jsx)(d.A,{value:"definition",label:"Definition",children:(0,t.jsx)(n.p,{children:'Bridges Algorithm, also known as the "Bridges of Konigsberg" problem, is a classic graph theory problem that aims to determine whether it is possible to traverse all the bridges of a city\'s river system exactly once and return to the starting point without crossing any bridge twice. This algorithmic problem is essential in understanding Eulerian paths and circuits'})}),(0,t.jsx)(d.A,{value:"how",label:"Explanation",children:(0,t.jsx)(n.p,{children:"Start by creating a graph depicting the city's bridges. Calculate the degree of each node, representing the number of bridges connected to it. If there are more than two nodes with odd degrees, it's impossible to cross all bridges exactly once without retracing steps. In the case of exactly two nodes with odd degrees, begin the journey from one and conclude at the other. When all nodes have even degrees, any node can serve as the starting point for the route"})}),(0,t.jsx)(d.A,{value:"guidance",label:"Guidance",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Identify the nodes and edges in the graph"}),"\n",(0,t.jsx)(n.li,{children:"Calculate the degree of each node by counting the number of incident edges"}),"\n",(0,t.jsx)(n.li,{children:"Determine if there are any nodes with odd degrees"}),"\n",(0,t.jsx)(n.li,{children:"If there are more than two nodes with odd degrees, it's impossible to solve the problem"}),"\n",(0,t.jsx)(n.li,{children:"If there are exactly two nodes with odd degrees, start the path from one of these nodes and end it at the other"}),"\n",(0,t.jsx)(n.li,{children:"If all nodes have even degrees, any node can be chosen as a starting point"}),"\n",(0,t.jsx)(n.li,{children:"Traverse the graph using depth-first search or breadth-first search to find a path that crosses each bridge exactly once"}),"\n",(0,t.jsx)(n.li,{children:"Backtrack if necessary to explore alternative paths"}),"\n",(0,t.jsx)(n.li,{children:"If a path exists that traverses all bridges exactly once, return it as the solution"}),"\n"]})}),(0,t.jsx)(d.A,{value:"tips",label:"Tips",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"use graph representation techniques such as adjacency lists or matrices for efficient traversal"}),"\n",(0,t.jsx)(n.li,{children:"employ backtracking to explore alternative paths when necessary"}),"\n",(0,t.jsx)(n.li,{children:"validate the solution by ensuring that all bridges are traversed exactly once"}),"\n"]})})]}),"\n",(0,t.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,t.jsxs)(r.A,{queryString:"primary",children:[(0,t.jsx)(d.A,{value:"practice",label:"Practice",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'function BridgesAlgorithm(graph):\n  odd_degree_nodes = []\n  for node in graph.nodes:\n    if degree(node) % 2 != 0:\n      odd_degree_nodes.append(node)\n\n  if length(odd_degree_nodes) > 2:\n    return "No solution exists"\n  else if length(odd_degree_nodes) == 2:\n    start_node = odd_degree_nodes[0]\n    end_node = odd_degree_nodes[1]\n  else:\n    start_node = any_node\n    end_node = any_node\n\n  path = find_path(graph, start_node)\n  return path\n\nfunction find_path(graph, node):\n  path = []\n  stack = [node]\n  while stack is not empty:\n    current_node = stack.pop()\n    path.append(current_node)\n    for neighbor in graph.neighbors(current_node):\n      if edge(current_node, neighbor) not in path:\n        stack.push(neighbor)\n  return path\n'})})}),(0,t.jsx)(d.A,{value:"solution",label:"Solution",children:(0,t.jsxs)(r.A,{queryString:"code",children:[(0,t.jsx)(d.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,t.jsx)(a.A,{language:"go",children:l})}),(0,t.jsx)(d.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,t.jsx)(a.A,{language:"java",children:o})}),(0,t.jsx)(d.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,t.jsx)(a.A,{language:"js",children:c})}),(0,t.jsx)(d.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,t.jsx)(a.A,{language:"kotlin",children:u})}),(0,t.jsx)(d.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,t.jsx)(a.A,{language:"python",children:g})}),(0,t.jsx)(d.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,t.jsx)(a.A,{language:"rust",children:v})}),(0,t.jsx)(d.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,t.jsx)(a.A,{language:"ts",children:h})})]})})]})]})}function y(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(x,{...e})}):x(e)}}}]);