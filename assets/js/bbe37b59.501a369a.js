"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[9188],{27188:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>j,contentTitle:()=>v,default:()=>b,frontMatter:()=>p,metadata:()=>f,toc:()=>x});var i=t(11527),r=t(88672),s=t(29140),a=t(52360),l=t(52296);const o='package main\n\nimport (\n    "math"\n)\n\ntype Edge struct {\n    src, dest, weight int\n}\n\nfunc bellmanFord(graph []Edge, V, E, src int) {\n    dist := make([]int, V)\n    for i := range dist {\n        dist[i] = math.MaxInt32\n    }\n    dist[src] = 0\n\n    for i := 1; i < V; i++ {\n        for j := 0; j < E; j++ {\n            u := graph[j].src\n            v := graph[j].dest\n            weight := graph[j].weight\n            if dist[u] != math.MaxInt32 && dist[u]+weight < dist[v] {\n                dist[v] = dist[u] + weight\n            }\n        }\n    }\n\n    for _, edge := range graph {\n        u := edge.src\n        v := edge.dest\n        weight := edge.weight\n        if dist[u] != math.MaxInt32 && dist[u]+weight < dist[v] {\n            fmt.Println("Graph contains negative weight cycle")\n            return\n        }\n    }\n\n    fmt.Println("Vertex Distance from Source:")\n    for i := 0; i < V; i++ {\n        fmt.Printf("Vertex %d --\x3e Distance %d\\n", i, dist[i])\n    }\n}\n',d='import java.util.Arrays;\n\nclass BellmanFord {\n\n  int V, E;\n\n  ;\n  Edge edge[];\n  BellmanFord(int v, int e) {\n    V = v;\n    E = e;\n    edge = new Edge[e];\n    for (int i = 0; i < e; ++i) {\n      edge[i] = new Edge();\n    }\n  }\n\n  void BellmanFordAlgo(BellmanFord graph, int src) {\n    int V = graph.V, E = graph.E;\n    int dist[] = new int[V];\n\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[src] = 0;\n\n    for (int i = 1; i < V; ++i) {\n      for (int j = 0; j < E; ++j) {\n        int u = graph.edge[j].src;\n        int v = graph.edge[j].dest;\n        int weight = graph.edge[j].weight;\n        if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {\n          dist[v] = dist[u] + weight;\n        }\n      }\n    }\n\n    for (int j = 0; j < E; ++j) {\n      int u = graph.edge[j].src;\n      int v = graph.edge[j].dest;\n      int weight = graph.edge[j].weight;\n      if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {\n        System.out.println("Graph contains negative weight cycle");\n      }\n    }\n\n    System.out.println("Vertex Distance from Source");\n    for (int i = 0; i < V; ++i) {\n      System.out.println(i + "\\t\\t" + dist[i]);\n    }\n  }\n\n  class Edge {\n\n    int src, dest, weight;\n\n    Edge() {\n      src = dest = weight = 0;\n    }\n  }\n}\n',c='function BellmanFord(graph, V, E, src) {\n  let dist = new Array(V).fill(Number.MAX_SAFE_INTEGER);\n  dist[src] = 0;\n\n  for (let i = 1; i < V; i++) {\n    for (let j = 0; j < E; j++) {\n      let u = graph[j].src;\n      let v = graph[j].dest;\n      let weight = graph[j].weight;\n      if (dist[u] != Number.MAX_SAFE_INTEGER && dist[u] + weight < dist[v]) {\n        dist[v] = dist[u] + weight;\n      }\n    }\n  }\n\n  for (let j = 0; j < E; j++) {\n    let u = graph[j].src;\n    let v = graph[j].dest;\n    let weight = graph[j].weight;\n    if (dist[u] != Number.MAX_SAFE_INTEGER && dist[u] + weight < dist[v]) {\n      console.log("Graph contains negative weight cycle");\n      return;\n    }\n  }\n\n  console.log("Vertex Distance from Source:");\n  for (let i = 0; i < V; i++) {\n    console.log(i + "\\t\\t" + dist[i]);\n  }\n}\n',h='class Edge(val src: Int, val dest: Int, val weight: Int)\n\nfun bellmanFord(graph: List<Edge>, V: Int, E: Int, src: Int) {\n    val dist = IntArray(V) { Int.MAX_VALUE }\n    dist[src] = 0\n\n    for (i in 1 until V) {\n        for (j in 0 until E) {\n            val u = graph[j].src\n            val v = graph[j].dest\n            val weight = graph[j].weight\n            if (dist[u] != Int.MAX_VALUE && dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight\n            }\n        }\n    }\n\n    for (j in 0 until E) {\n        val u = graph[j].src\n        val v = graph[j].dest\n        val weight = graph[j].weight\n        if (dist[u] != Int.MAX_VALUE && dist[u] + weight < dist[v]) {\n            println("Graph contains negative weight cycle")\n            return\n        }\n    }\n\n    println("Vertex Distance from Source:")\n    for (i in 0 until V) {\n        println("$i \\t\\t ${dist[i]}")\n    }\n}\n',g='def bellman_ford(graph, V, E, src):\n    dist = [float("Inf")] * V\n    dist[src] = 0\n\n    for _ in range(V - 1):\n        for u, v, weight in graph:\n            if dist[u] != float("Inf") and dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n\n    for u, v, weight in graph:\n        if dist[u] != float("Inf") and dist[u] + weight < dist[v]:\n            print("Graph contains negative weight cycle")\n            return\n\n    print("Vertex Distance from Source")\n    for i in range(V):\n        print(f"{i}\\t\\t{dist[i]}")\n',u='use std::cmp::Ordering;\n\n#[derive(Clone, Copy)]\nstruct Edge {\n    src: usize,\n    dest: usize,\n    weight: i32,\n}\n\nimpl Edge {\n    pub fn new(src: usize, dest: usize, weight: i32) -> Self {\n        Edge { src, dest, weight }\n    }\n}\n\nfn bellman_ford(graph: &Vec<Edge>, v: usize, e: usize, src: usize) {\n    let mut dist: Vec<i32> = vec![i32::MAX; v];\n    dist[src] = 0;\n\n    for _ in 1..v {\n        for j in 0..e {\n            let u = graph[j].src;\n            let v = graph[j].dest;\n            let weight = graph[j].weight;\n            if dist[u] != i32::MAX && dist[u] + weight < dist[v] {\n                dist[v] = dist[u] + weight;\n            }\n        }\n    }\n\n    for j in 0..e {\n        let u = graph[j].src;\n        let v = graph[j].dest;\n        let weight = graph[j].weight;\n        if dist[u] != i32::MAX && dist[u] + weight < dist[v] {\n            println!("Graph contains negative weight cycle");\n            return;\n        }\n    }\n\n    println!("Vertex Distance from Source:");\n    for i in 0..v {\n        println!("{} \\t\\t {}", i, dist[i]);\n    }\n}\n',m='class Edge {\n  src: number;\n  dest: number;\n  weight: number;\n\n  constructor(src: number, dest: number, weight: number) {\n    this.src = src;\n    this.dest = dest;\n    this.weight = weight;\n  }\n}\n\nfunction bellmanFord(graph: Edge[], V: number, E: number, src: number): void {\n  let dist: number[] = Array(V).fill(Number.MAX_SAFE_INTEGER);\n  dist[src] = 0;\n\n  for (let i = 1; i < V; i++) {\n    for (let j = 0; j < E; j++) {\n      let u: number = graph[j].src;\n      let v: number = graph[j].dest;\n      let weight: number = graph[j].weight;\n      if (dist[u] != Number.MAX_SAFE_INTEGER && dist[u] + weight < dist[v]) {\n        dist[v] = dist[u] + weight;\n      }\n    }\n  }\n\n  for (let j = 0; j < E; j++) {\n    let u: number = graph[j].src;\n    let v: number = graph[j].dest;\n    let weight: number = graph[j].weight;\n    if (dist[u] != Number.MAX_SAFE_INTEGER && dist[u] + weight < dist[v]) {\n      console.log("Graph contains negative weight cycle");\n      return;\n    }\n  }\n\n  console.log("Vertex Distance from Source:");\n  for (let i = 0; i < V; i++) {\n    console.log(i + "\\t\\t" + dist[i]);\n  }\n}\n',p={title:"Bellman-Ford Algorithm",description:"Bellman-Ford Algorithm",hide_table_of_contents:!0},v=void 0,f={id:"education/computer-science/algorithms/algo/bellman-ford-algorithm",title:"Bellman-Ford Algorithm",description:"Bellman-Ford Algorithm",source:"@site/docs/education/01-computer-science/10-algorithms/03-algo/bellman-ford-algorithm.mdx",sourceDirName:"education/01-computer-science/10-algorithms/03-algo",slug:"/education/computer-science/algorithms/algo/bellman-ford-algorithm",permalink:"/docs/education/computer-science/algorithms/algo/bellman-ford-algorithm",draft:!1,unlisted:!1,editUrl:"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/03-algo/bellman-ford-algorithm.mdx",tags:[],version:"current",frontMatter:{title:"Bellman-Ford Algorithm",description:"Bellman-Ford Algorithm",hide_table_of_contents:!0},sidebar:"education",previous:{title:"Articulation Points",permalink:"/docs/education/computer-science/algorithms/algo/articulation-points"},next:{title:"Best Time To Buy Sell Stocks",permalink:"/docs/education/computer-science/algorithms/algo/best-time-to-buy-sell-stocks"}},j={},x=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function w(e){const n={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(s.Z,{children:[(0,i.jsx)(a.Z,{value:"definition",label:"Definition",children:(0,i.jsx)(n.p,{children:"The Bellman-Ford Algorithm is a dynamic programming algorithm used to find the shortest path from a single source vertex to all other vertices in a weighted graph, even if the graph contains negative weight edges (as long as there are no negative weight cycles)"})}),(0,i.jsx)(a.Z,{value:"how",label:"Explanation",children:(0,i.jsx)(n.p,{children:"Repeatedly relaxing edges, updating the shortest path estimates until they converge to the optimal solution"})}),(0,i.jsx)(a.Z,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Initialization","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"set the distance to the source vertex as 0 and all other vertices as infinity"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Iterative Relaxation (Repeat V-1 times)","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["for each edge (u, v) in the graph","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["if the distance to v through u is shorter than the current distance to v","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"update the distance to v as the distance to u plus the weight of edge (u, v)"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Check for Negative Cycles","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["after V-1 iterations","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["check each edge (u, v) in the graph","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"if the distance to v can still be decreased, then there exists a negative weight cycle"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["Output","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"return the shortest distances calculated from the source vertex to all other vertices"}),"\n"]}),"\n"]}),"\n"]})}),(0,i.jsx)(a.Z,{value:"tips",label:"Tips",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"keep track of the minimum distances and update them iteratively"}),"\n",(0,i.jsx)(n.li,{children:"handle negative weight cycles separately as they can cause the algorithm to enter an infinite loop"}),"\n",(0,i.jsx)(n.li,{children:"be cautious about the complexity, as the algorithm can become inefficient for large graphs with many edges"}),"\n"]})})]}),"\n",(0,i.jsx)(n.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(s.Z,{children:[(0,i.jsx)(a.Z,{value:"practice",label:"Practice",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"function findArticulationPoints(graph):\n  # Initialize variables and data structures\n  articulationPoints = []\n  visited = {}\n  discoveryTime = {}\n  low = {}\n  parent = {}\n  time = 0\n\n  # Perform DFS traversal\n  for each vertex in graph.vertices():\n    if vertex not in visited:\n      dfs(vertex, visited, discoveryTime, low, parent, articulationPoints, time)\n\n  return articulationPoints\n\nfunction dfs(vertex, visited, discoveryTime, low, parent, articulationPoints, time):\n  # Mark vertex as visited and set its discovery time\n  visited[vertex] = True\n  time += 1\n  discoveryTime[vertex] = time\n  low[vertex] = time\n  children = 0\n\n  # Iterate over adjacent vertices\n  for each neighbor in graph.neighbors(vertex):\n    if neighbor not in visited:\n      # Update parent of neighbor\n      parent[neighbor] = vertex\n      children += 1\n      dfs(neighbor, visited, discoveryTime, low, parent, articulationPoints, time)\n\n      # Update low value of vertex\n      low[vertex] = min(low[vertex], low[neighbor])\n\n      # Check if vertex is an articulation point\n      if parent[vertex] is None and children > 1:\n        articulationPoints.append(vertex)\n      elif parent[vertex] is not None and low[neighbor] >= discoveryTime[vertex]:\n        articulationPoints.append(vertex)\n    elif neighbor != parent[vertex]:\n      # Update low value of vertex if neighbor is not parent\n      low[vertex] = min(low[vertex], discoveryTime[neighbor])\n"})})}),(0,i.jsx)(a.Z,{value:"solution",label:"Solution",children:(0,i.jsxs)(s.Z,{queryString:"code",children:[(0,i.jsx)(a.Z,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(l.Z,{language:"go",children:o})}),(0,i.jsx)(a.Z,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(l.Z,{language:"java",children:d})}),(0,i.jsx)(a.Z,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(l.Z,{language:"js",children:c})}),(0,i.jsx)(a.Z,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(l.Z,{language:"kotlin",children:h})}),(0,i.jsx)(a.Z,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(l.Z,{language:"python",children:g})}),(0,i.jsx)(a.Z,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(l.Z,{language:"rust",children:u})}),(0,i.jsx)(a.Z,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(l.Z,{language:"ts",children:m})})]})})]})]})}function b(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(w,{...e})}):w(e)}}}]);