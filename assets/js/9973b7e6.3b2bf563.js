"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[6971],{94544:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>k,contentTitle:()=>x,default:()=>T,frontMatter:()=>h,metadata:()=>r,toc:()=>N});const r=JSON.parse('{"id":"education/computer-science/algorithms/algo/discrete-fourier-transform","title":"Discrete Fourier Transform","description":"Discrete Fourier Transform","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/discrete-fourier-transform.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/discrete-fourier-transform","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/discrete-fourier-transform","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/discrete-fourier-transform.mdx","tags":[],"version":"current","frontMatter":{"title":"Discrete Fourier Transform","description":"Discrete Fourier Transform","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Dijkstra Algorithm","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/dijkstra-algorithm"},"next":{"title":"Euclidean Algorithm","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/euclidean-algorithm"}}');var a=t(86070),o=t(15658),l=t(33407),i=t(33903),u=t(68171);const s='package main\n\nimport (\n    "math"\n)\n\ntype ComplexNumber struct {\n    Real float64\n    Imag float64\n}\n\n// Discrete Fourier Transform (DFT)\n\nfunc DFT(input []float64) []ComplexNumber {\n    N := len(input)\n    output := make([]ComplexNumber, N)\n\n    for k := 0; k < N; k++ {\n        var sumReal, sumImag float64\n        for n := 0; n < N; n++ {\n            angle := -2 * math.Pi * float64(k) * float64(n) / float64(N)\n            sumReal += input[n] * math.Cos(angle)\n            sumImag += input[n] * math.Sin(angle)\n        }\n        output[k] = ComplexNumber{Real: sumReal, Imag: sumImag}\n    }\n\n    return output\n}\n\n// Inverse Discrete Fourier Transform (IDFT)\nfunc IDFT(input []ComplexNumber) []float64 {\n    N := len(input)\n    output := make([]float64, N)\n\n    for n := 0; n < N; n++ {\n        var sumReal, sumImag float64\n        for k := 0; k < N; k++ {\n            angle := 2 * math.Pi * float64(k) * float64(n) / float64(N)\n            sumReal += input[k].Real * math.Cos(angle) - input[k].Imag * math.Sin(angle)\n            sumImag += input[k].Real * math.Sin(angle) + input[k].Imag * math.Cos(angle)\n        }\n        output[n] = sumReal / float64(N) // Scaling factor 1/N\n    }\n\n    return output\n}\n\n// Fast Fourier Transform (FFT)\nfunc FFT(input []float64) []ComplexNumber {\n    N := len(input)\n\n    if N <= 1 {\n        result := make([]ComplexNumber, N)\n        for i := 0; i < N; i++ {\n            result[i] = ComplexNumber{Real: input[i], Imag: 0}\n        }\n        return result\n    }\n\n    even := make([]float64, N/2)\n    odd := make([]float64, N/2)\n\n    for i := 0; i < N/2; i++ {\n        even[i] = input[2*i]\n        odd[i] = input[2*i+1]\n    }\n\n    evenTransformed := FFT(even)\n    oddTransformed := FFT(odd)\n\n    output := make([]ComplexNumber, N)\n\n    for k := 0; k < N/2; k++ {\n        angle := -2 * math.Pi * float64(k) / float64(N)\n        expReal := math.Cos(angle)\n        expImag := math.Sin(angle)\n\n        termReal := expReal*oddTransformed[k].Real - expImag*oddTransformed[k].Imag\n        termImag := expReal*oddTransformed[k].Imag + expImag*oddTransformed[k].Real\n\n        output[k] = ComplexNumber{Real: evenTransformed[k].Real + termReal, Imag: evenTransformed[k].Imag + termImag}\n        output[k+N/2] = ComplexNumber{Real: evenTransformed[k].Real - termReal, Imag: evenTransformed[k].Imag - termImag}\n    }\n\n    return output\n}\n',m="import java.util.Arrays;\n\npublic class FourierTransform {\n\n  // Discrete Fourier Transform (DFT)\n  public static Complex[] DFT(double[] input) {\n    int N = input.length;\n    Complex[] output = new Complex[N];\n\n    for (int k = 0; k < N; k++) {\n      double sumReal = 0;\n      double sumImag = 0;\n      for (int n = 0; n < N; n++) {\n        double angle = -2 * Math.PI * k * n / N;\n        sumReal += input[n] * Math.cos(angle);\n        sumImag += input[n] * Math.sin(angle);\n      }\n      output[k] = new Complex(sumReal, sumImag);\n    }\n\n    return output;\n  }\n\n  // Inverse Discrete Fourier Transform (IDFT)\n  public static double[] IDFT(Complex[] input) {\n    int N = input.length;\n    double[] output = new double[N];\n\n    for (int n = 0; n < N; n++) {\n      double sumReal = 0;\n      double sumImag = 0;\n      for (int k = 0; k < N; k++) {\n        double angle = 2 * Math.PI * k * n / N;\n        sumReal += input[k].real * Math.cos(angle) - input[k].imag * Math.sin(angle);\n        sumImag += input[k].real * Math.sin(angle) + input[k].imag * Math.cos(angle);\n      }\n      output[n] = sumReal / N; // Scaling factor 1/N\n    }\n\n    return output;\n  }\n\n  // Fast Fourier Transform (FFT)\n  public static Complex[] FFT(double[] input) {\n    int N = input.length;\n\n    if (N == 1) {\n      return new Complex[]{new Complex(input[0], 0)};\n    }\n\n    double[] even = new double[N / 2];\n    double[] odd = new double[N / 2];\n\n    for (int i = 0; i < N / 2; i++) {\n      even[i] = input[2 * i];\n      odd[i] = input[2 * i + 1];\n    }\n\n    Complex[] evenTransformed = FFT(even);\n    Complex[] oddTransformed = FFT(odd);\n\n    Complex[] output = new Complex[N];\n\n    for (int k = 0; k < N / 2; k++) {\n      double angle = -2 * Math.PI * k / N;\n      Complex exp = new Complex(Math.cos(angle), Math.sin(angle));\n\n      Complex term = oddTransformed[k].multiply(exp);\n\n      output[k] = evenTransformed[k].add(term);\n      output[k + N / 2] = evenTransformed[k].subtract(term);\n    }\n\n    return output;\n  }\n\n  public static class Complex {\n\n    double real;\n    double imag;\n\n    public Complex(double real, double imag) {\n      this.real = real;\n      this.imag = imag;\n    }\n\n    public Complex add(Complex other) {\n      return new Complex(this.real + other.real, this.imag + other.imag);\n    }\n\n    public Complex subtract(Complex other) {\n      return new Complex(this.real - other.real, this.imag - other.imag);\n    }\n\n    public Complex multiply(Complex other) {\n      return new Complex(this.real * other.real - this.imag * other.imag,\n          this.real * other.imag + this.imag * other.real);\n    }\n  }\n}\n",p="// Discrete Fourier Transform (DFT)\nfunction DFT(input) {\n  const N = input.length;\n  const output = new Array(N);\n  const theta = (-2 * Math.PI) / N;\n\n  for (let k = 0; k < N; k++) {\n    let sumReal = 0;\n    let sumImag = 0;\n    for (let n = 0; n < N; n++) {\n      const angle = theta * k * n;\n      sumReal += input[n] * Math.cos(angle);\n      sumImag += input[n] * Math.sin(angle);\n    }\n    output[k] = { real: sumReal, imag: sumImag };\n  }\n  return output;\n}\n\n// Inverse Discrete Fourier Transform (IDFT)\nfunction IDFT(input) {\n  const N = input.length;\n  const output = new Array(N);\n  const theta = (2 * Math.PI) / N;\n\n  for (let n = 0; n < N; n++) {\n    let sumReal = 0;\n    let sumImag = 0;\n    for (let k = 0; k < N; k++) {\n      const angle = theta * k * n;\n      sumReal +=\n        input[k].real * Math.cos(angle) - input[k].imag * Math.sin(angle);\n      sumImag +=\n        input[k].real * Math.sin(angle) + input[k].imag * Math.cos(angle);\n    }\n    output[n] = sumReal / N; // Scaling factor 1/N\n  }\n  return output;\n}\n\n// Fast Fourier Transform (FFT)\nfunction FFT(input) {\n  const N = input.length;\n\n  if (N <= 1) {\n    return input;\n  }\n\n  const even = new Array(N / 2);\n  const odd = new Array(N / 2);\n\n  for (let i = 0; i < N / 2; i++) {\n    even[i] = input[2 * i];\n    odd[i] = input[2 * i + 1];\n  }\n\n  const evenTransformed = FFT(even);\n  const oddTransformed = FFT(odd);\n\n  const output = new Array(N);\n\n  for (let k = 0; k < N / 2; k++) {\n    const angle = (-2 * Math.PI * k) / N;\n    const exp = {\n      real: Math.cos(angle),\n      imag: Math.sin(angle),\n    };\n\n    const term = {\n      real:\n        exp.real * oddTransformed[k].real - exp.imag * oddTransformed[k].imag,\n      imag:\n        exp.real * oddTransformed[k].imag + exp.imag * oddTransformed[k].real,\n    };\n\n    output[k] = {\n      real: evenTransformed[k].real + term.real,\n      imag: evenTransformed[k].imag + term.imag,\n    };\n\n    output[k + N / 2] = {\n      real: evenTransformed[k].real - term.real,\n      imag: evenTransformed[k].imag - term.imag,\n    };\n  }\n\n  return output;\n}\n",c="import kotlin.math.*\n\ndata class Complex(val real: Double, val imag: Double) {\n    operator fun plus(other: Complex) = Complex(real + other.real, imag + other.imag)\n    operator fun minus(other: Complex) = Complex(real - other.real, imag - other.imag)\n    operator fun times(other: Complex) = Complex(\n            real * other.real - imag * other.imag,\n            real * other.imag + imag * other.real\n    )\n}\n\n// Discrete Fourier Transform (DFT)\nfun dft(input: DoubleArray): Array<Complex> {\n    val N = input.size\n    val output = Array(N) { Complex(0.0, 0.0) }\n\n    for (k in 0 until N) {\n        var sumReal = 0.0\n        var sumImag = 0.0\n        for (n in 0 until N) {\n            val angle = -2 * PI * k * n / N\n            sumReal += input[n] * cos(angle)\n            sumImag += input[n] * sin(angle)\n        }\n        output[k] = Complex(sumReal, sumImag)\n    }\n\n    return output\n}\n\n// Inverse Discrete Fourier Transform (IDFT)\nfun idft(input: Array<Complex>): DoubleArray {\n    val N = input.size\n    val output = DoubleArray(N)\n\n    for (n in 0 until N) {\n        var sumReal = 0.0\n        var sumImag = 0.0\n        for (k in 0 until N) {\n            val angle = 2 * PI * k * n / N\n            sumReal += input[k].real * cos(angle) - input[k].imag * sin(angle)\n            sumImag += input[k].real * sin(angle) + input[k].imag * cos(angle)\n        }\n        output[n] = sumReal / N // Scaling factor 1/N\n    }\n\n    return output\n}\n\n// Fast Fourier Transform (FFT)\nfun fft(input: DoubleArray): Array<Complex> {\n    val N = input.size\n\n    if (N == 1) {\n        return arrayOf(Complex(input[0], 0.0))\n    }\n\n    val even = DoubleArray(N / 2)\n    val odd = DoubleArray(N / 2)\n\n    for (i in 0 until N / 2) {\n        even[i] = input[2 * i]\n        odd[i] = input[2 * i + 1]\n    }\n\n    val evenTransformed = fft(even)\n    val oddTransformed = fft(odd)\n\n    val output = Array(N) { Complex(0.0, 0.0) }\n\n    for (k in 0 until N / 2) {\n        val angle = -2 * PI * k / N\n        val exp = Complex(cos(angle), sin(angle))\n        val term = oddTransformed[k] * exp\n\n        output[k] = evenTransformed[k] + term\n        output[k + N / 2] = evenTransformed[k] - term\n    }\n\n    return output\n}\n",f="import math\n\nclass ComplexNumber:\n    def __init__(self, real, imag):\n        self.real = real\n        self.imag = imag\n\n    def add(self, other):\n        return ComplexNumber(self.real + other.real, self.imag + other.imag)\n\n    def subtract(self, other):\n        return ComplexNumber(self.real - other.real, self.imag - other.imag)\n\n    def multiply(self, other):\n        return ComplexNumber(\n            self.real * other.real - self.imag * other.imag,\n            self.real * other.imag + self.imag * other.real\n        )\n\n# Discrete Fourier Transform (DFT)\ndef DFT(input_signal):\n    N = len(input_signal)\n    output = [ComplexNumber(0, 0)] * N\n\n    for k in range(N):\n        for n in range(N):\n            angle = -2 * math.pi * k * n / N\n            output[k] = output[k].add(ComplexNumber(input_signal[n] * math.cos(angle),\n                                                    input_signal[n] * math.sin(angle)))\n\n    return output\n\n# Inverse Discrete Fourier Transform (IDFT)\ndef IDFT(input_spectrum):\n    N = len(input_spectrum)\n    output = [0] * N\n\n    for n in range(N):\n        for k in range(N):\n            angle = 2 * math.pi * k * n / N\n            output[n] += input_spectrum[k].real * math.cos(angle) - input_spectrum[k].imag * math.sin(angle)\n\n    return [value / N for value in output]\n\n# Fast Fourier Transform (FFT)\ndef FFT(input_signal):\n    N = len(input_signal)\n\n    if N <= 1:\n        return input_signal\n\n    even = FFT(input_signal[::2])\n    odd = FFT(input_signal[1::2])\n\n    factor = [math.exp(-2j * math.pi * k / N) for k in range(N//2)]\n\n    return [even[k] + factor[k] * odd[k] for k in range(N//2)] + \\\n           [even[k] - factor[k] * odd[k] for k in range(N//2)]\n",g="use std::f64::consts::PI;\n\n#[derive(Debug, Clone, Copy)]\nstruct Complex {\n    real: f64,\n    imag: f64,\n}\n\nimpl Complex {\n    fn new(real: f64, imag: f64) -> Complex {\n        Complex { real, imag }\n    }\n\n    fn add(self, other: Complex) -> Complex {\n        Complex::new(self.real + other.real, self.imag + other.imag)\n    }\n\n    fn subtract(self, other: Complex) -> Complex {\n        Complex::new(self.real - other.real, self.imag - other.imag)\n    }\n\n    fn multiply(self, other: Complex) -> Complex {\n        Complex::new(\n            self.real * other.real - self.imag * other.imag,\n            self.real * other.imag + self.imag * other.real,\n        )\n    }\n}\n\n// Discrete Fourier Transform (DFT)\nfn dft(input_signal: &[f64]) -> Vec<Complex> {\n    let n = input_signal.len();\n    let mut output = vec![Complex::new(0.0, 0.0); n];\n\n    for k in 0..n {\n        for n in 0..n {\n            let angle = -2.0 * PI * (k as f64) * (n as f64) / (n as f64);\n            output[k] = output[k].add(Complex::new(input_signal[n] * angle.cos(), input_signal[n] * angle.sin()));\n        }\n    }\n\n    output\n}\n\n// Inverse Discrete Fourier Transform (IDFT)\nfn idft(input_spectrum: &[Complex]) -> Vec<f64> {\n    let n = input_spectrum.len();\n    let mut output = vec![0.0; n];\n\n    for n in 0..n {\n        for k in 0..n {\n            let angle = 2.0 * PI * (k as f64) * (n as f64) / (n as f64);\n            output[n] += input_spectrum[k].real * angle.cos() - input_spectrum[k].imag * angle.sin();\n        }\n    }\n\n    output.iter().map(|&x| x / (n as f64)).collect()\n}\n\n// Fast Fourier Transform (FFT)\nfn fft(input_signal: &[f64]) -> Vec<Complex> {\n    let n = input_signal.len();\n\n    if n <= 1 {\n        return input_signal.iter().map(|&x| Complex::new(x, 0.0)).collect();\n    }\n\n    let even: Vec<f64> = input_signal.iter().enumerate().filter(|(i, _)| i % 2 == 0).map(|(_, &x)| x).collect();\n    let odd: Vec<f64> = input_signal.iter().enumerate().filter(|(i, _)| i % 2 != 0).map(|(_, &x)| x).collect();\n\n    let even_transformed = fft(&even);\n    let odd_transformed = fft(&odd);\n\n    let factor: Vec<Complex> = (0..n / 2).map(|k| {\n        let angle = -2.0 * PI * (k as f64) / (n as f64);\n        Complex::new(angle.cos(), angle.sin())\n    }).collect();\n\n    let mut output = vec![Complex::new(0.0, 0.0); n];\n\n    for k in 0..n / 2 {\n        let term = odd_transformed[k].multiply(factor[k]);\n        output[k] = even_transformed[k].add(term);\n        output[k + n / 2] = even_transformed[k].subtract(term);\n    }\n\n    output\n}\n",d="class ComplexNumber {\n  constructor(\n    public real: number,\n    public imag: number,\n  ) {}\n\n  add(other: ComplexNumber): ComplexNumber {\n    return new ComplexNumber(this.real + other.real, this.imag + other.imag);\n  }\n\n  subtract(other: ComplexNumber): ComplexNumber {\n    return new ComplexNumber(this.real - other.real, this.imag - other.imag);\n  }\n\n  multiply(other: ComplexNumber): ComplexNumber {\n    return new ComplexNumber(\n      this.real * other.real - this.imag * other.imag,\n      this.real * other.imag + this.imag * other.real,\n    );\n  }\n}\n\n// Discrete Fourier Transform (DFT)\nfunction DFT(input: number[]): ComplexNumber[] {\n  const N = input.length;\n  const output: ComplexNumber[] = [];\n\n  for (let k = 0; k < N; k++) {\n    let sumReal = 0;\n    let sumImag = 0;\n    for (let n = 0; n < N; n++) {\n      const angle = (-2 * Math.PI * k * n) / N;\n      sumReal += input[n] * Math.cos(angle);\n      sumImag += input[n] * Math.sin(angle);\n    }\n    output.push(new ComplexNumber(sumReal, sumImag));\n  }\n\n  return output;\n}\n\n// Inverse Discrete Fourier Transform (IDFT)\nfunction IDFT(input: ComplexNumber[]): number[] {\n  const N = input.length;\n  const output: number[] = [];\n\n  for (let n = 0; n < N; n++) {\n    let sumReal = 0;\n    let sumImag = 0;\n    for (let k = 0; k < N; k++) {\n      const angle = (2 * Math.PI * k * n) / N;\n      sumReal +=\n        input[k].real * Math.cos(angle) - input[k].imag * Math.sin(angle);\n      sumImag +=\n        input[k].real * Math.sin(angle) + input[k].imag * Math.cos(angle);\n    }\n    output.push(sumReal / N);\n  }\n\n  return output;\n}\n\n// Fast Fourier Transform (FFT)\nfunction FFT(input: number[]): ComplexNumber[] {\n  const N = input.length;\n\n  if (N <= 1) {\n    return input.map((val) => new ComplexNumber(val, 0));\n  }\n\n  const even: number[] = [];\n  const odd: number[] = [];\n  for (let i = 0; i < N / 2; i++) {\n    even.push(input[2 * i]);\n    odd.push(input[2 * i + 1]);\n  }\n\n  const evenTransformed = FFT(even);\n  const oddTransformed = FFT(odd);\n\n  const output: ComplexNumber[] = [];\n  for (let k = 0; k < N / 2; k++) {\n    const angle = (-2 * Math.PI * k) / N;\n    const exp = new ComplexNumber(Math.cos(angle), Math.sin(angle));\n\n    const term = oddTransformed[k].multiply(exp);\n\n    output.push(evenTransformed[k].add(term));\n    output.push(evenTransformed[k].subtract(term));\n  }\n\n  return output;\n}\n",h={title:"Discrete Fourier Transform",description:"Discrete Fourier Transform",hide_table_of_contents:!0},x=void 0,k={},N=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function b(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,a.jsxs)(l.A,{queryString:"primary",children:[(0,a.jsx)(i.A,{value:"definition",label:"Definition",children:(0,a.jsx)(e.p,{children:"The Discrete Fourier Transform (DFT) algorithm is a fundamental method for analyzing the frequencies present in discrete signals. It transforms a sequence of complex numbers representing a signal from the time domain into a sequence of complex numbers representing the signal in the frequency domain"})}),(0,a.jsx)(i.A,{value:"how",label:"Explanation",children:(0,a.jsx)(e.p,{children:"Commence by taking a sequence of complex numbers that denote discrete data points within a time domain. Proceed by multiplying each data point by a complex sinusoid of differing frequencies. Aggregate the products obtained for each frequency, resulting in complex numbers that express the amplitudes and phases corresponding to those frequencies. This process iterates across all frequencies to encompass the entire spectrum of interest."})}),(0,a.jsx)(i.A,{value:"guidance",label:"Guidance",children:(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Get a list of numbers"}),"\n",(0,a.jsxs)(e.li,{children:["Loop Through Frequencies for each frequency from the start to the end","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"start with a total of zero for this frequency"}),"\n",(0,a.jsxs)(e.li,{children:["Loop Through Data Points for each number in the list","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Imagine a swinging arrow that goes around a circle. The arrow's speed depends on the frequency and its position depends on which number you're looking at"}),"\n",(0,a.jsx)(e.li,{children:"Multiply the number by where the arrow is pointing, and add it to the total for this frequency"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.li,{children:"Return a list of all these totals, which shows how much of each frequency is in the original list of numbers"}),"\n"]})}),(0,a.jsx)(i.A,{value:"tips",label:"Tips",children:(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"utilize efficient algorithms like the Fast Fourier Transform (FFT) for practical implementations, as it significantly reduces computational complexity"}),"\n",(0,a.jsx)(e.li,{children:"understand the properties of complex numbers and how they behave when multiplied and added"}),"\n",(0,a.jsx)(e.li,{children:"choose appropriate data structures and algorithms for handling large datasets efficiently"}),"\n"]})})]}),"\n",(0,a.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,a.jsxs)(l.A,{queryString:"primary",children:[(0,a.jsx)(i.A,{value:"practice",label:"Practice",children:(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"DiscreteFourierTransform(input_sequence):\n  N = length(input_sequence)\n  output_sequence = array of length N\n\n  for k from 0 to N-1:\n    Y_k = 0\n    for n from 0 to N-1:\n      omega = e^(-2*pi*i*k*n/N)\n      Y_k += input_sequence[n] * omega\n    output_sequence[k] = Y_k\n\n  return output_sequence\n"})})}),(0,a.jsx)(i.A,{value:"solution",label:"Solution",children:(0,a.jsxs)(l.A,{queryString:"code",children:[(0,a.jsx)(i.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,a.jsx)(u.A,{language:"go",children:s})}),(0,a.jsx)(i.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,a.jsx)(u.A,{language:"java",children:m})}),(0,a.jsx)(i.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,a.jsx)(u.A,{language:"js",children:p})}),(0,a.jsx)(i.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,a.jsx)(u.A,{language:"kotlin",children:c})}),(0,a.jsx)(i.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,a.jsx)(u.A,{language:"python",children:f})}),(0,a.jsx)(i.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,a.jsx)(u.A,{language:"rust",children:g})}),(0,a.jsx)(i.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,a.jsx)(u.A,{language:"ts",children:d})})]})})]})]})}function T(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(b,{...n})}):b(n)}}}]);