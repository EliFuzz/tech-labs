"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[4489],{66327:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>y,contentTitle:()=>x,default:()=>A,frontMatter:()=>p,metadata:()=>t,toc:()=>j});const t=JSON.parse('{"id":"education/computer-science/algorithms/algo/merge-sort","title":"Merge Sort","description":"Merge Sort","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/merge-sort.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/merge-sort","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/merge-sort","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/merge-sort.mdx","tags":[],"version":"current","frontMatter":{"title":"Merge Sort","description":"Merge Sort","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Maximum Subarray","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/maximum-subarray"},"next":{"title":"N-Queens Problem","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/n-queens-problem"}}');var i=n(86070),l=n(15658),a=n(33407),s=n(33903),o=n(68171);const g="package main\n\nfunc mergeSort(arr []int) []int {\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\n\tmid := len(arr) / 2\n\tleft := mergeSort(arr[:mid])\n\tright := mergeSort(arr[mid:])\n\n\treturn merge(left, right)\n}\n\nfunc merge(left, right []int) []int {\n\tresult := make([]int, 0, len(left)+len(right))\n\n\tfor len(left) > 0 || len(right) > 0 {\n\t\tif len(left) == 0 {\n\t\t\treturn append(result, right...)\n\t\t}\n\t\tif len(right) == 0 {\n\t\t\treturn append(result, left...)\n\t\t}\n\t\tif left[0] <= right[0] {\n\t\t\tresult = append(result, left[0])\n\t\t\tleft = left[1:]\n\t\t} else {\n\t\t\tresult = append(result, right[0])\n\t\t\tright = right[1:]\n\t\t}\n\t}\n\n\treturn result\n}\n",h="import java.util.Arrays;\n\npublic class MergeSort {\n\n  public static void mergeSort(int[] arr) {\n    if (arr.length <= 1) {\n      return;\n    }\n    int mid = arr.length / 2;\n    int[] left = Arrays.copyOfRange(arr, 0, mid);\n    int[] right = Arrays.copyOfRange(arr, mid, arr.length);\n    mergeSort(left);\n    mergeSort(right);\n    merge(arr, left, right);\n  }\n\n  public static void merge(int[] arr, int[] left, int[] right) {\n    int i = 0, j = 0, k = 0;\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) {\n        arr[k++] = left[i++];\n      } else {\n        arr[k++] = right[j++];\n      }\n    }\n    while (i < left.length) {\n      arr[k++] = left[i++];\n    }\n    while (j < right.length) {\n      arr[k++] = right[j++];\n    }\n  }\n}\n",d="function mergeSort(arr) {\n  if (arr.length <= 1) {\n    return arr;\n  }\n\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n\n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  let result = [];\n  let leftIndex = 0;\n  let rightIndex = 0;\n\n  while (leftIndex < left.length && rightIndex < right.length) {\n    if (left[leftIndex] < right[rightIndex]) {\n      result.push(left[leftIndex]);\n      leftIndex++;\n    } else {\n      result.push(right[rightIndex]);\n      rightIndex++;\n    }\n  }\n\n  return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n}\n",c="fun mergeSort(arr: IntArray): IntArray {\n    if (arr.size <= 1) return arr\n\n    val mid = arr.size / 2\n    val left = mergeSort(arr.sliceArray(0 until mid))\n    val right = mergeSort(arr.sliceArray(mid until arr.size))\n\n    return merge(left, right)\n}\n\nfun merge(left: IntArray, right: IntArray): IntArray {\n    val result = mutableListOf<Int>()\n    var leftIndex = 0\n    var rightIndex = 0\n\n    while (leftIndex < left.size && rightIndex < right.size) {\n        if (left[leftIndex] < right[rightIndex]) {\n            result.add(left[leftIndex])\n            leftIndex++\n        } else {\n            result.add(right[rightIndex])\n            rightIndex++\n        }\n    }\n    while (leftIndex < left.size) {\n        result.add(left[leftIndex])\n        leftIndex++\n    }\n    while (rightIndex < right.size) {\n        result.add(right[rightIndex])\n        rightIndex++\n    }\n    return result.toIntArray()\n}\n",u="def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n\n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n\n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n",m="fn merge_sort(arr: &mut [i32]) {\n    if arr.len() <= 1 {\n        return;\n    }\n\n    let mid = arr.len() / 2;\n    let (left, right) = arr.split_at_mut(mid);\n    merge_sort(left);\n    merge_sort(right);\n    merge(arr, left, right);\n}\n\nfn merge(arr: &mut [i32], left: &mut [i32], right: &mut [i32]) {\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n\n    while i < left.len() && j < right.len() {\n        if left[i] <= right[j] {\n            arr[k] = left[i];\n            i += 1;\n        } else {\n            arr[k] = right[j];\n            j += 1;\n        }\n        k += 1;\n    }\n\n    while i < left.len() {\n        arr[k] = left[i];\n        i += 1;\n        k += 1;\n    }\n\n    while j < right.len() {\n        arr[k] = right[j];\n        j += 1;\n        k += 1;\n    }\n}\n",f="function mergeSort(arr: number[]): number[] {\n  if (arr.length <= 1) {\n    return arr;\n  }\n\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n\n  return merge(left, right);\n}\n\nfunction merge(left: number[], right: number[]): number[] {\n  let result: number[] = [];\n  let leftIndex = 0;\n  let rightIndex = 0;\n\n  while (leftIndex < left.length && rightIndex < right.length) {\n    if (left[leftIndex] < right[rightIndex]) {\n      result.push(left[leftIndex]);\n      leftIndex++;\n    } else {\n      result.push(right[rightIndex]);\n      rightIndex++;\n    }\n  }\n\n  return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n}\n",p={title:"Merge Sort",description:"Merge Sort",hide_table_of_contents:!0},x=void 0,y={},j=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function b(e){const r={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.h2,{id:"definition",children:"Definition"}),"\n",(0,i.jsxs)(a.A,{queryString:"primary",children:[(0,i.jsx)(s.A,{value:"definition",label:"Definition",children:(0,i.jsx)(r.p,{children:"Merge Sort is a popular comparison-based sorting algorithm that follows the divide-and-conquer paradigm. It recursively divides the input array into smaller sub-arrays until each sub-array contains only one element, then merges those sub-arrays in a sorted manner"})}),(0,i.jsx)(s.A,{value:"how",label:"Explanation",children:(0,i.jsx)(r.p,{children:"Merge Sort operates by dividing the array into halves until each subset contains only one element. Then, it merges adjacent pairs of these subsets, comparing elements and arranging them in the correct order. This process continues recursively until the entire array is sorted. The key operation is the merging step, where two sorted arrays are combined into a single sorted array. It repeatedly compares the elements from the two arrays, selecting the smaller (or larger) element and appending it to the result array until one of the arrays is exhausted. The remaining elements from the non-empty array are then appended to the result"})}),(0,i.jsx)(s.A,{value:"guidance",label:"Guidance",children:(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Divide the array into two halves"}),"\n",(0,i.jsx)(r.li,{children:"Recursively apply Merge Sort on each half until each sub-array contains only one element"}),"\n",(0,i.jsxs)(r.li,{children:["Merge the sorted sub-arrays by comparing elements from each and arranging them in ascending order","\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"repeat until all sub-arrays are merged into a single sorted array"}),"\n"]}),"\n"]}),"\n"]})}),(0,i.jsx)(s.A,{value:"tips",label:"Tips",children:(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"ensure proper handling of edge cases, such as empty arrays or arrays with only one element"}),"\n",(0,i.jsx)(r.li,{children:"use an auxiliary array during the merging step to store the sorted elements temporarily"}),"\n",(0,i.jsx)(r.li,{children:"consider implementing an optimized version of Merge Sort that avoids unnecessary memory allocations or copying of arrays"}),"\n"]})})]}),"\n",(0,i.jsx)(r.h2,{id:"practice",children:"Practice"}),"\n",(0,i.jsxs)(a.A,{queryString:"primary",children:[(0,i.jsx)(s.A,{value:"practice",label:"Practice",children:(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"mergeSort(array)\n  if length of array <= 1\n    return array\n  else\n    mid = length of array / 2\n    leftArray = mergeSort(first half of array)\n    rightArray = mergeSort(second half of array)\n    return merge(leftArray, rightArray)\n\nmerge(leftArray, rightArray)\n  result = []\n  while leftArray is not empty and rightArray is not empty\n    if first element of leftArray <= first element of rightArray\n      append first element of leftArray to result\n      remove first element from leftArray\n    else\n      append first element of rightArray to result\n      remove first element from rightArray\n  append remaining elements of leftArray to result\n  append remaining elements of rightArray to result\n  return result\n"})})}),(0,i.jsx)(s.A,{value:"solution",label:"Solution",children:(0,i.jsxs)(a.A,{queryString:"code",children:[(0,i.jsx)(s.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,i.jsx)(o.A,{language:"go",children:g})}),(0,i.jsx)(s.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,i.jsx)(o.A,{language:"java",children:h})}),(0,i.jsx)(s.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,i.jsx)(o.A,{language:"js",children:d})}),(0,i.jsx)(s.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,i.jsx)(o.A,{language:"kotlin",children:c})}),(0,i.jsx)(s.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,i.jsx)(o.A,{language:"python",children:u})}),(0,i.jsx)(s.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,i.jsx)(o.A,{language:"rust",children:m})}),(0,i.jsx)(s.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,i.jsx)(o.A,{language:"ts",children:f})})]})})]})]})}function A(e={}){const{wrapper:r}={...(0,l.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(b,{...e})}):b(e)}}}]);