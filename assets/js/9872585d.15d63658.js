"use strict";(self.webpackChunkclassic=self.webpackChunkclassic||[]).push([[6423],{92129:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>x,contentTitle:()=>f,default:()=>y,frontMatter:()=>j,metadata:()=>t,toc:()=>b});const t=JSON.parse('{"id":"education/computer-science/algorithms/algo/integer-partition","title":"Integer Partition","description":"Integer Partition","source":"@site/docs/education/01-computer-science/10-algorithms/04-algo/integer-partition.mdx","sourceDirName":"education/01-computer-science/10-algorithms/04-algo","slug":"/education/computer-science/algorithms/algo/integer-partition","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/integer-partition","draft":false,"unlisted":false,"editUrl":"https://github.com/EliFuzz/tech-labs/docs/education/01-computer-science/10-algorithms/04-algo/integer-partition.mdx","tags":[],"version":"current","frontMatter":{"title":"Integer Partition","description":"Integer Partition","hide_table_of_contents":true},"sidebar":"education","previous":{"title":"Insertion Sort","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/insertion-sort"},"next":{"title":"Interpolation Search","permalink":"/tech-labs/docs/education/computer-science/algorithms/algo/interpolation-search"}}');var r=i(23420),a=i(38906),o=i(31519),l=i(20007),s=i(20636);const c="package main\n\nfunc countPartitions(n int) int {\n    dp := make([]int, n+1)\n    dp[0] = 1\n    for i := 1; i <= n; i++ {\n        for j := i; j <= n; j++ {\n            dp[j] += dp[j-i]\n        }\n    }\n    return dp[n]\n}\n",d="public class IntegerPartition {\n\n  public static int countPartitions(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      for (int j = i; j <= n; j++) {\n        dp[j] += dp[j - i];\n      }\n    }\n    return dp[n];\n  }\n}\n",u="function countPartitions(n) {\n  let dp = new Array(n + 1).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i <= n; i++) {\n    for (let j = i; j <= n; j++) {\n      dp[j] += dp[j - i];\n    }\n  }\n  return dp[n];\n}\n",p="fun countPartitions(n: Int): Int {\n    val dp = IntArray(n + 1)\n    dp[0] = 1\n    for (i in 1..n) {\n        for (j in i..n) {\n            dp[j] += dp[j - i]\n        }\n    }\n    return dp[n]\n}\n",h="def count_partitions(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            dp[j] += dp[j - i]\n    return dp[n]\n",g="fn count_partitions(n: usize) -> usize {\n    let mut dp = vec![0; n + 1];\n    dp[0] = 1;\n    for i in 1..=n {\n        for j in i..=n {\n            dp[j] += dp[j - i];\n        }\n    }\n    dp[n]\n}\n",m="function countPartitions(n: number): number {\n  const dp: number[] = new Array(n + 1).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i <= n; i++) {\n    for (let j = i; j <= n; j++) {\n      dp[j] += dp[j - i];\n    }\n  }\n  return dp[n];\n}\n",j={title:"Integer Partition",description:"Integer Partition",hide_table_of_contents:!0},f=void 0,x={},b=[{value:"Definition",id:"definition",level:2},{value:"Practice",id:"practice",level:2}];function v(n){const e={code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(o.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"definition",label:"Definition",children:(0,r.jsx)(e.p,{children:"The Integer Partition Algorithm aims to find all possible ways to partition a given integer into a sum of positive integers. It's a fundamental problem in combinatorics and dynamic programming, often used in various fields like number theory and computer science"})}),(0,r.jsx)(l.A,{value:"how",label:"Explanation",children:(0,r.jsxs)(e.p,{children:["Select the target integer that you wish to partition. Next, set up a two-dimensional array designated for storing partition counts. Iterate through each integer starting from 1 up to the chosen target integer. For each integer ",(0,r.jsx)(e.code,{children:"i"}),", systematically go through all potential partition sizes ",(0,r.jsx)(e.code,{children:"j"}),". Employ dynamic programming principles to continually update the counts of partitions. Upon completion, return the count of partitions available for the target integer, thus completing the integer partitioning algorithm"]})}),(0,r.jsx)(l.A,{value:"guidance",label:"Guidance",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Start with the target integer, let's call it n"}),"\n",(0,r.jsx)(e.li,{children:'Create a grid called "partitions" with (n+1) rows and (n+1) columns, and fill it with zeros'}),"\n",(0,r.jsxs)(e.li,{children:["For each row in the grid (from 0 to n)","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"set the value at column 1 to 1"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["Now, for each row (from 1 to n) and each column (from 1 to n)","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"If the column index is greater than the row index, copy the value from the diagonal (same row, same column)"}),"\n",(0,r.jsx)(e.li,{children:"Otherwise, add the value from the previous column to the value from the row-index difference column"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.li,{children:"The result is the intersection of the nth row and nth column in the grid"}),"\n"]})}),(0,r.jsx)(l.A,{value:"tips",label:"Tips",children:(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"utilize dynamic programming to avoid redundant calculations"}),"\n",(0,r.jsx)(e.li,{children:"take advantage of memoization to store intermediate results"}),"\n",(0,r.jsx)(e.li,{children:"ensure proper bounds checking to avoid index out of range errors"}),"\n"]})})]}),"\n",(0,r.jsx)(e.h2,{id:"practice",children:"Practice"}),"\n",(0,r.jsxs)(o.A,{queryString:"primary",children:[(0,r.jsx)(l.A,{value:"practice",label:"Practice",children:(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"integerPartition(n):\n  partitions = 2D array of size (n+1) x (n+1) filled with 0s\n  for i from 0 to n:\n    partitions[i][1] = 1\n  for i from 1 to n:\n    for j from 1 to n:\n      if j > i:\n        partitions[i][j] = partitions[i][i]\n      else:\n        partitions[i][j] = partitions[i][j-1] + partitions[i-j][j]\n  return partitions[n][n]\n"})})}),(0,r.jsx)(l.A,{value:"solution",label:"Solution",children:(0,r.jsxs)(o.A,{queryString:"code",children:[(0,r.jsx)(l.A,{value:"go",label:"",attributes:{title:"Go Lang",className:"code_lang go m"},children:(0,r.jsx)(s.A,{language:"go",children:c})}),(0,r.jsx)(l.A,{value:"java",label:"",attributes:{title:"Java",className:"code_lang java m"},children:(0,r.jsx)(s.A,{language:"java",children:d})}),(0,r.jsx)(l.A,{value:"js",label:"",attributes:{title:"JavaScript",className:"code_lang js m"},children:(0,r.jsx)(s.A,{language:"js",children:u})}),(0,r.jsx)(l.A,{value:"kotlin",label:"",attributes:{title:"Kotlin",className:"code_lang kotlin m"},children:(0,r.jsx)(s.A,{language:"kotlin",children:p})}),(0,r.jsx)(l.A,{value:"python",label:"",attributes:{title:"Python",className:"code_lang python m"},children:(0,r.jsx)(s.A,{language:"python",children:h})}),(0,r.jsx)(l.A,{value:"rust",label:"",attributes:{title:"Rust",className:"code_lang rust m"},children:(0,r.jsx)(s.A,{language:"rust",children:g})}),(0,r.jsx)(l.A,{value:"ts",label:"",attributes:{title:"TypeScript",className:"code_lang ts m"},children:(0,r.jsx)(s.A,{language:"ts",children:m})})]})})]})]})}function y(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(v,{...n})}):v(n)}}}]);