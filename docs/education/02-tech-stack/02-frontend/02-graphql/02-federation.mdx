---
title: Federation
description: GraphQL Federation
hide_table_of_contents: true
---

import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";

<Tabs queryString="primary">
    <TabItem
    value="query-execution"
    label="Query Execution"
    >
    **Query Planning**

    Router analyzes incoming queries and creates an execution plan:

    1. **Parse Query**: break down the query into field selections
    2. **Identify Entities**: determine which entities need to be resolved
    3. **Plan Execution**: create optimal execution order
    4. **Execute Subqueries**: send requests to appropriate subgraphs
    5. **Compose Response**: merge responses into final result

    **Query Execution**

    Based on the query execution plan generated by the router, the query could be executed sequentially or in parallel across multiple subgraphs. The router orchestrates the execution, ensuring that dependencies are resolved correctly.

    ```mermaid
    sequenceDiagram
        participant Client
        participant Router
        participant User Preferences
        participant User Activity
        participant User Notifications

        Client->>Router: GraphQL query
        Router->>Router: parse & plan query

        Router->>User Preferences: fetch user preferences
        User Preferences->>Router: return user preferences

        par User Activity
            Router->>User Activity: fetch user activity
        and User Notifications
            Router->>User Notifications: fetch user notifications
        end

        User Activity->>Router: return user activity
        User Notifications->>Router: return user notifications

        Router->>Router: compose final response
        Router->>Client: complete response
    ```
    </TabItem>
    <TabItem value="schema-composition" label="Schema Composition">
    ```mermaid
    graph BT
        Sales(Sales) --> Composer(Schema Composer)
        Inventory(Inventory) --> Composer
        Shipping(Shipping) --> Composer
        Composer --> Schema(Supergraph Schema)
        Schema --> Router(Router Configuration)
    ```

    <table className="text_vertical">
    <thead>
        <tr>
        <th>Aspect</th>
        <th>Rule</th>
        <th>Details</th>
        <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
        <td><b>Type Merging</b></td>
        <td>
            Types (`objects`, `interfaces`, `enums`, `scalars`, `unions`,
            `inputs`) with the
            <a
            href="https://www.apollographql.com/docs/graphos/schema-design/federated-schemas/reference/composition-rules#merging-types-from-multiple-subgraphs"
            >same name across different subgraphs are merged into a single,
            unified type in the Supergraph schema</a>.
        </td>
        <td>
            <ul>
            <li>
                <b>Fields</b>: fields within merged object types are additive.
                If multiple subgraphs define the same type, all unique fields
                from those types are combined.
            </li>
            <li>
                <b>Conflict Resolution</b>: if 2 subgraphs define fields with
                the same name on a merged type but with different types, this
                results in a composition error. The field type must be
                consistent across all subgraphs that define it.
            </li>
            <li>
                <b>Directives</b>: directives applied to merged types or their
                fields are also merged. Conflicts arise if the same directive is
                applied with conflicting arguments.
            </li>
            </ul>
        </td>
        <td>
            ```graphql
            # if Subgraph A defines
            type Product {
                id: ID!
                name: String!
            }

            # and Subgraph B defines
            type Product {
                id: ID!
                price: Float!
            }

            # the merged Supergraph type will be
            type Product {
                id: ID!
                name: String!
                price: Float!
            }
            ```
        </td>
        </tr>
        <tr>
        <td><b>Field Uniqueness and Ownership</b></td>
        <td>
            <a
            href="https://www.apollographql.com/docs/graphos/schema-design/federated-schemas/entities/resolve-another-subgraphs-fields"
            >Each field on an object type must be "owned" by exactly one
            subgraph</a>, unless it's a `@shareable` field.
        </td>
        <td>
            <ul>
            <li>
                <b>Single Source of Truth</b>: this rule ensures a single source
                of truth for a field's resolution logic. If multiple subgraphs
                define the same field on a type, only one subgraph is designated
                as the "owner" responsible for resolving that field.
            </li>
            <li>
                <b>`@shareable` Directive</b>: fields marked with the
                `@shareable` directive can be defined and owned by multiple
                subgraphs. This is typically used for fields that are stable and
                can be resolved identically by different services (e.g., ID
                fields, static data).
            </li>
            <li>
                <b>Composition Errors</b>: if a non-shareable field is defined
                in multiple subgraphs without explicit ownership delegation
                (e.g., through `@external` and `@provides` or `@requires`), it
                will lead to a composition error.
            </li>
            </ul>
        </td>
        <td>
            ```graphql
            type Product @key(fields: "id") {
                id: ID!
                # provided by one subgraph
                name: String! @external
                # provided by another subgraph
                # using `@external` on the consuming subgraph
                price: Float!
            }
            ```
        </td>
        </tr>
        <tr>
        <td><b>Entity Extensions</b></td>
        <td>
            Entities (types marked with `@key`) can be extended across multiple
            subgraphs. This allows different services to contribute fields to
            the same entity.
        </td>
        <td>
            <ul>
            <li>
                <b>`@key` Directive</b>: defines the primary key(s) for an
                entity, allowing the Supergraph to uniquely identify instances
                of that type.
            </li>
            <li>
                <b>`@extends` Directive</b>: used in a subgraph to indicate that
                a type is an extension of an entity defined in another subgraph.
                The subgraph adding the extension does not "own" the base
                entity, but rather contributes additional fields to it.
            </li>
            <li>
                <b>`@external` Directive</b>: marks a field as being defined in
                another subgraph. This is used in conjunction with `@extends` to
                declare fields that are part of the entity's key or are required
                from another subgraph to resolve local fields.
            </li>
            <li>
                <b>`@requires` Directive</b>: specifies that a field's
                resolution depends on the values of other external fields from
                the same entity.
            </li>
            <li>
                <b>`@provides` Directive</b>: used to declare that a subgraph
                can resolve a field from a federated entity even if it's not the
                primary owner, typically for optimizing query plans.
            </li>
            </ul>
        </td>
        <td>
            ```graphql
            # Subgraph A defines User
            type User @key(fields: "id") {
                id: ID!
                name: String!
            }

            # Subgraph B extends User
            extend type User @key(fields: "id") {
                id: ID! @external
                reviews: [Review!]! @requires(fields: "id")
            }
            ```
        </td>
        </tr>
        <tr>
        <td><b>Directive Validation</b></td>
        <td>
            Federation-specific directives (`@key`, `@extends`, `@external`,
            `@requires`, `@provides`, `@shareable`, `@inaccessible`, `@tag`,
            `@override`, etc.) are rigorously validated during composition to
            ensure correct usage and prevent inconsistencies.
        </td>
        <td>
            <ul>
            <li>
                <b>Placement</b>: directives must be applied to the correct
                schema locations (e.g., `@key` on object types, `@external` on
                fields).
            </li>
            <li>
                <b>Arguments</b>: directive arguments must be valid and adhere
                to their definitions (e.g., `fields` argument of `@key` must
                refer to existing fields).
            </li>
            <li>
                <b>Semantic Checks</b>: the composer performs semantic checks,
                such as ensuring that `@requires` fields are also marked
                `@external` and that key fields are always available for
                resolution.
            </li>
            <li>
                <b>Composition Errors</b>: invalid directive usage or conflicts
                in directive application will result in composition errors,
                preventing the Supergraph schema from being built.
            </li>
            </ul>
        </td>
        <td></td>
        </tr>
        <tr>
        <td>
        <b>Root Operation Type Merging (Query, Mutation, Subscription)</b>
        </td>
        <td>
            Root operation types (`Query`, `Mutation`, `Subscription`) are
            special: they are always merged, and their fields are additive
            across all subgraphs.
        </td>
        <td>
            <ul>
            <li>
                <b>Additive Fields</b>: if multiple subgraphs define fields on
                `Query`, `Mutation`, or `Subscription`, all unique fields are
                combined into a single root type in the Supergraph.
            </li>
            <li>
                <b>No Ownership Conflict</b>: unlike regular object fields,
                fields on root operation types do not have ownership conflicts,
                as each subgraph provides its own set of root fields.
            </li>
            </ul>
        </td>
        <td>
            ```graphql
            # Subgraph A has
            type Query {
                users: [User!]!
            }

            # Subgraph B has
            type Query {
                products: [Product!]!
            }

            # Supergraph Query will have both
            type Query {
                users: [User!]!
                products: [Product!]!
            }
            ```
        </td>
        </tr>
        <tr>
        <td><b>Interface and Union Type Compatibility</b></td>
        <td>
            When an interface or union type is merged or extended, all
            implementing types or member types must be resolvable and consistent
            across subgraphs.
        </td>
        <td>
            <ul>
            <li>
                <b>Implementations</b>: if an interface is implemented by a type
                that is also part of the Supergraph, that type must adhere to
                the interface contract.
            </li>
            <li>
                <b>Union Members</b>: all member types of a union must be
                resolvable entity types within the Supergraph.
            </li>
            <li>
                <b>Composition Errors</b>: inconsistencies in type
                implementations or unresolved union members will lead to
                composition errors.
            </li>
            </ul>
        </td>
        <td></td>
        </tr>
        <tr>
        <td><b>Enum and Scalar Type Consistency</b></td>
        <td>
            Enum and scalar types with the same name must have identical
            definitions (values for enums, and underlying
            serialization/deserialization logic for scalars) across all
            subgraphs.
        </td>
        <td>
            <ul>
            <li>
                <b>Exact Match</b>: for enums, the set of values must be an
                exact match. Any discrepancy in values or their order will cause
                a composition error.
            </li>
            <li>
                <b>Standard Scalars</b>: standard GraphQL scalars (ID, String,
                Int, Float, Boolean) are implicitly consistent.
            </li>
            <li>
                <b>Custom Scalars</b>: custom scalars require careful
                coordination to ensure their serialization and deserialization
                logic is consistent across all subgraphs that define or use
                them.
            </li>
            </ul>
        </td>
        <td>

        ```graphql
        # Subgraph A defines
        enum Status {
            ACTIVE
            INACTIVE
        }

        # Subgraph B defines
        enum Status {
            ACTIVE
            PENDING
        }

        # this will cause a composition error
        # due to inconsistent enum values
        ```
        </td>
        </tr>
        <tr>
        <td><b>Schema Directives and Metadata</b></td>
        <td>
            Directives defined at the schema level and other schema-level
            metadata (like `@link`) are also composed, with rules for merging
            and conflict resolution.
        </td>
        <td>
            <ul>
            <li>
                <b>`@link` Directive</b>: used to declare the usage of external
                schema specifications (like `@federation` from
                `https://specs.apollo.dev/federation/v2.0`). Conflicts can arise
                if linked specifications clash.
            </li>
            <li>
                <b>Additive Behavior</b>: generally, schema-level directives and
                extensions (e.g., `extend schema`) are additive, but conflicts
                in arguments or contradictory definitions can lead to
                composition errors.
            </li>
            </ul>
        </td>
        <td></td>
        </tr>
    </tbody>
    </table>
    </TabItem>
    <TabItem value="query-optimization" label="Query Optimization">
    - **Query Planning**: optimize execution order
    - **Parallel Execution**: execute independent subqueries in parallel
    - **Query Deduplication**: cache and reuse identical queries
    - **Field Selection**: only fetch requested fields
    - **Minimize Operations Spanning Multiple Subgraphs**: design schemas to keep most queries within single subgraphs when possible, as cross-subgraph operations add query plan complexity and increase latency
    - **Overusing of @shareable and Shared Types**: the `@shareable` directive enables multiple subgraphs to resolve the same entities or fields, offering query planner flexibility. However, overusing `@shareable` can exponentially increase potential query paths, which degrades performance. Use it primarily where consistency between subgraphs is guaranteed and necessary
    - **Schema Evolution and Compatibility**: changes to fields and directives like `@requires` can impact current query plans and introduce latency. Manage schema migrations carefully, deploying them atomically to avoid disruptions or performance regressions
    - **Query Caching**: use caching mechanisms to store query for frequently static executed queries [APQ (Automatic Persisted Queries)](https://www.apollographql.com/docs/apollo-server/performance/apq)
    - **Query Complexity Analysis**: analyze query complexity to prevent overly complex queries that can degrade performance. Implement limits on query depth and breadth
    - **Database Indexes**: ensure that database queries are optimized with appropriate indexes to speed up data retrieval

    **Subgraph Caching**

    <table>
        <thead>
            <tr>
                <th>Aspect</th>
                <th>DataLoader</th>
                <th>Redis</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Scope</td>
                <td>Per-request, in-memory</td>
                <td>Cross-request, distributed</td>
            </tr>
            <tr>
                <td>Pros</td>
                <td>
                    <ul>
                        <li><b>N+1 Query Problem</b>: use DataLoader within resolvers when your subgraph needs to fetch related data that causes multiple roundtrips to backend services or databases due to GraphQL's nested query patterns</li>
                        <li><b>Optimizing Per-Request Data Fetching</b>: to cache and reuse fetched entities within a single request context</li>
                        <li><b>Field-Level Data Fetching Efficiency</b>: use when different fields in your schema (resolved separately) require data from the same resource (e.g., batched loading of products, categories, or user profiles), ensuring single batched reads</li>
                    </ul>
                </td>
                <td>
                    <ul>
                        <li><b>Cross-Service (Distributed) Caching</b>: cache entities or frequently-requested subgraph query results across all instances and requests in clustered or horizontally scaled environments</li>
                        <li><b>Pub/Sub for Subscriptions and Realtime Updates</b>: when your subgraph needs to support real-time updates (GraphQL subscriptions) at scale, distributing events among multiple subgraph or server instances so that all clients receive relevant updates, regardless of the processing node</li>
                        <li><b>Message Brokering Across Microservices</b>: leverage for message passing or notification delivery between distinct microservices or subgraph instances, ensuring that each microservice can communicate asynchronously and efficiently, especially in event-driven architectures</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>Use Case</td>
                <td>Batching and caching per-request data-fetch operations</td>
                <td>Cross-service caching, Pub/Sub for subscriptions, message brokering</td>
            </tr>
        </tbody>
    </table>
    </TabItem>
    <TabItem value="common-types" label="Common Types">
    <table>
        <thead>
            <tr>
                <th>Field</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>scalar ID</code></td>
                <td><a href="https://www.apollographql.com/docs/apollo-server/schema/custom-scalars">Scalar type</a> used to represent a unique identifier for a resource</td>
            </tr>
            <tr>
                <td><code>enum CountryCode</code></td>
                <td>2 letter <a href="https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes">ISO 3166</a> code representing a country</td>
            </tr>
            <tr>
                <td><code>enum LanguageCode</code></td>
                <td>2 letter <a href="https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes">ISO 639</a> code representing a language</td>
            </tr>
            <tr>
                <td><code>input PageInput</code></td>
                <td><a href="https://relay.dev/graphql/connections.htm#sec-Arguments">Input type</a> for <a href="https://graphql.org/learn/pagination/">pagination</a> parameters</td>
            </tr>
            <tr>
                <td><code>type PageInfo</code></td>
                <td>Contains information about <a href="https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo">pagination</a>, such as total count and whether there are more pages available</td>
            </tr>
        </tbody>
    </table>
    </TabItem>
    <TabItem value="entity-relationships" label="Entity Relationships">
    <table className="text_vertical">
        <thead>
            <tr>
                <th>Aspect</th>
                <th>Definition</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><b>Entity Definition and Keys</b></td>
                <td>Entities are the core building blocks of federation. They represent business objects that can span multiple subgraphs</td>
                <td>
                    ```graphql
                    # Primary entity definition (Users subgraph)
                    type User @key(fields: "id") {
                        id: ID!
                        username: String!
                        email: String!
                        createdAt: String!
                    }

                    # Entity with multiple keys (Products subgraph)
                    type Product @key(fields: "id") @key(fields: "sku") {
                        id: ID!
                        sku: String!
                        name: String!
                        price: Float!
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Entity Extensions</b></td>
                <td>Other subgraphs can extend entities to add domain-specific fields</td>
                <td>
                    ```graphql
                    # Orders subgraph extends User
                    extend type User @key(fields: "id") {
                        id: ID! @external
                        orders: [Order!]!
                        totalSpent: Float!
                        loyaltyLevel: LoyaltyLevel!
                    }

                    # Reviews subgraph extends Product
                    extend type Product @key(fields: "id") {
                        id: ID! @external
                        reviews: [Review!]!
                        averageRating: Float!
                        reviewCount: Int!
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Single Subgraph One-to-One</b></td>
                <td>Within a single subgraph, one entity can directly reference another entity</td>
                <td>
                    ```graphql
                    # User Profile (1:1 relationship)
                    type User @key(fields: "id") {
                        id: ID!
                        username: String!
                        profile: UserProfile
                    }

                    type UserProfile {
                        id: ID!
                        user: User!
                        firstName: String
                        lastName: String
                        avatar: String
                        bio: String
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Cross-Subgraph One-to-One</b></td>
                <td>One entity in one subgraph can reference an entity in another subgraph using the `@external` directive</td>
                <td>
                    ```graphql
                    # User subgraph
                    type User @key(fields: "id") {
                        id: ID!
                        username: String!
                        email: String!
                    }

                    # Profile subgraph extends User
                    extend type User @key(fields: "id") {
                        id: ID! @external
                        profile: UserProfile!
                    }

                    type UserProfile {
                        id: ID!
                        firstName: String
                        lastName: String
                        avatar: String
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Single Subgraph One-to-Many</b></td>
                <td>Within a single subgraph, one entity can have multiple related entities</td>
                <td>
                    ```graphql
                    # User has many posts
                    type User @key(fields: "id") {
                        id: ID!
                        username: String!
                        posts: [Post!]!
                    }

                    type Post @key(fields: "id") {
                        id: ID!
                        title: String!
                        content: String!
                        author: User!
                        createdAt: String!
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Paginated One-to-Many</b></td>
                <td>When one entity has many related entities, pagination is often used to efficiently fetch large sets of data</td>
                <td>
                    ```graphql
                    # User has many orders (paginated)
                    extend type User @key(fields: "id") {
                        id: ID! @external
                        orders(
                            first: Int
                            after: String
                            status: OrderStatus
                            dateRange: DateRangeInput
                        ): OrderConnection!
                    }

                    type OrderConnection {
                        edges: [OrderEdge!]!
                        pageInfo: PageInfo!
                        totalCount: Int!
                    }

                    type OrderEdge {
                        node: Order!
                        cursor: String!
                    }

                    type Order @key(fields: "id") {
                        id: ID!
                        user: User!
                        status: OrderStatus!
                        total: Money!
                        createdAt: String!
                    }

                    input DateRangeInput {
                        from: String!
                        to: String!
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Single Subgraph Many-to-Many</b></td>
                <td>Within a single subgraph, one entity can be related to multiple instances of another entity</td>
                <td>
                    ```graphql
                    # Products and Categories
                    type Product @key(fields: "id") {
                        id: ID!
                        name: String!
                        categories: [Category!]!
                    }

                    type Category @key(fields: "id") {
                        id: ID!
                        name: String!
                        products: [Product!]!
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Many-to-Many with Junction Table</b></td>
                <td> In many-to-many relationships, a junction table is often used to represent the relationship between 2` entities</td>
                <td>
                    ```graphql
                    # Users and Roles with permissions
                    type User @key(fields: "id") {
                        id: ID!
                        username: String!
                        roleAssignments: [UserRoleAssignment!]!
                        roles: [Role!]!
                    }

                    type Role @key(fields: "id") {
                        id: ID!
                        name: String!
                        permissions: [Permission!]!
                        userAssignments: [UserRoleAssignment!]!
                    }

                    type UserRoleAssignment {
                        id: ID!
                        user: User!
                        role: Role!
                        assignedAt: String!
                        assignedBy: User!
                        expiresAt: String
                    }

                    type Permission {
                        id: ID!
                        name: String!
                        resource: String!
                        action: String!
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Cross-Subgraph Entity Extension Pattern</b></td>
                <td>Allows entities to be extended across subgraphs, enabling more flexible and modular architecture</td>
                <td>
                    ```graphql
                    # Users subgraph (primary definition)
                    type User @key(fields: "id") {
                        id: ID!
                        username: String!
                        email: String!
                    }

                    # Orders subgraph (extends User)
                    extend type User @key(fields: "id") {
                        id: ID! @external
                        orders: [Order!]!
                        totalOrderValue: Float!
                    }

                    # Reviews subgraph (extends User)
                    extend type User @key(fields: "id") {
                        id: ID! @external
                        reviews: [Review!]!
                        reviewCount: Int!
                        averageRating: Float!
                    }

                    # Wishlist subgraph (extends User)
                    extend type User @key(fields: "id") {
                        id: ID! @external
                        wishlist: Wishlist!
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Cross-Subgraph Reference Resolution</b></td>
                <td>Enables one subgraph to reference entities from another subgraph using a representation (primary key + typename). The `_resolveReference` resolver in each subgraph handles this, allowing distributed services to compose a unified API</td>
                <td>
                    **Entity Definition and Key in the Products Subgraph**

                    ```graphql
                    # products subgraph (schema)
                    type Product @key(fields: "upc") {
                        upc: String!
                        name: String
                        price: Int
                    }
                    ```

                    **Reference Resolver in the Products Subgraph**

                    ```typescript
                    Product: {
                        // this resolver is called when an entity of type Product
                        // is referenced by another subgraph
                        // given only an identifying key (like "upc")
                        __resolveReference(reference: ProductReference) {
                            // Find product by upc
                            return fetchProductByUPC(reference.upc);
                        }
                    }
                    ```

                    **Representing the Reference in the Reviews Subgraph**

                    ```typescript
                    // when the Reviews subgraph needs to provide a Product
                    // (for example, for a Review.product field)
                    // it must issue a representation
                    // this tells the gateway and the entity resolver
                    // that the referenced entity is a Product identified
                    // by its upc
                    Review: {
                        product(review: Review) {
                            return { __typename: "Product", upc: review.upc };
                        }
                    }
                    ```

                    **End-to-End Query**

                    ```graphql
                    # Router composes these subgraphs, allowing a client to run
                    query {
                        reviews {
                            product {
                                name
                                price
                            }
                        }
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Required Fields Pattern</b></td>
                <td>When an entity is extended across subgraphs, some fields may be required for resolution. The `@requires` directive specifies which fields must be available from the base entity to resolve the extended fields</td>
                <td>
                ```graphql
                # Analytics subgraph
                extend type User @key(fields: "id") {
                    id: ID! @external
                    username: String! @external
                    email: String! @external

                    # Field that requires external data
                    displayName: String! @requires(fields: "username")
                    emailDomain: String! @requires(fields: "email")
                    userMetrics: UserMetrics! @requires(fields: "username email")
                }

                type UserMetrics {
                    username: String!
                    totalLogins: Int!
                    lastLoginAt: String
                    emailDomain: String!
                }
                ```
                </td>
            </tr>
            <tr>
                <td><b>Interface-Based Polymorphism</b></td>
                <td>Interfaces allow different subgraphs to define types that share a common contract, enabling polymorphic relationships</td>
                <td>
                    ```graphql
                    # Content management system
                    interface Content {
                        id: ID!
                        title: String!
                        author: User!
                        createdAt: String!
                        updatedAt: String!
                    }

                    type Article implements Content @key(fields: "id") {
                        id: ID!
                        title: String!
                        author: User!
                        createdAt: String!
                        updatedAt: String!
                        # Article-specific fields
                        body: String!
                        summary: String!
                        tags: [Tag!]!
                    }

                    type Video implements Content @key(fields: "id") {
                        id: ID!
                        title: String!
                        author: User!
                        createdAt: String!
                        updatedAt: String!
                        # Video-specific fields
                        duration: Int!
                        videoUrl: String!
                        thumbnail: String!
                    }

                    # User can create different types of content
                    extend type User @key(fields: "id") {
                        id: ID! @external
                        content: [Content!]!
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Union-Based Polymorphism</b></td>
                <td>Unions allow a field to return different types, enabling flexible relationships where the type is not known until runtime</td>
                <td>
                    ```graphql
                    # Search results can be different types
                    union SearchResult = Product | Article | User | Category

                    type SearchResponse {
                        query: String!
                        total: Int!
                        results: [SearchResult!]!
                    }

                    type Query {
                        search(query: String!, types: [SearchType!]): SearchResponse!
                    }

                    enum SearchType {
                        PRODUCT
                        ARTICLE
                        USER
                        CATEGORY
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Conditional Access Control</b></td>
                <td>Allows for fine-grained authorization based on user roles and permissions</td>
                <td>
                    ```graphql
                    directive @hasRole(role: String!) on FIELD_DEFINITION

                    type Query {
                        me: User! @hasRole(role: "USER")
                        adminPanel: Admin! @hasRole(role: "ADMIN")
                    }
                    ```
                </td>
            </tr>
            <tr>
                <td><b>Dynamic Relationships</b></td>
                <td>Relationships that depend on the current user context or other runtime conditions</td>
                <td>
                ```graphql
                # Recommendations based on user behavior
                extend type Product @key(fields: "id") {
                    id: ID! @external
                    # Dynamic relationship based on current user
                    recommendedProducts: [Product!]!
                    userRecommendationScore: Float
                }
                ```
                </td>
            </tr>
        </tbody>
    </table>
    </TabItem>
    <TabItem value="best-practices" label="Best Practices">
        <table className="text_vertical">
            <thead>
                <tr>
                    <th>Aspect</th>
                    <th>Definition</th>
                    <th>Example</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><b>Entity Keys</b></td>
                    <td>Always use stable, immutable identifiers as entity keys</td>
                    <td>
                    ```graphql
                    # ✅ Good: Use stable IDs
                    type User @key(fields: "id") {
                        id: ID!
                        username: String!
                    }

                    # ❌ Bad: Avoid mutable fields as keys
                    type User @key(fields: "email") {
                        email: String!
                        username: String!
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Multiple Keys</b></td>
                    <td>Provide multiple key options for flexibility</td>
                    <td>
                    ```graphql
                    # ✅ Good: Multiple keys for different use cases
                    type Product @key(fields: "id") @key(fields: "sku") {
                        id: ID!
                        sku: String!
                        name: String!
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Design Minimal Entity Representations</b></td>
                    <td>Keep entity key fields minimal and avoid large objects</td>
                    <td>
                    ```graphql
                    # ✅ Good: Minimal key
                    type User @key(fields: "id") {
                        id: ID!
                        # other fields...
                    }

                    # ❌ Bad: Complex key
                    type User @key(fields: "id profile { firstName lastName }") {
                        id: ID!
                        profile: UserProfile!
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Field's single Source of Truth</b></td>
                    <td>Each field should have a clear owner</td>
                    <td>
                    ```graphql
                    # Users subgraph owns identity
                    type User @key(fields: "id") {
                        id: ID!
                        username: String!
                        email: String!
                    }

                    # Profile subgraph owns profile data
                    extend type User @key(fields: "id") {
                        id: ID! @external
                        profile: UserProfile!
                        preferences: UserPreferences!
                    }

                    # Orders subgraph owns order data
                    extend type User @key(fields: "id") {
                        id: ID! @external
                        orders: [Order!]!
                        totalSpent: Float!
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Use `@shareable` Judiciously</b></td>
                    <td>Only mark fields as `@shareable` when they truly can be computed by multiple subgraphs</td>
                    <td>
                    ```graphql
                    # ✅ Good: Computed field that both subgraphs can derive
                    type Product @key(fields: "id") {
                        id: ID!
                        name: String! @shareable
                        price: Float!
                    }

                    # ❌ Bad: Database field shared between subgraphs
                    type User @key(fields: "id") {
                        id: ID!
                        email: String! @shareable # This creates data consistency issues
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Schema Evolution: Use Deprecation Before Removal</b></td>
                    <td>Always deprecate fields before removing them</td>
                    <td>
                    ```graphql
                    type User @key(fields: "id") {
                        id: ID!
                        name: String! @deprecated(reason: "Use firstName and lastName instead")
                        firstName: String!
                        lastName: String!
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Additive Changes Only</b></td>
                    <td>Make only additive changes to maintain compatibility</td>
                    <td>
                    ```graphql
                    # ✅ Good: Adding new fields
                    type User @key(fields: "id") {
                        id: ID!
                        username: String!
                        email: String!
                        createdAt: String! # New field added
                        lastLoginAt: String # New optional field
                    }

                    # ❌ Bad: Removing or changing existing fields
                    type User @key(fields: "id") {
                        id: ID!
                        # username: String!    # Don't remove fields
                        email: Int! # Don't change field types
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Use Relay-Style Connections</b></td>
                    <td>Implement consistent pagination</td>
                    <td>
                    ```graphql
                    type User @key(fields: "id") {
                        id: ID!
                        orders(input: PageInput): OrderConnection!
                    }

                    input PageInput {
                        first: Int = 10
                        after: String
                        last: Int
                        before: String
                    }

                    type OrderConnection {
                        edges: [OrderEdge!]!
                        pageInfo: PageInfo!
                        totalCount: Int!
                    }

                    type OrderEdge {
                        node: Order!
                        cursor: String!
                    }

                    type PageInfo {
                        hasNextPage: Boolean!
                        hasPreviousPage: Boolean!
                        startCursor: String
                        endCursor: String
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Domain-Driven Design Schema</b></td>
                    <td>Design your subgraph schemas around business domains, not technical boundaries</td>
                    <td>
                    ```graphql
                    # ✅ Good: User domain focuses on identity and profile
                    # Users subgraph
                    type User @key(fields: "id") {
                        id: ID!
                        username: String!
                        email: String!
                        profile: UserProfile!
                        preferences: UserPreferences!
                    }

                    type UserProfile {
                        firstName: String
                        lastName: String
                        avatar: String
                    }

                    type UserPreferences {
                        language: String!
                        timezone: String!
                        notifications: NotificationSettings!
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Single Responsibility Principle</b></td>
                    <td>Each subgraph should own a specific set of related types and fields</td>
                    <td>
                    ```graphql
                    # ✅ Good: Clear ownership boundaries
                    # Inventory subgraph owns stock-related data
                    extend type Product @key(fields: "id") {
                        id: ID! @external
                        inventory: ProductInventory!
                        availability: AvailabilityStatus!
                        stockLevel: Int!
                    }

                    type ProductInventory {
                        warehouse: String!
                        quantity: Int!
                        reserved: Int!
                        available: Int!
                    }

                    enum AvailabilityStatus {
                        IN_STOCK
                        LOW_STOCK
                        OUT_OF_STOCK
                        DISCONTINUED
                    }
                    ```
                    </td>
                </tr>
            </tbody>
        </table>
    </TabItem>
    <TabItem value="troubleshooting" label="Troubleshooting">
        **Schema Composition Issues**

        <table className="text_vertical">
            <thead>
                <tr>
                    <th>Category</th>
                    <th>Issue</th>
                    <th>Solution</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td rowSpan="4"><b>Schema Composition</b></td>
                    <td>Invalid Federation Directives</td>
                    <td>
                        ```graphql
                        # ❌ Problem: Missing @key directive
                        type User {
                            id: ID!
                            username: String!
                        }

                        # ✅ Solution: Add @key directive
                        type User @key(fields: "id") {
                            id: ID!
                            username: String!
                        }
                        ```
                    </td>
                </tr>
                <tr>
                    <td>Inconsistent Entity Definitions</td>
                    <td>
                        ```graphql
                        # ❌ Problem: Different key fields across subgraphs
                        # Subgraph A
                        type User @key(fields: "id") {
                            id: ID!
                        }

                        # Subgraph B
                        extend type User @key(fields: "userId") {
                            userId: ID! @external
                        }

                        # ✅ Solution: Use consistent key fields
                        # Both subgraphs
                        type User @key(fields: "id") {
                            id: ID!
                        }
                        ```
                    </td>
                </tr>
                <tr>
                    <td><b>Missing `@external` Directive</b></td>
                    <td>
                        ```graphql
                        # ❌ Problem: Extended field not marked as external
                        extend type User @key(fields: "id") {
                            id: ID!  # Missing @external
                            orders: [Order!]!
                        }

                        # ✅ Solution: Mark external fields
                        extend type User @key(fields: "id") {
                            id: ID! @external
                            orders: [Order!]!
                        }
                        ```
                    </td>
                </tr>
                <tr>
                    <td>Conflicting Field Definitions</td>
                    <td>
                        ```graphql
                        # ❌ Problem: Same field defined differently
                        # Subgraph A
                        type Product @key(fields: "id") {
                            id: ID!
                            name: String!
                        }

                        # Subgraph B
                        type Product @key(fields: "id") {
                            id: ID!
                            name: String  # Different nullability
                        }

                        # ✅ Solution: Make fields consistent or use @shareable
                        type Product @key(fields: "id") {
                            id: ID!
                            name: String! @shareable
                        }
                        ```
                    </td>
                </tr>
                <tr>
                    <td rowSpan="3"><b>Reference Resolution</b></td>
                    <td>Missing Reference Resolver</td>
                    <td>
                        ```typescript
                        // ❌ Problem: No __resolveReference implementation
                        const resolvers = {
                            User: {
                                // Missing __resolveReference
                                orders: async (user) => { /* ... */ }
                            }
                        };

                        // ✅ Solution: Implement __resolveReference
                        const resolvers = {
                            User: {
                                __resolveReference: async (user: { id: string }) => {
                                    return await UserService.findById(user.id);
                                },
                                orders: async (user) => { /* ... */ }
                            }
                        };
                        ```
                    </td>
                </tr>
                <tr>
                    <td>Reference Resolver Returns Null</td>
                    <td>
                        ```typescript
                        // ❌ Problem: Returns null for valid reference
                        User: {
                            __resolveReference: async (user: { id: string }) => {
                                const userData = await UserService.findById(user.id);
                                return userData; // null if not found
                            }
                        }

                        // ✅ Solution: Handle missing entities appropriately
                        User: {
                            __resolveReference: async (user: { id: string }) => {
                                const userData = await UserService.findById(user.id);
                                if (!userData) {
                                    throw new Error(`User with id ${user.id} not found`);
                                }
                                return userData;
                            }
                        }
                        ```
                    </td>
                </tr>
                <tr>
                    <td>Incorrect Key Field Mapping</td>
                    <td>
                        ```typescript
                        // ❌ Problem: Wrong key field in reference
                        User: {
                            __resolveReference: async (user: { userId: string }) => {
                                // Entity key is 'id' but resolver expects 'userId'
                                return await UserService.findById(user.userId);
                            }
                        }

                        // ✅ Solution: Use correct key field
                        User: {
                            __resolveReference: async (user: { id: string }) => {
                                return await UserService.findById(user.id);
                            }
                        }
                        ```
                    </td>
                </tr>
            </tbody>
        </table>
    </TabItem>

</Tabs>
