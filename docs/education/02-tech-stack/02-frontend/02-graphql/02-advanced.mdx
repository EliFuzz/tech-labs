---
title: Advanced
description: Advanced GraphQL Topics
hide_table_of_contents: true
---

import TabItem from "@theme/TabItem";
import Tabs from "@theme/Tabs";

# Advanced

## Domain-Driven Design (DDD)

<Tabs queryString="primary">
    <TabItem value="core" label="Core Concepts">
        <Tabs queryString="primary">
            <TabItem value="core-fundamentals" label="Fundamentals" attributes={{className:"tabs__vertical"}}>
            <table class="text_vertical">
                <thead>
                <tr>
                    <th>DDD Concept</th>
                    <th>Definition</th>
                    <th>Characteristics</th>
                    <th>Considerations</th>
                    <th>Example</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td><b>Ubiquitous Language</b></td>
                    <td>A common language shared between domain experts and developers, reflected in code and schema</td>
                    <td>
                    <ul>
                        <li>Type names must use domain terminology, not technical terms</li>
                        <li>Field names should match business vocabulary exactly</li>
                        <li>Descriptions should use domain language</li>
                    </ul>
                    </td>
                    <td>
                    <ul>
                        <li>All type names use business terminology</li>
                        <li>Field names match domain expert vocabulary</li>
                        <li>Schema descriptions use ubiquitous language</li>
                        <li>No technical jargon in public schema</li>
                        <li>Consistent terminology across all types</li>
                    </ul>
                    </td>
                    <td>
                    ```graphql
                    # ✅ Good - Uses domain language
                    type Order {
                        orderNumber: String!
                        customer: Customer!
                        lineItems: [LineItem!]!
                        totalAmount: Money!
                        status: OrderStatus!
                    }

                    # ❌ Bad - Uses technical language
                    type OrderRecord {
                        id: ID!
                        customerId: ID!
                        items: [OrderItemRecord!]!
                        total: Float!
                        statusCode: Int!
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Bounded Contexts</b></td>
                    <td>Explicit boundaries within which a domain model is defined and applicable</td>
                    <td>
                    <ul>
                        <li>Each subgraph represents one bounded context</li>
                        <li>Types within a context have consistent meaning</li>
                        <li>Cross-context references use federation</li>
                    </ul>
                    </td>
                    <td>
                    <ul>
                        <li>Each subgraph maps to exactly one bounded context</li>
                        <li>No overlapping responsibilities between subgraphs</li>
                        <li>Clear ownership boundaries defined</li>
                        <li>Context boundaries align with team boundaries</li>
                        <li>Minimal coupling between contexts</li>
                    </ul>
                    </td>
                    <td>
                    Consider separate bounded contexts when applicable:
                    <ul>
                        <li>Does this concept have different meanings in different parts of the business?</li>
                        <li>Do different teams own different aspects of this concept?</li>
                        <li>Would changes to this concept affect different business capabilities?</li>
                    </ul>
                    </td>
                </tr>
                <tr>
                    <td><b>Entities</b></td>
                    <td>Objects with distinct identity that persists over time</td>
                    <td>
                    <ul>
                        <li>Always have an `id` field</li>
                        <li>Identity is stable across operations</li>
                        <li>Can be referenced from other contexts</li>
                        <li>Support federation `@key` directive</li>
                    </ul>
                    </td>
                    <td>
                    <ul>
                        <li>All entities have stable identity fields</li>
                        <li>Identity fields are immutable</li>
                        <li>Entities can be federated across subgraphs</li>
                        <li>Entity boundaries respect aggregate boundaries</li>
                        <li>Identity generation strategy is consistent</li>
                    </ul>
                    </td>
                    <td>
                    ```graphql
                    type Customer @key(fields: "id") {
                        id: ID!
                        customerNumber: String!
                        profile: CustomerProfile!
                        # Entity-specific behavior
                        orders: [Order!]!
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Value Objects</b></td>
                    <td>Objects that describe characteristics but have no conceptual identity</td>
                    <td>
                    <ul>
                        <li>No `id` field</li>
                        <li>Immutable by design</li>
                        <li>Compared by value, not identity</li>
                        <li>Often embedded within entities</li>
                    </ul>
                    </td>
                    <td>
                    <ul>
                        <li>Value objects have no identity fields</li>
                        <li>All fields are non-nullable where appropriate</li>
                        <li>Value objects are immutable</li>
                        <li>Validation rules are embedded in type design</li>
                        <li>Consistent representation across contexts</li>
                    </ul>
                    </td>
                    <td>
                    ```graphql
                    type Money {
                        amount: Decimal!
                        currency: Currency!
                    }

                    type Address {
                        street: String!
                        city: String!
                        postalCode: String!
                        country: Country!
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Aggregates</b></td>
                    <td>Clusters of entities and value objects that are treated as a single unit for data changes</td>
                    <td>
                    <ul>
                        <li>Root entity serves as aggregate root</li>
                        <li>Internal consistency maintained within aggregate</li>
                        <li>External references only to aggregate root</li>
                        <li>Mutations operate on entire aggregate</li>
                    </ul>
                    </td>
                    <td>
                    <ul>
                        <li>Aggregate root is clearly identified</li>
                        <li>Internal entities not exposed as top-level types</li>
                        <li>Mutations target aggregate roots only</li>
                        <li>Aggregate boundaries respect business invariants</li>
                        <li>Cross-aggregate references use IDs only</li>
                    </ul>
                    </td>
                    <td>
                    ```graphql
                    # Aggregate Root
                    type Order @key(fields: "id") {
                        id: ID!
                        orderNumber: String!
                        customer: Customer! # External reference
                        lineItems: [LineItem!]! # Internal entities
                        shippingAddress: Address! # Value object
                        totalAmount: Money! # Value object
                        status: OrderStatus!
                    }

                    # Internal Entity (not directly accessible)
                    type LineItem {
                        productId: ID!
                        quantity: Int!
                        unitPrice: Money!
                        lineTotal: Money!
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Domain Services</b></td>
                    <td>Operations that don't naturally belong to entities or value objects</td>
                    <td>
                    <ul>
                        <li>Implemented as mutations or queries</li>
                        <li>Operate across multiple aggregates</li>
                        <li>Encapsulate complex business logic</li>
                    </ul>
                    </td>
                    <td>
                    <ul>
                        <li>Domain services have clear business purpose</li>
                        <li>Services operate on domain concepts, not data structures</li>
                        <li>Complex business rules encapsulated in services</li>
                        <li>Services maintain aggregate boundaries</li>
                        <li>Input/output types use domain language</li>
                    </ul>
                    </td>
                    <td>
                    ```graphql
                    type Mutation {
                        # Domain Service: Order Processing
                        processOrder(input: ProcessOrderInput!): ProcessOrderPayload!

                        # Domain Service: Inventory Allocation
                        allocateInventory(input: AllocateInventoryInput!): AllocationResult!
                    }

                    type Query {
                        # Domain Service: Pricing Calculation
                        calculateShipping(input: ShippingCalculationInput!): ShippingQuote!
                    }
                    ```
                    </td>
                </tr>
                <tr>
                    <td><b>Domain Events</b></td>
                    <td>Something that happened in the domain that domain experts care about</td>
                    <td>
                    <ul>
                        <li>Modeled as types for event sourcing</li>
                        <li>Used in subscriptions for real-time updates</li>
                        <li>Enable loose coupling between contexts</li>
                    </ul>
                    </td>
                    <td>
                    <ul>
                        <li>Events represent business-significant occurrences</li>
                        <li>Event names use past tense</li>
                        <li>Events are immutable</li>
                        <li>Events include necessary context data</li>
                        <li>Event versioning strategy defined</li>
                    </ul>
                    </td>
                    <td>
                    ```graphql
                    type OrderPlaced implements DomainEvent {
                        eventId: ID!
                        aggregateId: ID!
                        occurredAt: DateTime!
                        version: Int!

                        # Event-specific data
                        orderNumber: String!
                        customerId: ID!
                        totalAmount: Money!
                    }

                    type Subscription {
                        orderEvents(customerId: ID): OrderEvent!
                    }

                    union OrderEvent = OrderPlaced | OrderShipped | OrderCancelled
                    ```
                    </td>
                </tr>
                </tbody>
            </table>
            </TabItem>
            <TabItem value="core-federation" label="Federation">
                <table>
                <thead>
                    <tr>
                    <th>DDD Concept</th>
                    <th>Definition</th>
                    <th>Characteristics</th>
                    <th>Considerations</th>
                    <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><b>Subgraph as Bounded Context</b></td>
                        <td>A subgraph represents a bounded context in a federated architecture, owned by a domain-specific team</td>
                        <td>
                            <ul>
                                <li>One subgraph per bounded context</li>
                                <li>Autonomous deployment and ownership</li>
                                <li>Minimal external dependencies</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Align subgraphs with team responsibilities</li>
                                <li>Ensure clear boundaries and independence</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # Customer Subgraph
                        type Customer @key(fields: "id") {
                            id: ID!
                            profile: CustomerProfile!
                            contactInformation: ContactInfo!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Entity Ownership and Extension</b></td>
                        <td>Entities are defined in their owning context and extended elsewhere with relevant data only</td>
                        <td>
                            <ul>
                                <li>Primary definition includes full business meaning</li>
                                <li>Extensions only add context-specific info</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                            <li>Respect ownership boundaries</li>
                            <li>Mark external fields properly</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # Primary (Customer Subgraph)
                        type Customer @key(fields: "id") {
                            id: ID!
                            customerNumber: String!
                        }

                        # Extension (Order Subgraph)
                        extend type Customer @key(fields: "id") {
                            id: ID! @external
                            orders: [Order!]!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Cross-Context References</b></td>
                        <td>Reference external entities via ID or use federated references for richer linking across subgraphs</td>
                        <td>
                            <ul>
                            <li>Use stable identifiers</li>
                            <li>Maintain referential integrity</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                            <li>Avoid embedding external data</li>
                            <li>Resolve federated references correctly</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        type Order @key(fields: "id") {
                            id: ID!
                            customerId: ID!
                        }

                        # Federated reference
                        type Order @key(fields: "id") {
                            id: ID!
                            customer: Customer!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Aggregate-Centric Design</b></td>
                        <td>Subgraphs encapsulate domain aggregates, exposing root and child entities along with behavior (mutations)</td>
                        <td>
                            <ul>
                            <li>Encapsulates full aggregate</li>
                            <li>Mutations scoped to aggregate boundaries</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                            <li>Maintain invariants within subgraph</li>
                            <li>Ensure ownership and isolation</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # Order Aggregate
                        type Order @key(fields: "id") {
                            id: ID!
                            lineItems: [LineItem!]!
                        }

                        type Mutation {
                            placeOrder(input: PlaceOrderInput!): PlaceOrderPayload!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Capability-Centric Subgraph</b></td>
                        <td>Organize subgraphs around business capabilities such as pricing, inventory, or promotions</td>
                        <td>
                            <ul>
                            <li>Focused service interfaces</li>
                            <li>Minimal external data access</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                            <li>Boundaries must be clearly defined</li>
                            <li>Keep internal logic self-contained</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # Pricing Subgraph
                        type Query {
                            calculatePrice(input: PriceCalculationInput!): PriceQuote!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Event-Driven Subgraph</b></td>
                        <td>Subgraphs that publish or consume domain events for reactive architectures</td>
                        <td>
                            <ul>
                            <li>Implements event types</li>
                            <li>Subscription-based updates</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                            <li>Ensure schema stability for events</li>
                            <li>Preserve event order</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # Inventory Events
                        type Subscription {
                            inventoryUpdates(productIds: [ID!]): InventoryUpdate!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Federation Directives</b></td>
                        <td>Directives like `@key`, `@external`, `@requires`, and `@provides` support cross-subgraph coordination</td>
                        <td>
                            <ul>
                                <li>`@key` defines identity</li>
                                <li>`@external` marks fields from other contexts</li>
                                <li>`@requires` declares data dependencies</li>
                                <li>`@provides` exposes computed fields</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Use keys that are stable and immutable</li>
                                <li>Track data ownership and resolution logic</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        extend type Customer @key(fields: "id") {
                            id: ID! @external
                            email: String! @external
                            preferences: Preferences! @requires(fields: "email")
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Schema Composition Strategy</b></td>
                        <td>Ensure consistent and valid schema composition across all subgraphs</td>
                        <td>
                            <ul>
                            <li>No conflicting definitions</li>
                            <li>External references resolvable</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                            <li>Detect circular dependencies early</li>
                            <li>Validate supergraph composition regularly</li>
                            </ul>
                        </td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><b>Query Planning Optimization</b></td>
                        <td>Optimize how queries are planned and resolved across subgraphs in the federated graph</td>
                        <td>
                            <ul>
                            <li>Batch calls to reduce latency</li>
                            <li>Cache federation metadata</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                            <li>Monitor performance and plan cost</li>
                            <li>Limit query complexity</li>
                            </ul>
                        </td>
                        <td></td>
                    </tr>
                </tbody>
                </table>

            </TabItem>

        </Tabs>
    </TabItem>
    <TabItem value="ddd" label="DDD">
        <Tabs queryString="secondary">
            <TabItem value="ddd-bounded-context" label="Bounded Context" attributes={{className:"tabs__vertical"}}>
                <table class="text_vertical">
                    <thead>
                        <tr>
                            <th>DDD Concept</th>
                            <th>Definition</th>
                            <th>Characteristics</th>
                            <th>Considerations</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><b>Bounded Context Mapping</b></td>
                            <td>A strategic design practice that defines explicit boundaries between different parts of a domain model</td>
                            <td>In GraphQL federation, these boundaries directly translate to subgraph boundaries</td>
                            <td>Crucial for successful federated architecture</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><b>Context Identification Strategy: Business Capability Analysis</b></td>
                            <td>Identify distinct business capabilities and their boundaries</td>
                            <td>
                                <ul>
                                <li>Delivers independent business value</li>
                                <li>Can be owned by a single team</li>
                                <li>Has its own data and business rules</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>Each capability delivers independent value</li>
                                <li>Clear ownership boundaries defined</li>
                                <li>Minimal overlap between capabilities</li>
                                <li>Capabilities align with organizational structure</li>
                                <li>Data ownership clearly defined</li>
                                </ul>
                            </td>
                            <td>
                            ```markdown
                            E-commerce Domain:
                            ├── Customer Management
                            │   ├── Customer Registration
                            │   ├── Profile Management
                            │   └── Customer Support
                            ├── Product Catalog
                            │   ├── Product Information
                            │   ├── Inventory Management
                            │   └── Pricing
                            ├── Order Management
                            │   ├── Order Processing
                            │   ├── Payment Processing
                            │   └── Fulfillment
                            └── Marketing
                                ├── Promotions
                                ├── Recommendations
                                └── Analytics
                            ```
                            </td>
                            </tr>
                            <tr>
                            <td><b>Context Identification Strategy: Data Ownership Analysis</b></td>
                            <td>Identify which parts of the domain model are owned by which contexts</td>
                            <td>
                                <ul>
                                <li>Single context creates data</li>
                                <li>Single context has authority to change data</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>Each data element has single owner</li>
                                <li>Ownership aligns with business authority</li>
                                <li>Cross-context references use IDs</li>
                                <li>No shared mutable state</li>
                                <li>Data consistency responsibilities clear</li>
                                </ul>
                            </td>
                            <td>
                                ```graphql
                                type Customer @key(fields: "id") {
                                    id: ID!
                                    customerNumber: String!
                                    profile: CustomerProfile!
                                    contactInfo: ContactInfo!
                                }

                                # Order Context - Owns order data, references customer
                                type Order @key(fields: "id") {
                                    id: ID!
                                    customerId: ID! # Reference, not ownership
                                    orderNumber: String!
                                    lineItems: [LineItem!]! # Owns line items
                                }

                                # Product Context - Owns product information
                                type Product @key(fields: "id") {
                                    id: ID!
                                    sku: String!
                                    name: String!
                                    description: String!
                                }
                                ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Context Identification Strategy: Team Boundary Analysis</b></td>
                            <td>Align context boundaries with team structure and expertise</td>
                            <td>
                                <ul>
                                <li>One team per bounded context</li>
                                <li>Team has domain expertise for their context</li>
                                <li>Team can make independent decisions</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>One team per bounded context</li>
                                <li>Team has domain expertise for their context</li>
                                <li>Team can make independent decisions</li>
                                <li>Minimal coordination required between teams</li>
                                <li>Clear escalation paths for cross-context issues</li>
                                </ul>
                            </td>
                            <td>
                                ```markdown
                                Team Structure → Context Mapping:
                                Frontend Team → Customer Experience Context
                                ├── User Interface
                                ├── User Experience
                                └── Client-side State

                                Backend Teams:
                                ├── Customer Team → Customer Management Context
                                ├── Catalog Team → Product Catalog Context
                                ├── Order Team → Order Management Context
                                └── Platform Team → Shared Infrastructure Context
                                ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Context Relationship Pattern: Shared Kernel</b></td>
                            <td>Two contexts share a common subset of the domain model</td>
                            <td>
                                <ul>
                                <li>Common value objects across contexts</li>
                                <li>Shared business rules</li>
                                <li>Small, stable shared model</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>Shared model is small and stable</li>
                                <li>Changes require coordination</li>
                                <li>Shared types are value objects</li>
                                <li>No shared entities</li>
                                <li>Clear governance for shared model</li>
                                </ul>
                            </td>
                            <td>
                                ```graphql
                                scalar Money
                                scalar DateTime

                                enum Currency {
                                    USD
                                    EUR
                                    GBP
                                }

                                type Address {
                                    street: String!
                                    city: String!
                                    postalCode: String!
                                    country: String!
                                }
                                ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Context Relationship Pattern: Customer-Supplier</b></td>
                            <td>One context (supplier) provides services to another context (customer)</td>
                            <td>
                                <ul>
                                <li>Clear supplier-customer relationship</li>
                                <li>Supplier provides stable interface</li>
                                <li>Customer adapts to supplier changes</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>Clear supplier-customer relationship</li>
                                <li>Supplier provides stable interface</li>
                                <li>Customer adapts to supplier changes</li>
                                <li>Service level agreements defined</li>
                                <li>Backward compatibility maintained</li>
                                </ul>
                            </td>
                            <td>
                                ```graphql
                                type Product @key(fields: "id") {
                                    id: ID!
                                    sku: String!
                                    name: String!
                                    price: Money!
                                }

                                # Customer Context (Order Management)
                                extend type Product @key(fields: "id") {
                                    id: ID! @external
                                    # Uses product data for order processing
                                }

                                type LineItem {
                                    product: Product!
                                    quantity: Int!
                                    unitPrice: Money!
                                }
                                ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Context Relationship Pattern: Conformist</b></td>
                            <td>Customer context conforms to supplier's model without translation</td>
                            <td>
                                <ul>
                                <li>Supplier has strong domain expertise</li>
                                <li>Customer has limited influence</li>
                                <li>Integration cost is high</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>Supplier model fits customer needs</li>
                                <li>Customer accepts supplier changes</li>
                                <li>No translation layer needed</li>
                                <li>Clear dependency management</li>
                                <li>Supplier stability assessed</li>
                                </ul>
                            </td>
                            <td>
                                ```graphql
                                # Supplier defines the model
                                type PaymentMethod {
                                    id: ID!
                                    type: PaymentType!
                                    details: PaymentDetails!
                                }

                                # Customer uses model as-is
                                type Order {
                                    id: ID!
                                    paymentMethod: PaymentMethod! # Direct usage
                                }
                                ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Context Relationship Pattern: Anti-Corruption Layer</b></td>
                            <td>Customer context translates supplier's model to protect its own model</td>
                            <td>
                                <ul>
                                <li>Supplier model doesn't fit domain</li>
                                <li>Legacy system integration</li>
                                <li>External service integration</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>Translation layer implemented</li>
                                <li>Internal model protected</li>
                                <li>Translation logic tested</li>
                                <li>Performance impact considered</li>
                                <li>Error handling for translation failures</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # External Supplier Model (legacy system)
                            type LegacyCustomer {
                                custId: String!
                                custName: String!
                                custAddr: String!
                            }

                            # Internal Domain Model
                            type Customer @key(fields: "id") {
                                id: ID!
                                customerNumber: String!
                                profile: CustomerProfile!
                                address: Address!
                            }

                            # Translation in resolver layer (not shown in schema)
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Context Relationship Pattern: Open Host Service</b></td>
                            <td>Context provides a well-defined service interface for multiple customers</td>
                            <td>
                                <ul>
                                <li>Stable, well-documented interface</li>
                                <li>Multiple consumer contexts</li>
                                <li>Versioning strategy defined</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>Stable, well-documented interface</li>
                                <li>Multiple consumer contexts</li>
                                <li>Versioning strategy defined</li>
                                <li>Service level agreements</li>
                                <li>Consumer feedback incorporated</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Open Host Service - Product Catalog
                            type Query {
                                product(id: ID!): Product
                                products(filter: ProductFilter): [Product!]!
                                searchProducts(query: String!): ProductSearchResult!
                            }

                            type Product @key(fields: "id") {
                                id: ID!
                                sku: String!
                                name: String!
                                description: String!
                                category: Category!
                                price: Money!
                                availability: Availability!
                            }

                            # Well-defined, stable interface for multiple consumers
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Context Relationship Pattern: Published Language</b></td>
                            <td>Shared language for integration between contexts</td>
                            <td>
                                <ul>
                                <li>Common language defined</li>
                                <li>Event schemas documented</li>
                                <li>Versioning strategy in place</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>Common language defined</li>
                                <li>Event schemas documented</li>
                                <li>Versioning strategy in place</li>
                                <li>Consumer compatibility maintained</li>
                                <li>Schema evolution managed</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Published Language - Domain Events
                            interface DomainEvent {
                                eventId: ID!
                                aggregateId: ID!
                                eventType: String!
                                occurredAt: DateTime!
                                version: Int!
                            }

                            type CustomerRegistered implements DomainEvent {
                                eventId: ID!
                                aggregateId: ID!
                                eventType: String!
                                occurredAt: DateTime!
                                version: Int!

                                # Event-specific data
                                customerId: ID!
                                customerNumber: String!
                                email: String!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Context Mapping in Federation: Subgraph Boundary Definition</b></td>
                            <td>Mapping Bounded Contexts to Subgraphs in a federated GraphQL architecture</td>
                            <td>
                                <ul>
                                <li>Represents a single bounded context</li>
                                <li>Can be owned by a single team</li>
                                <li>Entities and operations are cohesive</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>One bounded context per subgraph</li>
                                <li>Clear entity ownership</li>
                                <li>Cohesive operations</li>
                                <li>Minimal cross-subgraph dependencies</li>
                                <li>Team ownership aligned</li>
                                </ul>
                            </td>
                            <td>
                            ```markdown
                            Bounded Context → Subgraph Mapping:
                            Customer Management Context → Customer Subgraph
                            ├── Customer entity (primary)
                            ├── Customer profile management
                            ├── Customer authentication
                            └── Customer preferences

                            Product Catalog Context → Product Subgraph
                            ├── Product entity (primary)
                            ├── Product categories
                            ├── Product attributes
                            └── Product search

                            Order Management Context → Order Subgraph
                            ├── Order entity (primary)
                            ├── Order processing
                            ├── Order status tracking
                            └── Order history
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Cross-Context Integration Pattern: Event-Driven Integration</b></td>
                            <td>Use domain events for loose coupling between contexts</td>
                            <td>
                                <ul>
                                <li>Events represent business occurrences</li>
                                <li>Event schemas are stable</li>
                                <li>Eventual consistency acceptable</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>Events represent business occurrences</li>
                                <li>Event schemas are stable</li>
                                <li>Eventual consistency acceptable</li>
                                <li>Error handling for event processing</li>
                                <li>Event ordering considerations</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Publishing Context
                            type Mutation {
                                placeOrder(input: PlaceOrderInput!): PlaceOrderPayload!
                            }

                            type Subscription {
                                orderEvents: OrderEvent!
                            }

                            union OrderEvent = OrderPlaced | OrderShipped | OrderCancelled

                            # Consuming Context
                            type Subscription {
                                # Subscribe to events from other contexts
                                customerOrderEvents(customerId: ID!): OrderEvent!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Cross-Context Integration Pattern: Synchronous Integration</b></td>
                            <td>Direct federation for immediate consistency needs</td>
                            <td>
                                <ul>
                                <li>Immediate consistency required</li>
                                <li>Performance implications understood</li>
                                <li>Fallback strategies defined</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>Immediate consistency required</li>
                                <li>Performance implications understood</li>
                                <li>Fallback strategies defined</li>
                                <li>Circuit breaker patterns implemented</li>
                                <li>Monitoring and alerting in place</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Customer Context
                            type Customer @key(fields: "id") {
                                id: ID!
                                profile: CustomerProfile!
                            }

                            # Order Context
                            extend type Customer @key(fields: "id") {
                                id: ID! @external
                                orders: [Order!]! # Real-time access to orders
                                currentOrder: Order # Immediate consistency needed
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Context Evolution Strategy: Context Splitting</b></td>
                            <td>Dividing a large or complex context into smaller, more manageable ones</td>
                            <td>
                                <ul>
                                <li>Context becomes too large</li>
                                <li>Multiple teams need ownership</li>
                                <li>Different change frequencies</li>
                                <li>Distinct business capabilities emerge</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>Clear split rationale</li>
                                <li>New boundaries defined</li>
                                <li>Data migration planned</li>
                                <li>Interface contracts established</li>
                                <li>Rollback strategy prepared</li>
                                </ul>
                            </td>
                            <td></td>
                        </tr>
                        <tr>
                            <td><b>Context Evolution Strategy: Context Merging</b></td>
                            <td>Consolidating smaller or highly coupled contexts into a single, unified context</td>
                            <td>
                                <ul>
                                <li>Contexts are too small</li>
                                <li>High coupling between contexts</li>
                                <li>Single team ownership</li>
                                <li>Shared data model</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                <li>Merge benefits clear</li>
                                <li>Unified model designed</li>
                                <li>Migration strategy defined</li>
                                <li>Team alignment achieved</li>
                                <li>Monitoring during transition</li>
                                </ul>
                            </td>
                            <td></td>
                        </tr>
                        </tbody>
                    </table>
            </TabItem>
            <TabItem value="ddd-entity-aggregate" label="Entity Aggregate">
                <table class="text_vertical">
                    <thead>
                    <tr>
                        <th>DDD Concept</th>
                        <th>Definition</th>
                        <th>Characteristics</th>
                        <th>Considerations</th>
                        <th>Example</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><b>Ubiquitous Language</b></td>
                        <td>A common language shared between domain experts and developers, reflected in code and schema</td>
                        <td>
                        <ul>
                            <li>Type names must use domain terminology, not technical terms</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>All type names use business terminology</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # ✅ Good - Uses domain language
                        type Order {
                            orderNumber: String!
                            customer: Customer!
                            lineItems: [LineItem!]!
                            totalAmount: Money!
                            status: OrderStatus!
                        }

                        # ❌ Bad - Uses technical language
                        type OrderRecord {
                            id: ID!
                            customerId: ID!
                            items: [OrderItemRecord!]!
                            total: Float!
                            statusCode: Int!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Entity Identity Design</b></td>
                        <td>Every entity must have a stable, unique identity that persists throughout its lifecycle</td>
                        <td>
                        <ul>
                            <li>Identity fields are immutable</li>
                            <li>Identity fields are unique across all instances</li>
                            <li>Identity generation strategy is consistent</li>
                            <li>Identity fields are suitable for federation keys</li>
                            <li>Business meaning of identity is clear</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Is there a natural business identifier? (Yes → Business key; No → Technical identifier)</li>
                            <li>Is the business identifier immutable? (No → Technical identifier; Yes → Business key)</li>
                            <li>Do external systems need specific identifier format? (Yes → Multiple keys; No → Single key)</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # UUID-based identity
                        type Customer @key(fields: "id") {
                            id: ID! # UUID: "550e8400-e29b-41d4-a716-446655440000"
                            customerNumber: String!
                            profile: CustomerProfile!
                        }

                        # Business key identity
                        type Product @key(fields: "sku") {
                            sku: String! # Business key: "LAPTOP-DELL-XPS13"
                            name: String!
                            description: String!
                        }

                        # Composite identity
                        type OrderLineItem @key(fields: "orderId productSku") {
                            orderId: ID!
                            productSku: String!
                            quantity: Int!
                            unitPrice: Money!
                        }

                        # Multiple identity options
                        type Customer @key(fields: "id") @key(fields: "customerNumber") {
                            id: ID!
                            customerNumber: String! # Alternative key for legacy systems
                            email: String!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Entity Lifecycle Modeling</b></td>
                        <td>Model entity states and transitions explicitly in the schema</td>
                        <td>
                        <ul>
                            <li>All possible states explicitly modeled</li>
                            <li>State transitions are clear</li>
                            <li>Lifecycle timestamps included</li>
                            <li>State-dependent fields identified</li>
                            <li>Invalid state combinations prevented</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Explicitly define all possible states</li>
                            <li>Ensure clear transitions between states</li>
                            <li>Include timestamps for key lifecycle events</li>
                            <li>Identify fields that are dependent on the entity's state</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type Order @key(fields: "id") {
                            id: ID!
                            orderNumber: String!
                            status: OrderStatus!
                            createdAt: DateTime!
                            updatedAt: DateTime!

                            # Lifecycle-specific fields
                            placedAt: DateTime
                            shippedAt: DateTime
                            deliveredAt: DateTime
                            cancelledAt: DateTime

                            # State-dependent data
                            trackingNumber: String # Only available when shipped
                            cancellationReason: String # Only available when cancelled
                        }

                        enum OrderStatus {
                            DRAFT
                            PLACED
                            CONFIRMED
                            SHIPPED
                            DELIVERED
                            CANCELLED
                            RETURNED
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Owned Relationships</b></td>
                        <td>Entity owns and manages related entities within aggregate boundary</td>
                        <td>
                        <ul>
                            <li>Owned entities not exposed as top-level types</li>
                            <li>Owned entities have no independent identity</li>
                            <li>Lifecycle tied to owning entity</li>
                            <li>Consistency maintained within aggregate</li>
                            <li>No external references to owned entities</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Are the related entities always accessed and managed through the owning entity?</li>
                            <li>Do the related entities lack independent meaning outside the owner?</li>
                            <li>Is their lifecycle directly dependent on the owning entity's lifecycle?</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type Order @key(fields: "id") {
                            id: ID!
                            # Owned entities - managed within aggregate
                            lineItems: [LineItem!]! # Order owns line items
                            shippingAddress: Address! # Order owns shipping address
                            billingAddress: Address! # Order owns billing address
                        }

                        type LineItem {
                            # No @key directive - not independently accessible
                            productSku: String!
                            quantity: Int!
                            unitPrice: Money!
                            lineTotal: Money!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Referenced Relationships</b></td>
                        <td>Entity references other entities by identity</td>
                        <td>
                        <ul>
                            <li>References use stable identifiers</li>
                            <li>Referenced entities defined in appropriate contexts</li>
                            <li>Federation directives correctly applied</li>
                            <li>Circular dependencies avoided</li>
                            <li>Reference integrity handled at application level</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Are the referenced entities independent and can exist without the referencing entity?</li>
                            <li>Do the referenced entities have their own lifecycle and management?</li>
                            <li>Is data consistency across these entities handled at a higher level (e.g., eventual consistency)?</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type Order @key(fields: "id") {
                            id: ID!
                            customerId: ID! # Reference to Customer entity
                            # Federated reference - resolved across subgraphs
                            customer: Customer!
                        }

                        # Customer defined in different subgraph
                        extend type Customer @key(fields: "id") {
                            id: ID! @external
                            orders: [Order!]! # Back-reference
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Aggregate Root Design</b></td>
                        <td>Each aggregate has exactly one root entity that serves as the entry point</td>
                        <td>
                        <ul>
                            <li>Single aggregate root identified</li>
                            <li>Root entity has clear identity</li>
                            <li>All aggregate components accessible through root</li>
                            <li>Business invariants maintained at aggregate level</li>
                            <li>Aggregate boundaries respect consistency requirements</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>What is the primary entity that all other entities within the aggregate depend on?</li>
                            <li>Does this root encapsulate all changes to its internal entities?</li>
                            <li>Are all business rules and invariants applied at the root level?</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # Aggregate Root
                        type Order @key(fields: "id") {
                            id: ID!
                            orderNumber: String!
                            customerId: ID!

                            # Aggregate components
                            lineItems: [LineItem!]!
                            shippingAddress: Address!
                            billingAddress: Address!

                            # Aggregate-level computed fields
                            totalAmount: Money!
                            itemCount: Int!
                            status: OrderStatus!

                            # Aggregate behavior
                            canBeCancelled: Boolean!
                            canBeModified: Boolean!
                        }

                        # Internal entities - not directly accessible
                        type LineItem {
                            productSku: String!
                            productName: String!
                            quantity: Int!
                            unitPrice: Money!
                            lineTotal: Money!
                        }

                        # Value objects
                        type Address {
                            street: String!
                            city: String!
                            postalCode: String!
                            country: String!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Aggregate Boundary Definition</b></td>
                        <td>Defines the scope of consistency and transactional integrity</td>
                        <td>
                        <ul>
                            <li>Aggregate boundaries respect business invariants</li>
                            <li>Entities within aggregate are highly cohesive</li>
                            <li>Cross-aggregate references use IDs</li>
                            <li>Aggregate size is manageable</li>
                            <li>Consistency requirements clearly defined</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Do these entities need to be consistent together? (Yes → Same aggregate; No → Different aggregates)</li>
                            <li>Do these entities change together? (Yes → Same aggregate; No → Different aggregates)</li>
                            <li>Can these entities exist independently? (No → Same aggregate; Yes → Different aggregates)</li>
                            <li>Is the relationship ownership or reference? (Ownership → Same aggregate; Reference → Different aggregates)</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # Single Aggregate: Order + LineItems + Addresses
                        type Order @key(fields: "id") {
                            id: ID!
                            # These must be consistent together
                            lineItems: [LineItem!]! # Owned - same aggregate
                            shippingAddress: Address! # Owned - same aggregate
                            totalAmount: Money! # Computed from line items
                        }

                        # Separate Aggregate: Customer
                        type Customer @key(fields: "id") {
                            id: ID!
                            profile: CustomerProfile!
                            # Orders reference customer but are separate aggregates
                        }

                        # Reference between aggregates
                        type Order @key(fields: "id") {
                            customerId: ID! # Reference, not ownership
                            customer: Customer! # Federated reference
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Aggregate Operations</b></td>
                        <td>Design mutations that operate on complete aggregates</td>
                        <td>
                        <ul>
                            <li>Mutations target aggregate roots</li>
                            <li>Input types include all necessary data</li>
                            <li>Business rules validated in mutations</li>
                            <li>Aggregate consistency maintained</li>
                            <li>Error handling for business rule violations</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Do the mutations only modify one aggregate at a time?</li>
                            <li>Are all necessary inputs for a complete aggregate operation provided in a single mutation?</li>
                            <li>Are business rules for the aggregate enforced within the mutation?</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type Mutation {
                            # Aggregate creation
                            createOrder(input: CreateOrderInput!): CreateOrderPayload!

                            # Aggregate modification
                            updateOrder(input: UpdateOrderInput!): UpdateOrderPayload!
                            addLineItem(input: AddLineItemInput!): AddLineItemPayload!
                            removeLineItem(input: RemoveLineItemInput!): RemoveLineItemPayload!

                            # Aggregate state transitions
                            confirmOrder(orderId: ID!): ConfirmOrderPayload!
                            cancelOrder(input: CancelOrderInput!): CancelOrderPayload!
                        }

                        input CreateOrderInput {
                            customerId: ID!
                            lineItems: [LineItemInput!]!
                            shippingAddress: AddressInput!
                            billingAddress: AddressInput!
                        }

                        input LineItemInput {
                            productSku: String!
                            quantity: Int!
                        }

                        type CreateOrderPayload {
                            order: Order
                            errors: [Error!]!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Entity Inheritance and Polymorphism</b></td>
                        <td>Model entity hierarchies using GraphQL interfaces and unions</td>
                        <td>
                        <ul>
                            <li>Interface defines common entity contract</li>
                            <li>Concrete types implement interface completely</li>
                            <li>Type-specific fields clearly separated</li>
                            <li>Federation keys consistent across types</li>
                            <li>Polymorphic queries supported</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Are there shared behaviors or attributes across different entity types?</li>
                            <li>Do client applications need to query or operate on these entities polymorphically?</li>
                            <li>Is the hierarchy stable and unlikely to change frequently?</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # Base entity interface
                        interface Product @key(fields: "id") {
                            id: ID!
                            sku: String!
                            name: String!
                            description: String!
                            price: Money!
                        }

                        # Concrete entity types
                        type PhysicalProduct implements Product @key(fields: "id") {
                            id: ID!
                            sku: String!
                            name: String!
                            description: String!
                            price: Money!

                            # Physical product specific fields
                            weight: Weight!
                            dimensions: Dimensions!
                            shippingClass: ShippingClass!
                        }

                        type DigitalProduct implements Product @key(fields: "id") {
                            id: ID!
                            sku: String!
                            name: String!
                            description: String!
                            price: Money!

                            # Digital product specific fields
                            downloadUrl: String!
                            licenseType: LicenseType!
                            fileSize: Int!
                        }

                        # Union for polymorphic queries
                        union ProductVariant = PhysicalProduct | DigitalProduct
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Entity Versioning Patterns</b></td>
                        <td>Handle entity evolution over time</td>
                        <td>
                        <ul>
                            <li>Version fields for optimistic locking</li>
                            <li>Deprecated fields properly marked</li>
                            <li>Migration path documented</li>
                            <li>Schema version tracking</li>
                            <li>Backward compatibility maintained</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Do you need to prevent concurrent updates to the same entity?</li>
                            <li>Do you need to track changes to an entity's structure or data over time?</li>
                            <li>Is backward compatibility a significant concern for your clients?</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type Customer @key(fields: "id") {
                            id: ID!
                            version: Int! # Optimistic locking
                            # Core fields
                            customerNumber: String!
                            profile: CustomerProfile!

                            # Versioned fields with deprecation
                            email: String! @deprecated(reason: "Use profile.contactInfo.email")
                            phone: String @deprecated(reason: "Use profile.contactInfo.phone")

                            # Evolution tracking
                            createdAt: DateTime!
                            updatedAt: DateTime!
                            schemaVersion: String! # Track schema evolution
                        }

                        type CustomerProfile {
                            personalInfo: PersonalInfo!
                            contactInfo: ContactInfo!
                            preferences: CustomerPreferences!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Soft Delete Patterns</b></td>
                        <td>Handle entity deletion without data loss</td>
                        <td>
                        <ul>
                            <li>Soft delete flags included</li>
                            <li>Deletion metadata captured</li>
                            <li>Queries filter deleted entities by default</li>
                            <li>Conditional field resolution based on deletion status</li>
                            <li>Data retention policies considered</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Is there a business requirement to retain deleted data for auditing or recovery?</li>
                            <li>Do you need to differentiate between truly deleted entities and logically deleted ones?</li>
                            <li>How should queries behave when encountering soft-deleted entities?</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type Customer @key(fields: "id") {
                            id: ID!
                            customerNumber: String!

                            # Soft delete fields
                            isActive: Boolean!
                            deletedAt: DateTime
                            deletionReason: String

                            # Conditional fields based on deletion status
                            profile: CustomerProfile # Null when deleted
                            orders: [Order!]! # Empty when deleted
                        }

                        type Query {
                            # Active customers only by default
                            customers(includeDeleted: Boolean = false): [Customer!]!
                            customer(id: ID!, includeDeleted: Boolean = false): Customer
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Nested Aggregates (Anti-Pattern)</b></td>
                        <td>Avoid aggregates within aggregates</td>
                        <td>
                        <ul>
                            <li>No aggregates nested within other aggregates</li>
                            <li>Cross-aggregate references use IDs</li>
                            <li>Federation used for cross-aggregate navigation</li>
                            <li>Aggregate boundaries clearly defined</li>
                            <li>Consistency boundaries respected</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Does one aggregate truly "own" another, or does it merely reference it?</li>
                            <li>Would modifying the "inner" aggregate require modifying the "outer" aggregate's invariants?</li>
                            <li>Are the consistency requirements distinct for each potential aggregate?</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # ❌ Bad - Nested aggregates
                        type Order @key(fields: "id") {
                            id: ID!
                            customer: Customer! # Customer is separate aggregate
                            lineItems: [LineItem!]!
                        }

                        # ✅ Good - Reference to separate aggregate
                        type Order @key(fields: "id") {
                            id: ID!
                            customerId: ID! # Reference only
                            customer: Customer! # Federated reference
                            lineItems: [LineItem!]!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Aggregate Collaboration Patterns</b></td>
                        <td>Model how aggregates work together</td>
                        <td>
                        <ul>
                            <li>Aggregates remain independent</li>
                            <li>Collaboration through events or services</li>
                            <li>Eventual consistency between aggregates</li>
                            <li>Compensation patterns for failures</li>
                            <li>Clear responsibility boundaries</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>How do independent aggregates interact without violating their boundaries?</li>
                            <li>What mechanisms (e.g., domain events) facilitate communication and data synchronization?</li>
                            <li>How are eventual consistency and potential failures handled?</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # Order aggregate
                        type Order @key(fields: "id") {
                            id: ID!
                            customerId: ID!
                            status: OrderStatus!
                        }

                        # Inventory aggregate
                        type InventoryItem @key(fields: "productSku") {
                            productSku: String!
                            quantityAvailable: Int!
                            quantityReserved: Int!
                        }

                        # Collaboration through domain events
                        type Mutation {
                            placeOrder(input: PlaceOrderInput!): PlaceOrderPayload!
                            # This triggers InventoryReserved event
                        }

                        type Subscription {
                            inventoryEvents: InventoryEvent!
                        }

                        union InventoryEvent = InventoryReserved | InventoryReleased
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Aggregate Factories</b></td>
                        <td>Encapsulate complex aggregate creation logic</td>
                        <td>
                        <ul>
                            <li>Complex creation logic encapsulated</li>
                            <li>Factory methods have clear purpose</li>
                            <li>Input validation comprehensive</li>
                            <li>Business rules enforced during creation</li>
                            <li>Error handling for creation failures</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Is the creation process for an aggregate complex, involving multiple steps or external dependencies?</li>
                            <li>Do you need to ensure that an aggregate is always created in a valid state?</li>
                            <li>Can the creation logic be reused across different parts of the application?</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type Mutation {
                            # Factory method for complex order creation
                            createOrderFromCart(input: CreateOrderFromCartInput!): CreateOrderPayload!

                            # Factory method for subscription orders
                            createSubscriptionOrder(input: CreateSubscriptionInput!): CreateOrderPayload!
                        }

                        input CreateOrderFromCartInput {
                            cartId: ID!
                            shippingAddressId: ID!
                            paymentMethodId: ID!
                            promotionCodes: [String!]
                        }

                        type CreateOrderPayload {
                            order: Order
                            warnings: [Warning!]!
                            errors: [Error!]!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Entity Distribution Strategies</b></td>
                        <td>Distribute entity data across appropriate subgraphs</td>
                        <td>
                        <ul>
                            <li>Entity data distributed by business capability</li>
                            <li>Core entity in primary subgraph</li>
                            <li>Extensions in relevant subgraphs</li>
                            <li>No data duplication across subgraphs</li>
                            <li>Clear ownership boundaries</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Which business domain is primarily responsible for managing a given entity?</li>
                            <li>How can different subgraphs extend an entity without duplicating core data?</li>
                            <li>How do you ensure a single source of truth for critical entity data?</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # Customer subgraph - Core customer data
                        type Customer @key(fields: "id") {
                            id: ID!
                            customerNumber: String!
                            profile: CustomerProfile!
                            registrationDate: DateTime!
                        }

                        # Order subgraph - Order-related customer data
                        extend type Customer @key(fields: "id") {
                            id: ID! @external
                            orders: [Order!]!
                            orderHistory: OrderHistory!
                            loyaltyPoints: Int!
                        }

                        # Marketing subgraph - Marketing-related customer data
                        extend type Customer @key(fields: "id") {
                            id: ID! @external
                            marketingPreferences: MarketingPreferences!
                            campaignHistory: [Campaign!]!
                            segmentMemberships: [Segment!]!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Cross-Subgraph Entity Consistency</b></td>
                        <td>Maintain consistency across distributed entity data</td>
                        <td>
                        <ul>
                            <li>Consistency strategy defined</li>
                            <li>Event-driven updates implemented</li>
                            <li>Version tracking for consistency checks</li>
                            <li>Conflict resolution strategies</li>
                            <li>Monitoring for consistency issues</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>What level of consistency (e.g., strong, eventual) is required between subgraphs?</li>
                            <li>How are changes to an entity propagated across subgraphs?</li>
                            <li>How are conflicts resolved when multiple subgraphs modify the same entity's state?</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # Event-driven consistency
                        type Subscription {
                            customerEvents: CustomerEvent!
                        }

                        union CustomerEvent = CustomerUpdated | CustomerDeleted

                        type CustomerUpdated implements DomainEvent {
                            eventId: ID!
                            customerId: ID!
                            updatedFields: [String!]!
                            occurredAt: DateTime!
                        }

                        # Eventual consistency handling
                        type Customer @key(fields: "id") {
                            id: ID!
                            # Include version for consistency checks
                            version: Int!
                            lastSyncedAt: DateTime!
                        }
                        ```
                        </td>
                    </tr>
                    </tbody>
                </table>
            </TabItem>
            <TabItem value="ddd-value-object" label="Value Object">
                <table class="text_vertical">
                    <thead>
                    <tr>
                        <th>DDD Concept</th>
                        <th>Definition</th>
                        <th>Characteristics</th>
                        <th>Considerations</th>
                        <th>Example</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><b>Value Object Representation</b></td>
                        <td>Immutable objects that describe characteristics or attributes but have no conceptual identity</td>
                        <td>
                        <ul>
                            <li><b>Immutability</b>: Cannot be modified after creation; operations return new instance</li>
                            <li><b>Value Equality</b>: Equal if all their attributes are equal</li>
                            <li><b>Self-Validation</b>: Validate their own invariants</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>No mutation operations on value object fields</li>
                            <li>All fields are non-nullable where appropriate</li>
                            <li>Equality based on all attributes, with comparison operations available</li>
                            <li>Validation rules embedded in type design; invalid instances cannot be created</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # Immutable value object
                        type Money {
                            amount: Decimal! # Cannot be changed
                            currency: Currency! # Cannot be changed
                        }

                        # Value Equality - Two Money objects are equal if amount and currency match
                        type Money {
                            amount: Decimal!
                            currency: Currency!
                            isZero: Boolean!
                        }

                        # Self-Validation - Email value object with validation
                        type Email {
                            address: String! # Always valid email format
                            domain: String!
                            isValid: Boolean! # Always true for existing instances
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Money Pattern</b></td>
                        <td>Represent monetary values with currency information</td>
                        <td>
                        <ul>
                            <li>Includes `amount` and `currency`</li>
                            <li>Can have computed properties like `formattedAmount`, `displayValue`, `minorUnits`</li>
                            <li>Supports arithmetic operations (add, subtract, multiply)</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Currency always specified</li>
                            <li>Decimal precision appropriate for currency</li>
                            <li>Arithmetic operations handle currency compatibility</li>
                            <li>Display formatting included</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type Money {
                            amount: Decimal!
                            currency: Currency!
                            formattedAmount: String!
                            displayValue: String!
                        }

                        enum Currency {
                            USD
                            EUR
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Address Pattern</b></td>
                        <td>Represent physical or mailing addresses</td>
                        <td>
                        <ul>
                            <li>Includes `street`, `city`, `state`, `postalCode`, `country`</li>
                            <li>Can have computed properties like `formattedAddress`, `isValid`, `coordinates`</li>
                            <li>Supports validation services</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Country-specific validation rules</li>
                            <li>Standardized formatting</li>
                            <li>Geocoding integration considered</li>
                            <li>International address support</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type Address {
                            street: String!
                            city: String!
                            state: String
                            postalCode: String!
                            country: Country!
                            formattedAddress: String!
                            isValid: Boolean!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Date Range Pattern</b></td>
                        <td>Represent periods or ranges of time</td>
                        <td>
                        <ul>
                            <li>Includes `startDate` and `endDate`</li>
                            <li>Can have computed properties like `duration`, `isActive`, `isEmpty`</li>
                            <li>Supports business logic like `contains` and `overlaps`</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Start date before or equal to end date</li>
                            <li>Timezone considerations handled</li>
                            <li>Overlap detection implemented</li>
                            <li>Duration calculations accurate</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type DateRange {
                            startDate: Date!
                            endDate: Date!
                            duration: Duration!
                            isActive: Boolean!
                        }

                        type Duration {
                            days: Int!
                            hours: Int!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Measurement Pattern</b></td>
                        <td>Represent quantities with units</td>
                        <td>
                        <ul>
                            <li>Includes `value` and `unit`</li>
                            <li>Supports unit conversions (e.g., `inGrams`, `inKilograms`)</li>
                            <li>Can be composed for complex measurements (e.g., `Dimensions`)</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Unit conversions available</li>
                            <li>Precision appropriate for use case</li>
                            <li>Standard units supported</li>
                            <li>Arithmetic operations handle unit compatibility</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type Weight {
                            value: Decimal!
                            unit: WeightUnit!
                            inGrams: Decimal!
                            inKilograms: Decimal!
                        }

                        enum WeightUnit {
                            GRAM
                            KILOGRAM
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Composite Value Objects</b></td>
                        <td>Value objects composed of other value objects</td>
                        <td>
                        <ul>
                            <li>Combines multiple value objects (e.g., `ContactInfo` combines `Email`, `PhoneNumber`, `Address`)</li>
                            <li>Computed properties can leverage components</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Component value objects properly modeled</li>
                            <li>Composition relationships clear</li>
                            <li>Validation cascades to components</li>
                            <li>Immutability maintained throughout composition</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type ContactInfo {
                            email: Email!
                            phone: PhoneNumber
                            address: Address!
                            isComplete: Boolean!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Polymorphic Value Objects</b></td>
                        <td>Different value object types for similar concepts</td>
                        <td>
                        <ul>
                            <li>Uses interfaces to define common contracts (e.g., `Identifier`)</li>
                            <li>Specific types implement the interface and add relevant behavior (e.g., `CustomerNumber`, `ProductSKU`)</li>
                            <li>Unions can be used for polymorphic usage</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Interface defines common contract</li>
                            <li>Specific types add relevant behavior</li>
                            <li>Type discrimination clear</li>
                            <li>Validation rules type-specific</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        interface Identifier {
                            value: String!
                            type: IdentifierType!
                            isValid: Boolean!
                        }

                        type CustomerNumber implements Identifier {
                            value: String!
                            region: String!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Enumeration Value Objects</b></td>
                        <td>Rich enumerations with behavior and data</td>
                        <td>
                        <ul>
                            <li>Enum provides type safety for a core concept (e.g., `OrderStatusCode`)</li>
                            <li>Associated rich type adds behavior and metadata (e.g., `OrderStatus` with `canTransitionTo`, `isTerminal`)</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Enum provides type safety</li>
                            <li>Rich type adds behavior and metadata</li>
                            <li>State transitions clearly defined</li>
                            <li>Business rules embedded</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type OrderStatus {
                            code: OrderStatusCode!
                            name: String!
                            canTransitionTo: [OrderStatusCode!]!
                            isTerminal: Boolean!
                        }

                        enum OrderStatusCode {
                            DRAFT
                            CONFIRMED
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Collection Value Objects</b></td>
                        <td>Immutable collections with domain behavior</td>
                        <td>
                        <ul>
                            <li>Encapsulates a collection of other objects (e.g., `LineItems` containing `LineItem`)</li>
                            <li>Provides collection-level behavior (e.g., `totalQuantity`, `totalAmount`, `hasProduct`)</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Collection operations available</li>
                            <li>Aggregation functions provided</li>
                            <li>Business logic encapsulated</li>
                            <li>Immutability maintained</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type LineItems {
                            items: [LineItem!]!
                            totalQuantity: Int!
                            totalAmount: Money!
                            itemCount: Int!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Format Validation</b></td>
                        <td>Validate value object format and structure</td>
                        <td>
                        <ul>
                            <li>Embedded validation rules to ensure correct format (e.g., email address format)</li>
                            <li>Can include validation metadata (e.g., `validationRules`, `isDisposable`)</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Format validation rules defined</li>
                            <li>Standard formats used where applicable</li>
                            <li>Validation metadata exposed</li>
                            <li>International standards followed</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type Email {
                            address: String! # Always valid format
                            localPart: String!
                            domain: String!
                            validationRules: [ValidationRule!]!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Business Rule Validation</b></td>
                        <td>Embed business rules in value object validation</td>
                        <td>
                        <ul>
                            <li>Validation ensures adherence to domain constraints (e.g., `ProductSKU` has `isDiscontinued`, `isRestricted`)</li>
                            <li>Includes business metadata (e.g., `category`, `manufacturer`, `riskLevel`)</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Business rules embedded in validation</li>
                            <li>Domain constraints enforced</li>
                            <li>Business metadata included</li>
                            <li>Compliance requirements met</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type ProductSKU {
                            value: String!
                            isValid: Boolean!
                            category: ProductCategory!
                            isDiscontinued: Boolean!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Scalar Serialization</b></td>
                        <td>Serialize simple value objects as scalars</td>
                        <td>
                        <ul>
                            <li>Defines custom GraphQL scalars for simple value objects (e.g., `Money`, `Email`, `PhoneNumber`)</li>
                            <li>Validation happens during deserialization</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Scalar serialization format documented</li>
                            <li>Validation happens during deserialization</li>
                            <li>Error handling for invalid formats</li>
                            <li>Client libraries support custom scalars</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        scalar Money
                        scalar Email

                        type Customer {
                            id: ID!
                            email: Email! # Serialized as string, validated as email
                            creditLimit: Money! # Serialized with currency info
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Object Serialization</b></td>
                        <td>Serialize complex value objects as objects</td>
                        <td>
                        <ul>
                            <li>Represents value objects as GraphQL types with their fields (e.g., `Address`, `Money`)</li>
                            <li>Input types mirror output types for consistency</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Input types mirror output types</li>
                            <li>Nested objects properly structured</li>
                            <li>Optional fields clearly marked</li>
                            <li>Validation rules consistent</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        type Address {
                            street: String!
                            city: String!
                            postalCode: String!
                            country: Country!
                        }

                        input AddressInput {
                            street: String!
                            city: String!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Shared Value Objects</b></td>
                        <td>Share common value objects across subgraphs in a federated architecture</td>
                        <td>
                        <ul>
                            <li>Common value objects like `Money`, `Email`, `Address` are defined once</li>
                            <li>Used consistently across different subgraphs (e.g., Customer subgraph and Order subgraph)</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Shared value objects consistently defined</li>
                            <li>No conflicting definitions across subgraphs</li>
                            <li>Shared types documented</li>
                            <li>Version compatibility maintained</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        scalar Money
                        type Address {
                            street: String!
                            city: String!
                            postalCode: String!
                        }

                        # Customer subgraph
                        type Customer @key(fields: "id") {
                            id: ID!
                            address: Address!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Context-Specific Value Objects</b></td>
                        <td>Allow context-specific interpretations of value objects in a federated architecture</td>
                        <td>
                        <ul>
                            <li>Value objects can have different fields or behaviors based on the specific domain context (e.g., `Address` in customer context vs. `ShippingAddress` in shipping context)</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Context-specific needs addressed</li>
                            <li>No unnecessary coupling between contexts</li>
                            <li>Clear mapping between contexts</li>
                            <li>Context boundaries respected</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # Customer context - full address
                        type Address {
                            street: String!
                            city: String!
                            state: String!
                            isVerified: Boolean!
                        }

                        # Shipping context - shipping-focused address
                        type ShippingAddress {
                            street: String!
                            city: String!
                            deliveryInstructions: String
                            isResidential: Boolean!
                        }
                        ```
                        </td>
                    </tr>
                    </tbody>
                </table>
            </TabItem>
            <TabItem value="ddd-domain-event" label="Domain Event">
            <table>
                <thead>
                    <tr>
                        <th>DDD Concept</th>
                        <th>Definition</th>
                        <th>Characteristics</th>
                        <th>Considerations</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><b>Ubiquitous Language</b></td>
                        <td>A common language shared between domain experts and developers, reflected in code and schema</td>
                        <td>
                            <ul>
                                <li>Type names must use domain terminology, not technical terms</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>All type names use business terminology</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # ✅ Good - Uses domain language
                        type Order {
                            orderNumber: String!
                            customer: Customer!
                            lineItems: [LineItem!]!
                            totalAmount: Money!
                            status: OrderStatus!
                        }

                        # ❌ Bad - Uses technical language
                        type OrderRecord {
                            id: ID!
                            customerId: ID!
                            items: [OrderItemRecord!]!
                            total: Float!
                            statusCode: Int!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Business Significance (Domain Event Modeling)</b></td>
                        <td>Events represent occurrences that domain experts care about</td>
                        <td>
                            <ul>
                                <li>Events use business language</li>
                                <li>Events represent business state changes</li>
                                <li>Events are meaningful to domain experts</li>
                                <li>Events capture business context</li>
                                <li>Events avoid technical implementation details</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Ensure events directly reflect business processes</li>
                                <li>Avoid creating events for mere technical operations</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # ✅ Good - Business significant events
                        type CustomerRegistered implements DomainEvent {
                            eventId: ID!
                            aggregateId: ID!
                            occurredAt: DateTime!
                            version: Int!

                            # Business-relevant data
                            customerId: ID!
                            customerNumber: String!
                            email: String!
                            registrationChannel: RegistrationChannel!
                        }

                        type OrderPlaced implements DomainEvent {
                            eventId: ID!
                            aggregateId: ID!
                            occurredAt: DateTime!
                            version: Int!

                            # Business context
                            orderNumber: String!
                            customerId: ID!
                            totalAmount: Money!
                            orderSource: OrderSource!
                        }

                        # ❌ Bad - Technical events
                        type DatabaseRecordUpdated implements DomainEvent {
                            eventId: ID!
                            tableName: String!
                            recordId: String!
                            changedFields: [String!]!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Immutability (Domain Event Modeling)</b></td>
                        <td>Events cannot be changed once created</td>
                        <td>
                            <ul>
                                <li>No mutation operations on events</li>
                                <li>Event data is immutable</li>
                                <li>Event history preserved</li>
                                <li>Append-only event store</li>
                                <li>Compensation events for corrections</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Design systems to append events, not alter them</li>
                                <li>Use compensation events for error correction instead of modifying past events</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        interface DomainEvent {
                            eventId: ID! # Immutable identifier
                            aggregateId: ID! # Source aggregate
                            occurredAt: DateTime! # When it happened
                            version: Int! # Event version for evolution
                            eventType: String! # Event type identifier
                        }

                        # Events are append-only
                        type Mutation {
                            # Events are published, not updated
                            publishEvent(event: DomainEventInput!): PublishEventResult!

                            # No update or delete operations for events
                            # updateEvent - NOT ALLOWED
                            # deleteEvent - NOT ALLOWED
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Past Tense Naming (Domain Event Modeling)</b></td>
                        <td>Events describe what has already happened</td>
                        <td>
                            <ul>
                                <li>Event names use past tense</li>
                                <li>Event names describe completed actions</li>
                                <li>Event names are specific and clear</li>
                                <li>Event names follow domain language</li>
                                <li>Event names avoid ambiguity</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Use clear, unambiguous past tense verbs for event names</li>
                                <li>Ensure names reflect completed actions, not ongoing processes or commands</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # ✅ Good - Past tense names
                        type CustomerRegistered implements DomainEvent
                        type OrderPlaced implements DomainEvent
                        type PaymentProcessed implements DomainEvent
                        type InventoryAdjusted implements DomainEvent
                        type ProductDiscontinued implements DomainEvent

                        # ❌ Bad - Present/future tense
                        type CustomerRegistration implements DomainEvent
                        type PlaceOrder implements DomainEvent
                        type ProcessPayment implements DomainEvent
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Base Event Interface (Event Structure Patterns)</b></td>
                        <td>Define common structure for all domain events</td>
                        <td>
                            <ul>
                                <li>Common event metadata defined</li>
                                <li>Event identity fields included</li>
                                <li>Temporal information captured</li>
                                <li>Causation chain trackable</li>
                                <li>Source attribution clear</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Establish a consistent base interface for all events</li>
                                <li>Include essential metadata for traceability and debugging</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        interface DomainEvent {
                            # Event identity
                            eventId: ID!
                            eventType: String!

                            # Source information
                            aggregateId: ID!
                            aggregateType: String!
                            aggregateVersion: Int!

                            # Temporal information
                            occurredAt: DateTime!

                            # Event evolution
                            eventVersion: Int!

                            # Causation tracking
                            causationId: ID # ID of command that caused this event
                            correlationId: ID # ID linking related events
                            # Metadata
                            userId: ID # Who triggered the event
                            source: EventSource! # Where the event originated
                        }

                        enum EventSource {
                            USER_ACTION
                            SYSTEM_PROCESS
                            EXTERNAL_INTEGRATION
                            SCHEDULED_TASK
                            COMPENSATION
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Event Payload Patterns (Event Structure Patterns)</b></td>
                        <td>Structure event data for different use cases</td>
                        <td>
                            <ul>
                                <li>Event payload size appropriate</li>
                                <li>Critical data included in payload</li>
                                <li>Snapshots used for mutable data</li>
                                <li>References used for stable data</li>
                                <li>Payload evolution considered</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Decide whether to include full data or references based on consumer needs and data volatility</li>
                                <li>Use snapshots for mutable data at the time of the event</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # Minimal event - just the fact
                        type CustomerRegistered implements DomainEvent {
                            # Base event fields
                            eventId: ID!
                            aggregateId: ID!
                            occurredAt: DateTime!

                            # Minimal payload
                            customerId: ID!
                            email: String!
                        }

                        # Rich event - includes relevant context
                        type OrderPlaced implements DomainEvent {
                            # Base event fields
                            eventId: ID!
                            aggregateId: ID!
                            occurredAt: DateTime!

                            # Rich payload
                            orderNumber: String!
                            customerId: ID!
                            lineItems: [OrderLineItemSnapshot!]!
                            shippingAddress: AddressSnapshot!
                            totalAmount: Money!
                            paymentMethod: PaymentMethodSnapshot!
                            orderSource: OrderSource!
                        }

                        # Snapshot types for event data
                        type OrderLineItemSnapshot {
                            productSku: String!
                            productName: String!
                            quantity: Int!
                            unitPrice: Money!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Event Versioning (Event Structure Patterns)</b></td>
                        <td>Handle event schema evolution over time</td>
                        <td>
                            <ul>
                                <li>Event versioning strategy defined</li>
                                <li>Backward compatibility maintained</li>
                                <li>Version migration paths clear</li>
                                <li>Legacy version support planned</li>
                                <li>Schema evolution documented</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Plan for how event schemas will evolve without breaking existing consumers</li>
                                <li>Use version numbers and potentially unions for backward compatibility</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # Version 1 of event
                        type CustomerRegisteredV1 implements DomainEvent {
                            eventId: ID!
                            eventVersion: Int! # Always 1
                            customerId: ID!
                            email: String!
                        }

                        # Version 2 adds more fields
                        type CustomerRegisteredV2 implements DomainEvent {
                            eventId: ID!
                            eventVersion: Int! # Always 2
                            customerId: ID!
                            email: String!
                            # New fields in v2
                            customerNumber: String!
                            registrationChannel: RegistrationChannel!
                        }

                        # Union for handling multiple versions
                        union CustomerRegisteredEvent = CustomerRegisteredV1 | CustomerRegisteredV2

                        # Current version alias
                        type CustomerRegistered implements DomainEvent {
                            eventId: ID!
                            eventVersion: Int!
                            customerId: ID!
                            email: String!
                            customerNumber: String!
                            registrationChannel: RegistrationChannel!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Event Streams (Event Aggregation Patterns)</b></td>
                        <td>Group related events into streams</td>
                        <td>
                            <ul>
                                <li>Event streams logically grouped</li>
                                <li>Stream filtering available</li>
                                <li>Stream ordering preserved</li>
                                <li>Stream pagination supported</li>
                                <li>Stream subscription management</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Define clear logical groupings for events (e.g., by aggregate)</li>
                                <li>Provide mechanisms for filtering, ordering, and subscribing to event streams</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        type Subscription {
                            # Stream all events for an aggregate
                            customerEvents(customerId: ID!): CustomerEvent!

                            # Stream events by type
                            orderEvents(filter: OrderEventFilter): OrderEvent!

                            # Stream events by time range
                            domainEvents(
                                from: DateTime!
                                to: DateTime
                                eventTypes: [String!]
                            ): DomainEvent!
                        }

                        union CustomerEvent = CustomerRegistered | CustomerUpdated | CustomerDeactivated

                        union OrderEvent =
                          OrderPlaced
                        | OrderConfirmed
                        | OrderShipped
                        | OrderDelivered
                        | OrderCancelled

                        input OrderEventFilter {
                            customerId: ID
                            orderStatus: [OrderStatus!]
                            dateRange: DateRangeInput
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Event Projections (Event Aggregation Patterns)</b></td>
                        <td>Create read models from event streams</td>
                        <td>
                            <ul>
                                <li>Projections built from events</li>
                                <li>Projection state clearly defined</li>
                                <li>Projection versioning handled</li>
                                <li>Projection rebuilding supported</li>
                                <li>Projection consistency monitored</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Design projections to be eventually consistent, tailored for specific query needs</li>
                                <li>Ensure projections can be rebuilt from the event stream</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # Event-sourced aggregate state
                        type CustomerProjection {
                            customerId: ID!
                            currentState: CustomerState!
                            version: Int!
                            lastUpdated: DateTime!

                            # Projected from events
                            registrationDate: DateTime!
                            totalOrders: Int!
                            totalSpent: Money!
                            loyaltyLevel: LoyaltyLevel!

                            # Event history
                            eventHistory: [CustomerEvent!]!
                        }

                        type CustomerState {
                            customerNumber: String!
                            profile: CustomerProfile!
                            isActive: Boolean!
                            preferences: CustomerPreferences!
                        }

                        # Query projections
                        type Query {
                            customerProjection(customerId: ID!): CustomerProjection
                            customerProjections(
                                filter: CustomerProjectionFilter
                                orderBy: CustomerProjectionSort
                            ): [CustomerProjection!]!
                        }

                        input CustomerProjectionFilter {
                            isActive: Boolean
                            loyaltyLevel: [LoyaltyLevel!]
                            registeredAfter: DateTime
                            totalSpentRange: MoneyRangeInput
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Event Sagas (Event Aggregation Patterns)</b></td>
                        <td>Coordinate long-running business processes</td>
                        <td>
                            <ul>
                                <li>Saga state explicitly modeled</li>
                                <li>Saga steps clearly defined</li>
                                <li>Compensation actions tracked</li>
                                <li>Saga timeout handling</li>
                                <li>Saga failure recovery</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Model the state of the saga explicitly to track progress and handle failures</li>
                                <li>Define clear compensation actions for when a saga fails</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # Saga state tracking
                        type OrderFulfillmentSaga {
                            sagaId: ID!
                            orderId: ID!
                            currentStep: SagaStep!
                            status: SagaStatus!
                            startedAt: DateTime!
                            completedAt: DateTime

                            # Saga state
                            inventoryReserved: Boolean!
                            paymentProcessed: Boolean!
                            shippingArranged: Boolean!

                            # Compensation tracking
                            compensationActions: [CompensationAction!]!
                        }

                        enum SagaStep {
                            RESERVE_INVENTORY
                            PROCESS_PAYMENT
                            ARRANGE_SHIPPING
                            COMPLETE_ORDER
                        }

                        enum SagaStatus {
                            RUNNING
                            COMPLETED
                            FAILED
                            COMPENSATING
                            COMPENSATED
                        }

                        type CompensationAction {
                            actionType: String!
                            executedAt: DateTime!
                            reason: String!
                        }

                        # Saga coordination
                        type Mutation {
                            startOrderFulfillmentSaga(orderId: ID!): StartSagaResult!
                            compensateOrderFulfillment(sagaId: ID!, reason: String!): CompensationResult!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Event Publishing (Cross-Context Event Patterns)</b></td>
                        <td>Publish events for consumption by other contexts</td>
                        <td>
                            <ul>
                                <li>Event publishing mechanism defined</li>
                                <li>Event routing configured</li>
                                <li>Target contexts identified</li>
                                <li>Publishing reliability ensured</li>
                                <li>Event ordering preserved</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Define clear contracts for published events</li>
                                <li>Ensure reliable delivery and proper routing to interested consumers</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # Publishing context
                        type Mutation {
                            placeOrder(input: PlaceOrderInput!): PlaceOrderPayload!
                            # Publishes OrderPlaced event
                        }

                        type Subscription {
                            # Publish events to subscribers
                            orderEvents: OrderEvent!
                            inventoryEvents: InventoryEvent!
                            paymentEvents: PaymentEvent!
                        }

                        # Event metadata for routing
                        type OrderPlaced implements DomainEvent {
                            eventId: ID!
                            aggregateId: ID!

                            # Routing information
                            publishedTo: [String!]! # Target contexts
                            routingKey: String! # Message routing
                            # Business data
                            orderNumber: String!
                            customerId: ID!
                            totalAmount: Money!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Event Consumption (Cross-Context Event Patterns)</b></td>
                        <td>Consume events from other contexts</td>
                        <td>
                            <ul>
                                <li>Event subscription configured</li>
                                <li>Event handlers implemented</li>
                                <li>Error handling defined</li>
                                <li>Retry logic implemented</li>
                                <li>Dead letter handling</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Implement robust error handling and retry mechanisms for event consumption</li>
                                <li>Consider dead-letter queues for events that cannot be processed</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # Consuming context
                        type Subscription {
                            # Subscribe to external events
                            externalOrderEvents: OrderEvent!
                            externalCustomerEvents: CustomerEvent!
                        }

                        # Event handlers
                        type Mutation {
                            handleOrderPlaced(event: OrderPlacedInput!): HandleEventResult!
                            handleCustomerRegistered(event: CustomerRegisteredInput!): HandleEventResult!
                        }

                        type HandleEventResult {
                            success: Boolean!
                            eventId: ID!
                            processedAt: DateTime!
                            errors: [EventProcessingError!]!
                        }

                        type EventProcessingError {
                            code: String!
                            message: String!
                            retryable: Boolean!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Event Translation (Cross-Context Event Patterns)</b></td>
                        <td>Translate events between context boundaries</td>
                        <td>
                            <ul>
                                <li>Event translation rules defined</li>
                                <li>Data mapping documented</li>
                                <li>Translation errors handled</li>
                                <li>Schema compatibility maintained</li>
                                <li>Translation testing comprehensive</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Define clear translation rules and handle potential data mismatches</li>
                                <li>Ensure robust error handling for translation failures</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        # External event format
                        type ExternalOrderPlaced {
                            id: String!
                            customer_id: String!
                            order_total: Float!
                            currency: String!
                            timestamp: String!
                        }

                        # Internal event format
                        type OrderPlaced implements DomainEvent {
                            eventId: ID!
                            aggregateId: ID!
                            occurredAt: DateTime!

                            # Translated data
                            orderNumber: String!
                            customerId: ID!
                            totalAmount: Money!
                        }

                        # Translation service
                        type Mutation {
                            translateExternalEvent(externalEvent: ExternalEventInput!): TranslationResult!
                        }

                        type TranslationResult {
                            internalEvent: DomainEvent
                            translationErrors: [TranslationError!]!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Event Store Design (Event Sourcing Patterns)</b></td>
                        <td>Store events as the source of truth</td>
                        <td>
                            <ul>
                                <li>Event storage mechanism defined</li>
                                <li>Event retrieval patterns supported</li>
                                <li>Concurrency conflicts handled</li>
                                <li>Event ordering guaranteed</li>
                                <li>Storage scalability considered</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Choose an event store that supports immutable appends and efficient retrieval</li>
                                <li>Address concurrency and ensure strict event ordering</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        type EventStore {
                            # Event storage
                            appendEvent(event: DomainEventInput!): AppendResult!

                            # Event retrieval
                            getEvents(aggregateId: ID!, fromVersion: Int, toVersion: Int): [DomainEvent!]!

                            getEventsByType(
                                eventType: String!
                                from: DateTime
                                to: DateTime
                            ): [DomainEvent!]!
                        }

                        type AppendResult {
                            success: Boolean!
                            eventId: ID!
                            version: Int!
                            errors: [EventStoreError!]!
                        }

                        type EventStoreError {
                            code: EventStoreErrorCode!
                            message: String!
                        }

                        enum EventStoreErrorCode {
                            CONCURRENCY_CONFLICT
                            INVALID_EVENT
                            STORAGE_ERROR
                            SERIALIZATION_ERROR
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Snapshot Patterns (Event Sourcing Patterns)</b></td>
                        <td>Optimize event replay with snapshots</td>
                        <td>
                            <ul>
                                <li>Snapshot strategy defined</li>
                                <li>Snapshot frequency optimized</li>
                                <li>Snapshot consistency ensured</li>
                                <li>Snapshot storage managed</li>
                                <li>Rebuild performance monitored</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Determine optimal snapshot frequency to balance storage vs. replay performance</li>
                                <li>Ensure snapshots are consistent with the event stream</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        type AggregateSnapshot {
                            aggregateId: ID!
                            aggregateType: String!
                            version: Int!
                            snapshotData: JSON!
                            createdAt: DateTime!
                        }

                        type Query {
                            # Get latest snapshot
                            getSnapshot(aggregateId: ID!): AggregateSnapshot

                            # Rebuild from events
                            rebuildAggregate(
                                aggregateId: ID!
                                fromSnapshot: Boolean = true
                            ): AggregateRebuildResult!
                        }

                        type AggregateRebuildResult {
                            aggregateId: ID!
                            finalVersion: Int!
                            eventsProcessed: Int!
                            snapshotUsed: Boolean!
                            rebuildTime: Duration!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Event Metrics (Event Monitoring and Observability)</b></td>
                        <td>Monitor event processing and performance</td>
                        <td>
                            <ul>
                                <li>Event volume monitoring</li>
                                <li>Performance metrics tracked</li>
                                <li>Error rates monitored</li>
                                <li>Business metrics included</li>
                                <li>Alerting thresholds defined</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Define key metrics for event volume, performance, and errors</li>
                                <li>Set up alerting for critical thresholds</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        type EventMetrics {
                            # Volume metrics
                            eventsPublished: Int!
                            eventsConsumed: Int!
                            eventsPerSecond: Float!

                            # Performance metrics
                            averageProcessingTime: Duration!
                            processingLatency: Duration!

                            # Error metrics
                            processingErrors: Int!
                            errorRate: Float!
                            deadLetterCount: Int!

                            # Business metrics
                            eventsByType: [EventTypeMetric!]!
                            eventsBySource: [EventSourceMetric!]!
                        }

                        type EventTypeMetric {
                            eventType: String!
                            count: Int!
                            averageSize: Int!
                            errorRate: Float!
                        }

                        type Query {
                            eventMetrics(
                                timeRange: DateRangeInput!
                                aggregateBy: MetricAggregation!
                            ): EventMetrics!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Event Tracing (Event Monitoring and Observability)</b></td>
                        <td>Trace event flows across contexts</td>
                        <td>
                            <ul>
                                <li>Event tracing implemented</li>
                                <li>Correlation IDs tracked</li>
                                <li>Cross-context flows visible</li>
                                <li>Performance bottlenecks identified</li>
                                <li>Trace data retention managed</li>
                            </ul>
                        </td>
                        <td>
                            <ul>
                                <li>Implement correlation IDs to trace events across multiple services</li>
                                <li>Visualize event flows to identify bottlenecks and issues</li>
                            </ul>
                        </td>
                        <td>
                        ```graphql
                        type EventTrace {
                            traceId: ID!
                            correlationId: ID!
                            events: [TracedEvent!]!
                            totalDuration: Duration!
                            contextTransitions: Int!
                        }

                        type TracedEvent {
                            eventId: ID!
                            eventType: String!
                            context: String!
                            timestamp: DateTime!
                            processingDuration: Duration!
                            causedBy: ID # Previous event in chain
                            causedEvents: [ID!]! # Subsequent events
                        }

                        type Query {
                            traceEvents(correlationId: ID!, traceId: ID): EventTrace!

                            findEventTraces(
                                aggregateId: ID
                                eventType: String
                                timeRange: DateRangeInput!
                            ): [EventTrace!]!
                        }
                        ```
                        </td>
                    </tr>
                </tbody>
            </table>
            </TabItem>
        </Tabs>
    </TabItem>
    <TabItem value="schema" label="Schema">
        <Tabs queryString="secondary">
            <TabItem value="schema-subgraph-relationships" label="Subgraph Relationships" attributes={{className:"tabs__vertical"}}>
                <table class="text_vertical">
                    <thead>
                        <tr>
                            <th>DDD Concept</th>
                            <th>Definition</th>
                            <th>Characteristics</th>
                            <th>Considerations</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><b>Cross-Subgraph Relationships</b></td>
                            <td>Fundamental to GraphQL federation, enabling distributed domain models while maintaining bounded context integrity</td>
                            <td>Patterns for modeling relationships that span multiple subgraphs in DDD-compliant ways</td>
                            <td>Ensuring bounded context integrity, effective communication between subgraphs</td>
                            <td>
                                See individual relationship patterns for examples.
                            </td>
                        </tr>
                        <tr>
                            <td><b>Reference Relationships</b></td>
                            <td>One entity references another entity by stable identifier</td>
                            <td>
                                <ul>
                                    <li>References use stable, immutable identifiers</li>
                                    <li>Referenced entities are owned by appropriate contexts</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Is the referenced entity owned by another bounded context?</li>
                                    <li>Is the relationship stable over time?</li>
                                    <li>Do you need immediate access to referenced entity data?</li>
                                    <li>Reference integrity is handled at application level</li>
                                    <li>Broken references are handled gracefully</li>
                                    <li>Reference relationships are documented</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Order subgraph - owns Order entity
                            type Order @key(fields: "id") {
                                id: ID!
                                orderNumber: String!
                                customerId: ID! # Reference to Customer entity
                                productIds: [ID!]! # References to Product entities
                                status: OrderStatus!
                                totalAmount: Money!
                            }

                            # Customer subgraph - owns Customer entity
                            type Customer @key(fields: "id") {
                                id: ID!
                                customerNumber: String!
                                profile: CustomerProfile!
                            }

                            # Product subgraph - owns Product entity
                            type Product @key(fields: "sku") {
                                sku: String!
                                name: String!
                                price: Money!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Federated Navigation Relationships</b></td>
                            <td>Enable rich navigation across subgraph boundaries using federation</td>
                            <td>
                                <ul>
                                    <li>Federation keys are properly defined</li>
                                    <li>External fields are marked correctly</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Navigation relationships are bidirectional where needed</li>
                                    <li>Performance implications are considered</li>
                                    <li>Error handling for unavailable services</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Order subgraph
                            type Order @key(fields: "id") {
                                id: ID!
                                orderNumber: String!
                                customerId: ID!

                                # Federated navigation to Customer
                                customer: Customer!

                                # Federated navigation to Products
                                lineItems: [LineItem!]!
                            }

                            type LineItem {
                                productSku: String!
                                quantity: Int!
                                unitPrice: Money!

                                # Federated navigation to Product
                                product: Product!
                            }

                            # Customer subgraph
                            type Customer @key(fields: "id") {
                                id: ID!
                                customerNumber: String!
                                profile: CustomerProfile!
                            }

                            # Extend Customer with order-related data
                            extend type Customer @key(fields: "id") {
                                id: ID! @external

                                # Back-navigation to orders
                                orders: [Order!]!
                                recentOrders: [Order!]!
                                orderHistory: OrderHistory!
                            }

                            # Product subgraph
                            type Product @key(fields: "sku") {
                                sku: String!
                                name: String!
                                description: String!
                                price: Money!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Aggregated Relationships</b></td>
                            <td>Provide aggregated views of cross-subgraph data</td>
                            <td>
                                <ul>
                                    <li>Aggregations are computed in owning context</li>
                                    <li>Aggregation data is kept up-to-date</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Performance of aggregation queries is acceptable</li>
                                    <li>Aggregation consistency is managed</li>
                                    <li>Aggregation evolution is planned</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Customer subgraph
                            type Customer @key(fields: "id") {
                                id: ID!
                                profile: CustomerProfile!
                            }

                            # Order subgraph extends Customer with order aggregations
                            extend type Customer @key(fields: "id") {
                                id: ID! @external

                                # Aggregated order data
                                orderStatistics: OrderStatistics!
                                loyaltyMetrics: LoyaltyMetrics!
                            }

                            type OrderStatistics {
                                totalOrders: Int!
                                totalSpent: Money!
                                averageOrderValue: Money!
                                lastOrderDate: DateTime!

                                # Time-based aggregations
                                ordersThisYear: Int!
                                spentThisYear: Money!
                                ordersThisMonth: Int!
                                spentThisMonth: Money!
                            }

                            type LoyaltyMetrics {
                                loyaltyPoints: Int!
                                loyaltyLevel: LoyaltyLevel!
                                nextLevelRequirement: Int!
                                lifetimeValue: Money!
                            }

                            # Product subgraph extends Customer with product preferences
                            extend type Customer @key(fields: "id") {
                                id: ID! @external

                                # Product-related aggregations
                                favoriteCategories: [ProductCategory!]!
                                recommendedProducts: [Product!]!
                                purchaseHistory: ProductPurchaseHistory!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Event-Driven Relationships</b></td>
                            <td>Maintain relationship consistency through domain events</td>
                            <td>
                                <ul>
                                    <li>Events represent meaningful business occurrences</li>
                                    <li>Event schemas are stable and versioned</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Event processing is idempotent</li>
                                    <li>Event ordering is handled correctly</li>
                                    <li>Event failure recovery is implemented</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Customer subgraph publishes events
                            type Subscription {
                                customerEvents: CustomerEvent!
                            }

                            union CustomerEvent = CustomerRegistered | CustomerUpdated | CustomerDeactivated

                            type CustomerRegistered implements DomainEvent {
                                eventId: ID!
                                customerId: ID!
                                customerNumber: String!
                                email: String!
                                registrationDate: DateTime!
                            }

                            # Order subgraph consumes customer events
                            type Mutation {
                                # Event handlers (internal)
                                handleCustomerRegistered(event: CustomerRegisteredInput!): HandleEventResult!
                                handleCustomerUpdated(event: CustomerUpdatedInput!): HandleEventResult!
                            }

                            # Order subgraph maintains customer snapshot
                            type CustomerSnapshot {
                                customerId: ID!
                                customerNumber: String!
                                email: String!
                                isActive: Boolean!
                                lastSyncedAt: DateTime!
                            }

                            type Order @key(fields: "id") {
                                id: ID!
                                customerId: ID!

                                # Reference to local customer snapshot
                                customerSnapshot: CustomerSnapshot!

                                # Federated reference to live customer data
                                customer: Customer!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Conditional Relationships</b></td>
                            <td>Relationships that exist only under certain conditions</td>
                            <td>
                                <ul>
                                    <li>Conditions are clearly documented</li>
                                    <li>Conditional logic is consistent</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Error handling for invalid conditions</li>
                                    <li>Performance impact of conditions considered</li>
                                    <li>Conditions are testable</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Customer @key(fields: "id") {
                                id: ID!
                                profile: CustomerProfile!
                                status: CustomerStatus!
                            }

                            # Order subgraph
                            extend type Customer @key(fields: "id") {
                                id: ID! @external
                                status: CustomerStatus! @external

                                # Conditional relationships based on status
                                activeOrders: [Order!]! # Only for active customers
                                orderHistory: OrderHistory # Only for customers with orders
                                loyaltyProgram: LoyaltyProgram # Only for eligible customers
                            }

                            type Query {
                                # Conditional queries
                                customerOrders(customerId: ID!, includeInactive: Boolean = false): [Order!]!
                            }

                            # Resolver logic handles conditions
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Temporal Relationships</b></td>
                            <td>Relationships that change over time</td>
                            <td>
                                <ul>
                                    <li>Temporal boundaries are clearly defined</li>
                                    <li>Historical data is preserved</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Time-based queries are efficient</li>
                                    <li>Temporal consistency is maintained</li>
                                    <li>Timezone handling is correct</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Customer @key(fields: "id") {
                                id: ID!
                                profile: CustomerProfile!
                            }

                            # Subscription subgraph
                            extend type Customer @key(fields: "id") {
                                id: ID! @external

                                # Current subscription
                                currentSubscription: Subscription

                                # Historical subscriptions
                                subscriptionHistory: [Subscription!]!

                                # Time-based queries
                                subscriptionAt(date: DateTime!): Subscription
                                subscriptionsDuring(period: DateRange!): [Subscription!]!
                            }

                            type Subscription @key(fields: "id") {
                                id: ID!
                                customerId: ID!
                                plan: SubscriptionPlan!

                                # Temporal information
                                startDate: DateTime!
                                endDate: DateTime
                                status: SubscriptionStatus!

                                # Temporal relationships
                                previousSubscription: Subscription
                                nextSubscription: Subscription
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Hierarchical Relationships</b></td>
                            <td>Parent-child relationships across subgraphs</td>
                            <td>
                                <ul>
                                    <li>Hierarchy levels are clearly defined</li>
                                    <li>Parent-child relationships are consistent</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Circular references are prevented</li>
                                    <li>Hierarchy navigation is efficient</li>
                                    <li>Hierarchy changes are handled correctly</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Organization subgraph
                            type Organization @key(fields: "id") {
                                id: ID!
                                name: String!
                                type: OrganizationType!
                            }

                            # Customer subgraph
                            type Customer @key(fields: "id") {
                                id: ID!
                                profile: CustomerProfile!
                                organizationId: ID # Reference to organization
                            }

                            # Extend Organization with customer relationships
                            extend type Organization @key(fields: "id") {
                                id: ID! @external

                                # Hierarchical customer relationships
                                customers: [Customer!]!
                                primaryContact: Customer
                                billingContact: Customer

                                # Aggregated customer data
                                customerCount: Int!
                                totalCustomerValue: Money!
                            }

                            # Extend Customer with organization context
                            extend type Customer @key(fields: "id") {
                                id: ID! @external

                                # Parent organization
                                organization: Organization

                                # Role within organization
                                organizationRole: OrganizationRole
                                permissions: [Permission!]!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Data Locality Optimization</b></td>
                            <td>Optimize data placement for common query patterns</td>
                            <td>
                                <ul>
                                    <li>Frequently accessed data is co-located</li>
                                    <li>Data duplication is minimized</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Data consistency is maintained</li>
                                    <li>Update mechanisms are in place</li>
                                    <li>Performance gains are measured</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Order subgraph includes frequently accessed customer data
                            type Order @key(fields: "id") {
                                id: ID!
                                orderNumber: String!
                                customerId: ID!

                                # Local customer data for performance
                                customerSnapshot: CustomerSnapshot!

                                # Full customer data via federation
                                customer: Customer! @provides(fields: "customerNumber email")
                            }

                            type CustomerSnapshot {
                                customerNumber: String!
                                email: String!
                                name: String!
                                loyaltyLevel: LoyaltyLevel!
                                # Snapshot of frequently needed customer data
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Batch Loading Patterns</b></td>
                            <td>Optimize cross-subgraph data loading</td>
                            <td>
                                <ul>
                                    <li>Batch loading is implemented for N+1 problems</li>
                                    <li>Batch sizes are optimized</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Caching is implemented where appropriate</li>
                                    <li>Error handling for batch failures</li>
                                    <li>Performance monitoring is in place</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Product subgraph
                            type Product @key(fields: "sku") {
                                sku: String!
                                name: String!
                                price: Money!
                            }

                            # Order subgraph with batch loading
                            type Order @key(fields: "id") {
                                id: ID!
                                lineItems: [LineItem!]!
                            }

                            type LineItem {
                                productSku: String!
                                quantity: Int!

                                # Batch loaded product data
                                product: Product!
                            }

                            # Resolver implements DataLoader pattern for batch loading
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Caching Strategies</b></td>
                            <td>Cache cross-subgraph relationship data</td>
                            <td>
                                <ul>
                                    <li>Cache invalidation strategy is defined</li>
                                    <li>Cache TTL is appropriate</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Cache consistency is maintained</li>
                                    <li>Cache performance is monitored</li>
                                    <li>Cache failures are handled gracefully</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Customer @key(fields: "id") {
                                id: ID!
                                profile: CustomerProfile!

                                # Cached relationship data
                                recentOrders: [Order!]! # Cached for performance
                                orderSummary: OrderSummary! # Pre-computed and cached
                            }

                            type OrderSummary {
                                totalOrders: Int!
                                totalSpent: Money!
                                lastOrderDate: DateTime!

                                # Cache metadata
                                lastUpdated: DateTime!
                                cacheExpiry: DateTime!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Graceful Degradation</b></td>
                            <td>Handle subgraph unavailability gracefully</td>
                            <td>
                                <ul>
                                    <li>Fallback data is available</li>
                                    <li>Service unavailability is handled</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Error messages are informative</li>
                                    <li>Partial data is clearly indicated</li>
                                    <li>Recovery mechanisms are in place</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Customer @key(fields: "id") {
                                id: ID!
                                profile: CustomerProfile!
                            }

                            extend type Customer @key(fields: "id") {
                                id: ID! @external

                                # May return null if order service unavailable
                                orders: [Order!]

                                # Cached/snapshot data always available
                                orderSummary: OrderSummary!
                            }

                            type OrderSummary {
                                totalOrders: Int!
                                lastOrderDate: DateTime!
                                isLive: Boolean! # Indicates if data is current
                                lastUpdated: DateTime!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Circuit Breaker Pattern</b></td>
                            <td>Prevent cascade failures in cross-subgraph calls</td>
                            <td>
                                <ul>
                                    <li>Circuit breaker thresholds are configured</li>
                                    <li>Service health is monitored</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Fallback behavior is defined</li>
                                    <li>Recovery testing is performed</li>
                                    <li>Alerts are configured for service issues</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Customer @key(fields: "id") {
                                id: ID!
                                profile: CustomerProfile!
                            }

                            extend type Customer @key(fields: "id") {
                                id: ID! @external

                                # Protected by circuit breaker
                                orders: [Order!]

                                # Service health indicator
                                orderServiceStatus: ServiceStatus!
                            }

                            enum ServiceStatus {
                                AVAILABLE
                                DEGRADED
                                UNAVAILABLE
                            }
                            ```
                            </td>
                        </tr>
                    </tbody>
                </table>
            </TabItem>
            <TabItem value="schema-naming-conventions" label="Naming Conventions">
                <table>
                    <thead>
                        <tr>
                            <th>DDD Concept</th>
                            <th>Definition</th>
                            <th>Characteristics</th>
                            <th>Considerations</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><b>Ubiquitous Language</b></td>
                            <td>A common language shared between domain experts and developers, reflected in code and schema</td>
                            <td>
                                <ul>
                                    <li>Type names must use domain terminology, not technical terms</li>
                                    <li>Names match domain expert vocabulary</li>
                                    <li>No technical abbreviations in public schema</li>
                                    <li>Consistent terminology across all types</li>
                                    <li>Names are meaningful to business users</li>
                                    <li>Domain concepts clearly expressed</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>All type names use business terminology</li>
                                    <li>Ensures clarity and maintainability</li>
                                    <li>Reduces miscommunication between teams</li>
                                    <li>Supports long-term schema evolution</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # ✅ Good - Uses business language
                            type Customer {
                                customerNumber: String!
                                loyaltyLevel: LoyaltyLevel!
                                creditLimit: Money!
                            }

                            type Order {
                                orderNumber: String!
                                fulfillmentStatus: FulfillmentStatus!
                                shippingMethod: ShippingMethod!
                            }

                            # ❌ Bad - Uses technical language
                            type CustomerRecord {
                                custId: String!
                                lvl: Int!
                                creditAmt: Float!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Clarity and Readability</b></td>
                            <td>Names should be self-documenting and unambiguous</td>
                            <td>
                                <ul>
                                    <li>Names are descriptive and specific</li>
                                    <li>No ambiguous abbreviations</li>
                                    <li>Boolean fields clearly indicate true/false meaning (e.g., `isAvailableForPurchase`)</li>
                                    <li>Collection fields indicate plurality (e.g., `lineItems`)</li>
                                    <li>Purpose is clear from name alone</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Improves understanding for all schema users</li>
                                    <li>Reduces the need for external documentation</li>
                                    <li>Facilitates easier debugging and maintenance</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # ✅ Good - Clear and specific
                            type ProductCatalogEntry {
                                productSku: String!
                                displayName: String!
                                shortDescription: String!
                                detailedDescription: String!
                                isAvailableForPurchase: Boolean!
                            }

                            # ❌ Bad - Ambiguous and unclear
                            type Product {
                                id: String!
                                name: String!
                                desc: String!
                                info: String!
                                flag: Boolean!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Consistency</b></td>
                            <td>Apply naming patterns consistently across the entire schema</td>
                            <td>
                                <ul>
                                    <li>ID fields follow consistent pattern (e.g., `customerId`, `orderId`)</li>
                                    <li>Date fields use consistent suffixes (e.g., `registrationDate`, `lastLoginDate`)</li>
                                    <li>Similar concepts use similar naming</li>
                                    <li>Patterns applied across all types</li>
                                    <li>Exceptions are documented</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Ensures predictability and reduces cognitive load</li>
                                    <li>Streamlines development and integration</li>
                                    <li>Supports automated tooling and code generation</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # ✅ Good - Consistent patterns
                            type Customer {
                                customerId: ID!
                                customerNumber: String!
                                registrationDate: DateTime!
                                lastLoginDate: DateTime!
                            }

                            type Order {
                                orderId: ID!
                                orderNumber: String!
                                placementDate: DateTime!
                                lastModifiedDate: DateTime!
                            }

                            # ❌ Bad - Inconsistent patterns
                            type Customer {
                                id: ID!
                                customerNum: String!
                                registered: DateTime!
                                lastLogin: DateTime!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Entity Types Naming</b></td>
                            <td>Use singular nouns in PascalCase for entity types</td>
                            <td>
                                <ul>
                                    <li>Singular noun form</li>
                                    <li>PascalCase formatting (e.g., `Customer`, `Product`)</li>
                                    <li>No prefixes or suffixes unless necessary for compound names</li>
                                    <li>Compound names clearly joined (e.g., `CustomerProfile`)</li>
                                    <li>Names reflect domain concepts</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Clearly identifies core domain entities</li>
                                    <li>Aligns with common GraphQL type naming conventions</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Entity types
                            type Customer @key(fields: "id") {
                                id: ID!
                                customerNumber: String!
                            }

                            type Product @key(fields: "sku") {
                                sku: String!
                                name: String!
                            }

                            # Compound entity names
                            type CustomerProfile {
                                personalInfo: PersonalInfo!
                                contactInfo: ContactInfo!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Value Object Types Naming</b></td>
                            <td>Use descriptive nouns that indicate the value's purpose</td>
                            <td>
                                <ul>
                                    <li>Names indicate value purpose (e.g., `Money`, `Address`)</li>
                                    <li>No "Value" or "Object" suffixes</li>
                                    <li>Descriptive and specific</li>
                                    <li>Consistent with domain language</li>
                                    <li>Clear semantic meaning</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Distinguishes value objects from entities</li>
                                    <li>Promotes reusability of common data structures</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Value objects
                            type Money {
                                amount: Decimal!
                                currency: Currency!
                            }

                            type Address {
                                street: String!
                                city: String!
                                postalCode: String!
                                country: String!
                            }

                            # Measurement value objects
                            type Weight {
                                value: Decimal!
                                unit: WeightUnit!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Enum Types Naming</b></td>
                            <td>Use singular nouns with descriptive suffixes when needed</td>
                            <td>
                                <ul>
                                    <li>Enum type names are singular (e.g., `Currency`, `OrderStatus`)</li>
                                    <li>Enum values are UPPER_SNAKE_CASE (e.g., `USD`, `PENDING_PAYMENT`)</li>
                                    <li>Values are descriptive and clear</li>
                                    <li>No redundant prefixes in values</li>
                                    <li>Logical grouping of related values</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Provides clear, self-documenting lists of discrete values</li>
                                    <li>Ensures consistent representation of fixed choices</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Simple enums
                            enum Currency {
                                USD
                                EUR
                                GBP
                            }

                            enum OrderStatus {
                                DRAFT
                                PENDING_PAYMENT
                                CONFIRMED
                            }

                            # Enums with descriptive suffixes
                            enum PaymentMethod {
                                CREDIT_CARD
                                DEBIT_CARD
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Interface Types Naming</b></td>
                            <td>Use descriptive names that indicate the common contract</td>
                            <td>
                                <ul>
                                    <li>Names indicate common behavior or contract (e.g., `Identifiable`, `Purchasable`)</li>
                                    <li>Use adjective forms when appropriate (e.g., `Timestamped`)</li>
                                    <li>Clear semantic meaning</li>
                                    <li>No "Interface" suffix</li>
                                    <li>Focused on single responsibility</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Defines shared behaviors and structures across types</li>
                                    <li>Promotes schema extensibility and polymorphism</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Domain interfaces
                            interface DomainEvent {
                                eventId: ID!
                                aggregateId: ID!
                                occurredAt: DateTime!
                            }

                            interface Identifiable {
                                id: ID!
                            }

                            # Business capability interfaces
                            interface Purchasable {
                                price: Money!
                                isAvailable: Boolean!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Union Types Naming</b></td>
                            <td>Use descriptive names that indicate the union purpose</td>
                            <td>
                                <ul>
                                    <li>Names indicate union purpose (e.g., `OrderEvent`, `SearchResult`)</li>
                                    <li>Clear semantic grouping</li>
                                    <li>No "Union" suffix</li>
                                    <li>Logical member types</li>
                                    <li>Consistent with domain concepts</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Allows for returning multiple possible types for a single field</li>
                                    <li>Enhances flexibility in representing diverse but related data</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Event unions
                            union OrderEvent = OrderPlaced | OrderShipped | OrderDelivered

                            # Search result unions
                            union SearchResult = Product | Category | Brand

                            # Error unions
                            union ValidationError = FieldError | BusinessRuleError
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Scalar Fields Naming</b></td>
                            <td>Use camelCase with descriptive names</td>
                            <td>
                                <ul>
                                    <li>camelCase formatting (e.g., `firstName`, `totalOrderCount`)</li>
                                    <li>Descriptive and specific</li>
                                    <li>Boolean fields start with "is", "has", "can", etc. (e.g., `isActive`)</li>
                                    <li>Date fields end with "Date" (e.g., `registrationDate`)</li>
                                    <li>Count fields end with "Count" (e.g., `totalOrderCount`)</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Provides clear and consistent field access</li>
                                    <li>Aligns with common JavaScript/GraphQL field naming conventions</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Customer {
                                firstName: String!
                                lastName: String!
                                emailAddress: String!
                                isActive: Boolean!
                                registrationDate: DateTime!
                                totalOrderCount: Int!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Object Fields Naming</b></td>
                            <td>Use camelCase names that indicate the relationship</td>
                            <td>
                                <ul>
                                    <li>Names indicate relationship type (e.g., `profile`, `billingAddress`)</li>
                                    <li>Singular for single objects (e.g., `customer`)</li>
                                    <li>Plural for collections (e.g., `lineItems`)</li>
                                    <li>Clear ownership vs. reference</li>
                                    <li>Consistent relationship naming</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Defines relationships between different types in the schema</li>
                                    <li>Enhances graph traversability and data retrieval</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Customer {
                                profile: CustomerProfile!
                                billingAddress: Address!
                                primaryPaymentMethod: PaymentMethod
                            }

                            type Order {
                                lineItems: [LineItem!]!
                                customer: Customer!
                                paymentMethod: PaymentMethod!
                            }

                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Collection Fields Naming</b></td>
                            <td>Use plural nouns that clearly indicate the collection contents</td>
                            <td>
                                <ul>
                                    <li>Plural noun forms (e.g., `orders`, `paymentMethods`)</li>
                                    <li>Clear collection contents</li>
                                    <li>Descriptive qualifiers when filtered (e.g., `activeOrders`, `recommendedProducts`)</li>
                                    <li>Consistent collection naming</li>
                                    <li>Appropriate nullability (e.g., `[Order!]!`)</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Represents lists of related items</li>
                                    <li>Facilitates querying multiple entities at once</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Customer {
                                orders: [Order!]!
                                paymentMethods: [PaymentMethod!]!
                                activeOrders: [Order!]!
                            }

                            type Product {
                                variants: [ProductVariant!]!
                                categories: [Category!]!
                                images: [ProductImage!]!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Query Operations Naming</b></td>
                            <td>Use descriptive verbs and nouns that indicate the query purpose</td>
                            <td>
                                <ul>
                                    <li>Descriptive query names (e.g., `customer`, `searchProducts`, `calculateShipping`)</li>
                                    <li>Consistent parameter naming</li>
                                    <li>Clear return type indication</li>
                                    <li>Logical grouping of related queries</li>
                                    <li>Appropriate nullability</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Defines entry points for data retrieval</li>
                                    <li>Ensures clarity on what data can be fetched</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Query {
                                customer(id: ID!): Customer
                                products(filter: ProductFilter): [Product!]!
                                searchProducts(query: String!): ProductSearchResult!
                                calculateShipping(input: ShippingCalculationInput!): ShippingQuote!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Mutation Operations Naming</b></td>
                            <td>Use imperative verbs that clearly describe the action</td>
                            <td>
                                <ul>
                                    <li>Imperative verb forms (e.g., `createCustomer`, `updateOrderStatus`, `cancelOrder`)</li>
                                    <li>Clear action description</li>
                                    <li>Consistent input/payload pattern (e.g., `CreateCustomerInput`, `CreateCustomerPayload`)</li>
                                    <li>Business-focused operation names</li>
                                    <li>Appropriate error handling</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Defines operations that modify data</li>
                                    <li>Provides clear intent for state changes</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Mutation {
                                createCustomer(input: CreateCustomerInput!): CreateCustomerPayload!
                                updateOrderStatus(input: UpdateOrderStatusInput!): UpdateOrderStatusPayload!
                                cancelOrder(orderId: ID!, reason: String!): CancelOrderPayload!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Subscription Operations Naming</b></td>
                            <td>Use descriptive names that indicate the event stream</td>
                            <td>
                                <ul>
                                    <li>Names indicate event streams (e.g., `customerUpdates`, `orderEvents`)</li>
                                    <li>Clear subscription purpose</li>
                                    <li>Appropriate filtering options</li>
                                    <li>Consistent event naming</li>
                                    <li>Real-time semantics clear</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Enables real-time data updates</li>
                                    <li>Supports event-driven architectures</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Subscription {
                                customerUpdates(customerId: ID!): CustomerEvent!
                                orderEvents(filter: OrderEventFilter): OrderEvent!
                                priceUpdates(productSkus: [String!]!): PriceUpdate!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Input Types Naming</b></td>
                            <td>Use descriptive names with "Input" suffix</td>
                            <td>
                                <ul>
                                    <li>"Input" suffix for all input types (e.g., `CreateCustomerInput`, `CustomerFilter`)</li>
                                    <li>Descriptive base names</li>
                                    <li>Appropriate field nullability</li>
                                    <li>Logical field grouping</li>
                                    <li>Consistent with output types</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Clearly identifies types used for mutation arguments</li>
                                    <li>Promotes reusability of complex input structures</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            input CreateCustomerInput {
                                firstName: String!
                                lastName: String!
                                emailAddress: String!
                            }

                            input CustomerFilter {
                                isActive: Boolean
                                registeredAfter: DateTime
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Payload Types Naming</b></td>
                            <td>Use descriptive names with "Payload" suffix</td>
                            <td>
                                <ul>
                                    <li>"Payload" suffix for all payload types (e.g., `CreateCustomerPayload`, `UpdateCustomerPayload`)</li>
                                    <li>Include primary result object</li>
                                    <li>Include error and warning arrays</li>
                                    <li>Additional metadata when relevant (e.g., `orderNumber`, `estimatedDelivery`)</li>
                                    <li>Consistent error handling pattern</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Standardizes mutation responses</li>
                                    <li>Provides a consistent way to return data, errors, and warnings</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type CreateCustomerPayload {
                                customer: Customer
                                errors: [Error!]!
                                warnings: [Warning!]!
                            }

                            type PlaceOrderPayload {
                                order: Order
                                orderNumber: String!
                                confirmationNumber: String!
                                errors: [Error!]!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Subgraph Naming</b></td>
                            <td>Use domain-focused names that reflect bounded contexts</td>
                            <td>
                                <ul>
                                    <li>Domain-focused names (e.g., `customer-management`, `order-processing`)</li>
                                    <li>Kebab-case formatting</li>
                                    <li>Clear business capability indication</li>
                                    <li>No technical implementation details</li>
                                    <li>Consistent with bounded context names</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Organizes a federated graph into logical, self-contained services</li>
                                    <li>Promotes team autonomy and clear ownership</li>
                                </ul>
                            </td>
                            <td>
                            ```markdown
                            customer-management
                            product-catalog
                            order-processing
                            inventory-management
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Deprecation Naming</b></td>
                            <td>Use clear deprecation messages with migration guidance</td>
                            <td>
                                <ul>
                                    <li>Clear deprecation reasons provided</li>
                                    <li>Migration guidance provided</li>
                                    <li>Version information when relevant</li>
                                    <li>Alternative field/value indicated</li>
                                    <li>Consistent deprecation messaging</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Communicates changes to consumers without breaking existing integrations</li>
                                    <li>Facilitates a smooth evolution of the schema</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Customer {
                                email: String @deprecated(reason: "Use profile.contactInfo.emailAddress instead")
                                phone: String @deprecated(reason: "Use profile.contactInfo.phoneNumber instead")
                            }

                            enum OrderStatus {
                                PENDING @deprecated(reason: "Use PENDING_PAYMENT instead")
                                PENDING_PAYMENT
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Versioning Conventions</b></td>
                            <td>Use semantic versioning concepts in schema evolution</td>
                            <td>
                                <ul>
                                    <li>Version information tracked</li>
                                    <li>Breaking changes documented</li>
                                    <li>Migration paths clear</li>
                                    <li>Backward compatibility maintained where possible</li>
                                    <li>Evolution strategy defined</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Manages schema changes over time</li>
                                    <li>Ensures stability for consumers while allowing for new features</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type CustomerV2 {
                                id: ID!
                                customerNumber: String!
                                profile: CustomerProfileV2!
                            }

                            type SchemaInfo {
                                version: String! # "2.1.0"
                                deprecatedFields: [DeprecatedField!]!
                            }
                            ```
                            </td>
                        </tr>
                    </tbody>
                </table>
            </TabItem>
            <TabItem value="schema-strategies" label="Strategies">
                <table class="text_vertical">
                    <thead>
                        <tr>
                            <th>DDD Concept</th>
                            <th>Definition</th>
                            <th>Characteristics</th>
                            <th>Considerations</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><b>Domain-Centric Organization</b></td>
                            <td>Organize schema files around domain concepts and aggregates</td>
                            <td>
                                <ul>
                                    <li>Files grouped by domain concepts</li>
                                    <li>Related types co-located</li>
                                    <li>Clear separation of concerns</li>
                                    <li>Shared types properly organized</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Schema composition is clear</li>
                                </ul>
                            </td>
                            <td>
                            ```markdown
                            customer-subgraph/
                            ├── schema/
                            │   ├── customer/
                            │   │   ├── customer.graphql
                            │   │   ├── customer-profile.graphql
                            │   │   ├── customer-queries.graphql
                            │   │   └── customer-mutations.graphql
                            │   ├── address/
                            │   │   ├── address.graphql
                            │   │   └── address-validation.graphql
                            │   ├── loyalty/
                            │   │   ├── loyalty-program.graphql
                            │   │   └── loyalty-calculations.graphql
                            │   ├── shared/
                            │   │   ├── scalars.graphql
                            │   │   ├── enums.graphql
                            │   │   └── interfaces.graphql
                            │   └── schema.graphql
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Layer-Based Organization</b></td>
                            <td>Organize schema files by architectural layers</td>
                            <td>
                                <ul>
                                    <li>Clear architectural layers</li>
                                    <li>Consistent layer organization</li>
                                    <li>Dependencies flow correctly</li>
                                    <li>Layer boundaries respected</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Easy to navigate structure</li>
                                </ul>
                            </td>
                            <td>
                            ```markdown
                            order-subgraph/
                            ├── schema/
                            │   ├── entities/
                            │   │   ├── order.graphql
                            │   │   ├── line-item.graphql
                            │   │   └── order-status.graphql
                            │   ├── value-objects/
                            │   │   ├── money.graphql
                            │   │   ├── address.graphql
                            │   │   └── date-range.graphql
                            │   ├── services/
                            │   │   ├── pricing-service.graphql
                            │   │   ├── shipping-service.graphql
                            │   │   └── tax-service.graphql
                            │   ├── events/
                            │   │   ├── order-events.graphql
                            │   │   └── event-interfaces.graphql
                            │   ├── operations/
                            │   │   ├── queries.graphql
                            │   │   ├── mutations.graphql
                            │   │   └── subscriptions.graphql
                            │   └── schema.graphql
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Feature-Based Organization</b></td>
                            <td>Organize schema files around business features</td>
                            <td>
                                <ul>
                                    <li>Features clearly defined</li>
                                    <li>Feature boundaries respected</li>
                                    <li>Cross-feature dependencies minimized</li>
                                    <li>Feature evolution supported</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Business alignment clear</li>
                                </ul>
                            </td>
                            <td>
                            ```markdown
                            product-subgraph/
                            ├── schema/
                            │   ├── catalog-management/
                            │   │   ├── product.graphql
                            │   │   ├── category.graphql
                            │   │   ├── catalog-queries.graphql
                            │   │   └── catalog-mutations.graphql
                            │   ├── inventory-tracking/
                            │   │   ├── inventory.graphql
                            │   │   ├── stock-levels.graphql
                            │   │   └── inventory-operations.graphql
                            │   ├── pricing/
                            │   │   ├── price.graphql
                            │   │   ├── discounts.graphql
                            │   │   └── pricing-rules.graphql
                            │   ├── search/
                            │   │   ├── search-types.graphql
                            │   │   ├── filters.graphql
                            │   │   └── search-operations.graphql
                            │   └── schema.graphql
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Aggregate-Centric Type Grouping</b></td>
                            <td>Group types around domain aggregates</td>
                            <td>
                                <ul>
                                    <li>Aggregate boundaries clear</li>
                                    <li>Related types grouped together</li>
                                    <li>Aggregate operations co-located</li>
                                    <li>Aggregate consistency maintained</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Clear ownership model</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # customer-aggregate.graphql
                            # Customer Aggregate Root
                            type Customer @key(fields: "id") {
                                id: ID!
                                customerNumber: String!
                                profile: CustomerProfile!
                                status: CustomerStatus!
                                addresses: CustomerAddresses!
                            }

                            # Customer Profile (part of Customer aggregate)
                            type CustomerProfile {
                                personalInfo: PersonalInfo!
                                contactInfo: ContactInfo!
                                preferences: CustomerPreferences!
                            }

                            # Customer Addresses (part of Customer aggregate)
                            type CustomerAddresses {
                                billing: Address!
                                shipping: Address
                                additional: [Address!]!
                            }

                            # Customer-specific enums
                            enum CustomerStatus {
                                ACTIVE
                                INACTIVE
                                SUSPENDED
                                PENDING_VERIFICATION
                            }

                            # Customer operations
                            extend type Query {
                                customer(id: ID!): Customer
                                customerByNumber(customerNumber: String!): Customer
                            }

                            extend type Mutation {
                                createCustomer(input: CreateCustomerInput!): CreateCustomerPayload!
                                updateCustomer(input: UpdateCustomerInput!): UpdateCustomerPayload!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Interface-Based Type Organization</b></td>
                            <td>Organize types around common interfaces and contracts</td>
                            <td>
                                <ul>
                                    <li>Interfaces define clear contracts</li>
                                    <li>Common behavior abstracted</li>
                                    <li>Interface implementations consistent</li>
                                    <li>Interface evolution planned</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Polymorphic queries supported</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # identifiable-interface.graphql
                            interface Identifiable {
                                id: ID!
                            }

                            interface Timestamped {
                                createdAt: DateTime!
                                updatedAt: DateTime!
                            }

                            interface Versioned {
                                version: Int!
                                lastModifiedBy: String!
                            }

                            # auditable-types.graphql
                            interface Auditable implements Identifiable & Timestamped {
                                id: ID!
                                createdAt: DateTime!
                                updatedAt: DateTime!
                                auditTrail: [AuditEntry!]!
                            }

                            type AuditEntry {
                                action: AuditAction!
                                performedBy: String!
                                performedAt: DateTime!
                                changes: [FieldChange!]!
                            }

                            # domain-entities.graphql
                            type Customer implements Identifiable & Timestamped & Auditable
                            @key(fields: "id") {
                                id: ID!
                                createdAt: DateTime!
                                updatedAt: DateTime!
                                auditTrail: [AuditEntry!]!

                                # Customer-specific fields
                                customerNumber: String!
                                profile: CustomerProfile!
                            }

                            type Order implements Identifiable & Timestamped & Versioned
                            @key(fields: "id") {
                                id: ID!
                                createdAt: DateTime!
                                updatedAt: DateTime!
                                version: Int!
                                lastModifiedBy: String!

                                # Order-specific fields
                                orderNumber: String!
                                status: OrderStatus!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Value Object Clustering</b></td>
                            <td>Group related value objects together</td>
                            <td>
                                <ul>
                                    <li>Related value objects grouped</li>
                                    <li>Value object behavior included</li>
                                    <li>Input types provided</li>
                                    <li>Validation rules embedded</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Reusability maximized</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # money-types.graphql
                            type Money {
                                amount: Decimal!
                                currency: Currency!

                                # Money behavior
                                formattedAmount: String!
                                minorUnits: Int!
                            }

                            enum Currency {
                                USD
                                EUR
                                GBP
                                JPY
                                CAD
                            }

                            input MoneyInput {
                                amount: Decimal!
                                currency: Currency!
                            }

                            # measurement-types.graphql
                            type Weight {
                                value: Decimal!
                                unit: WeightUnit!

                                # Conversions
                                inGrams: Decimal!
                                inKilograms: Decimal!
                                inPounds: Decimal!
                            }

                            type Dimensions {
                                length: Length!
                                width: Length!
                                height: Length!

                                # Computed properties
                                volume: Volume!
                                surfaceArea: Area!
                            }

                            enum WeightUnit {
                                GRAM
                                KILOGRAM
                                POUND
                                OUNCE
                            }

                            # contact-types.graphql
                            type ContactInfo {
                                email: Email!
                                phone: PhoneNumber
                                address: Address!
                            }

                            type Email {
                                address: String!
                                isVerified: Boolean!
                                verifiedAt: DateTime
                            }

                            type PhoneNumber {
                                number: String!
                                countryCode: String!
                                type: PhoneType!
                                isVerified: Boolean!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Modular Schema Composition</b></td>
                            <td>Compose schemas from modular components</td>
                            <td>
                                <ul>
                                    <li>Clear import structure</li>
                                    <li>Dependency order correct</li>
                                    <li>No circular dependencies</li>
                                    <li>Modular boundaries respected</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Schema composition validates</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # schema.graphql - Main composition file
                            # Import base types
                            #import "shared/scalars.graphql"
                            #import "shared/interfaces.graphql"
                            #import "shared/enums.graphql"

                            # Import domain modules
                            #import "customer/customer-types.graphql"
                            #import "customer/customer-operations.graphql"
                            #import "order/order-types.graphql"
                            #import "order/order-operations.graphql"
                            #import "product/product-types.graphql"
                            #import "product/product-operations.graphql"

                            # Import value objects
                            #import "value-objects/money.graphql"
                            #import "value-objects/address.graphql"
                            #import "value-objects/contact.graphql"

                            # Import events
                            #import "events/domain-events.graphql"
                            #import "events/event-subscriptions.graphql"

                            # Schema definition
                            schema {
                                query: Query
                                mutation: Mutation
                                subscription: Subscription
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Namespace-Based Organization</b></td>
                            <td>Use GraphQL namespaces to organize related functionality</td>
                            <td>
                                <ul>
                                    <li>Namespaces logically organized</li>
                                    <li>Related operations grouped</li>
                                    <li>Namespace boundaries clear</li>
                                    <li>Query paths intuitive</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Namespace evolution supported</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Namespace for customer operations
                            type CustomerOperations {
                                # Customer queries
                                byId(id: ID!): Customer
                                byNumber(customerNumber: String!): Customer
                                search(query: String!, filter: CustomerFilter): CustomerSearchResult!

                                # Customer analytics
                                analytics(filter: AnalyticsFilter!): CustomerAnalytics!
                                segmentation(criteria: SegmentationCriteria!): [CustomerSegment!]!
                            }

                            # Namespace for order operations
                            type OrderOperations {
                                # Order queries
                                byId(id: ID!): Order
                                byNumber(orderNumber: String!): Order
                                byCustomer(customerId: ID!, filter: OrderFilter): [Order!]!

                                # Order analytics
                                analytics(filter: OrderAnalyticsFilter!): OrderAnalytics!
                                reports(type: ReportType!, period: DateRange!): OrderReport!
                            }

                            # Root query with namespaces
                            type Query {
                                customers: CustomerOperations!
                                orders: OrderOperations!
                                products: ProductOperations!
                                inventory: InventoryOperations!
                            }

                            # Usage: query { customers { byId(id: "123") { name } } }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Context-Aware Schema Organization</b></td>
                            <td>Organize schema elements by bounded context concerns</td>
                            <td>
                                <ul>
                                    <li>Context boundaries respected</li>
                                    <li>Context-specific concerns separated</li>
                                    <li>Cross-context relationships clear</li>
                                    <li>Context evolution independent</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Domain alignment maintained</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # customer-context.graphql
                            # Customer bounded context types and operations
                            type Customer @key(fields: "id") {
                                id: ID!
                                # Core customer context data
                                customerNumber: String!
                                profile: CustomerProfile!
                                registrationInfo: RegistrationInfo!
                            }

                            type CustomerProfile {
                                personalInfo: PersonalInfo!
                                contactInfo: ContactInfo!
                                preferences: CustomerPreferences!
                            }

                            extend type Query {
                                # Customer context queries
                                customer(id: ID!): Customer
                                customerProfile(customerId: ID!): CustomerProfile
                            }

                            extend type Mutation {
                                # Customer context mutations
                                registerCustomer(input: RegisterCustomerInput!): RegisterCustomerPayload!
                                updateProfile(input: UpdateProfileInput!): UpdateProfilePayload!
                            }

                            # order-context.graphql
                            # Order bounded context extensions
                            extend type Customer @key(fields: "id") {
                                id: ID! @external

                                # Order context view of customer
                                orderHistory: OrderHistory!
                                loyaltyStatus: LoyaltyStatus!
                                shippingPreferences: ShippingPreferences!
                            }

                            extend type Query {
                                # Order context queries
                                customerOrders(customerId: ID!): [Order!]!
                                orderStatistics(customerId: ID!): OrderStatistics!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Schema Documentation Strategy</b></td>
                            <td>Organize comprehensive schema documentation</td>
                            <td>
                                <ul>
                                    <li>All types documented</li>
                                    <li>Business rules explained</li>
                                    <li>Examples provided</li>
                                    <li>Relationships documented</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Evolution notes included</li>
                                </ul>
                            </td>
                            <td>
                                ```graphql
                            """
                            Customer aggregate root representing a business customer.

                            The Customer entity encapsulates all customer-related information
                            and serves as the primary entry point for customer operations.

                            Business Rules:
                            - Customer numbers must be unique across the system
                            - Email addresses must be verified before account activation
                            - Customer status changes trigger domain events

                            Related Aggregates:
                            - Order: Customers can place multiple orders
                            - Payment: Customers can have multiple payment methods
                            """
                            type Customer @key(fields: "id") {
                                """
                                Unique identifier for the customer.

                                This ID is stable across the customer lifecycle and is used
                                for federation across subgraphs.
                                """
                                id: ID!

                                """
                                Business identifier for the customer.

                                Format: CUS-YYYYMMDD-NNNN
                                Example: CUS-20231201-0001

                                Generated automatically during customer registration.
                                """
                                customerNumber: String!

                                """
                                Customer profile containing personal and contact information.

                                The profile is a value object that encapsulates all
                                customer-specific data and preferences.
                                """
                                profile: CustomerProfile!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Schema Metadata Organization</b></td>
                            <td>Include rich metadata for schema governance</td>
                            <td>
                                <ul>
                                    <li>Ownership information included</li>
                                    <li>Version information tracked</li>
                                    <li>Business rules documented</li>
                                    <li>Performance hints provided</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Governance metadata complete</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Schema metadata
                            directive @owner(team: String!, contact: String!) on OBJECT | FIELD_DEFINITION
                            directive @since(version: String!) on OBJECT | FIELD_DEFINITION | ENUM_VALUE
                            directive @businessRule(description: String!) on OBJECT | FIELD_DEFINITION
                            directive @performance(complexity: Int!, cacheHint: String) on FIELD_DEFINITION

                            type Customer
                            @key(fields: "id")
                            @owner(team: "Customer Experience", contact: "customer-team@company.com")
                            @since(version: "1.0.0")
                            @businessRule(
                                description: "Customer must have verified email before activation"
                            ) {
                            id: ID! @since(version: "1.0.0")

                            customerNumber: String!
                                @since(version: "1.0.0")
                                @businessRule(description: "Must follow format CUS-YYYYMMDD-NNNN")

                            profile: CustomerProfile!
                                @since(version: "1.1.0")
                                @performance(complexity: 5, cacheHint: "300s")

                            loyaltyLevel: LoyaltyLevel!
                                @since(version: "2.0.0")
                                @performance(complexity: 3, cacheHint: "600s")
                            }
                            ```
                            </td>
                        </tr>
                    </tbody>
                </table>
            </TabItem>
            <TabItem value="schema-modularization" label="Modularization">
                <table class="text_vertical">
                    <thead>
                        <tr>
                            <th>DDD Concept</th>
                            <th>Definition</th>
                            <th>Characteristics</th>
                            <th>Considerations</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><b>Ubiquitous Language</b></td>
                            <td>A common language shared between domain experts and developers, reflected in code and schema</td>
                            <td>
                                <ul>
                                    <li>Type names must use domain terminology, not technical terms</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>All type names use business terminology</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # ✅ Good - Uses domain language
                            type Order {
                                orderNumber: String!
                                customer: Customer!
                                lineItems: [LineItem!]!
                                totalAmount: Money!
                                status: OrderStatus!
                            }

                            # ❌ Bad - Uses technical language
                            type OrderRecord {
                                id: ID!
                                customerId: ID!
                                items: [OrderItemRecord!]!
                                total: Float!
                                statusCode: Int!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Domain Module Pattern</b></td>
                            <td>Create modules around domain aggregates and bounded contexts</td>
                            <td>
                                <ul>
                                    <li>Module boundaries align with domain boundaries</li>
                                    <li>Clear module dependencies</li>
                                    <li>Well-defined module interface</li>
                                    <li>Module versioning strategy</li>
                                    <li>Module documentation complete</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Encapsulates all related types, operations, and business logic within a bounded context</li>
                                    <li>Dependencies and exports are explicitly defined</li>
                                </ul>
                            </td>
                            <td>
                            ```markdown
                            customer-domain-module/
                            ├── types/
                            │   ├── customer.graphql
                            │   ├── customer-profile.graphql
                            │   ├── customer-address.graphql
                            │   └── customer-enums.graphql
                            ├── operations/
                            │   ├── customer-queries.graphql
                            │   ├── customer-mutations.graphql
                            │   └── customer-subscriptions.graphql
                            ├── interfaces/
                            │   ├── customer-interfaces.graphql
                            │   └── customer-contracts.graphql
                            ├── events/
                            │   ├── customer-events.graphql
                            │   └── customer-handlers.graphql
                            └── module.graphql
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Capability Module Pattern</b></td>
                            <td>Organize modules around business capabilities</td>
                            <td>
                                <ul>
                                    <li>Capability clearly defined</li>
                                    <li>Service interfaces well-designed</li>
                                    <li>Capability versioning managed</li>
                                    <li>Integration points documented</li>
                                    <li>Capability testing comprehensive</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Provides comprehensive capabilities, such as price calculation or discount application</li>
                                    <li>Defines metadata and services for the capability</li>
                                </ul>
                            </td>
                            <td>
                            ```markdown
                            pricing-capability-module/
                            ├── services/
                            │   ├── price-calculation.graphql
                            │   ├── discount-engine.graphql
                            │   └── tax-calculation.graphql
                            ├── types/
                            │   ├── price-quote.graphql
                            │   ├── discount-types.graphql
                            │   └── tax-types.graphql
                            ├── rules/
                            │   ├── pricing-rules.graphql
                            │   ├── discount-rules.graphql
                            │   └── tax-rules.graphql
                            └── capability.graphql
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Shared Module Pattern</b></td>
                            <td>Create reusable modules for common types and functionality</td>
                            <td>
                                <ul>
                                    <li>Shared types are truly reusable</li>
                                    <li>Module stability is appropriate</li>
                                    <li>Versioning strategy is clear</li>
                                    <li>Usage guidelines provided</li>
                                    <li>Governance model defined</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Provides common value objects and types used across multiple bounded contexts</li>
                                    <li>Emphasizes immutability, self-validating types, and backward compatibility</li>
                                </ul>
                            </td>
                            <td>
                            ```markdown
                            shared-value-objects-module/
                            ├── money/
                            │   ├── money-types.graphql
                            │   ├── currency-types.graphql
                            │   └── money-operations.graphql
                            ├── temporal/
                            │   ├── date-types.graphql
                            │   ├── duration-types.graphql
                            │   └── date-range-types.graphql
                            ├── contact/
                            │   ├── address-types.graphql
                            │   ├── email-types.graphql
                            │   └── phone-types.graphql
                            ├── measurement/
                            │   ├── weight-types.graphql
                            │   ├── dimension-types.graphql
                            │   └── volume-types.graphql
                            └── shared-module.graphql
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Hierarchical Module Composition</b></td>
                            <td>Compose modules in hierarchical layers</td>
                            <td>
                                <ul>
                                    <li>Layer dependencies are clear</li>
                                    <li>No circular dependencies</li>
                                    <li>Layer boundaries respected</li>
                                    <li>Composition order correct</li>
                                    <li>Dependency validation automated</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Organizes schemas into distinct layers (e.g., Foundation, Value Objects, Domain, Capability, Integration)</li>
                                    <li>Defines strict dependency rules to prevent circular dependencies</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            subgraph-schema/
                            ├── foundation/
                            │   ├── shared-scalars/
                            │   ├── shared-interfaces/
                            │   └── shared-enums/
                            ├── value-objects/
                            │   ├── money-module/
                            │   ├── contact-module/
                            │   └── temporal-module/
                            ├── domain-modules/
                            │   ├── customer-module/
                            │   ├── product-module/
                            │   └── order-module/
                            ├── capability-modules/
                            │   ├── pricing-module/
                            │   ├── inventory-module/
                            │   └── shipping-module/
                            ├── integration-modules/
                            │   ├── federation-module/
                            │   ├── event-module/
                            │   └── api-module/
                            └── schema.graphql
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Plugin-Based Module System</b></td>
                            <td>Design modules as pluggable components</td>
                            <td>
                                <ul>
                                    <li>Plugin interface well-defined</li>
                                    <li>Module lifecycle managed</li>
                                    <li>Configuration externalized</li>
                                    <li>Dependencies resolved automatically</li>
                                    <li>Plugin registry maintained</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Modules implement a common `ModulePlugin` interface</li>
                                    <li>Supports dynamic activation/deactivation and dependency resolution</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            interface ModulePlugin {
                                name: String!
                                version: String!
                                isEnabled: Boolean!
                                dependencies: [ModuleDependency!]!
                                initialize: InitializationResult!
                                validate: ValidationResult!
                                activate: ActivationResult!
                                deactivate: DeactivationResult!
                            }

                            type CustomerModulePlugin implements ModulePlugin {
                                # ... (details omitted for brevity)
                            }

                            type ModuleRegistry {
                                registeredModules: [ModulePlugin!]!
                                activeModules: [ModulePlugin!]!
                                moduleGraph: ModuleDependencyGraph!
                                # ... (operations omitted for brevity)
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Event-Driven Module Integration</b></td>
                            <td>Integrate modules through domain events</td>
                            <td>
                                <ul>
                                    <li>Event contracts well-defined</li>
                                    <li>Event routing configured</li>
                                    <li>Error handling robust</li>
                                    <li>Event ordering preserved</li>
                                    <li>Module coupling minimized</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Modules communicate by publishing and subscribing to domain events</li>
                                    <li>Events are well-defined, and handlers manage event processing</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            interface ModuleEvent {
                                eventId: ID!
                                moduleSource: String!
                                eventType: String!
                                occurredAt: DateTime!
                                payload: JSON!
                            }

                            type CustomerModuleEvent implements ModuleEvent {
                                # ... (details omitted for brevity)
                            }

                            type ModuleEventHandler {
                                handlerName: String!
                                moduleSource: String!
                                eventTypes: [String!]!
                                isActive: Boolean!
                                # ... (configuration omitted for brevity)
                            }

                            type ModuleEventBus {
                                publishEvent(event: ModuleEventInput!): PublishResult!
                                subscribeToEvents(filter: EventFilter!): Subscription!
                                getEventHistory(filter: EventHistoryFilter!): [ModuleEvent!]!
                                # ... (metrics omitted for brevity)
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Module Lifecycle Management</b></td>
                            <td>Define clear lifecycle stages for modules</td>
                            <td>
                                <ul>
                                    <li>Lifecycle stages clearly defined</li>
                                    <li>Transition criteria specified</li>
                                    <li>Ownership model clear</li>
                                    <li>Quality gates enforced</li>
                                    <li>Compliance requirements met</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Defines stages like DEVELOPMENT, PRODUCTION, DEPRECATED, and transition criteria</li>
                                    <li>Includes governance policies for ownership, changes, and quality</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type ModuleLifecycle {
                                currentStage: LifecycleStage!
                                stageHistory: [LifecycleStageEntry!]!
                                nextStage: LifecycleStage
                                stageTransitionCriteria: [String!]!
                            }

                            enum LifecycleStage {
                                DEVELOPMENT
                                TESTING
                                STAGING
                                PRODUCTION
                                MAINTENANCE
                                DEPRECATED
                                RETIRED
                            }

                            type ModuleGovernance {
                                owner: ModuleOwner!
                                maintainers: [ModuleMaintainer!]!
                                reviewers: [ModuleReviewer!]!
                                # ... (policies and gates omitted for brevity)
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Module Versioning Strategy</b></td>
                            <td>Implement semantic versioning for modules</td>
                            <td>
                                <ul>
                                    <li>Semantic versioning followed</li>
                                    <li>Breaking changes documented</li>
                                    <li>Migration guides provided</li>
                                    <li>Dependency constraints clear</li>
                                    <li>Compatibility matrix maintained</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Adheres to semantic versioning (major, minor, patch)</li>
                                    <li>Documents release notes, breaking changes, and deprecations with migration guides</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type ModuleVersion {
                                version: String! # "2.1.0"
                                majorVersion: Int! # 2
                                minorVersion: Int! # 1
                                patchVersion: Int! # 0
                                # ... (metadata and compatibility omitted for brevity)
                                dependencies: [ModuleDependency!]!
                                dependents: [ModuleDependent!]!
                            }

                            type BreakingChange {
                                type: BreakingChangeType!
                                description: String!
                                migrationGuide: String!
                                affectedTypes: [String!]!
                                introducedInVersion: String!
                            }

                            enum BreakingChangeType {
                                TYPE_REMOVED
                                FIELD_REMOVED
                                FIELD_TYPE_CHANGED
                                OPERATION_REMOVED
                                OPERATION_SIGNATURE_CHANGED
                                ENUM_VALUE_REMOVED
                            }
                            ```
                            </td>
                        </tr>
                    </tbody>
                </table>
            </TabItem>
            <TabItem value="schema-versioning" label="Versioning">
                <table class="text_vertical">
                    <thead>
                        <tr>
                            <th>DDD Concept</th>
                            <th>Definition</th>
                            <th>Characteristics</th>
                            <th>Considerations</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><b>Schema Evolution and Versioning</b></td>
                            <td>Strategies for evolving DDD-compliant schemas in GraphQL federated architectures while maintaining backward compatibility</td>
                            <td>
                                <ul>
                                    <li>Requires careful planning</li>
                                    <li>Enables domain model growth</li>
                                    <li>Avoids breaking existing clients</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Maintaining backward compatibility is crucial</li>
                                    <li>Schema evolution should reflect domain model evolution</li>
                                    <li>Federation impact must be considered during subgraph evolution</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Version 1.0 - Initial schema
                            type Customer @key(fields: "id") {
                                id: ID!
                                name: String!
                                email: String!
                            }

                            # Version 1.1 - Additive changes (safe)
                            type Customer @key(fields: "id") {
                                id: ID!
                                name: String!
                                email: String!
                                phone: String
                                registrationDate: DateTime
                                displayName: String!
                                isActive: Boolean!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Backward Compatibility</b></td>
                            <td>New schema versions must not break existing clients</td>
                            <td>
                                <ul>
                                    <li>Safe evolution patterns: adding optional fields, types, enum values (at end), operations, or deprecating fields with alternatives</li>
                                    <li>Unsafe evolution patterns: removing fields without deprecation, changing field types, making optional fields required, removing enum values, changing operation signatures</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>All changes should maintain backward compatibility</li>
                                    <li>Deprecated fields need clear migration paths</li>
                                    <li>New fields should be optional or have defaults</li>
                                    <li>Breaking changes must be avoided</li>
                                    <li>Migration timeline should be communicated</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Version 1.2 - Field deprecation (safe with migration period)
                            type Customer @key(fields: "id") {
                                id: ID!
                                name: String! @deprecated(reason: "Use profile.fullName instead")
                                email: String! @deprecated(reason: "Use profile.contactInfo.email instead")
                                phone: String @deprecated(reason: "Use profile.contactInfo.phone instead")
                                profile: CustomerProfile!
                                displayName: String!
                                isActive: Boolean!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Domain-Driven Evolution</b></td>
                            <td>Schema evolution should reflect domain model evolution</td>
                            <td>
                                <ul>
                                    <li>Evolution is driven by a deeper understanding of the business domain</li>
                                    <li>Business concepts are properly modeled</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Evolution should reflect deeper domain understanding</li>
                                    <li>Business concepts should be properly modeled</li>
                                    <li>Domain expert feedback must be incorporated</li>
                                    <li>Ubiquitous language must be maintained</li>
                                    <li>Business rules should be embedded in the schema</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # V2: Richer domain model as understanding grows
                            type Customer @key(fields: "id") {
                                id: ID!
                                customerNumber: String!
                                profile: CustomerProfile!
                                status: CustomerStatus!
                                name: String! @deprecated(reason: "Use profile.fullName")
                                email: String! @deprecated(reason: "Use profile.contactInfo.email")
                            }

                            type CustomerProfile {
                                personalInfo: PersonalInfo!
                                contactInfo: ContactInfo!
                                preferences: CustomerPreferences!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Federated Evolution</b></td>
                            <td>Subgraph evolution must consider federation impact</td>
                            <td>
                                <ul>
                                    <li>Changes within a subgraph can affect the overall federated graph</li>
                                    <li>Requires coordination across subgraphs</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Federation keys should remain stable</li>
                                    <li>External field changes require coordination</li>
                                    <li>Cross-subgraph impacts must be assessed</li>
                                    <li>Schema composition should continue to work</li>
                                    <li>Query planning should not be negatively affected</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # V2: Enhanced customer with multiple keys
                            type Customer @key(fields: "id") @key(fields: "customerNumber") {
                                id: ID!
                                customerNumber: String!
                                profile: CustomerProfile!
                                name: String! @deprecated(reason: "Use profile.fullName")
                                email: String! @deprecated(reason: "Use profile.contactInfo.email")
                            }

                            extend type Customer @key(fields: "customerNumber") {
                                customerNumber: String! @external
                                orders: [Order!]!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Semantic Versioning for Schemas</b></td>
                            <td>Applying semantic versioning principles to GraphQL schemas</td>
                            <td>
                                <ul>
                                    <li>Uses Major, Minor, and Patch version increments</li>
                                    <li>Major for breaking changes, Minor for backward-compatible features, Patch for bug fixes</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Version numbers should follow semantic versioning</li>
                                    <li>Breaking changes should increment the major version</li>
                                    <li>New features should increment the minor version</li>
                                    <li>Bug fixes should increment the patch version</li>
                                    <li>Version metadata should be maintained</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type SchemaInfo {
                                version: String! # "2.1.0"
                                majorVersion: Int! # 2
                                minorVersion: Int! # 1
                                patchVersion: Int! # 0
                                deprecatedFields: [DeprecatedField!]!
                                addedInVersion: String!
                                compatibilityLevel: CompatibilityLevel!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Field-Level Versioning</b></td>
                            <td>Versioning individual fields for granular evolution</td>
                            <td>
                                <ul>
                                    <li>Allows for independent evolution of fields</li>
                                    <li>Provides clear deprecation timelines for specific fields</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Field versions should be tracked</li>
                                    <li>Deprecation timelines should be clear</li>
                                    <li>Migration guidance should be provided</li>
                                    <li>Field evolution should be documented</li>
                                    <li>Client impact should be assessed</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Customer @key(fields: "id") {
                                id: ID!
                                name: String! @deprecated(reason: "Use profile.fullName. Removed in v3.0")
                                email: String! @deprecated(reason: "Use profile.contactInfo.email. Removed in v3.0")
                                customerNumber: String! # Added in v2.0
                                profile: CustomerProfile! # Added in v2.0
                                loyaltyLevel: LoyaltyLevel! # Added in v2.1
                                fieldVersions: [FieldVersion!]!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Type Versioning</b></td>
                            <td>Versioning entire types when significant changes occur</td>
                            <td>
                                <ul>
                                    <li>Allows new type versions to coexist with old ones during migration</li>
                                    <li>Useful for major structural changes to a type</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Type versions should coexist during migration</li>
                                    <li>Migration paths should be clearly defined</li>
                                    <li>Data consistency must be maintained</li>
                                    <li>Client migration should be supported</li>
                                    <li>A rollback strategy should exist</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # V1 Customer type
                            type Customer @key(fields: "id") {
                                id: ID!
                                name: String!
                                email: String!
                            }

                            # V2 Customer type (coexisting during migration)
                            type CustomerV2 @key(fields: "id") @key(fields: "customerNumber") {
                                id: ID!
                                customerNumber: String!
                                profile: CustomerProfile!
                                status: CustomerStatus!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Gradual Migration</b></td>
                            <td>Migrating clients gradually over time</td>
                            <td>
                                <ul>
                                    <li>Supports both old and new patterns concurrently</li>
                                    <li>Provides migration helpers and guidance to clients</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Migration timelines should be communicated</li>
                                    <li>Legacy and new patterns should coexist</li>
                                    <li>Migration assistance should be provided</li>
                                    <li>Progress should be tracked</li>
                                    <li>Support should be available during migration</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Customer @key(fields: "id") {
                                id: ID!
                                name: String! @deprecated(reason: "Use profile.fullName")
                                email: String! @deprecated(reason: "Use profile.contactInfo.email")
                                profile: CustomerProfile!
                                migrationInfo: MigrationInfo!
                            }

                            type Query {
                                customer(id: ID!): Customer @deprecated(reason: "Use customerByNumber")
                                customerByNumber(customerNumber: String!): Customer
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Feature Flags for Schema Evolution</b></td>
                            <td>Using feature flags to control schema evolution</td>
                            <td>
                                <ul>
                                    <li>New schema elements can be toggled on or off using flags</li>
                                    <li>Allows for gradual rollout and testing of new features</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Feature flags should control new functionality</li>
                                    <li>Flag states should be clearly documented</li>
                                    <li>Flag rollout should be gradual</li>
                                    <li>Flag removal should be planned</li>
                                    <li>Flag dependencies should be managed</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Customer @key(fields: "id") {
                                id: ID!
                                name: String!
                                email: String!
                                profile: CustomerProfile # Available when "enhanced_customer_profile" flag is enabled
                                loyaltyProgram: LoyaltyProgram # Available when "loyalty_program" flag is enabled
                            }

                            type Query {
                                customer(id: ID!): Customer
                                customerAnalytics(customerId: ID!): CustomerAnalytics # Requires "analytics" flag
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Blue-Green Schema Deployment</b></td>
                            <td>Deploying new schema versions alongside existing ones</td>
                            <td>
                                <ul>
                                    <li>New versions are deployed to a separate "green" environment</li>
                                    <li>Traffic can be gradually shifted from "blue" to "green."</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Both environments should be fully functional</li>
                                    <li>Traffic can be gradually shifted</li>
                                    <li>Rollback should be immediate if needed</li>
                                    <li>Data consistency must be maintained</li>
                                    <li>Monitoring should cover both environments</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Blue environment (current production)
                            type Customer @key(fields: "id") {
                                id: ID!
                                name: String!
                                email: String!
                            }

                            # Green environment (new version)
                            type Customer @key(fields: "id") @key(fields: "customerNumber") {
                                id: ID!
                                customerNumber: String!
                                profile: CustomerProfile!
                                name: String! @deprecated(reason: "Use profile.fullName")
                                email: String! @deprecated(reason: "Use profile.contactInfo.email")
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Schema Change Events</b></td>
                            <td>Publishing events when schema changes occur</td>
                            <td>
                                <ul>
                                    <li>Clients can subscribe to these events to react to schema updates</li>
                                    <li>Provides a real-time notification mechanism for schema evolution</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Schema changes should be published as events</li>
                                    <li>Clients should be able to subscribe to schema changes</li>
                                    <li>Change notifications should include migration guidance</li>
                                    <li>Event history should be maintained</li>
                                    <li>Change impact should be communicated</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Subscription {
                                schemaChanges: SchemaChangeEvent!
                            }

                            union SchemaChangeEvent =
                            FieldAdded
                            | FieldDeprecated
                            | FieldRemoved
                            | TypeAdded
                            | TypeModified

                            type FieldAdded implements SchemaChangeEvent {
                                eventId: ID!
                                timestamp: DateTime!
                                typeName: String!
                                fieldName: String!
                                fieldType: String!
                                version: String!
                                description: String!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Automated Migration Detection</b></td>
                            <td>Automatically detecting and suggesting migrations</td>
                            <td>
                                <ul>
                                    <li>Tools can analyze client schemas and suggest necessary updates</li>
                                    <li>Estimates migration effort and identifies automation opportunities</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Migration opportunities should be identified automatically</li>
                                    <li>Migration effort should be estimated</li>
                                    <li>Automation should be provided where possible</li>
                                    <li>Migration tracking should be available</li>
                                    <li>Success metrics should be defined</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Query {
                                migrationOpportunities(clientId: String!): [MigrationOpportunity!]!
                                schemaCompatibility(clientSchema: String!): CompatibilityReport!
                            }

                            type MigrationOpportunity {
                                type: MigrationType!
                                description: String!
                                currentUsage: String!
                                recommendedChange: String!
                                effort: MigrationEffort!
                                deadline: DateTime!
                                automationAvailable: Boolean!
                            }
                            ```
                            </td>
                        </tr>
                    </tbody>
                </table>
            </TabItem>
        </Tabs>
    </TabItem>
    <TabItem value="decisions" label="Decisions">
        <Tabs queryString="secondary">
            <TabItem value="schema-decision-tree" label="Decision Tree" attributes={{className:"tabs__vertical"}}>
            <table class="text_vertical">
            <thead>
                <tr>
                <th>Category</th>
                <th>Decision Tree</th>
                <th>Checklist</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                <td colspan="3">
                    <h2>Bounded Context Decisions</h2>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Context Boundary Identification</h3>
                </td>
                <td>
                    <b>Should this be a separate bounded context?</b>
                    <ul>
                    <li>Does this concept have different meanings in different parts of the business? <b>→ Yes: Separate bounded contexts / No: Continue evaluation</b></li>
                    <li>Do different teams have expertise in different aspects of this concept? <b>→ Yes: Consider separate bounded contexts / No: Continue evaluation</b></li>
                    <li>Would changes to this concept affect different business capabilities? <b>→ Yes: Separate bounded contexts / No: Continue evaluation</b></li>
                    <li>Can this concept be owned and evolved independently? <b>→ Yes: Good candidate for separate context / No: Consider shared context or different boundaries</b></li>
                    <li>Does this concept have its own data and business rules? <b>→ Yes: Strong candidate for separate context / No: Likely part of larger context</b></li>
                    </ul>
                </td>
                <td>
                    <b>Context Boundary Validation</b>
                    <ul>
                    <li>Context has clear business purpose</li>
                    <li>Context can be owned by single team</li>
                    <li>Context has minimal dependencies on other contexts</li>
                    <li>Context boundaries align with data ownership</li>
                    <li>Context size is manageable for team</li>
                    <li>Context has cohesive set of capabilities</li>
                    <li>Context interfaces are well-defined</li>
                    <li>Context can evolve independently</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Subgraph Mapping Decision</h3>
                </td>
                <td>
                    <b>Should this bounded context be a single subgraph?</b>
                    <ul>
                    <li>Does the context represent a single business capability? <b>→ No: Consider splitting into multiple subgraphs / Yes: Continue evaluation</b></li>
                    <li>Can the context be owned by a single team? <b>→ No: Split into team-owned subgraphs / Yes: Continue evaluation</b></li>
                    <li>Are all entities in the context highly cohesive? <b>→ No: Consider entity-based subgraph split / Yes: Continue evaluation</b></li>
                    <li>Does the context have consistent change frequency? <b>→ No: Consider splitting by change patterns / Yes: Good candidate for single subgraph</b></li>
                    <li>Is the context size manageable for development and deployment? <b>→ No: Consider splitting for manageability / Yes: Proceed with single subgraph</b></li>
                    </ul>
                </td>
                <td>
                    <b>Subgraph Design Validation</b>
                    <ul>
                    <li>Subgraph represents single bounded context</li>
                    <li>Subgraph has clear ownership</li>
                    <li>Subgraph entities are cohesive</li>
                    <li>Subgraph has minimal external dependencies</li>
                    <li>Subgraph can be deployed independently</li>
                    <li>Subgraph has appropriate size and complexity</li>
                    <li>Subgraph interfaces are well-defined</li>
                    <li>Subgraph evolution strategy is clear</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td colspan="3">
                    <h2>Entity and Aggregate Decisions</h2>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Entity vs Value Object Decision</h3>
                </td>
                <td>
                    <b>Should this be an entity or value object?</b>
                    <ul>
                    <li>Does this concept have a distinct identity that matters to the business? <b>→ Yes: Entity / No: Continue evaluation</b></li>
                    <li>Does this concept need to be tracked over time? <b>→ Yes: Entity / No: Continue evaluation</b></li>
                    <li>Can two instances with the same attributes be considered identical? <b>→ Yes: Value Object / No: Entity</b></li>
                    <li>Does this concept have a lifecycle independent of other concepts? <b>→ Yes: Entity / No: Value Object</b></li>
                    </ul>
                </td>
                <td>
                    <b>Entity Design Validation</b>
                    <ul>
                    <li>Entity has stable, unique identity</li>
                    <li>Entity identity is meaningful to business</li>
                    <li>Entity has independent lifecycle</li>
                    <li>Entity can be referenced from other contexts</li>
                    <li>Entity supports required operations</li>
                    <li>Entity boundaries are clear</li>
                    <li>Entity state changes are tracked</li>
                    <li>Entity relationships are well-defined</li>
                    </ul>
                    <br />
                    <b>Value Object Design Validation</b>
                    <ul>
                    <li>Value object has no identity</li>
                    <li>Value object is immutable</li>
                    <li>Value object validates its own invariants</li>
                    <li>Value object can be compared by value</li>
                    <li>Value object encapsulates related attributes</li>
                    <li>Value object has clear semantic meaning</li>
                    <li>Value object is reusable across contexts</li>
                    <li>Value object serialization is well-defined</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Aggregate Boundary Decision</h3>
                </td>
                <td>
                    <b>Should these entities be in the same aggregate?</b>
                    <ul>
                    <li>Do these entities need to be consistent together? <b>→ Yes: Same aggregate / No: Continue evaluation</b></li>
                    <li>Do these entities change together as part of business operations? <b>→ Yes: Same aggregate / No: Continue evaluation</b></li>
                    <li>Can these entities exist independently? <b>→ No: Same aggregate / Yes: Continue evaluation</b></li>
                    <li>Is the relationship ownership or reference? <b>→ Ownership: Same aggregate / Reference: Different aggregates</b></li>
                    <li>Would separating these entities create consistency issues? <b>→ Yes: Same aggregate / No: Different aggregates</b></li>
                    </ul>
                </td>
                <td>
                    <b>Aggregate Design Validation</b>
                    <ul>
                    <li>Aggregate has single root entity</li>
                    <li>Aggregate maintains business invariants</li>
                    <li>Aggregate size is manageable</li>
                    <li>Aggregate boundaries respect consistency requirements</li>
                    <li>Aggregate operations are atomic</li>
                    <li>Aggregate can be loaded and saved as unit</li>
                    <li>Aggregate has clear ownership</li>
                    <li>Aggregate minimizes external dependencies</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td colspan="3">
                    <h2>Federation Design Decisions</h2>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Entity Federation Strategy</h3>
                </td>
                <td>
                    <b>How should this entity be federated?</b>
                    <ul>
                    <li>Is this entity owned by this subgraph? <b>→ Yes: Define as primary entity with @key / No: Continue evaluation</b></li>
                    <li>Does this subgraph need to add context-specific data to the entity? <b>→ Yes: Extend entity with relevant fields / No: Continue evaluation</b></li>
                    <li>Does this subgraph only need to reference the entity? <b>→ Yes: Reference by ID only / No: Extend with needed fields</b></li>
                    <li>Does this subgraph need to provide data for other subgraphs? <b>→ Yes: Use @provides directive / No: Standard extension</b></li>
                    </ul>
                </td>
                <td>
                    <b>Entity Federation Validation</b>
                    <ul>
                    <li>Entity ownership is clear</li>
                    <li>Key fields are stable and unique</li>
                    <li>External fields are properly marked</li>
                    <li>Required fields are available</li>
                    <li>Provided fields are accurate</li>
                    <li>Federation directives are correct</li>
                    <li>Cross-subgraph references are minimal</li>
                    <li>Performance implications are considered</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Field Resolution Strategy</h3>
                </td>
                <td>
                    <b>How should this field be resolved?</b>
                    <ul>
                    <li>Is the data owned by this subgraph? <b>→ Yes: Resolve locally / No: Continue evaluation</b></li>
                    <li>Is the data available from another subgraph? <b>→ Yes: Use federation to resolve / No: Continue evaluation</b></li>
                    <li>Can the data be computed from available data? <b>→ Yes: Compute in resolver / No: Continue evaluation</b></li>
                    <li>Is the data critical for this context? <b>→ Yes: Consider data replication / No: Use reference or omit</b></li>
                    </ul>
                </td>
                <td>
                    <b>Field Resolution Validation</b>
                    <ul>
                    <li>Data ownership is clear</li>
                    <li>Resolution strategy is efficient</li>
                    <li>Dependencies are minimal</li>
                    <li>Error handling is robust</li>
                    <li>Performance is acceptable</li>
                    <li>Caching strategy is defined</li>
                    <li>Fallback behavior is specified</li>
                    <li>Monitoring is in place</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td colspan="3">
                    <h2>Schema Design Decisions</h2>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Type Design Strategy</h3>
                </td>
                <td>
                    <b>What GraphQL type should this concept be?</b>
                    <ul>
                    <li>Does this concept represent a distinct business entity? <b>→ Yes: Object Type / No: Continue evaluation</b></li>
                    <li>Does this concept represent a set of related values? <b>→ Yes: Object Type (Value Object) / No: Continue evaluation</b></li>
                    <li>Does this concept represent a choice from fixed options? <b>→ Yes: Enum Type / No: Continue evaluation</b></li>
                    <li>Does this concept define a contract for multiple implementations? <b>→ Yes: Interface Type / No: Continue evaluation</b></li>
                    <li>Does this concept represent one of several possible types? <b>→ Yes: Union Type / No: Scalar Type</b></li>
                    </ul>
                </td>
                <td>
                    <b>Type Design Validation</b>
                    <ul>
                    <li>Type purpose is clear</li>
                    <li>Type name follows conventions</li>
                    <li>Type fields are appropriate</li>
                    <li>Type relationships are well-defined</li>
                    <li>Type supports required operations</li>
                    <li>Type evolution is considered</li>
                    <li>Type documentation is complete</li>
                    <li>Type validation is comprehensive</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Field Design Strategy</h3>
                </td>
                <td>
                    <b>How should this field be designed?</b>
                    <ul>
                    <li>Is this field always present? <b>→ Yes: Non-nullable field / No: Continue evaluation</b></li>
                    <li>Can this field be null in valid business scenarios? <b>→ Yes: Nullable field / No: Non-nullable field</b></li>
                    <li>Does this field represent a collection? <b>→ Yes: List type / No: Continue evaluation</b></li>
                    <li>Can the collection be empty? <b>→ Yes: Nullable list or non-null list of nullable items / No: Non-null list of non-null items</b></li>
                    <li>Is this field computed from other data? <b>→ Yes: Resolver-computed field / No: Direct field mapping</b></li>
                    </ul>
                </td>
                <td>
                    <b>Field Design Validation</b>
                    <ul>
                    <li>Field nullability is correct</li>
                    <li>Field type is appropriate</li>
                    <li>Field name follows conventions</li>
                    <li>Field documentation is clear</li>
                    <li>Field validation is defined</li>
                    <li>Field performance is acceptable</li>
                    <li>Field evolution is considered</li>
                    <li>Field relationships are correct</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td colspan="3">
                    <h2>Operation Design Decisions</h2>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Query vs Mutation Decision</h3>
                </td>
                <td>
                    <b>Should this be a query or mutation?</b>
                    <ul>
                    <li>Does this operation change system state? <b>→ Yes: Mutation / No: Query</b></li>
                    <li>Does this operation have side effects? <b>→ Yes: Mutation / No: Query</b></li>
                    <li>Is this operation idempotent? <b>→ No: Mutation / Yes: Could be Query</b></li>
                    <li>Does this operation need to be cached? <b>→ Yes: Prefer Query / No: Either Query or Mutation</b></li>
                    </ul>
                </td>
                <td>
                    <b>Operation Design Validation</b>
                    <ul>
                    <li>Operation type is appropriate (Query/Mutation/Subscription)</li>
                    <li>Operation name is descriptive</li>
                    <li>Operation parameters are well-defined</li>
                    <li>Operation return type is appropriate</li>
                    <li>Operation error handling is comprehensive</li>
                    <li>Operation performance is acceptable</li>
                    <li>Operation security is considered</li>
                    <li>Operation documentation is complete</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Input Design Strategy</h3>
                </td>
                <td>
                    <b>How should operation inputs be structured?</b>
                    <ul>
                    <li>Does the operation have multiple parameters? <b>→ Yes: Use input object / No: Continue evaluation</b></li>
                    <li>Are the parameters logically related? <b>→ Yes: Group in input object / No: Consider separate parameters</b></li>
                    <li>Will the operation parameters evolve over time? <b>→ Yes: Use input object for flexibility / No: Either approach acceptable</b></li>
                    <li>Do multiple operations share similar parameters? <b>→ Yes: Create reusable input types / No: Operation-specific input</b></li>
                    </ul>
                </td>
                <td>
                    <b>Input Design Validation</b>
                    <ul>
                    <li>Input structure is logical</li>
                    <li>Input fields are appropriately nullable</li>
                    <li>Input validation is comprehensive</li>
                    <li>Input evolution is considered</li>
                    <li>Input reusability is maximized</li>
                    <li>Input documentation is clear</li>
                    <li>Input naming follows conventions</li>
                    <li>Input complexity is manageable</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td colspan="3">
                    <h2>Event Design Decisions</h2>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Event Granularity Decision</h3>
                </td>
                <td>
                    <b>What should be the scope of this event?</b>
                    <ul>
                    <li>Does this represent a single business occurrence? <b>→ Yes: Single event / No: Continue evaluation</b></li>
                    <li>Do multiple things happen atomically? <b>→ Yes: Single event with rich payload / No: Multiple events</b></li>
                    <li>Do different consumers need different parts of the information? <b>→ Yes: Consider multiple events or rich event with optional data / No: Single event</b></li>
                    <li>Is the event payload becoming too large? <b>→ Yes: Split into multiple events / No: Single event acceptable</b></li>
                    </ul>
                </td>
                <td>
                    <b>Event Design Validation</b>
                    <ul>
                    <li>Event represents business occurrence</li>
                    <li>Event name uses past tense</li>
                    <li>Event payload is appropriate size</li>
                    <li>Event is immutable</li>
                    <li>Event includes necessary context</li>
                    <li>Event versioning is considered</li>
                    <li>Event ordering is defined</li>
                    <li>Event error handling is specified</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Event Publishing Strategy</h3>
                </td>
                <td>
                    <b>How should this event be published?</b>
                    <ul>
                    <li>Do consumers need immediate notification? <b>→ Yes: Real-time publishing / No: Continue evaluation</b></li>
                    <li>Can consumers tolerate eventual consistency? <b>→ Yes: Asynchronous publishing / No: Synchronous publishing</b></li>
                    <li>Do all consumers need all events? <b>→ No: Filtered publishing / Yes: Broadcast publishing</b></li>
                    <li>Is event ordering important? <b>→ Yes: Ordered publishing / No: Unordered publishing acceptable</b></li>
                    </ul>
                </td>
                <td>
                    <b>Event Publishing Validation</b>
                    <ul>
                    <li>Publishing mechanism is appropriate</li>
                    <li>Event routing is configured</li>
                    <li>Event filtering is available</li>
                    <li>Event ordering is preserved when needed</li>
                    <li>Event delivery guarantees are defined</li>
                    <li>Event error handling is robust</li>
                    <li>Event monitoring is in place</li>
                    <li>Event retention is managed</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td colspan="3">
                    <h2>Performance and Scalability Decisions</h2>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Caching Strategy Decision</h3>
                </td>
                <td>
                    <b>What caching strategy should be used?</b>
                    <ul>
                    <li>Does this data change frequently? <b>→ Yes: Short TTL or no caching / No: Continue evaluation</b></li>
                    <li>Is this data expensive to compute? <b>→ Yes: Cache with appropriate TTL / No: Continue evaluation</b></li>
                    <li>Do multiple clients request the same data? <b>→ Yes: Shared caching / No: Client-side caching</b></li>
                    <li>Is data consistency critical? <b>→ Yes: Cache invalidation strategy needed / No: TTL-based caching acceptable</b></li>
                    </ul>
                </td>
                <td>
                    <b>Caching Strategy Validation</b>
                    <ul>
                    <li>Caching strategy matches data characteristics</li>
                    <li>Cache TTL is appropriate</li>
                    <li>Cache invalidation is handled</li>
                    <li>Cache performance is monitored</li>
                    <li>Cache consistency is maintained</li>
                    <li>Cache storage is appropriate</li>
                    <li>Cache security is considered</li>
                    <li>Cache evolution is planned</li>
                    </ul>
                </td>
                </tr>
                <tr>
                <td>
                    <h3>Pagination Strategy Decision</h3>
                </td>
                <td>
                    <b>What pagination approach should be used?</b>
                    <ul>
                    <li>Is the dataset size bounded and small? <b>→ Yes: No pagination needed / No: Continue evaluation</b></li>
                    <li>Do clients need to navigate arbitrarily through the dataset? <b>→ Yes: Cursor-based pagination / No: Continue evaluation</b></li>
                    <li>Is the dataset frequently updated? <b>→ Yes: Cursor-based pagination / No: Offset-based pagination acceptable</b></li>
                    <li>Do clients need to know total count? <b>→ Yes: Include total count / No: Omit total count for performance</b></li>
                    </ul>
                </td>
                <td>
                    <b>Pagination Strategy Validation</b>
                    <ul>
                    <li>Pagination approach matches use case</li>
                    <li>Page size limits are enforced</li>
                    <li>Pagination performance is acceptable</li>
                    <li>Pagination consistency is maintained</li>
                    <li>Pagination metadata is appropriate</li>
                    <li>Pagination error handling is robust</li>
                    <li>Pagination documentation is clear</li>
                    <li>Pagination evolution is considered</li>
                    </ul>
                </td>
                </tr>
            </tbody>
            </table>
            </TabItem>
            <TabItem value="schema-patterns" label="Patterns">
                <table class="text_vertical">
                    <thead>
                        <tr>
                            <th>DDD Concept</th>
                            <th>Definition</th>
                            <th>Characteristics</th>
                            <th>Considerations</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><b>Ubiquitous Language</b></td>
                            <td>A common language shared between domain experts and developers, reflected in code and schema</td>
                            <td>
                                <ul>
                                    <li>Type names must use domain terminology, not technical terms</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>All type names use business terminology</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # ✅ Good - Uses domain language
                            type Order {
                                orderNumber: String!
                                customer: Customer!
                                lineItems: [LineItem!]!
                                totalAmount: Money!
                                status: OrderStatus!
                            }

                            # ❌ Bad - Uses technical language
                            type OrderRecord {
                                id: ID!
                                customerId: ID!
                                items: [OrderItemRecord!]!
                                total: Float!
                                statusCode: Int!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Aggregate Root Pattern</b></td>
                            <td>Designate a single entity as the aggregate root and route all operations through it</td>
                            <td>
                                <ul>
                                    <li>Complex business entities with multiple components</li>
                                    <li>Strong consistency requirements</li>
                                    <li>Clear business boundaries</li>
                                    <li>Transactional operations needed</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Maintains business invariants</li>
                                    <li>Encapsulates business logic</li>
                                    <li>Clear ownership boundaries</li>
                                    <li>Simplified consistency model</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Aggregate Root
                            type Order @key(fields: "id") {
                                id: ID!
                                orderNumber: String!
                                customerId: ID!

                                # Aggregate components (owned entities)
                                lineItems: [LineItem!]!
                                shippingAddress: Address!
                                billingAddress: Address!

                                # Aggregate state
                                status: OrderStatus!
                                totalAmount: Money!

                                # Aggregate behavior
                                canBeCancelled: Boolean!
                                canBeModified: Boolean!
                                estimatedDelivery: DateTime!
                            }

                            # Internal entities (not directly accessible)
                            type LineItem {
                                productSku: String!
                                quantity: Int!
                                unitPrice: Money!
                                lineTotal: Money!
                            }

                            # Mutations operate on aggregate root
                            type Mutation {
                                createOrder(input: CreateOrderInput!): CreateOrderPayload!
                                addLineItem(orderId: ID!, input: LineItemInput!): AddLineItemPayload!
                                updateOrderStatus(orderId: ID! status: OrderStatus!): UpdateOrderStatusPayload!
                                cancelOrder(orderId: ID!, reason: String!): CancelOrderPayload!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Domain Service Pattern</b></td>
                            <td>Create domain services that encapsulate complex business logic</td>
                            <td>
                                <ul>
                                    <li>Complex calculations or algorithms</li>
                                    <li>Operations spanning multiple aggregates</li>
                                    <li>Stateless business logic</li>
                                    <li>Cross-cutting concerns</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Encapsulates complex logic</li>
                                    <li>Promotes reusability</li>
                                    <li>Clear separation of concerns</li>
                                    <li>Testable business logic</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Query {
                            # Pricing domain service
                                calculatePrice(input: PriceCalculationInput!): PriceQuote!

                                # Shipping domain service
                                calculateShipping(input: ShippingCalculationInput!): ShippingQuote!

                                # Inventory domain service
                                checkAvailability(input: AvailabilityCheckInput!): AvailabilityResult!

                                # Recommendation domain service
                                getRecommendations(input: RecommendationInput!): RecommendationResult!
                            }

                            type PriceQuote {
                                basePrice: Money!
                                discounts: [Discount!]!
                                taxes: [Tax!]!
                                finalPrice: Money!
                                validUntil: DateTime!

                                # Service metadata
                                calculationId: ID!
                                calculatedAt: DateTime!
                                pricingRules: [PricingRule!]!
                            }

                            type Mutation {
                                # Order processing domain service
                                processOrder(input: ProcessOrderInput!): ProcessOrderResult!

                                # Payment processing domain service
                                processPayment(input: ProcessPaymentInput!): ProcessPaymentResult!

                                # Fulfillment domain service
                                fulfillOrder(input: FulfillOrderInput!): FulfillOrderResult!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Repository Pattern</b></td>
                            <td>Create repository-style query interfaces that hide persistence details</td>
                            <td>
                                <ul>
                                    <li>Complex query requirements</li>
                                    <li>Multiple access patterns for same data</li>
                                    <li>Need for pagination and filtering</li>
                                    <li>Abstraction over data storage</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Domain-focused query interface</li>
                                    <li>Hides persistence complexity</li>
                                    <li>Supports multiple access patterns</li>
                                    <li>Enables query optimization</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            type Query {
                                # Customer repository
                                customer(id: ID!): Customer
                                customerByNumber(customerNumber: String!): Customer
                                customerByEmail(email: String!): Customer
                                customers(filter: CustomerFilter, sort: CustomerSort): CustomerConnection!

                                # Product repository
                                product(sku: String!): Product
                                productsByCategory(category: String!): [Product!]!
                                searchProducts(query: String!, filter: ProductFilter): ProductSearchResult!

                                # Order repository
                                order(id: ID!): Order
                                orderByNumber(orderNumber: String!): Order
                                customerOrders(customerId: ID!, filter: OrderFilter): [Order!]!
                                ordersInDateRange(from: DateTime!, to: DateTime!): [Order!]!
                            }

                            # Rich filter types
                            input CustomerFilter {
                                isActive: Boolean
                                loyaltyLevel: [LoyaltyLevel!]
                                registeredAfter: DateTime
                                registeredBefore: DateTime
                                hasOrders: Boolean
                                totalSpentRange: MoneyRange
                            }

                            # Connection types for pagination
                            type CustomerConnection {
                                edges: [CustomerEdge!]!
                                pageInfo: PageInfo!
                                totalCount: Int!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Entity Extension Pattern</b></td>
                            <td>Use GraphQL federation to extend entities with relevant context data</td>
                            <td>
                                <ul>
                                    <li>Entity spans multiple bounded contexts</li>
                                    <li>Context-specific data needs</li>
                                    <li>Avoiding god objects</li>
                                    <li>Maintaining separation of concerns</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Maintains bounded context integrity</li>
                                    <li>Avoids data duplication</li>
                                    <li>Enables rich cross-context queries</li>
                                    <li>Supports independent evolution</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Customer subgraph (entity owner)
                            type Customer @key(fields: "id") {
                                id: ID!
                                customerNumber: String!
                                profile: CustomerProfile!
                                registrationDate: DateTime!
                            }

                            # Order subgraph (extends with order context)
                            extend type Customer @key(fields: "id") {
                                id: ID! @external

                                # Order-specific customer data
                                orders: [Order!]!
                                orderHistory: OrderHistory!
                                loyaltyPoints: Int!
                                preferredShippingAddress: Address
                            }

                            # Marketing subgraph (extends with marketing context)
                            extend type Customer @key(fields: "id") {
                                id: ID! @external

                                # Marketing-specific customer data
                                marketingPreferences: MarketingPreferences!
                                campaignHistory: [Campaign!]!
                                segmentMemberships: [Segment!]!
                                recommendedProducts: [Product!]!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Federated Aggregate Pattern</b></td>
                            <td>Keep aggregate root in one subgraph and use events for cross-aggregate coordination</td>
                            <td>
                                <ul>
                                    <li>Aggregates span multiple contexts</li>
                                    <li>Eventual consistency is acceptable</li>
                                    <li>Need for loose coupling</li>
                                    <li>Complex business processes</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Maintains aggregate boundaries</li>
                                    <li>Enables loose coupling</li>
                                    <li>Supports complex workflows</li>
                                    <li>Provides audit trail</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Order subgraph (aggregate owner)
                            type Order @key(fields: "id") {
                                id: ID!
                                customerId: ID!
                                status: OrderStatus!
                                lineItems: [LineItem!]!
                                totalAmount: Money!
                            }

                            type Mutation {
                            placeOrder(input: PlaceOrderInput!): PlaceOrderPayload!
                                # Publishes OrderPlaced event
                            }

                            # Inventory subgraph (separate aggregate)
                            type InventoryItem @key(fields: "productSku") {
                                productSku: String!
                                quantityAvailable: Int!
                                quantityReserved: Int!
                            }

                            type Subscription {
                                # Listens for order events
                                orderEvents: OrderEvent!
                            }

                            type Mutation {
                                # Handles order events
                                reserveInventory(input: ReserveInventoryInput!): ReserveInventoryPayload!
                            }

                            # Event coordination
                            union OrderEvent = OrderPlaced | OrderCancelled | OrderShipped
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Gateway Aggregation Pattern</b></td>
                            <td>Create aggregation types that combine data from multiple sources</td>
                            <td>
                                <ul>
                                    <li>Complex UI requirements</li>
                                    <li>Multiple data sources needed</li>
                                    <li>Performance optimization required</li>
                                    <li>Simplified client queries</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Reduces client complexity</li>
                                    <li>Optimizes data fetching</li>
                                    <li>Provides unified views</li>
                                    <li>Enables caching strategies</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Gateway aggregation types
                            type CustomerDashboard {
                                customer: Customer!
                                orderSummary: OrderSummary!
                                paymentMethods: [PaymentMethod!]!
                                recommendations: [Product!]!
                                notifications: [Notification!]!

                                # Aggregation metadata
                                lastUpdated: DateTime!
                                dataFreshness: DataFreshness!
                            }

                            type OrderSummary {
                                totalOrders: Int!
                                totalSpent: Money!
                                averageOrderValue: Money!
                                lastOrderDate: DateTime!

                                # Recent activity
                                recentOrders: [Order!]!
                                pendingOrders: [Order!]!
                            }

                            type Query {
                                # Aggregated views
                                customerDashboard(customerId: ID!): CustomerDashboard!
                                orderAnalytics(filter: AnalyticsFilter!): OrderAnalytics!
                                inventoryReport(filter: InventoryFilter!): InventoryReport!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Event Sourcing Pattern</b></td>
                            <td>Store all changes as immutable events and build current state from events</td>
                            <td>
                                <ul>
                                    <li>Complete audit trail required</li>
                                    <li>Temporal queries needed</li>
                                    <li>Complex business processes</li>
                                    <li>Regulatory compliance</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Complete audit trail</li>
                                    <li>Temporal query capabilities</li>
                                    <li>Natural event publishing</li>
                                    <li>Debugging and analysis support</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Event store interface
                            type EventStore {
                                events(aggregateId: ID!, fromVersion: Int): [DomainEvent!]!
                                eventsByType(eventType: String!, from: DateTime): [DomainEvent!]!
                                appendEvent(event: DomainEventInput!): AppendEventResult!
                            }

                            # Domain events
                            interface DomainEvent {
                                eventId: ID!
                                aggregateId: ID!
                                eventType: String!
                                occurredAt: DateTime!
                                version: Int!
                            }

                            type CustomerRegistered implements DomainEvent {
                                eventId: ID!
                                aggregateId: ID!
                                eventType: String!
                                occurredAt: DateTime!
                                version: Int!

                                # Event data
                                customerNumber: String!
                                email: String!
                                registrationChannel: String!
                            }

                            # Event-sourced aggregate
                            type Customer @key(fields: "id") {
                                id: ID!
                                version: Int!

                                # Current state (projected from events)
                                customerNumber: String!
                                profile: CustomerProfile!
                                status: CustomerStatus!

                                # Event history
                                events: [DomainEvent!]!

                                # Temporal queries
                                stateAt(timestamp: DateTime!): CustomerSnapshot!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Saga Pattern</b></td>
                            <td>Use saga orchestration to manage distributed transactions</td>
                            <td>
                                <ul>
                                    <li>Long-running business processes</li>
                                    <li>Multiple service coordination</li>
                                    <li>Compensation required</li>
                                    <li>Complex workflows</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Manages distributed transactions</li>
                                    <li>Provides compensation mechanisms</li>
                                    <li>Enables complex workflows</li>
                                    <li>Maintains process visibility</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Saga orchestrator
                            type OrderFulfillmentSaga {
                                sagaId: ID!
                                orderId: ID!
                                currentStep: SagaStep!
                                status: SagaStatus!

                                # Saga state
                                inventoryReserved: Boolean!
                                paymentProcessed: Boolean!
                                shippingArranged: Boolean!

                                # Compensation tracking
                                compensationActions: [CompensationAction!]!

                                # Saga timeline
                                startedAt: DateTime!
                                completedAt: DateTime
                                steps: [SagaStepExecution!]!
                            }

                            enum SagaStep {
                                RESERVE_INVENTORY
                                PROCESS_PAYMENT
                                ARRANGE_SHIPPING
                                COMPLETE_ORDER
                            }

                            type Mutation {
                                # Saga management
                                startOrderFulfillment(orderId: ID!): StartSagaResult!
                                compensateOrderFulfillment(sagaId: ID!): CompensationResult!

                                # Step execution
                                executeReserveInventory(sagaId: ID!): StepResult!
                                executeProcessPayment(sagaId: ID!): StepResult!
                                executeArrangeShipping(sagaId: ID!): StepResult!
                            }

                            type Subscription {
                                sagaEvents(sagaId: ID!): SagaEvent!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>DataLoader Pattern</b></td>
                            <td>Implement batching and caching for entity resolution</td>
                            <td>
                                <ul>
                                    <li>N+1 query problems</li>
                                    <li>High-frequency entity access</li>
                                    <li>Performance optimization needed</li>
                                    <li>Large result sets</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Eliminates N+1 queries</li>
                                    <li>Improves performance</li>
                                    <li>Reduces service load</li>
                                    <li>Enables caching</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Efficient entity resolution
                            type Order @key(fields: "id") {
                                id: ID!
                                customerId: ID!
                                lineItems: [LineItem!]!

                                # Efficiently resolved via DataLoader
                                customer: Customer!
                            }

                            type LineItem {
                                productSku: String!
                                quantity: Int!

                                # Batch loaded products
                                product: Product!
                            }

                            # Batch loading interface (implementation detail)
                            type BatchLoader {
                                loadCustomers(ids: [ID!]!): [Customer!]!
                                loadProducts(skus: [String!]!): [Product!]!
                                loadOrders(ids: [ID!]!): [Order!]!
                            }
                            ```
                            </td>
                        </tr>
                        <tr>
                            <td><b>Caching Strategy Pattern</b></td>
                            <td>Implement multi-level caching with appropriate invalidation strategies</td>
                            <td>
                                <ul>
                                    <li>Performance optimization required</li>
                                    <li>Expensive computations</li>
                                    <li>High-frequency access patterns</li>
                                    <li>Static or semi-static data</li>
                                </ul>
                            </td>
                            <td>
                                <ul>
                                    <li>Improves response times</li>
                                    <li>Reduces computational load</li>
                                    <li>Scales better under load</li>
                                    <li>Provides better user experience</li>
                                </ul>
                            </td>
                            <td>
                            ```graphql
                            # Cache-aware types
                            type Product @key(fields: "sku") {
                                sku: String!
                                name: String!
                                price: Money!

                                # Cache metadata
                                cacheInfo: CacheInfo!
                            }

                            type CacheInfo {
                                cacheKey: String!
                                ttl: Int!
                                lastUpdated: DateTime!
                                cacheHit: Boolean!
                            }

                            # Cache control directives
                            type Query {
                                # Short-lived cache for dynamic data
                                inventory(productSku: String!): InventoryLevel! @cacheControl(maxAge: 60)

                                # Long-lived cache for static data
                                productCatalog: [Product!]! @cacheControl(maxAge: 3600)

                                # No cache for personalized data
                                customerRecommendations(customerId: ID!): [Product!]! @cacheControl(maxAge: 0)
                            }
                            ```
                            </td>
                        </tr>
                    </tbody>
                </table>
            </TabItem>
            <TabItem value="schema-anti-patterns" label="Anti-Patterns">
                <table class="text_vertical">
                    <thead>
                    <tr>
                        <th>DDD Concept</th>
                        <th>Definition</th>
                        <th>Characteristics</th>
                        <th>Considerations</th>
                        <th>Example</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td><b>Ubiquitous Language</b></td>
                        <td>A common language shared between domain experts and developers, reflected in code and schema</td>
                        <td>
                        <ul>
                            <li>Type names must use domain terminology, not technical terms</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>All type names use business terminology</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # ✅ Good - Uses domain language
                        type Order {
                            orderNumber: String!
                            customer: Customer!
                            lineItems: [LineItem!]!
                            totalAmount: Money!
                            status: OrderStatus!
                        }

                        # ❌ Bad - Uses technical language
                        type OrderRecord {
                            id: ID!
                            customerId: ID!
                            items: [OrderItemRecord!]!
                            total: Float!
                            statusCode: Int!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Anemic Domain Model</b></td>
                        <td>Creating types that only contain data without behavior or business logic</td>
                        <td>
                        <ul>
                            <li>Separates data from behavior</li>
                            <li>Makes business logic hard to find and maintain</li>
                            <li>Violates DDD principles</li>
                            <li>Leads to procedural programming in GraphQL</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Embed business logic in domain types</li>
                            <li>Use computed fields for business rules</li>
                            <li>Create rich value objects</li>
                            <li>Encapsulate behavior with data</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # ❌ Bad - Anemic domain model
                        type Customer {
                            id: ID!
                            firstName: String!
                            lastName: String!
                            email: String!
                            totalSpent: Float!
                            orderCount: Int!
                        }

                        type Query {
                            # Business logic in separate operations
                            calculateCustomerDiscount(customerId: ID!, orderAmount: Float!): Float!
                            validateCustomerCredit(customerId: ID!, amount: Float!): Boolean!
                            determineShippingEligibility(customerId: ID!): Boolean!
                        }

                        # ✅ Good - Rich domain model
                        type Customer {
                            id: ID!
                            firstName: String!
                            lastName: String!
                            email: String!

                            # Business behavior embedded in the model
                            loyaltyLevel: LoyaltyLevel!
                            availableCredit: Money!
                            isEligibleForFreeShipping: Boolean!

                            # Computed business properties
                            lifetimeValue: Money!
                            riskScore: RiskScore!
                        }

                        type LoyaltyLevel {
                            tier: LoyaltyTier!
                            discountPercentage: Float!
                            benefits: [LoyaltyBenefit!]!
                            nextTierRequirement: Money
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Database-Driven Schema Design</b></td>
                        <td>Designing GraphQL schema to match database structure instead of domain model</td>
                        <td>
                        <ul>
                            <li>Exposes implementation details</li>
                            <li>Uses technical naming</li>
                            <li>Doesn't reflect business concepts</li>
                            <li>Makes schema hard to understand</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Design schema based on domain model</li>
                            <li>Use business terminology</li>
                            <li>Hide database implementation details</li>
                            <li>Focus on business capabilities</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # ❌ Bad - Database-driven design
                        type CustomerRecord {
                            cust_id: ID!
                            first_name: String!
                            last_name: String!
                            email_addr: String!
                            created_dt: String!
                            updated_dt: String!
                            status_cd: Int!
                        }

                        type OrderRecord {
                            order_id: ID!
                            cust_id: ID!
                            order_dt: String!
                            total_amt: Float!
                            currency_cd: String!
                            status_cd: Int!
                        }

                        type OrderLineRecord {
                            line_id: ID!
                            order_id: ID!
                            prod_id: ID!
                            qty: Int!
                            unit_price: Float!
                        }

                        # ✅ Good - Domain-driven design
                        type Customer @key(fields: "id") {
                            id: ID!
                            customerNumber: String!
                            profile: CustomerProfile!
                            registrationDate: DateTime!
                            status: CustomerStatus!
                        }

                        type Order @key(fields: "id") {
                            id: ID!
                            orderNumber: String!
                            customer: Customer!
                            placementDate: DateTime!
                            totalAmount: Money!
                            status: OrderStatus!
                            lineItems: [LineItem!]!
                        }

                        type LineItem {
                            product: Product!
                            quantity: Int!
                            unitPrice: Money!
                            lineTotal: Money!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>God Object Anti-Pattern</b></td>
                        <td>Creating overly large types that contain too many responsibilities</td>
                        <td>
                        <ul>
                            <li>Violates single responsibility principle</li>
                            <li>Makes types hard to understand and maintain</li>
                            <li>Creates tight coupling</li>
                            <li>Complicates evolution</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Decompose large types into smaller, focused types</li>
                            <li>Use composition over large flat structures</li>
                            <li>Group related fields into value objects</li>
                            <li>Respect aggregate boundaries</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # ❌ Bad - God object
                        type Customer {
                            # Identity
                            id: ID!
                            customerNumber: String!

                            # Personal info
                            firstName: String!
                            lastName: String!
                            birthDate: Date!

                            # Contact info
                            email: String!
                            phone: String!

                            # Address info
                            billingStreet: String!
                            billingCity: String!
                            billingState: String!
                            billingZip: String!
                            shippingStreet: String!
                            shippingCity: String!
                            shippingState: String!
                            shippingZip: String!

                            # Order info
                            orders: [Order!]!
                            totalOrders: Int!
                            totalSpent: Money!
                            averageOrderValue: Money!

                            # Payment info
                            paymentMethods: [PaymentMethod!]!
                            defaultPaymentMethod: PaymentMethod!

                            # Marketing info
                            marketingOptIn: Boolean!
                            preferredChannel: String!
                            segments: [String!]!

                            # Support info
                            supportTickets: [SupportTicket!]!
                            supportLevel: String!
                        }

                        # ✅ Good - Properly decomposed
                        type Customer @key(fields: "id") {
                            id: ID!
                            customerNumber: String!
                            profile: CustomerProfile!
                            status: CustomerStatus!
                        }

                        type CustomerProfile {
                            personalInfo: PersonalInfo!
                            contactInfo: ContactInfo!
                            addresses: CustomerAddresses!
                            preferences: CustomerPreferences!
                        }

                        type PersonalInfo {
                            firstName: String!
                            lastName: String!
                            birthDate: Date!
                        }

                        type ContactInfo {
                            email: String!
                            phone: String!
                            preferredContactMethod: ContactMethod!
                        }

                        type CustomerAddresses {
                            billing: Address!
                            shipping: Address
                            additional: [Address!]!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Chatty Federation</b></td>
                        <td>Creating excessive cross-subgraph calls for simple operations</td>
                        <td>
                        <ul>
                            <li>Poor query performance</li>
                            <li>High latency</li>
                            <li>Service coupling</li>
                            <li>Reliability issues</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Use @provides directive to optimize data fetching</li>
                            <li>Include necessary data in owning subgraph</li>
                            <li>Pre-compute aggregations</li>
                            <li>Design for query patterns</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # ❌ Bad - Chatty federation
                        # Customer subgraph
                        type Customer @key(fields: "id") {
                            id: ID!
                            name: String!
                        }

                        # Order subgraph
                        extend type Customer @key(fields: "id") {
                            id: ID! @external
                            orders: [Order!]!
                        }

                        # Product subgraph
                        extend type Order @key(fields: "id") {
                            id: ID! @external
                            products: [Product!]! @requires(fields: "lineItems { productId }")
                        }

                        # Inventory subgraph
                        extend type Product @key(fields: "id") {
                            id: ID! @external
                            availability: Availability! # Requires call to inventory service
                        }
                        # Results in: Customer → Orders → Products → Availability (4 service calls)

                        # ✅ Good - Optimized federation
                        # Order subgraph includes necessary data
                        type Order @key(fields: "id") {
                            id: ID!
                            customer: Customer! @provides(fields: "name")
                            lineItems: [LineItem!]!
                            orderSummary: OrderSummary! # Pre-computed summary
                        }

                        type LineItem {
                            product: Product! @provides(fields: "name price")
                            quantity: Int!
                            availability: AvailabilitySnapshot! # Snapshot at order time
                        }

                        type OrderSummary {
                            totalItems: Int!
                            totalAmount: Money!
                            estimatedDelivery: DateTime!
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Shared Database Anti-Pattern</b></td>
                        <td>Multiple subgraphs accessing the same database tables</td>
                        <td>
                        <ul>
                            <li>Violates bounded context principles</li>
                            <li>Creates tight coupling</li>
                            <li>Makes evolution difficult</li>
                            <li>Causes data consistency issues</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Each subgraph owns its data</li>
                            <li>Use events for data synchronization</li>
                            <li>Maintain separate data stores</li>
                            <li>Respect bounded context boundaries</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # ❌ Bad - Shared database access
                        # Customer subgraph accesses customers table
                        type Customer @key(fields: "id") {
                            id: ID!
                            name: String!
                            email: String!
                        }

                        # Order subgraph also accesses customers table
                        extend type Customer @key(fields: "id") {
                            id: ID! @external
                            # Directly queries customer table for this data
                            totalOrders: Int!
                            lastOrderDate: DateTime!
                        }

                        # Marketing subgraph also accesses customers table
                        extend type Customer @key(fields: "id") {
                            id: ID! @external
                            # Directly queries customer table
                            marketingSegments: [String!]!
                            optInStatus: Boolean!
                        }

                        # ✅ Good - Clear data ownership
                        # Customer subgraph owns customer data
                        type Customer @key(fields: "id") {
                            id: ID!
                            name: String!
                            email: String!
                            profile: CustomerProfile!
                        }

                        # Order subgraph maintains its own order statistics
                        extend type Customer @key(fields: "id") {
                            id: ID! @external
                            orderStatistics: OrderStatistics! # From order service's own data
                        }

                        # Marketing subgraph maintains its own customer data
                        extend type Customer @key(fields: "id") {
                            id: ID! @external
                            marketingProfile: MarketingProfile! # From marketing service's own data
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Leaky Abstraction Anti-Pattern</b></td>
                        <td>Exposing internal implementation details through the GraphQL schema</td>
                        <td>
                        <ul>
                            <li>Couples clients to implementation</li>
                            <li>Makes refactoring difficult</li>
                            <li>Exposes unnecessary complexity</li>
                            <li>Violates encapsulation</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Hide implementation details</li>
                            <li>Use domain language in schema</li>
                            <li>Focus on business capabilities</li>
                            <li>Maintain clean abstractions</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # ❌ Bad - Leaky abstraction
                        type Customer {
                            id: ID!
                            name: String!

                            # Exposing internal database structure
                            customerRecord: CustomerRecord!
                            auditLog: [AuditLogEntry!]!

                            # Exposing internal service calls
                            externalSystemId: String!
                            lastSyncTimestamp: DateTime!
                            syncStatus: String!

                            # Exposing caching details
                            cacheKey: String!
                            cacheExpiry: DateTime!
                        }

                        type CustomerRecord {
                            # Raw database fields
                            created_at: DateTime!
                            updated_at: DateTime!
                            version: Int!
                            deleted_flag: Boolean!
                        }

                        # ✅ Good - Clean abstraction
                        type Customer @key(fields: "id") {
                            id: ID!
                            customerNumber: String!
                            profile: CustomerProfile!

                            # Business-focused metadata
                            registrationDate: DateTime!
                            lastActivityDate: DateTime!
                            status: CustomerStatus!

                            # Domain-relevant relationships
                            orders: [Order!]!
                            preferences: CustomerPreferences!
                        }

                        enum CustomerStatus {
                            ACTIVE
                            INACTIVE
                            SUSPENDED
                            PENDING_VERIFICATION
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Primitive Obsession</b></td>
                        <td>Using primitive types instead of domain-specific value objects</td>
                        <td>
                        <ul>
                            <li>Loses domain meaning</li>
                            <li>No validation or business rules</li>
                            <li>Difficult to evolve</li>
                            <li>Error-prone for clients</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Create value objects for domain concepts</li>
                            <li>Use enums for fixed choices</li>
                            <li>Embed validation in types</li>
                            <li>Make invalid states unrepresentable</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # ❌ Bad - Primitive obsession
                        type Product {
                            id: ID!
                            name: String!
                            price: Float! # Should be Money
                            weight: Float! # Should be Weight with unit
                            dimensions: String! # Should be structured Dimensions
                            currency: String! # Should be enum
                            availability: String! # Should be enum or rich type
                            tags: String! # Should be array
                        }

                        type Order {
                            id: ID!
                            total: Float! # Should be Money
                            tax: Float! # Should be Money
                            shipping: Float! # Should be Money
                            status: String! # Should be enum
                            date: String! # Should be DateTime
                        }

                        # ✅ Good - Rich value objects
                        type Product {
                            id: ID!
                            name: String!
                            price: Money!
                            weight: Weight!
                            dimensions: Dimensions!
                            availability: ProductAvailability!
                            tags: [ProductTag!]!
                        }

                        type Money {
                            amount: Decimal!
                            currency: Currency!
                        }

                        type Weight {
                            value: Decimal!
                            unit: WeightUnit!
                        }

                        type Dimensions {
                            length: Length!
                            width: Length!
                            height: Length!
                        }

                        enum Currency {
                            USD
                            EUR
                            GBP
                        }

                        type ProductAvailability {
                            status: AvailabilityStatus!
                            quantity: Int!
                            restockDate: DateTime
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Inconsistent Nullability</b></td>
                        <td>Inconsistent or incorrect use of nullable vs non-nullable fields</td>
                        <td>
                        <ul>
                            <li>Confuses client developers</li>
                            <li>Leads to runtime errors</li>
                            <li>Makes schema hard to understand</li>
                            <li>Inconsistent error handling</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Use non-null for required business data</li>
                            <li>Use nullable only when business allows null</li>
                            <li>Be consistent across similar fields</li>
                            <li>Document nullability decisions</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # ❌ Bad - Inconsistent nullability
                        type Customer {
                            id: ID # Should be non-null
                            name: String! # Good
                            email: String # Should probably be non-null
                            phone: String! # Might be null in some cases
                            orders: [Order!] # List itself should be non-null
                            addresses: [Address!]! # Good
                        }

                        type Order {
                            id: ID! # Good
                            customer: Customer # Should be non-null
                            total: Money! # Good
                            items: [LineItem] # Should be non-null list
                        }

                        # ✅ Good - Consistent nullability
                        type Customer {
                            id: ID! # Always present
                            name: String! # Always required
                            email: String! # Required for customers
                            phone: String # Optional
                            orders: [Order!]! # Non-null list, might be empty
                            addresses: [Address!]! # Non-null list, might be empty
                        }

                        type Order {
                            id: ID! # Always present
                            customer: Customer! # Always has a customer
                            total: Money! # Always calculated
                            items: [LineItem!]! # Non-null list, never empty for valid orders
                        }
                        ```
                        </td>
                    </tr>
                    <tr>
                        <td><b>Over-Normalization</b></td>
                        <td>Excessive normalization that makes queries complex and inefficient</td>
                        <td>
                        <ul>
                            <li>Requires multiple queries for simple data</li>
                            <li>Poor performance</li>
                            <li>Complex client code</li>
                            <li>Doesn't match usage patterns</li>
                        </ul>
                        </td>
                        <td>
                        <ul>
                            <li>Design for query patterns</li>
                            <li>Group related data together</li>
                            <li>Use composition over excessive normalization</li>
                            <li>Consider client needs</li>
                        </ul>
                        </td>
                        <td>
                        ```graphql
                        # ❌ Bad - Over-normalized
                        type Customer {
                            id: ID!
                            personalInfoId: ID!
                            contactInfoId: ID!
                            addressIds: [ID!]!
                        }

                        type PersonalInfo {
                            id: ID!
                            firstName: String!
                            lastName: String!
                            birthDate: Date!
                        }

                        type ContactInfo {
                            id: ID!
                            emailId: ID!
                            phoneId: ID!
                        }

                        type Email {
                            id: ID!
                            address: String!
                            type: EmailType!
                        }

                        type Phone {
                            id: ID!
                            number: String!
                            type: PhoneType!
                        }
                        # Requires multiple queries to get basic customer info

                        # ✅ Good - Appropriate denormalization
                        type Customer {
                            id: ID!
                            profile: CustomerProfile!
                            addresses: [Address!]!
                        }

                        type CustomerProfile {
                            personalInfo: PersonalInfo!
                            contactInfo: ContactInfo!
                        }

                        type PersonalInfo {
                            firstName: String!
                            lastName: String!
                            birthDate: Date!
                        }

                        type ContactInfo {
                            primaryEmail: Email!
                            secondaryEmail: Email
                            primaryPhone: Phone!
                            secondaryPhone: Phone
                        }

                        type Email {
                            address: String!
                            type: EmailType!
                            isVerified: Boolean!
                        }

                        type Phone {
                            number: String!
                            type: PhoneType!
                            isVerified: Boolean!
                        }
                        ```
                        </td>
                    </tr>
                    </tbody>
                </table>
            </TabItem>
        </Tabs>
    </TabItem>

</Tabs>
