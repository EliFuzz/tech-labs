---
title: Architectural Styles
description: Architectural Styles
hide_table_of_contents: true
---


import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

<Tabs queryString="primary">
    <TabItem value="definition" label="Definition">
        Architectural style is a framework of guidelines dictating the structure and organization of a software system, encompassing component roles, interactions, and dependencies. It also addresses non-functional aspects like scalability, performance, security, testability, and maintainability. While not rigid, it offers a flexible approach adaptable to project requirements. There's no one-size-fits-all solution; instead, various trade-offs and considerations must be weighed to select the most suitable style for a given scenario
    </TabItem>
    <TabItem value="benefits" label="Benefits">
        - **Modularity**: breaking down a complex system into smaller and simpler components that can be developed, tested, deployed, and maintained independently
        - **Reusability**: avoiding duplication of code and logic by creating reusable components that can be shared across different parts of the system or even across different systems
        - **Extensibility**: allowing the system to evolve and adapt to changing requirements and new features by adding or modifying components without affecting the existing ones
        - **Testability**: making the system easier to test by isolating the components and their dependencies and providing clear interfaces and contracts between them
        - **Maintainability**: making the system easier to understand, modify, debug, and refactor by following consistent and coherent conventions and principles
        - **Decoupling**: reducing the coupling or dependency between components by minimizing the amount of information and behavior they share or expose to each other
    </TabItem>
    <TabItem value="performance" label="Software Performance">
        Software performance refers to the ability of a software system to execute its intended functions within a certain time frame and with optimal use of resources. It is a critical aspect of software development and maintenance, as it directly impacts the user experience, system reliability, and overall efficiency.

        Software performance can be defined as the measure of how well a software system executes its intended functions and responds to user input within a specified time frame.

        It encompasses various aspects, including:

        - **Response time**: The time it takes for the system to respond to user input or queries
        - **Throughput**: The number of tasks or requests the system can process within a given time frame
        - **Resource** utilization: The efficiency with which the system uses hardware and software resources, such as CPU, memory, disk I/O, and network bandwidth
        - **Scalability**: The system’s ability to handle increased workload or user traffic without a significant decrease in performance
        - **Reliability**: The system’s ability to perform its intended functions consistently and without errors or failures

        **Key Performance Indicators (KPIs) for Software Systems**

        Key Performance Indicators (KPIs) are measurable values that demonstrate how effectively a software system is achieving its intended goals.

        Some common KPIs for software performance include:

        - **Response time**: Average response time, response time variability, and response time distribution
        - **Throughput**: Number of requests processed per unit time, such as requests per second (RPS) or transactions per minute (TPM)
        - **Resource utilization**: CPU usage, memory usage, disk I/O, network bandwidth, and database queries per second
        - **Scalability**: Number of users, concurrent connections, or requests handled by the system without significant performance degradation
        - **Reliability**: Mean time between failures (MTBF), mean time to recover (MTTR), and error rates

        **Factors that Affect Software Performance**

        - **Hardware resources**: Availability, utilization, and performance of hardware components, such as CPU, memory, storage, and network interfaces
        - **Software architecture**: Design and structure of the software system, including the number of layers, components, and interactions between them
        - **Algorithmic complexity**: The time and space complexity of algorithms used in the software, which can impact response time and resource utilization
        - **Data size and growth**: The amount of data processed and stored by the system, which can affect performance as the data set grows
        - **User behavior**: Patterns and intensity of user activity, such as the number of concurrent users, frequency of requests, and usage patterns
        - **Network and I/O performance**: Network latency, packet loss, and I/O operations can impact the system’s ability to retrieve and process data
        - **Resource contention**: Competition for shared resources, such as CPU, memory, and I/O devices, which can lead to performance bottlenecks
        - **Interference and noise**: Interference from other systems or background processes, as well as random fluctuations in system performance, can affect software performance

        **Methods for Measuring and Monitoring Software Performance**

        - **Synthetic transactions**: Simulating user interactions to measure response time, throughput, and resource utilization
        - **Real-user monitoring**: Tracking actual user interactions to assess performance from the end-user perspective
        - **Load testing**: Testing the system under varying loads to evaluate its scalability and performance under different workloads
        - **Stress testing**: Testing the system under extreme conditions, such as high concurrency or large data sets, to identify performance bottlenecks
        - **End-user experience monitoring**: Monitoring user experience metrics, such as page load times, error rates, and user satisfaction
        - **Performance modeling**: Creating mathematical models of the system to predict performance under different conditions and optimize system configuration
        - **Performance benchmarking**: Comparing the system’s performance to industry-standard benchmarks or competing systems
        - **Root cause analysis**: Identifying the underlying causes of performance issues through techniques such as profiling, tracing, and logging
    </TabItem>
    <TabItem value="styles" label="Architectural Styles">
        **Ways to Apply Architectural Style**

        - **Entire system**: defining the high-level structure and organization of the system as a whole, such as how it is divided into subsystems or modules, how they communicate with each other, and how they interact with external systems or services
        - **Subsystem or module**: defining the internal structure and organization of a subsystem or module within the system, such as how it is divided into components or classes, how they collaborate with each other, and how they expose their functionality to other subsystems or modules
        - **Component or class**: defining the internal structure and organization of a component or class within a subsystem or module, such as how it is divided into methods or functions, how they implement the logic and behavior of the component or class, and how they access data or resources

        **Overview**

        <table>
            <thead>
                <tr>
                    <th>Architectural Style</th>
                    <th>Definition</th>
                    <th>Technical Concepts</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Asynchronous Messaging</td>
                    <td>Pattern where the sender and receiver of a message don't need to interact with the message queue at the same time</td>
                    <td>
                        <ul>
                            <li><b>Decoupling</b>: This refers to the lack of a direct connection between the sender and receiver, allowing them to operate independently</li>
                            <li><b>Message Exchange Architectures</b>: These are structures designed for transferring messages between a sender and receiver</li>
                            <li><b>Eventual Consistency</b>: This concept suggests that changes made to one service may potentially lead to unintended and negative consequences in other parts of the system</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Blackboard</td>
                    <td>Decentralized problem-solving model that uses a modular approach. It’s designed to tackle complex problems that don’t have a clear algorithm or pre-set architecture</td>
                    <td>
                        <ul>
                          <li><b>Initialization:</b> The blackboard is prepared with the initial problem statement and any available input data</li>
                          <li><b>Activation:</b> Based on the current state of the problem and the data on the blackboard, the controller selects and activates one or more knowledge sources</li>
                          <li><b>Execution:</b> The activated knowledge sources independently analyze the problem, apply their specialized algorithms or techniques, and produce partial solutions or hypotheses</li>
                          <li><b>Conflict resolution:</b> If multiple knowledge sources generate conflicting or overlapping solutions, a conflict resolution mechanism is used to reconcile the differences and select the most appropriate solution(s)</li>
                          <li><b>Update:</b> The knowledge sources update the blackboard with their outputs, such as new constraints, proposed solutions, or intermediate results</li>
                          <li><b>Iteration:</b> The controller repeats the activation and execution steps until a satisfactory solution is reached, convergence criteria are met, or a predefined time limit is exceeded</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Client-Server</td>
                    <td>Model of interaction in a distributed system where software runs on local client devices and connects to remote server resources</td>
                    <td>
                        <ul>
                          <li><b>Loose coupling:</b> Clients and servers are separate entities that communicate over a network</li>
                          <li><b>Horizontal scaling:</b> Servers can be added to handle increased load</li>
                          <li><b>Distributed database:</b> Data can be stored across multiple servers, improving availability and performance</li>
                          <li><b>Asynchronous communication:</b> Clients make requests to servers and continue processing until the server responds</li>
                          <li><b>Stateless or stateful:</b> Servers can be designed to be stateless for scalability or stateful for simplicity</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Cloud Computing Patterns</td>
                    <td>Adapting to the many new possibilities but very different set of architectural constraints offered by the cloud compared to traditional on-premises infrastructure</td>
                    <td>
                        <ul>
                          <li><b>Functional requirements:</b> What the system should do</li>
                          <li><b>Non-functional requirements:</b> How the system should perform</li>
                          <li><b>Constraints:</b> What is out-of-scope to change</li>
                          <li><b>Self-healing:</b> The system should be able to recover from failures automatically</li>
                          <li><b>Cost efficient:</b> The system should make optimal use of resources to minimize costs</li>
                          <li><b>Continuous Integration/Continuous Delivery (CI/CD):</b> The system should be easily updated and maintained</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Component-Based</td>
                    <td>Framework for building software based on reusable components. It provides a higher level of abstraction and divides the problem into sub-problems, each associated with component partitions</td>
                    <td>
                        <ul>
                          <li><b>Components:</b> The building blocks that are highly flexible, modular, and reused across several projects. They follow repeatable conventions and can be used across other interfaces and modules without compromising the integrity of your code or UX</li>
                          <li><b>Interfaces:</b> Well-defined communication interfaces containing methods, events, and properties</li>
                          <li><b>Contracts:</b> Define the functionality provided by the component and the functionality required from the system to be operational</li>
                          <li><b>Component models and frameworks:</b> Define standards for component implementation, composition, and deployment</li>
                          <li><b>Composition:</b> The way components are assembled to form a system</li>
                          <li><b>Certification:</b> The process of verifying that a component meets its specification</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Database-Centric</td>
                    <td>Treats data as a valuable and versatile asset, acknowledging its role in the larger enterprise and industry ecosystem</td>
                    <td>
                        <ul>
                          <li><b>Centralized Data:</b> Refers to data collected and stored in one place, allowing frequent access and modification by various components</li>
                          <li><b>Security, Integration, Portability, and Analysis:</b> Significantly simplified in a data-centric approach, facilitating faster insights across the entire data value chain</li>
                          <li><b>Interoperability and Versatility:</b> By freeing data from a single monolithic stack, there are greater opportunities for accelerating digital transformation</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Domain-Driven Design (DDD)</td>
                    <td>Architecture style that focuses on modeling business domains and their logic in code</td>
                    <td>
                        <ul>
                          <li><b>Domain model:</b> A central, conceptual model of the business domain that guides the design of the application</li>
                          <li><b>Bounded context:</b> A self-contained model representing a specific aspect of the business domain</li>
                          <li><b>Ubiquitous language:</b> A shared language used across the entire development team to describe the domain model</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Event-Driven</td>
                    <td>Design pattern that organizes the application around the production, transformation, and consumption of events</td>
                    <td>
                        <ul>
                          <li><b>Event sources:</b> Services or systems that generate events</li>
                          <li><b>Event processors:</b> Services or systems that consume and process events</li>
                          <li><b>Event stores:</b> Systems that store events for later processing</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Layered</td>
                    <td>Architecture that separates the application into distinct layers, each with its own set of responsibilities</td>
                    <td>
                        <ul>
                          <li><b>Logical separation of components:</b> Components that are related or similar are usually placed on the same layers</li>
                          <li><b>Layers of isolation:</b> Layers can be modified and the change won't affect other layers</li>
                          <li><b>Separation of concerns:</b> The modules on a single layer together perform a single function</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Microkernel</td>
                    <td>A type of operating system kernel that is designed to provide only the most basic services required for an operating system to function</td>
                    <td>
                        <ul>
                          <li><b>Minimal functional core:</b> Only essential services run in kernel space, such as low-level address space management, thread management, and inter-process communication (IPC)</li>
                          <li><b>User-level processes:</b> Services like device drivers and file systems are implemented as user-level processes, communicating with the microkernel via message passing</li>
                          <li><b>Modularity and flexibility:</b> The system is designed to easily add, remove, or replace services without affecting other parts of the system</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Model–View–Controller</td>
                    <td>Design pattern that separates an application into 3 interconnected components: the model, the view, and the controller</td>
                    <td>
                        <ul>
                          <li><b>Model:</b> The heart of the system, managing the data, logic, and rules of the application</li>
                          <li><b>View:</b> Represents any output of information</li>
                          <li><b>Controller:</b> Accepts input and transforms it into commands for either the model or view</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Monolithic Application</td>
                    <td>Single, self-contained unit that includes all the components and functionality of the application</td>
                    <td>
                        <ul>
                          <li><b>Tight coupling:</b> Components are closely integrated and communicate directly with each other</li>
                          <li><b>Vertical scaling:</b> The entire application is deployed and scaled as a single unit</li>
                          <li><b>Shared database:</b> A single database is used to store all data for the application</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Multitier Architecture</td>
                    <td>Client–server architecture in which presentation, application processing, and data management functions are physically separated</td>
                    <td>
                        <ul>
                          <li><b>N-tier architecture:</b> Software engineering approach where processing, data management, and presentation functions are physically and logically separated</li>
                          <li><b>Three-tier architecture:</b> Consists of 3 components: a presentation tier, a logic tier, and a data tier</li>
                          <li><b>Layer vs Tier:</b> A layer refers to the logical structure of elements in a software solution, while a tier refers to the physical structure of hardware elements in the system infrastructure</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Object Request Broker</td>
                    <td>Middleware architecture used in distributed computing to coordinate and enable communication between registered servers and clients</td>
                    <td>
                        <ul>
                          <li><b>Language Independence:</b> CORBA is not associated with a particular programming language, and any language with a CORBA binding can be used to call and implement CORBA objects</li>
                          <li><b>Interface Definition Language (IDL):</b> Objects are described in a syntax called IDL</li>
                          <li><b>Object Request Broker (ORB):</b> The ORB handles communication, marshaling, and unmarshaling of parameters, making parameter handling transparent for CORBA server and client applications</li>
                          <li><b>Naming Service:</b> The naming service holds references to CORBA objects</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Peer-to-Peer</td>
                    <td>Network architecture where each workstation, or node, has the same capabilities and responsibilities</td>
                    <td>
                        <ul>
                          <li><b>Decentralized:</b> Tasks are distributed among all peers, eliminating the need for a central server</li>
                          <li><b>Equal Contribution:</b> Every device in the network functions as both a client and a server</li>
                          <li><b>Resilience to Change:</b> The network can adapt to changes in its participants</li>
                          <li><b>Elimination of Single Points of Failure:</b> The dual role of peers as both clients and servers helps avoid single points of failure, making this architecture useful for applications that require high reliability</li>
                          <li><b>Resource Sharing:</b> The network allows for the sharing of resources among peers</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Pipes and Filters</td>
                    <td>Architectural pattern for stream processing. It consists of one or more components called filters</td>
                    <td>
                        <ul>
                          <li><b>Filters:</b> Components that transform or filter data, such as sorting and counting functions</li>
                          <li><b>Pipes:</b> Connectors that pass data from one filter to another</li>
                          <li><b>Independent Processing:</b> Filters do not share state with other filters, allowing them to work independently without needing to know the identity of their upstream or downstream filters</li>
                          <li><b>Change Resilience:</b> New filters can be added to existing systems since filters are separate from each other and connected by explicit connectors</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Presentation–Abstraction–Control (PAC)</td>
                    <td>Interaction-oriented software architecture that separates an interactive system into 3 types of components</td>
                    <td>
                        <ul>
                          <li><b>Abstraction Component:</b> Retrieves and processes data</li>
                          <li><b>Presentation Component:</b> Formats the visual and audio presentation of data</li>
                          <li><b>Control Component:</b> Handles the flow of control and communication between the other two components</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Publish-Subscribe</td>
                    <td>Messaging system where publishers categorize messages into classes without knowing the subscribers. Subscribers, on the other hand, show interest in certain classes of messages and receive only those, without knowing the publishers</td>
                    <td>
                        <ul>
                          <li><b>Decoupling:</b> Publishers and subscribers are independent entities, connected only through a message queue</li>
                          <li><b>Asynchronous communication:</b> Messages are exchanged without requiring immediate acknowledgement, allowing tasks to continue uninterrupted</li>
                          <li><b>Scalability:</b> The system can easily accommodate new publishers and subscribers without disruption</li>
                          <li><b>Fault tolerance:</b> If a message isn't processed successfully, it can be retried or moved to a separate queue for handling errors</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Reflection</td>
                    <td>Architectural style based on the concept of reflection, which allows a system to observe and modify its own structure and behavior</td>
                    <td>
                        <ul>
                          <li><b>Reification:</b> The process of making something real, bringing something into being, or making something concrete</li>
                          <li><b>Structural Language:</b> A declarative language that defines an architecture’s static skeleton</li>
                          <li><b>Dynamic Language:</b> An imperative language that appears as a set of constraining rules written in a concurrent language</li>
                          <li><b>Behavioral and structural reflection:</b> Involves agent computation and structure</li>
                          <li><b>Pre-reflective architecture:</b> There exists a particular precognitive communication between an architectural work and the body, which shapes the overall (embodied) experience of an architectural setting</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Representational State Transfer (REST)</td>
                    <td>Architectural style that uses a subset of HTTP. It is commonly used to create interactive applications that use Web services</td>
                    <td>
                        <ul>
                          <li><b>Stateless:</b> Each request from client to server must contain all the information needed to understand and process the request</li>
                          <li><b>Client-Server:</b> The client and server are separate entities that communicate over a network</li>
                          <li><b>Cacheable:</b> Clients can cache responses to improve performance</li>
                          <li><b>Layered System:</b> The architecture is composed of hierarchical layers, providing a high level of abstraction</li>
                          <li><b>Uniform Interface:</b> The method of communication between the client and server is standardized</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Rule-Based</td>
                    <td>Architectural style where the system’s behavior is dictated by a set of rules</td>
                    <td>
                        <ul>
                          <li><b>Rule Engine:</b> The core component that interprets and executes rules</li>
                          <li><b>Rules:</b> Defined in a specific format, often IF-THEN-ELSE statements</li>
                          <li><b>Fact Model:</b> The data on which rules operate</li>
                          <li><b>Rulebase:</b> The storage of rules</li>
                          <li><b>Inference Engine:</b> Applies the rules to the known facts to deduce new facts</li>
                          <li><b>Working Memory:</b> Stores the facts the system currently knows</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Sensor–Controller–Actuator</td>
                    <td>Architectural pattern that helps with actuating in face of several input senses</td>
                    <td>
                        <ul>
                          <li><b>Sensing:</b> Responsible for collecting sensor data</li>
                          <li><b>Planning:</b> Processes sensor data and passes information to the controller</li>
                          <li><b>Execution:</b> Also known as the controller, sends actuator commands based on information received from the planner</li>
                          <li><b>Sequential organization:</b> Components are organized sequentially, with sensor data passed to the planner, who then passes information to the controller, which sends actuator commands</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Service-Oriented Architecture (SOA)</td>
                    <td>Design pattern that organizes the application into a collection of interconnected services</td>
                    <td>
                        <ul>
                          <li><b>Service contracts:</b> Services communicate through well-defined interfaces</li>
                          <li><b>Service discovery:</b> Services are registered and discovered at runtime</li>
                          <li><b>Service composition:</b> Services are combined to form complex business processes</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Shared Nothing Architecture (SNA)</td>
                    <td>Distributed computing architecture that consists of multiple separated nodes that don’t share resources</td>
                    <td>
                        <ul>
                          <li><b>Independent Nodes:</b> Each node in the system is independent and self-sufficient with its own disk space and memory</li>
                          <li><b>Data Partitioning:</b> The data set/workload is split into smaller sets (nodes) distributed into different parts of the system</li>
                          <li><b>High-Speed Interconnect Network:</b> Nodes communicate and synchronize through a high-speed interconnect network</li>
                          <li><b>Scalability:</b> The system supports incremental growth. New nodes can be added to scale the distributed system horizontally</li>
                          <li><b>No Shared Resources:</b> Unlike other architectures, SNA has no shared resources</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td>Space-Based Architecture (SBA)</td>
                    <td>Distributed-computing architecture for achieving linear scalability of stateful, high-performance applications</td>
                    <td>
                        <ul>
                          <li><b>Tuple Space Paradigm:</b> Components interact by exchanging tuples or entries via shared spaces</li>
                          <li><b>Processing Units (PUs):</b> Self-sufficient units independent of each other, encapsulating business logic and required data</li>
                          <li><b>Space:</b> A distributed, shared memory data grid where all data resides and is accessible to every processing unit</li>
                          <li><b>Router:</b> Routes client requests to the appropriate processing unit</li>
                          <li><b>Shared Nothing System:</b> Achieves scalability by distributing both processing and storage across multiple servers</li>
                        </ul>
                    </td>
                </tr>
            </tbody>
        </table>
    </TabItem>

</Tabs>
